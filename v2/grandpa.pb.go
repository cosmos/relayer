// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: v1/grandpa.proto

package ibc_lightclients_grandpa_v1

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type RelayChain int32

const (
	RelayChain_POLKADOT RelayChain = 0
	RelayChain_KUSAMA   RelayChain = 1
	RelayChain_ROCOCO   RelayChain = 2
)

var RelayChain_name = map[int32]string{
	0: "POLKADOT",
	1: "KUSAMA",
	2: "ROCOCO",
}

var RelayChain_value = map[string]int32{
	"POLKADOT": 0,
	"KUSAMA":   1,
	"ROCOCO":   2,
}

func (x RelayChain) String() string {
	return proto.EnumName(RelayChain_name, int32(x))
}

func (RelayChain) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e1a037a92d169acc, []int{0}
}

type Authority struct {
	// ed25519 public key of the authority
	PublicKey []byte `protobuf:"bytes,1,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	// authority weight
	Weight uint64 `protobuf:"varint,2,opt,name=weight,proto3" json:"weight,omitempty"`
}

func (m *Authority) Reset()         { *m = Authority{} }
func (m *Authority) String() string { return proto.CompactTextString(m) }
func (*Authority) ProtoMessage()    {}
func (*Authority) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1a037a92d169acc, []int{0}
}
func (m *Authority) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Authority) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Authority.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Authority) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Authority.Merge(m, src)
}
func (m *Authority) XXX_Size() int {
	return m.Size()
}
func (m *Authority) XXX_DiscardUnknown() {
	xxx_messageInfo_Authority.DiscardUnknown(m)
}

var xxx_messageInfo_Authority proto.InternalMessageInfo

func (m *Authority) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

func (m *Authority) GetWeight() uint64 {
	if m != nil {
		return m.Weight
	}
	return 0
}

// ClientState for the grandpa client
type ClientState struct {
	// Latest relay chain block hash
	LatestRelayHash []byte `protobuf:"bytes,1,opt,name=latest_relay_hash,json=latestRelayHash,proto3" json:"latest_relay_hash,omitempty"`
	// Latest relay chain height
	LatestRelayHeight uint32 `protobuf:"varint,2,opt,name=latest_relay_height,json=latestRelayHeight,proto3" json:"latest_relay_height,omitempty"`
	// current grandpa authority set id
	CurrentSetId uint64 `protobuf:"varint,3,opt,name=current_set_id,json=currentSetId,proto3" json:"current_set_id,omitempty"`
	// Types that are valid to be assigned to XFrozenHeight:
	//	*ClientState_FrozenHeight
	XFrozenHeight isClientState_XFrozenHeight `protobuf_oneof:"_frozen_height"`
	// Known relay chains
	RelayChain RelayChain `protobuf:"varint,5,opt,name=relay_chain,json=relayChain,proto3,enum=ibc.lightclients.grandpa.v1.RelayChain" json:"relay_chain,omitempty"`
	// ParaId of associated parachain
	ParaId uint32 `protobuf:"varint,6,opt,name=para_id,json=paraId,proto3" json:"para_id,omitempty"`
	// latest parachain height
	LatestParaHeight uint32 `protobuf:"varint,7,opt,name=latest_para_height,json=latestParaHeight,proto3" json:"latest_para_height,omitempty"`
	// Current grandpa authorities
	CurrentAuthorities []*Authority `protobuf:"bytes,8,rep,name=current_authorities,json=currentAuthorities,proto3" json:"current_authorities,omitempty"`
}

func (m *ClientState) Reset()         { *m = ClientState{} }
func (m *ClientState) String() string { return proto.CompactTextString(m) }
func (*ClientState) ProtoMessage()    {}
func (*ClientState) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1a037a92d169acc, []int{1}
}
func (m *ClientState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientState.Merge(m, src)
}
func (m *ClientState) XXX_Size() int {
	return m.Size()
}
func (m *ClientState) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientState.DiscardUnknown(m)
}

var xxx_messageInfo_ClientState proto.InternalMessageInfo

type isClientState_XFrozenHeight interface {
	isClientState_XFrozenHeight()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ClientState_FrozenHeight struct {
	FrozenHeight uint64 `protobuf:"varint,4,opt,name=frozen_height,json=frozenHeight,proto3,oneof" json:"frozen_height,omitempty"`
}

func (*ClientState_FrozenHeight) isClientState_XFrozenHeight() {}

func (m *ClientState) GetXFrozenHeight() isClientState_XFrozenHeight {
	if m != nil {
		return m.XFrozenHeight
	}
	return nil
}

func (m *ClientState) GetLatestRelayHash() []byte {
	if m != nil {
		return m.LatestRelayHash
	}
	return nil
}

func (m *ClientState) GetLatestRelayHeight() uint32 {
	if m != nil {
		return m.LatestRelayHeight
	}
	return 0
}

func (m *ClientState) GetCurrentSetId() uint64 {
	if m != nil {
		return m.CurrentSetId
	}
	return 0
}

func (m *ClientState) GetFrozenHeight() uint64 {
	if x, ok := m.GetXFrozenHeight().(*ClientState_FrozenHeight); ok {
		return x.FrozenHeight
	}
	return 0
}

func (m *ClientState) GetRelayChain() RelayChain {
	if m != nil {
		return m.RelayChain
	}
	return RelayChain_POLKADOT
}

func (m *ClientState) GetParaId() uint32 {
	if m != nil {
		return m.ParaId
	}
	return 0
}

func (m *ClientState) GetLatestParaHeight() uint32 {
	if m != nil {
		return m.LatestParaHeight
	}
	return 0
}

func (m *ClientState) GetCurrentAuthorities() []*Authority {
	if m != nil {
		return m.CurrentAuthorities
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ClientState) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ClientState_FrozenHeight)(nil),
	}
}

type ParachainHeaderWithRelayHash struct {
	RelayHash       []byte                 `protobuf:"bytes,1,opt,name=relay_hash,json=relayHash,proto3" json:"relay_hash,omitempty"`
	ParachainHeader *ParachainHeaderProofs `protobuf:"bytes,2,opt,name=parachain_header,json=parachainHeader,proto3" json:"parachain_header,omitempty"`
}

func (m *ParachainHeaderWithRelayHash) Reset()         { *m = ParachainHeaderWithRelayHash{} }
func (m *ParachainHeaderWithRelayHash) String() string { return proto.CompactTextString(m) }
func (*ParachainHeaderWithRelayHash) ProtoMessage()    {}
func (*ParachainHeaderWithRelayHash) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1a037a92d169acc, []int{2}
}
func (m *ParachainHeaderWithRelayHash) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParachainHeaderWithRelayHash) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ParachainHeaderWithRelayHash.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ParachainHeaderWithRelayHash) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParachainHeaderWithRelayHash.Merge(m, src)
}
func (m *ParachainHeaderWithRelayHash) XXX_Size() int {
	return m.Size()
}
func (m *ParachainHeaderWithRelayHash) XXX_DiscardUnknown() {
	xxx_messageInfo_ParachainHeaderWithRelayHash.DiscardUnknown(m)
}

var xxx_messageInfo_ParachainHeaderWithRelayHash proto.InternalMessageInfo

func (m *ParachainHeaderWithRelayHash) GetRelayHash() []byte {
	if m != nil {
		return m.RelayHash
	}
	return nil
}

func (m *ParachainHeaderWithRelayHash) GetParachainHeader() *ParachainHeaderProofs {
	if m != nil {
		return m.ParachainHeader
	}
	return nil
}

// Grandpa finality proof
type FinalityProof struct {
	// The hash of block F for which justification is provided.
	Block []byte `protobuf:"bytes,1,opt,name=block,proto3" json:"block,omitempty"`
	// Justification of the block F.
	Justification []byte `protobuf:"bytes,2,opt,name=justification,proto3" json:"justification,omitempty"`
	// The set of headers in the range (B; F] that we believe are unknown to the caller. Ordered.
	UnknownHeaders [][]byte `protobuf:"bytes,3,rep,name=unknown_headers,json=unknownHeaders,proto3" json:"unknown_headers,omitempty"`
}

func (m *FinalityProof) Reset()         { *m = FinalityProof{} }
func (m *FinalityProof) String() string { return proto.CompactTextString(m) }
func (*FinalityProof) ProtoMessage()    {}
func (*FinalityProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1a037a92d169acc, []int{3}
}
func (m *FinalityProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FinalityProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FinalityProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FinalityProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FinalityProof.Merge(m, src)
}
func (m *FinalityProof) XXX_Size() int {
	return m.Size()
}
func (m *FinalityProof) XXX_DiscardUnknown() {
	xxx_messageInfo_FinalityProof.DiscardUnknown(m)
}

var xxx_messageInfo_FinalityProof proto.InternalMessageInfo

func (m *FinalityProof) GetBlock() []byte {
	if m != nil {
		return m.Block
	}
	return nil
}

func (m *FinalityProof) GetJustification() []byte {
	if m != nil {
		return m.Justification
	}
	return nil
}

func (m *FinalityProof) GetUnknownHeaders() [][]byte {
	if m != nil {
		return m.UnknownHeaders
	}
	return nil
}

// Holds relavant parachain proofs for both header and timestamp extrinsic.
type ParachainHeaderProofs struct {
	// State proofs that prove a parachain header exists at a given relay chain height
	StateProof [][]byte `protobuf:"bytes,1,rep,name=state_proof,json=stateProof,proto3" json:"state_proof,omitempty"`
	// Timestamp extrinsic for ibc
	Extrinsic []byte `protobuf:"bytes,2,opt,name=extrinsic,proto3" json:"extrinsic,omitempty"`
	// Timestamp extrinsic proof for previously proven parachain header.
	ExtrinsicProof [][]byte `protobuf:"bytes,3,rep,name=extrinsic_proof,json=extrinsicProof,proto3" json:"extrinsic_proof,omitempty"`
}

func (m *ParachainHeaderProofs) Reset()         { *m = ParachainHeaderProofs{} }
func (m *ParachainHeaderProofs) String() string { return proto.CompactTextString(m) }
func (*ParachainHeaderProofs) ProtoMessage()    {}
func (*ParachainHeaderProofs) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1a037a92d169acc, []int{4}
}
func (m *ParachainHeaderProofs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParachainHeaderProofs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ParachainHeaderProofs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ParachainHeaderProofs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParachainHeaderProofs.Merge(m, src)
}
func (m *ParachainHeaderProofs) XXX_Size() int {
	return m.Size()
}
func (m *ParachainHeaderProofs) XXX_DiscardUnknown() {
	xxx_messageInfo_ParachainHeaderProofs.DiscardUnknown(m)
}

var xxx_messageInfo_ParachainHeaderProofs proto.InternalMessageInfo

func (m *ParachainHeaderProofs) GetStateProof() [][]byte {
	if m != nil {
		return m.StateProof
	}
	return nil
}

func (m *ParachainHeaderProofs) GetExtrinsic() []byte {
	if m != nil {
		return m.Extrinsic
	}
	return nil
}

func (m *ParachainHeaderProofs) GetExtrinsicProof() [][]byte {
	if m != nil {
		return m.ExtrinsicProof
	}
	return nil
}

// ConsensusState defines the consensus state from Tendermint.
type ConsensusState struct {
	// timestamp that corresponds to the block height in which the ConsensusState
	// was stored.
	Timestamp *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// packet commitment root
	Root []byte `protobuf:"bytes,2,opt,name=root,proto3" json:"root,omitempty"`
}

func (m *ConsensusState) Reset()         { *m = ConsensusState{} }
func (m *ConsensusState) String() string { return proto.CompactTextString(m) }
func (*ConsensusState) ProtoMessage()    {}
func (*ConsensusState) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1a037a92d169acc, []int{5}
}
func (m *ConsensusState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConsensusState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusState.Merge(m, src)
}
func (m *ConsensusState) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusState) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusState.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusState proto.InternalMessageInfo

func (m *ConsensusState) GetTimestamp() *timestamppb.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *ConsensusState) GetRoot() []byte {
	if m != nil {
		return m.Root
	}
	return nil
}

// GRANDPA finality proof and parachain headers
type Header struct {
	// GRANDPA finality proof
	FinalityProof *FinalityProof `protobuf:"bytes,1,opt,name=finality_proof,json=finalityProof,proto3" json:"finality_proof,omitempty"`
	// new parachain headers finalized by the GRANDPA finality proof
	ParachainHeaders []*ParachainHeaderWithRelayHash `protobuf:"bytes,2,rep,name=parachain_headers,json=parachainHeaders,proto3" json:"parachain_headers,omitempty"`
}

func (m *Header) Reset()         { *m = Header{} }
func (m *Header) String() string { return proto.CompactTextString(m) }
func (*Header) ProtoMessage()    {}
func (*Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1a037a92d169acc, []int{6}
}
func (m *Header) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Header.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Header.Merge(m, src)
}
func (m *Header) XXX_Size() int {
	return m.Size()
}
func (m *Header) XXX_DiscardUnknown() {
	xxx_messageInfo_Header.DiscardUnknown(m)
}

var xxx_messageInfo_Header proto.InternalMessageInfo

func (m *Header) GetFinalityProof() *FinalityProof {
	if m != nil {
		return m.FinalityProof
	}
	return nil
}

func (m *Header) GetParachainHeaders() []*ParachainHeaderWithRelayHash {
	if m != nil {
		return m.ParachainHeaders
	}
	return nil
}

// GRANDPA misbehaviour type
type Misbehaviour struct {
	// First SCALE-encoded finality proof.
	FirstFinalityProof []byte `protobuf:"bytes,1,opt,name=first_finality_proof,json=firstFinalityProof,proto3" json:"first_finality_proof,omitempty"`
	// Second SCALE-encoded finality proof.
	SecondFinalityProof []byte `protobuf:"bytes,2,opt,name=second_finality_proof,json=secondFinalityProof,proto3" json:"second_finality_proof,omitempty"`
}

func (m *Misbehaviour) Reset()         { *m = Misbehaviour{} }
func (m *Misbehaviour) String() string { return proto.CompactTextString(m) }
func (*Misbehaviour) ProtoMessage()    {}
func (*Misbehaviour) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1a037a92d169acc, []int{7}
}
func (m *Misbehaviour) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Misbehaviour) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Misbehaviour.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Misbehaviour) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Misbehaviour.Merge(m, src)
}
func (m *Misbehaviour) XXX_Size() int {
	return m.Size()
}
func (m *Misbehaviour) XXX_DiscardUnknown() {
	xxx_messageInfo_Misbehaviour.DiscardUnknown(m)
}

var xxx_messageInfo_Misbehaviour proto.InternalMessageInfo

func (m *Misbehaviour) GetFirstFinalityProof() []byte {
	if m != nil {
		return m.FirstFinalityProof
	}
	return nil
}

func (m *Misbehaviour) GetSecondFinalityProof() []byte {
	if m != nil {
		return m.SecondFinalityProof
	}
	return nil
}

// ClientMessage for ics10-GRANDPA
type ClientMessage struct {
	// Types that are valid to be assigned to Message:
	//	*ClientMessage_Header
	//	*ClientMessage_Misbehaviour
	Message isClientMessage_Message `protobuf_oneof:"message"`
}

func (m *ClientMessage) Reset()         { *m = ClientMessage{} }
func (m *ClientMessage) String() string { return proto.CompactTextString(m) }
func (*ClientMessage) ProtoMessage()    {}
func (*ClientMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1a037a92d169acc, []int{8}
}
func (m *ClientMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientMessage.Merge(m, src)
}
func (m *ClientMessage) XXX_Size() int {
	return m.Size()
}
func (m *ClientMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientMessage.DiscardUnknown(m)
}

var xxx_messageInfo_ClientMessage proto.InternalMessageInfo

type isClientMessage_Message interface {
	isClientMessage_Message()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ClientMessage_Header struct {
	Header *Header `protobuf:"bytes,1,opt,name=header,proto3,oneof" json:"header,omitempty"`
}
type ClientMessage_Misbehaviour struct {
	Misbehaviour *Misbehaviour `protobuf:"bytes,2,opt,name=misbehaviour,proto3,oneof" json:"misbehaviour,omitempty"`
}

func (*ClientMessage_Header) isClientMessage_Message()       {}
func (*ClientMessage_Misbehaviour) isClientMessage_Message() {}

func (m *ClientMessage) GetMessage() isClientMessage_Message {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *ClientMessage) GetHeader() *Header {
	if x, ok := m.GetMessage().(*ClientMessage_Header); ok {
		return x.Header
	}
	return nil
}

func (m *ClientMessage) GetMisbehaviour() *Misbehaviour {
	if x, ok := m.GetMessage().(*ClientMessage_Misbehaviour); ok {
		return x.Misbehaviour
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ClientMessage) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ClientMessage_Header)(nil),
		(*ClientMessage_Misbehaviour)(nil),
	}
}

func init() {
	proto.RegisterEnum("ibc.lightclients.grandpa.v1.RelayChain", RelayChain_name, RelayChain_value)
	proto.RegisterType((*Authority)(nil), "ibc.lightclients.grandpa.v1.Authority")
	proto.RegisterType((*ClientState)(nil), "ibc.lightclients.grandpa.v1.ClientState")
	proto.RegisterType((*ParachainHeaderWithRelayHash)(nil), "ibc.lightclients.grandpa.v1.ParachainHeaderWithRelayHash")
	proto.RegisterType((*FinalityProof)(nil), "ibc.lightclients.grandpa.v1.FinalityProof")
	proto.RegisterType((*ParachainHeaderProofs)(nil), "ibc.lightclients.grandpa.v1.ParachainHeaderProofs")
	proto.RegisterType((*ConsensusState)(nil), "ibc.lightclients.grandpa.v1.ConsensusState")
	proto.RegisterType((*Header)(nil), "ibc.lightclients.grandpa.v1.Header")
	proto.RegisterType((*Misbehaviour)(nil), "ibc.lightclients.grandpa.v1.Misbehaviour")
	proto.RegisterType((*ClientMessage)(nil), "ibc.lightclients.grandpa.v1.ClientMessage")
}

func init() { proto.RegisterFile("v1/grandpa.proto", fileDescriptor_e1a037a92d169acc) }

var fileDescriptor_e1a037a92d169acc = []byte{
	// 800 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0x4f, 0x6f, 0x1b, 0x45,
	0x14, 0xf7, 0xc6, 0xa9, 0x53, 0x3f, 0xaf, 0x1d, 0x67, 0xd2, 0xc2, 0xaa, 0xb4, 0xae, 0xb5, 0x54,
	0xd4, 0x44, 0x68, 0x43, 0xcd, 0x05, 0x0e, 0x1c, 0x1c, 0x23, 0xe4, 0x2a, 0x44, 0x0e, 0x93, 0xa2,
	0x9e, 0x60, 0x35, 0x5e, 0x8f, 0xbd, 0x43, 0x36, 0x3b, 0xab, 0x99, 0xd9, 0x14, 0x73, 0xe1, 0xca,
	0x91, 0x0f, 0xc0, 0x27, 0xe0, 0xce, 0x27, 0xe0, 0xc2, 0xb1, 0x47, 0x8e, 0x28, 0xf9, 0x22, 0x68,
	0x67, 0xc6, 0x76, 0x36, 0x44, 0x96, 0x7a, 0x9b, 0x79, 0x7f, 0x7e, 0xef, 0xf7, 0x9b, 0xf7, 0xde,
	0x40, 0xfb, 0xf2, 0xc5, 0xe1, 0x5c, 0x90, 0x74, 0x9a, 0x91, 0x20, 0x13, 0x5c, 0x71, 0xf4, 0x01,
	0x9b, 0x44, 0x41, 0xc2, 0xe6, 0xb1, 0x8a, 0x12, 0x46, 0x53, 0x25, 0x83, 0xa5, 0xff, 0xf2, 0xc5,
	0xa3, 0xa7, 0x73, 0xce, 0xe7, 0x09, 0x3d, 0xd4, 0xa1, 0x93, 0x7c, 0x76, 0xa8, 0xd8, 0x05, 0x95,
	0x8a, 0x5c, 0x64, 0x26, 0xdb, 0x3f, 0x82, 0xfa, 0x20, 0x57, 0x31, 0x17, 0x4c, 0x2d, 0xd0, 0x13,
	0x80, 0x2c, 0x9f, 0x24, 0x2c, 0x0a, 0xcf, 0xe9, 0xc2, 0x73, 0xba, 0x4e, 0xcf, 0xc5, 0x75, 0x63,
	0x39, 0xa6, 0x0b, 0xf4, 0x1e, 0xd4, 0xde, 0xd0, 0xa2, 0x90, 0xb7, 0xd5, 0x75, 0x7a, 0xdb, 0xd8,
	0xde, 0xfc, 0x3f, 0xab, 0xd0, 0x18, 0xea, 0xda, 0x67, 0x8a, 0x28, 0x8a, 0x0e, 0x60, 0x2f, 0x21,
	0x8a, 0x4a, 0x15, 0x0a, 0x9a, 0x90, 0x45, 0x18, 0x13, 0x19, 0x5b, 0xb4, 0x5d, 0xe3, 0xc0, 0x85,
	0x7d, 0x44, 0x64, 0x8c, 0x02, 0xd8, 0x2f, 0xc7, 0xae, 0x0b, 0x34, 0xf1, 0xde, 0xcd, 0x68, 0xed,
	0x40, 0xcf, 0xa0, 0x15, 0xe5, 0x42, 0xd0, 0x54, 0x85, 0x92, 0xaa, 0x90, 0x4d, 0xbd, 0xaa, 0xe6,
	0xe2, 0x5a, 0xeb, 0x19, 0x55, 0x2f, 0xa7, 0xa8, 0x07, 0xcd, 0x99, 0xe0, 0x3f, 0xd3, 0x74, 0x89,
	0xb7, 0x5d, 0x04, 0x8d, 0x2a, 0xd8, 0x35, 0x66, 0x03, 0xf6, 0xab, 0xe3, 0xa0, 0x11, 0x34, 0x4c,
	0xe1, 0x28, 0x26, 0x2c, 0xf5, 0xee, 0x75, 0x9d, 0x5e, 0xab, 0xff, 0x3c, 0xd8, 0xf0, 0xa6, 0x81,
	0xa6, 0x33, 0x2c, 0xc2, 0x31, 0x88, 0xd5, 0x19, 0xbd, 0x0f, 0x3b, 0x19, 0x11, 0xa4, 0xa0, 0x54,
	0xd3, 0xec, 0x6b, 0xc5, 0xf5, 0xe5, 0x14, 0x7d, 0x02, 0xc8, 0x4a, 0xd4, 0x7e, 0xcb, 0x68, 0x47,
	0xc7, 0xb4, 0x8d, 0xe7, 0x94, 0x08, 0x62, 0x05, 0xbe, 0x86, 0xfd, 0xa5, 0x40, 0x62, 0x1b, 0xc3,
	0xa8, 0xf4, 0xee, 0x77, 0xab, 0xbd, 0x46, 0xff, 0xa3, 0x8d, 0xc4, 0x56, 0x8d, 0xc4, 0xc8, 0x42,
	0x0c, 0xd6, 0x08, 0x47, 0x6d, 0x68, 0x85, 0xa5, 0x47, 0xf1, 0x7f, 0x77, 0xe0, 0x71, 0x51, 0x59,
	0x4b, 0x1f, 0x51, 0x32, 0xa5, 0xe2, 0x35, 0x53, 0xf1, 0xba, 0x39, 0x4f, 0x00, 0xfe, 0xd7, 0xc1,
	0xba, 0x58, 0xb9, 0xbf, 0x87, 0x76, 0xb6, 0x4c, 0x0f, 0x63, 0x9d, 0xaf, 0x1b, 0xd7, 0xe8, 0xf7,
	0x37, 0xf2, 0xbc, 0x55, 0xf3, 0x54, 0x70, 0x3e, 0x93, 0x78, 0x37, 0x2b, 0x9b, 0x7d, 0x05, 0xcd,
	0xaf, 0x59, 0x4a, 0x12, 0xa6, 0x16, 0x3a, 0x04, 0x3d, 0x80, 0x7b, 0x93, 0x84, 0x47, 0xe7, 0x96,
	0x89, 0xb9, 0xa0, 0x67, 0xd0, 0xfc, 0x31, 0x97, 0x8a, 0xcd, 0x58, 0x44, 0x14, 0xe3, 0xa9, 0xa6,
	0xe0, 0xe2, 0xb2, 0x11, 0x3d, 0x87, 0xdd, 0x3c, 0x3d, 0x4f, 0xf9, 0x9b, 0x25, 0x53, 0xe9, 0x55,
	0xbb, 0xd5, 0x9e, 0x8b, 0x5b, 0xd6, 0x6c, 0x8a, 0x4a, 0xff, 0x17, 0x78, 0x78, 0x27, 0x3f, 0xf4,
	0x14, 0x1a, 0xb2, 0x18, 0xef, 0x30, 0x2b, 0xee, 0x9e, 0xa3, 0xb3, 0x41, 0x9b, 0x0c, 0xbd, 0xc7,
	0x50, 0xa7, 0x3f, 0x29, 0xc1, 0x52, 0xc9, 0x22, 0x4b, 0x62, 0x6d, 0x28, 0x08, 0xac, 0x2e, 0x16,
	0xc2, 0x12, 0x58, 0x99, 0x35, 0x8c, 0xff, 0x03, 0xb4, 0x86, 0x3c, 0x95, 0x34, 0x95, 0xb9, 0x34,
	0xfb, 0xf4, 0x39, 0xd4, 0x57, 0x6b, 0xab, 0xb5, 0x37, 0xfa, 0x8f, 0x02, 0xb3, 0xd8, 0xc1, 0x72,
	0xb1, 0x83, 0x57, 0xcb, 0x08, 0xbc, 0x0e, 0x46, 0x08, 0xb6, 0x05, 0xe7, 0xca, 0xb2, 0xd1, 0x67,
	0xff, 0x2f, 0x07, 0x6a, 0x46, 0x18, 0xfa, 0x16, 0x5a, 0x33, 0xfb, 0xc2, 0x2b, 0x55, 0x05, 0xfa,
	0xc1, 0xc6, 0xf6, 0x95, 0x9a, 0x82, 0x9b, 0xb3, 0x52, 0x8f, 0x66, 0xb0, 0x77, 0x7b, 0x26, 0xa4,
	0xb7, 0xa5, 0x87, 0xf7, 0x8b, 0x77, 0x19, 0x8a, 0xd2, 0x20, 0xe2, 0xf6, 0xad, 0xd9, 0x90, 0xbe,
	0x02, 0xf7, 0x84, 0xc9, 0x09, 0x8d, 0xc9, 0x25, 0xe3, 0xb9, 0x40, 0x9f, 0xc2, 0x83, 0x19, 0x13,
	0x52, 0x85, 0x77, 0x08, 0x72, 0x31, 0xd2, 0xbe, 0xf2, 0x34, 0xf5, 0xe1, 0xa1, 0xa4, 0x11, 0x4f,
	0xa7, 0xb7, 0x53, 0xcc, 0x63, 0xed, 0x1b, 0x67, 0x29, 0xc7, 0xff, 0xc3, 0x81, 0xa6, 0xf9, 0xe9,
	0x4e, 0xa8, 0x94, 0x64, 0x4e, 0xd1, 0x97, 0x50, 0xb3, 0x93, 0x6f, 0x9e, 0xee, 0xc3, 0x8d, 0x22,
	0x0d, 0xfb, 0x51, 0x05, 0xdb, 0x24, 0x34, 0x06, 0xf7, 0xe2, 0x86, 0x0c, 0xbb, 0x3e, 0x1f, 0x6f,
	0x04, 0xb9, 0xa9, 0xbb, 0xf8, 0xd2, 0x6e, 0x02, 0x1c, 0xd5, 0x61, 0xe7, 0xc2, 0x50, 0x3b, 0xe8,
	0x03, 0xac, 0xbf, 0x2a, 0xe4, 0xc2, 0xfd, 0xd3, 0xf1, 0x37, 0xc7, 0x83, 0xaf, 0xc6, 0xaf, 0xda,
	0x15, 0x04, 0x50, 0x3b, 0xfe, 0xee, 0x6c, 0x70, 0x32, 0x68, 0x3b, 0xc5, 0x19, 0x8f, 0x87, 0xe3,
	0xe1, 0xb8, 0xbd, 0x75, 0xe4, 0xfd, 0x7d, 0xd5, 0x71, 0xde, 0x5e, 0x75, 0x9c, 0x7f, 0xaf, 0x3a,
	0xce, 0x6f, 0xd7, 0x9d, 0xca, 0xdb, 0xeb, 0x4e, 0xe5, 0x9f, 0xeb, 0x4e, 0x65, 0x52, 0xd3, 0x93,
	0xf6, 0xd9, 0x7f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xec, 0x35, 0x90, 0xb5, 0x81, 0x06, 0x00, 0x00,
}

func (m *Authority) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Authority) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Authority) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Weight != 0 {
		i = encodeVarintGrandpa(dAtA, i, uint64(m.Weight))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PublicKey) > 0 {
		i -= len(m.PublicKey)
		copy(dAtA[i:], m.PublicKey)
		i = encodeVarintGrandpa(dAtA, i, uint64(len(m.PublicKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClientState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CurrentAuthorities) > 0 {
		for iNdEx := len(m.CurrentAuthorities) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CurrentAuthorities[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGrandpa(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.LatestParaHeight != 0 {
		i = encodeVarintGrandpa(dAtA, i, uint64(m.LatestParaHeight))
		i--
		dAtA[i] = 0x38
	}
	if m.ParaId != 0 {
		i = encodeVarintGrandpa(dAtA, i, uint64(m.ParaId))
		i--
		dAtA[i] = 0x30
	}
	if m.RelayChain != 0 {
		i = encodeVarintGrandpa(dAtA, i, uint64(m.RelayChain))
		i--
		dAtA[i] = 0x28
	}
	if m.XFrozenHeight != nil {
		{
			size := m.XFrozenHeight.Size()
			i -= size
			if _, err := m.XFrozenHeight.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.CurrentSetId != 0 {
		i = encodeVarintGrandpa(dAtA, i, uint64(m.CurrentSetId))
		i--
		dAtA[i] = 0x18
	}
	if m.LatestRelayHeight != 0 {
		i = encodeVarintGrandpa(dAtA, i, uint64(m.LatestRelayHeight))
		i--
		dAtA[i] = 0x10
	}
	if len(m.LatestRelayHash) > 0 {
		i -= len(m.LatestRelayHash)
		copy(dAtA[i:], m.LatestRelayHash)
		i = encodeVarintGrandpa(dAtA, i, uint64(len(m.LatestRelayHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClientState_FrozenHeight) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientState_FrozenHeight) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintGrandpa(dAtA, i, uint64(m.FrozenHeight))
	i--
	dAtA[i] = 0x20
	return len(dAtA) - i, nil
}
func (m *ParachainHeaderWithRelayHash) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParachainHeaderWithRelayHash) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ParachainHeaderWithRelayHash) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ParachainHeader != nil {
		{
			size, err := m.ParachainHeader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGrandpa(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.RelayHash) > 0 {
		i -= len(m.RelayHash)
		copy(dAtA[i:], m.RelayHash)
		i = encodeVarintGrandpa(dAtA, i, uint64(len(m.RelayHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FinalityProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FinalityProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FinalityProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UnknownHeaders) > 0 {
		for iNdEx := len(m.UnknownHeaders) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.UnknownHeaders[iNdEx])
			copy(dAtA[i:], m.UnknownHeaders[iNdEx])
			i = encodeVarintGrandpa(dAtA, i, uint64(len(m.UnknownHeaders[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Justification) > 0 {
		i -= len(m.Justification)
		copy(dAtA[i:], m.Justification)
		i = encodeVarintGrandpa(dAtA, i, uint64(len(m.Justification)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Block) > 0 {
		i -= len(m.Block)
		copy(dAtA[i:], m.Block)
		i = encodeVarintGrandpa(dAtA, i, uint64(len(m.Block)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ParachainHeaderProofs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParachainHeaderProofs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ParachainHeaderProofs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExtrinsicProof) > 0 {
		for iNdEx := len(m.ExtrinsicProof) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ExtrinsicProof[iNdEx])
			copy(dAtA[i:], m.ExtrinsicProof[iNdEx])
			i = encodeVarintGrandpa(dAtA, i, uint64(len(m.ExtrinsicProof[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Extrinsic) > 0 {
		i -= len(m.Extrinsic)
		copy(dAtA[i:], m.Extrinsic)
		i = encodeVarintGrandpa(dAtA, i, uint64(len(m.Extrinsic)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StateProof) > 0 {
		for iNdEx := len(m.StateProof) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.StateProof[iNdEx])
			copy(dAtA[i:], m.StateProof[iNdEx])
			i = encodeVarintGrandpa(dAtA, i, uint64(len(m.StateProof[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ConsensusState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsensusState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Root) > 0 {
		i -= len(m.Root)
		copy(dAtA[i:], m.Root)
		i = encodeVarintGrandpa(dAtA, i, uint64(len(m.Root)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != nil {
		{
			size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGrandpa(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Header) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Header) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ParachainHeaders) > 0 {
		for iNdEx := len(m.ParachainHeaders) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ParachainHeaders[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGrandpa(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.FinalityProof != nil {
		{
			size, err := m.FinalityProof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGrandpa(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Misbehaviour) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Misbehaviour) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Misbehaviour) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SecondFinalityProof) > 0 {
		i -= len(m.SecondFinalityProof)
		copy(dAtA[i:], m.SecondFinalityProof)
		i = encodeVarintGrandpa(dAtA, i, uint64(len(m.SecondFinalityProof)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FirstFinalityProof) > 0 {
		i -= len(m.FirstFinalityProof)
		copy(dAtA[i:], m.FirstFinalityProof)
		i = encodeVarintGrandpa(dAtA, i, uint64(len(m.FirstFinalityProof)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClientMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Message != nil {
		{
			size := m.Message.Size()
			i -= size
			if _, err := m.Message.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ClientMessage_Header) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientMessage_Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGrandpa(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ClientMessage_Misbehaviour) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientMessage_Misbehaviour) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Misbehaviour != nil {
		{
			size, err := m.Misbehaviour.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGrandpa(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func encodeVarintGrandpa(dAtA []byte, offset int, v uint64) int {
	offset -= sovGrandpa(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Authority) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovGrandpa(uint64(l))
	}
	if m.Weight != 0 {
		n += 1 + sovGrandpa(uint64(m.Weight))
	}
	return n
}

func (m *ClientState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LatestRelayHash)
	if l > 0 {
		n += 1 + l + sovGrandpa(uint64(l))
	}
	if m.LatestRelayHeight != 0 {
		n += 1 + sovGrandpa(uint64(m.LatestRelayHeight))
	}
	if m.CurrentSetId != 0 {
		n += 1 + sovGrandpa(uint64(m.CurrentSetId))
	}
	if m.XFrozenHeight != nil {
		n += m.XFrozenHeight.Size()
	}
	if m.RelayChain != 0 {
		n += 1 + sovGrandpa(uint64(m.RelayChain))
	}
	if m.ParaId != 0 {
		n += 1 + sovGrandpa(uint64(m.ParaId))
	}
	if m.LatestParaHeight != 0 {
		n += 1 + sovGrandpa(uint64(m.LatestParaHeight))
	}
	if len(m.CurrentAuthorities) > 0 {
		for _, e := range m.CurrentAuthorities {
			l = e.Size()
			n += 1 + l + sovGrandpa(uint64(l))
		}
	}
	return n
}

func (m *ClientState_FrozenHeight) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovGrandpa(uint64(m.FrozenHeight))
	return n
}
func (m *ParachainHeaderWithRelayHash) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RelayHash)
	if l > 0 {
		n += 1 + l + sovGrandpa(uint64(l))
	}
	if m.ParachainHeader != nil {
		l = m.ParachainHeader.Size()
		n += 1 + l + sovGrandpa(uint64(l))
	}
	return n
}

func (m *FinalityProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Block)
	if l > 0 {
		n += 1 + l + sovGrandpa(uint64(l))
	}
	l = len(m.Justification)
	if l > 0 {
		n += 1 + l + sovGrandpa(uint64(l))
	}
	if len(m.UnknownHeaders) > 0 {
		for _, b := range m.UnknownHeaders {
			l = len(b)
			n += 1 + l + sovGrandpa(uint64(l))
		}
	}
	return n
}

func (m *ParachainHeaderProofs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.StateProof) > 0 {
		for _, b := range m.StateProof {
			l = len(b)
			n += 1 + l + sovGrandpa(uint64(l))
		}
	}
	l = len(m.Extrinsic)
	if l > 0 {
		n += 1 + l + sovGrandpa(uint64(l))
	}
	if len(m.ExtrinsicProof) > 0 {
		for _, b := range m.ExtrinsicProof {
			l = len(b)
			n += 1 + l + sovGrandpa(uint64(l))
		}
	}
	return n
}

func (m *ConsensusState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovGrandpa(uint64(l))
	}
	l = len(m.Root)
	if l > 0 {
		n += 1 + l + sovGrandpa(uint64(l))
	}
	return n
}

func (m *Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FinalityProof != nil {
		l = m.FinalityProof.Size()
		n += 1 + l + sovGrandpa(uint64(l))
	}
	if len(m.ParachainHeaders) > 0 {
		for _, e := range m.ParachainHeaders {
			l = e.Size()
			n += 1 + l + sovGrandpa(uint64(l))
		}
	}
	return n
}

func (m *Misbehaviour) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FirstFinalityProof)
	if l > 0 {
		n += 1 + l + sovGrandpa(uint64(l))
	}
	l = len(m.SecondFinalityProof)
	if l > 0 {
		n += 1 + l + sovGrandpa(uint64(l))
	}
	return n
}

func (m *ClientMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Message != nil {
		n += m.Message.Size()
	}
	return n
}

func (m *ClientMessage_Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovGrandpa(uint64(l))
	}
	return n
}
func (m *ClientMessage_Misbehaviour) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Misbehaviour != nil {
		l = m.Misbehaviour.Size()
		n += 1 + l + sovGrandpa(uint64(l))
	}
	return n
}

func sovGrandpa(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGrandpa(x uint64) (n int) {
	return sovGrandpa(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Authority) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Authority: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Authority: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = append(m.PublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKey == nil {
				m.PublicKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			m.Weight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Weight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGrandpa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrandpa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestRelayHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LatestRelayHash = append(m.LatestRelayHash[:0], dAtA[iNdEx:postIndex]...)
			if m.LatestRelayHash == nil {
				m.LatestRelayHash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestRelayHeight", wireType)
			}
			m.LatestRelayHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LatestRelayHeight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentSetId", wireType)
			}
			m.CurrentSetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentSetId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrozenHeight", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.XFrozenHeight = &ClientState_FrozenHeight{v}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayChain", wireType)
			}
			m.RelayChain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RelayChain |= RelayChain(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParaId", wireType)
			}
			m.ParaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParaId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestParaHeight", wireType)
			}
			m.LatestParaHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LatestParaHeight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentAuthorities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrentAuthorities = append(m.CurrentAuthorities, &Authority{})
			if err := m.CurrentAuthorities[len(m.CurrentAuthorities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrandpa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrandpa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParachainHeaderWithRelayHash) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParachainHeaderWithRelayHash: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParachainHeaderWithRelayHash: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelayHash = append(m.RelayHash[:0], dAtA[iNdEx:postIndex]...)
			if m.RelayHash == nil {
				m.RelayHash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParachainHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParachainHeader == nil {
				m.ParachainHeader = &ParachainHeaderProofs{}
			}
			if err := m.ParachainHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrandpa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrandpa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FinalityProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FinalityProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FinalityProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Block = append(m.Block[:0], dAtA[iNdEx:postIndex]...)
			if m.Block == nil {
				m.Block = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Justification", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Justification = append(m.Justification[:0], dAtA[iNdEx:postIndex]...)
			if m.Justification == nil {
				m.Justification = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnknownHeaders", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnknownHeaders = append(m.UnknownHeaders, make([]byte, postIndex-iNdEx))
			copy(m.UnknownHeaders[len(m.UnknownHeaders)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrandpa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrandpa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParachainHeaderProofs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParachainHeaderProofs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParachainHeaderProofs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateProof", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StateProof = append(m.StateProof, make([]byte, postIndex-iNdEx))
			copy(m.StateProof[len(m.StateProof)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extrinsic", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Extrinsic = append(m.Extrinsic[:0], dAtA[iNdEx:postIndex]...)
			if m.Extrinsic == nil {
				m.Extrinsic = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtrinsicProof", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtrinsicProof = append(m.ExtrinsicProof, make([]byte, postIndex-iNdEx))
			copy(m.ExtrinsicProof[len(m.ExtrinsicProof)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrandpa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrandpa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &timestamppb.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Root = append(m.Root[:0], dAtA[iNdEx:postIndex]...)
			if m.Root == nil {
				m.Root = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrandpa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrandpa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Header) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalityProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FinalityProof == nil {
				m.FinalityProof = &FinalityProof{}
			}
			if err := m.FinalityProof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParachainHeaders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParachainHeaders = append(m.ParachainHeaders, &ParachainHeaderWithRelayHash{})
			if err := m.ParachainHeaders[len(m.ParachainHeaders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrandpa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrandpa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Misbehaviour) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Misbehaviour: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Misbehaviour: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstFinalityProof", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstFinalityProof = append(m.FirstFinalityProof[:0], dAtA[iNdEx:postIndex]...)
			if m.FirstFinalityProof == nil {
				m.FirstFinalityProof = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondFinalityProof", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecondFinalityProof = append(m.SecondFinalityProof[:0], dAtA[iNdEx:postIndex]...)
			if m.SecondFinalityProof == nil {
				m.SecondFinalityProof = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrandpa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrandpa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Header{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &ClientMessage_Header{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Misbehaviour", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Misbehaviour{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &ClientMessage_Misbehaviour{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrandpa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrandpa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGrandpa(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGrandpa
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGrandpa
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGrandpa
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGrandpa        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGrandpa          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGrandpa = fmt.Errorf("proto: unexpected end of group")
)
