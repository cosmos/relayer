// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: penumbra/custody/threshold/v1/threshold.proto

package thresholdv1

import (
	fmt "fmt"
	proto "github.com/cosmos/gogoproto/proto"
	v12 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/component/governance/v1"
	v11 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/component/stake/v1"
	v1 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/transaction/v1"
	v13 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/crypto/decaf377_frost/v1"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// A key one can use to verify signatures.
//
// This key can also serve as a unique identifier for users.
type VerificationKey struct {
	Inner []byte `protobuf:"bytes,1,opt,name=inner,proto3" json:"inner,omitempty"`
}

func (m *VerificationKey) Reset()         { *m = VerificationKey{} }
func (m *VerificationKey) String() string { return proto.CompactTextString(m) }
func (*VerificationKey) ProtoMessage()    {}
func (*VerificationKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_d60f2e30e69d733f, []int{0}
}
func (m *VerificationKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerificationKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerificationKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerificationKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerificationKey.Merge(m, src)
}
func (m *VerificationKey) XXX_Size() int {
	return m.Size()
}
func (m *VerificationKey) XXX_DiscardUnknown() {
	xxx_messageInfo_VerificationKey.DiscardUnknown(m)
}

var xxx_messageInfo_VerificationKey proto.InternalMessageInfo

func (m *VerificationKey) GetInner() []byte {
	if m != nil {
		return m.Inner
	}
	return nil
}

// A signature proving that a message was created by the owner of a verification key.
type Signature struct {
	Inner []byte `protobuf:"bytes,1,opt,name=inner,proto3" json:"inner,omitempty"`
}

func (m *Signature) Reset()         { *m = Signature{} }
func (m *Signature) String() string { return proto.CompactTextString(m) }
func (*Signature) ProtoMessage()    {}
func (*Signature) Descriptor() ([]byte, []int) {
	return fileDescriptor_d60f2e30e69d733f, []int{1}
}
func (m *Signature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Signature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Signature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Signature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Signature.Merge(m, src)
}
func (m *Signature) XXX_Size() int {
	return m.Size()
}
func (m *Signature) XXX_DiscardUnknown() {
	xxx_messageInfo_Signature.DiscardUnknown(m)
}

var xxx_messageInfo_Signature proto.InternalMessageInfo

func (m *Signature) GetInner() []byte {
	if m != nil {
		return m.Inner
	}
	return nil
}

// The message the coordinator sends in round 1 of the signing protocol.
type CoordinatorRound1 struct {
	// Types that are valid to be assigned to Request:
	//	*CoordinatorRound1_Plan
	//	*CoordinatorRound1_ValidatorDefinition
	//	*CoordinatorRound1_ValidatorVote
	Request isCoordinatorRound1_Request `protobuf_oneof:"request"`
}

func (m *CoordinatorRound1) Reset()         { *m = CoordinatorRound1{} }
func (m *CoordinatorRound1) String() string { return proto.CompactTextString(m) }
func (*CoordinatorRound1) ProtoMessage()    {}
func (*CoordinatorRound1) Descriptor() ([]byte, []int) {
	return fileDescriptor_d60f2e30e69d733f, []int{2}
}
func (m *CoordinatorRound1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CoordinatorRound1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CoordinatorRound1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CoordinatorRound1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CoordinatorRound1.Merge(m, src)
}
func (m *CoordinatorRound1) XXX_Size() int {
	return m.Size()
}
func (m *CoordinatorRound1) XXX_DiscardUnknown() {
	xxx_messageInfo_CoordinatorRound1.DiscardUnknown(m)
}

var xxx_messageInfo_CoordinatorRound1 proto.InternalMessageInfo

type isCoordinatorRound1_Request interface {
	isCoordinatorRound1_Request()
	MarshalTo([]byte) (int, error)
	Size() int
}

type CoordinatorRound1_Plan struct {
	Plan *v1.TransactionPlan `protobuf:"bytes,1,opt,name=plan,proto3,oneof" json:"plan,omitempty"`
}
type CoordinatorRound1_ValidatorDefinition struct {
	ValidatorDefinition *v11.Validator `protobuf:"bytes,2,opt,name=validator_definition,json=validatorDefinition,proto3,oneof" json:"validator_definition,omitempty"`
}
type CoordinatorRound1_ValidatorVote struct {
	ValidatorVote *v12.ValidatorVoteBody `protobuf:"bytes,3,opt,name=validator_vote,json=validatorVote,proto3,oneof" json:"validator_vote,omitempty"`
}

func (*CoordinatorRound1_Plan) isCoordinatorRound1_Request()                {}
func (*CoordinatorRound1_ValidatorDefinition) isCoordinatorRound1_Request() {}
func (*CoordinatorRound1_ValidatorVote) isCoordinatorRound1_Request()       {}

func (m *CoordinatorRound1) GetRequest() isCoordinatorRound1_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *CoordinatorRound1) GetPlan() *v1.TransactionPlan {
	if x, ok := m.GetRequest().(*CoordinatorRound1_Plan); ok {
		return x.Plan
	}
	return nil
}

func (m *CoordinatorRound1) GetValidatorDefinition() *v11.Validator {
	if x, ok := m.GetRequest().(*CoordinatorRound1_ValidatorDefinition); ok {
		return x.ValidatorDefinition
	}
	return nil
}

func (m *CoordinatorRound1) GetValidatorVote() *v12.ValidatorVoteBody {
	if x, ok := m.GetRequest().(*CoordinatorRound1_ValidatorVote); ok {
		return x.ValidatorVote
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CoordinatorRound1) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CoordinatorRound1_Plan)(nil),
		(*CoordinatorRound1_ValidatorDefinition)(nil),
		(*CoordinatorRound1_ValidatorVote)(nil),
	}
}

// The message the coordinator sends in round 2 of the signing protocol.
type CoordinatorRound2 struct {
	// The underlying signing packages being sent to the followers, for each signature.
	SigningPackages []*CoordinatorRound2_PartialSigningPackage `protobuf:"bytes,1,rep,name=signing_packages,json=signingPackages,proto3" json:"signing_packages,omitempty"`
}

func (m *CoordinatorRound2) Reset()         { *m = CoordinatorRound2{} }
func (m *CoordinatorRound2) String() string { return proto.CompactTextString(m) }
func (*CoordinatorRound2) ProtoMessage()    {}
func (*CoordinatorRound2) Descriptor() ([]byte, []int) {
	return fileDescriptor_d60f2e30e69d733f, []int{3}
}
func (m *CoordinatorRound2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CoordinatorRound2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CoordinatorRound2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CoordinatorRound2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CoordinatorRound2.Merge(m, src)
}
func (m *CoordinatorRound2) XXX_Size() int {
	return m.Size()
}
func (m *CoordinatorRound2) XXX_DiscardUnknown() {
	xxx_messageInfo_CoordinatorRound2.DiscardUnknown(m)
}

var xxx_messageInfo_CoordinatorRound2 proto.InternalMessageInfo

func (m *CoordinatorRound2) GetSigningPackages() []*CoordinatorRound2_PartialSigningPackage {
	if m != nil {
		return m.SigningPackages
	}
	return nil
}

// A commitment along with a FROST identifier.
type CoordinatorRound2_IdentifiedCommitments struct {
	// The serialization of a FROST identifier.
	Identifier []byte `protobuf:"bytes,1,opt,name=identifier,proto3" json:"identifier,omitempty"`
	// The commitments this person has produced for this round of signing.
	Commitments *v13.SigningCommitments `protobuf:"bytes,2,opt,name=commitments,proto3" json:"commitments,omitempty"`
}

func (m *CoordinatorRound2_IdentifiedCommitments) Reset() {
	*m = CoordinatorRound2_IdentifiedCommitments{}
}
func (m *CoordinatorRound2_IdentifiedCommitments) String() string { return proto.CompactTextString(m) }
func (*CoordinatorRound2_IdentifiedCommitments) ProtoMessage()    {}
func (*CoordinatorRound2_IdentifiedCommitments) Descriptor() ([]byte, []int) {
	return fileDescriptor_d60f2e30e69d733f, []int{3, 0}
}
func (m *CoordinatorRound2_IdentifiedCommitments) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CoordinatorRound2_IdentifiedCommitments) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CoordinatorRound2_IdentifiedCommitments.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CoordinatorRound2_IdentifiedCommitments) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CoordinatorRound2_IdentifiedCommitments.Merge(m, src)
}
func (m *CoordinatorRound2_IdentifiedCommitments) XXX_Size() int {
	return m.Size()
}
func (m *CoordinatorRound2_IdentifiedCommitments) XXX_DiscardUnknown() {
	xxx_messageInfo_CoordinatorRound2_IdentifiedCommitments.DiscardUnknown(m)
}

var xxx_messageInfo_CoordinatorRound2_IdentifiedCommitments proto.InternalMessageInfo

func (m *CoordinatorRound2_IdentifiedCommitments) GetIdentifier() []byte {
	if m != nil {
		return m.Identifier
	}
	return nil
}

func (m *CoordinatorRound2_IdentifiedCommitments) GetCommitments() *v13.SigningCommitments {
	if m != nil {
		return m.Commitments
	}
	return nil
}

// A FROST signing package without a message.
//
// We structure things this way because the message is derived from the transaction plan.
// FROST expects the signing package to include the identified commitments *and*
// the message, but we have no need to include the message.
type CoordinatorRound2_PartialSigningPackage struct {
	AllCommitments []*CoordinatorRound2_IdentifiedCommitments `protobuf:"bytes,1,rep,name=all_commitments,json=allCommitments,proto3" json:"all_commitments,omitempty"`
}

func (m *CoordinatorRound2_PartialSigningPackage) Reset() {
	*m = CoordinatorRound2_PartialSigningPackage{}
}
func (m *CoordinatorRound2_PartialSigningPackage) String() string { return proto.CompactTextString(m) }
func (*CoordinatorRound2_PartialSigningPackage) ProtoMessage()    {}
func (*CoordinatorRound2_PartialSigningPackage) Descriptor() ([]byte, []int) {
	return fileDescriptor_d60f2e30e69d733f, []int{3, 1}
}
func (m *CoordinatorRound2_PartialSigningPackage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CoordinatorRound2_PartialSigningPackage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CoordinatorRound2_PartialSigningPackage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CoordinatorRound2_PartialSigningPackage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CoordinatorRound2_PartialSigningPackage.Merge(m, src)
}
func (m *CoordinatorRound2_PartialSigningPackage) XXX_Size() int {
	return m.Size()
}
func (m *CoordinatorRound2_PartialSigningPackage) XXX_DiscardUnknown() {
	xxx_messageInfo_CoordinatorRound2_PartialSigningPackage.DiscardUnknown(m)
}

var xxx_messageInfo_CoordinatorRound2_PartialSigningPackage proto.InternalMessageInfo

func (m *CoordinatorRound2_PartialSigningPackage) GetAllCommitments() []*CoordinatorRound2_IdentifiedCommitments {
	if m != nil {
		return m.AllCommitments
	}
	return nil
}

// The first message the followers send back to the coordinator when signing.
type FollowerRound1 struct {
	Inner *FollowerRound1_Inner `protobuf:"bytes,1,opt,name=inner,proto3" json:"inner,omitempty"`
	// The verification key identifying the sender.
	Pk *VerificationKey `protobuf:"bytes,2,opt,name=pk,proto3" json:"pk,omitempty"`
	// A signature over the proto-encoded bytes of inner.
	Sig *Signature `protobuf:"bytes,3,opt,name=sig,proto3" json:"sig,omitempty"`
}

func (m *FollowerRound1) Reset()         { *m = FollowerRound1{} }
func (m *FollowerRound1) String() string { return proto.CompactTextString(m) }
func (*FollowerRound1) ProtoMessage()    {}
func (*FollowerRound1) Descriptor() ([]byte, []int) {
	return fileDescriptor_d60f2e30e69d733f, []int{4}
}
func (m *FollowerRound1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FollowerRound1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FollowerRound1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FollowerRound1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FollowerRound1.Merge(m, src)
}
func (m *FollowerRound1) XXX_Size() int {
	return m.Size()
}
func (m *FollowerRound1) XXX_DiscardUnknown() {
	xxx_messageInfo_FollowerRound1.DiscardUnknown(m)
}

var xxx_messageInfo_FollowerRound1 proto.InternalMessageInfo

func (m *FollowerRound1) GetInner() *FollowerRound1_Inner {
	if m != nil {
		return m.Inner
	}
	return nil
}

func (m *FollowerRound1) GetPk() *VerificationKey {
	if m != nil {
		return m.Pk
	}
	return nil
}

func (m *FollowerRound1) GetSig() *Signature {
	if m != nil {
		return m.Sig
	}
	return nil
}

// The inner message that will be signed by the follower.
type FollowerRound1_Inner struct {
	// One signing commitment pair for each signature requested by the plan, in order.
	Commitments []*v13.SigningCommitments `protobuf:"bytes,1,rep,name=commitments,proto3" json:"commitments,omitempty"`
}

func (m *FollowerRound1_Inner) Reset()         { *m = FollowerRound1_Inner{} }
func (m *FollowerRound1_Inner) String() string { return proto.CompactTextString(m) }
func (*FollowerRound1_Inner) ProtoMessage()    {}
func (*FollowerRound1_Inner) Descriptor() ([]byte, []int) {
	return fileDescriptor_d60f2e30e69d733f, []int{4, 0}
}
func (m *FollowerRound1_Inner) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FollowerRound1_Inner) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FollowerRound1_Inner.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FollowerRound1_Inner) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FollowerRound1_Inner.Merge(m, src)
}
func (m *FollowerRound1_Inner) XXX_Size() int {
	return m.Size()
}
func (m *FollowerRound1_Inner) XXX_DiscardUnknown() {
	xxx_messageInfo_FollowerRound1_Inner.DiscardUnknown(m)
}

var xxx_messageInfo_FollowerRound1_Inner proto.InternalMessageInfo

func (m *FollowerRound1_Inner) GetCommitments() []*v13.SigningCommitments {
	if m != nil {
		return m.Commitments
	}
	return nil
}

// The second message the followers send back to the coordinator when signing.
type FollowerRound2 struct {
	Inner *FollowerRound2_Inner `protobuf:"bytes,1,opt,name=inner,proto3" json:"inner,omitempty"`
	// The verification key identifying the sender.
	Pk *VerificationKey `protobuf:"bytes,2,opt,name=pk,proto3" json:"pk,omitempty"`
	// A signature over the proto-encoded bytes of inner.
	Sig *Signature `protobuf:"bytes,3,opt,name=sig,proto3" json:"sig,omitempty"`
}

func (m *FollowerRound2) Reset()         { *m = FollowerRound2{} }
func (m *FollowerRound2) String() string { return proto.CompactTextString(m) }
func (*FollowerRound2) ProtoMessage()    {}
func (*FollowerRound2) Descriptor() ([]byte, []int) {
	return fileDescriptor_d60f2e30e69d733f, []int{5}
}
func (m *FollowerRound2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FollowerRound2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FollowerRound2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FollowerRound2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FollowerRound2.Merge(m, src)
}
func (m *FollowerRound2) XXX_Size() int {
	return m.Size()
}
func (m *FollowerRound2) XXX_DiscardUnknown() {
	xxx_messageInfo_FollowerRound2.DiscardUnknown(m)
}

var xxx_messageInfo_FollowerRound2 proto.InternalMessageInfo

func (m *FollowerRound2) GetInner() *FollowerRound2_Inner {
	if m != nil {
		return m.Inner
	}
	return nil
}

func (m *FollowerRound2) GetPk() *VerificationKey {
	if m != nil {
		return m.Pk
	}
	return nil
}

func (m *FollowerRound2) GetSig() *Signature {
	if m != nil {
		return m.Sig
	}
	return nil
}

// The inner message that will be signed by the follower.
type FollowerRound2_Inner struct {
	// One share for each signature requested by the plan, in order.
	Shares []*v13.SignatureShare `protobuf:"bytes,1,rep,name=shares,proto3" json:"shares,omitempty"`
}

func (m *FollowerRound2_Inner) Reset()         { *m = FollowerRound2_Inner{} }
func (m *FollowerRound2_Inner) String() string { return proto.CompactTextString(m) }
func (*FollowerRound2_Inner) ProtoMessage()    {}
func (*FollowerRound2_Inner) Descriptor() ([]byte, []int) {
	return fileDescriptor_d60f2e30e69d733f, []int{5, 0}
}
func (m *FollowerRound2_Inner) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FollowerRound2_Inner) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FollowerRound2_Inner.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FollowerRound2_Inner) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FollowerRound2_Inner.Merge(m, src)
}
func (m *FollowerRound2_Inner) XXX_Size() int {
	return m.Size()
}
func (m *FollowerRound2_Inner) XXX_DiscardUnknown() {
	xxx_messageInfo_FollowerRound2_Inner.DiscardUnknown(m)
}

var xxx_messageInfo_FollowerRound2_Inner proto.InternalMessageInfo

func (m *FollowerRound2_Inner) GetShares() []*v13.SignatureShare {
	if m != nil {
		return m.Shares
	}
	return nil
}

// The first message we broadcast in the DKG protocol.
type DKGRound1 struct {
	// The package we're sending to other people
	Pkg *v13.DKGRound1Package `protobuf:"bytes,1,opt,name=pkg,proto3" json:"pkg,omitempty"`
	// A commitment to a share of the nullifier-deriving key
	NullifierCommitment []byte `protobuf:"bytes,2,opt,name=nullifier_commitment,json=nullifierCommitment,proto3" json:"nullifier_commitment,omitempty"`
	// An encryption key for the second round.
	Epk []byte `protobuf:"bytes,3,opt,name=epk,proto3" json:"epk,omitempty"`
	// A verification key establishing an identity for the sender of this message.
	Vk []byte `protobuf:"bytes,4,opt,name=vk,proto3" json:"vk,omitempty"`
}

func (m *DKGRound1) Reset()         { *m = DKGRound1{} }
func (m *DKGRound1) String() string { return proto.CompactTextString(m) }
func (*DKGRound1) ProtoMessage()    {}
func (*DKGRound1) Descriptor() ([]byte, []int) {
	return fileDescriptor_d60f2e30e69d733f, []int{6}
}
func (m *DKGRound1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DKGRound1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DKGRound1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DKGRound1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DKGRound1.Merge(m, src)
}
func (m *DKGRound1) XXX_Size() int {
	return m.Size()
}
func (m *DKGRound1) XXX_DiscardUnknown() {
	xxx_messageInfo_DKGRound1.DiscardUnknown(m)
}

var xxx_messageInfo_DKGRound1 proto.InternalMessageInfo

func (m *DKGRound1) GetPkg() *v13.DKGRound1Package {
	if m != nil {
		return m.Pkg
	}
	return nil
}

func (m *DKGRound1) GetNullifierCommitment() []byte {
	if m != nil {
		return m.NullifierCommitment
	}
	return nil
}

func (m *DKGRound1) GetEpk() []byte {
	if m != nil {
		return m.Epk
	}
	return nil
}

func (m *DKGRound1) GetVk() []byte {
	if m != nil {
		return m.Vk
	}
	return nil
}

// The second message we broadcast in the DKG protocol.
type DKGRound2 struct {
	Inner *DKGRound2_Inner `protobuf:"bytes,1,opt,name=inner,proto3" json:"inner,omitempty"`
	// The verification key identifying the sender.
	Vk []byte `protobuf:"bytes,2,opt,name=vk,proto3" json:"vk,omitempty"`
	// A signature over the proto-encoded inner message.
	Sig []byte `protobuf:"bytes,3,opt,name=sig,proto3" json:"sig,omitempty"`
}

func (m *DKGRound2) Reset()         { *m = DKGRound2{} }
func (m *DKGRound2) String() string { return proto.CompactTextString(m) }
func (*DKGRound2) ProtoMessage()    {}
func (*DKGRound2) Descriptor() ([]byte, []int) {
	return fileDescriptor_d60f2e30e69d733f, []int{7}
}
func (m *DKGRound2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DKGRound2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DKGRound2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DKGRound2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DKGRound2.Merge(m, src)
}
func (m *DKGRound2) XXX_Size() int {
	return m.Size()
}
func (m *DKGRound2) XXX_DiscardUnknown() {
	xxx_messageInfo_DKGRound2.DiscardUnknown(m)
}

var xxx_messageInfo_DKGRound2 proto.InternalMessageInfo

func (m *DKGRound2) GetInner() *DKGRound2_Inner {
	if m != nil {
		return m.Inner
	}
	return nil
}

func (m *DKGRound2) GetVk() []byte {
	if m != nil {
		return m.Vk
	}
	return nil
}

func (m *DKGRound2) GetSig() []byte {
	if m != nil {
		return m.Sig
	}
	return nil
}

// A round2 package, encrypted, along with an identifier for the recipient.
type DKGRound2_TargetedPackage struct {
	// A verification key identifying the recipient.
	Vk []byte `protobuf:"bytes,1,opt,name=vk,proto3" json:"vk,omitempty"`
	// The ciphertext of an encrypted frost package for round 2.
	EncryptedPackage []byte `protobuf:"bytes,2,opt,name=encrypted_package,json=encryptedPackage,proto3" json:"encrypted_package,omitempty"`
}

func (m *DKGRound2_TargetedPackage) Reset()         { *m = DKGRound2_TargetedPackage{} }
func (m *DKGRound2_TargetedPackage) String() string { return proto.CompactTextString(m) }
func (*DKGRound2_TargetedPackage) ProtoMessage()    {}
func (*DKGRound2_TargetedPackage) Descriptor() ([]byte, []int) {
	return fileDescriptor_d60f2e30e69d733f, []int{7, 0}
}
func (m *DKGRound2_TargetedPackage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DKGRound2_TargetedPackage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DKGRound2_TargetedPackage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DKGRound2_TargetedPackage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DKGRound2_TargetedPackage.Merge(m, src)
}
func (m *DKGRound2_TargetedPackage) XXX_Size() int {
	return m.Size()
}
func (m *DKGRound2_TargetedPackage) XXX_DiscardUnknown() {
	xxx_messageInfo_DKGRound2_TargetedPackage.DiscardUnknown(m)
}

var xxx_messageInfo_DKGRound2_TargetedPackage proto.InternalMessageInfo

func (m *DKGRound2_TargetedPackage) GetVk() []byte {
	if m != nil {
		return m.Vk
	}
	return nil
}

func (m *DKGRound2_TargetedPackage) GetEncryptedPackage() []byte {
	if m != nil {
		return m.EncryptedPackage
	}
	return nil
}

// An inner message that will be signed.
type DKGRound2_Inner struct {
	// Encrypted packages for each recipient.
	EncryptedPackages []*DKGRound2_TargetedPackage `protobuf:"bytes,1,rep,name=encrypted_packages,json=encryptedPackages,proto3" json:"encrypted_packages,omitempty"`
	// An opening of the share of the nullifier-deriving key commitment
	Nullifier []byte `protobuf:"bytes,2,opt,name=nullifier,proto3" json:"nullifier,omitempty"`
}

func (m *DKGRound2_Inner) Reset()         { *m = DKGRound2_Inner{} }
func (m *DKGRound2_Inner) String() string { return proto.CompactTextString(m) }
func (*DKGRound2_Inner) ProtoMessage()    {}
func (*DKGRound2_Inner) Descriptor() ([]byte, []int) {
	return fileDescriptor_d60f2e30e69d733f, []int{7, 1}
}
func (m *DKGRound2_Inner) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DKGRound2_Inner) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DKGRound2_Inner.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DKGRound2_Inner) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DKGRound2_Inner.Merge(m, src)
}
func (m *DKGRound2_Inner) XXX_Size() int {
	return m.Size()
}
func (m *DKGRound2_Inner) XXX_DiscardUnknown() {
	xxx_messageInfo_DKGRound2_Inner.DiscardUnknown(m)
}

var xxx_messageInfo_DKGRound2_Inner proto.InternalMessageInfo

func (m *DKGRound2_Inner) GetEncryptedPackages() []*DKGRound2_TargetedPackage {
	if m != nil {
		return m.EncryptedPackages
	}
	return nil
}

func (m *DKGRound2_Inner) GetNullifier() []byte {
	if m != nil {
		return m.Nullifier
	}
	return nil
}

func init() {
	proto.RegisterType((*VerificationKey)(nil), "penumbra.custody.threshold.v1.VerificationKey")
	proto.RegisterType((*Signature)(nil), "penumbra.custody.threshold.v1.Signature")
	proto.RegisterType((*CoordinatorRound1)(nil), "penumbra.custody.threshold.v1.CoordinatorRound1")
	proto.RegisterType((*CoordinatorRound2)(nil), "penumbra.custody.threshold.v1.CoordinatorRound2")
	proto.RegisterType((*CoordinatorRound2_IdentifiedCommitments)(nil), "penumbra.custody.threshold.v1.CoordinatorRound2.IdentifiedCommitments")
	proto.RegisterType((*CoordinatorRound2_PartialSigningPackage)(nil), "penumbra.custody.threshold.v1.CoordinatorRound2.PartialSigningPackage")
	proto.RegisterType((*FollowerRound1)(nil), "penumbra.custody.threshold.v1.FollowerRound1")
	proto.RegisterType((*FollowerRound1_Inner)(nil), "penumbra.custody.threshold.v1.FollowerRound1.Inner")
	proto.RegisterType((*FollowerRound2)(nil), "penumbra.custody.threshold.v1.FollowerRound2")
	proto.RegisterType((*FollowerRound2_Inner)(nil), "penumbra.custody.threshold.v1.FollowerRound2.Inner")
	proto.RegisterType((*DKGRound1)(nil), "penumbra.custody.threshold.v1.DKGRound1")
	proto.RegisterType((*DKGRound2)(nil), "penumbra.custody.threshold.v1.DKGRound2")
	proto.RegisterType((*DKGRound2_TargetedPackage)(nil), "penumbra.custody.threshold.v1.DKGRound2.TargetedPackage")
	proto.RegisterType((*DKGRound2_Inner)(nil), "penumbra.custody.threshold.v1.DKGRound2.Inner")
}

func init() {
	proto.RegisterFile("penumbra/custody/threshold/v1/threshold.proto", fileDescriptor_d60f2e30e69d733f)
}

var fileDescriptor_d60f2e30e69d733f = []byte{
	// 928 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x56, 0xdd, 0x6e, 0x1b, 0x45,
	0x14, 0xf6, 0xae, 0xdb, 0xa2, 0x4c, 0x82, 0x93, 0x4c, 0x53, 0xc9, 0xb2, 0xa8, 0x95, 0xfa, 0x86,
	0xa0, 0xd2, 0x59, 0xad, 0x23, 0x68, 0x65, 0x24, 0x2e, 0xe2, 0xd0, 0x26, 0xaa, 0x40, 0xd6, 0x26,
	0x18, 0x09, 0x45, 0x4a, 0x27, 0xbb, 0xe3, 0xf5, 0x68, 0xd7, 0x33, 0xdb, 0x99, 0xf1, 0x22, 0xbf,
	0x01, 0x57, 0xa8, 0xcf, 0x80, 0x90, 0x40, 0xf0, 0x04, 0x7d, 0x03, 0xc4, 0x55, 0x2f, 0xb8, 0xe0,
	0x12, 0x25, 0x77, 0x3c, 0x05, 0xda, 0xbf, 0xd9, 0xb5, 0xf3, 0xe3, 0x0a, 0xb8, 0xe0, 0x6e, 0xcf,
	0xcc, 0xf9, 0xbe, 0xf3, 0xed, 0x77, 0xce, 0xb1, 0x17, 0x3c, 0x8a, 0x08, 0x9b, 0x4e, 0xce, 0x04,
	0xb6, 0xdc, 0xa9, 0x54, 0xdc, 0x9b, 0x59, 0x6a, 0x2c, 0x88, 0x1c, 0xf3, 0xd0, 0xb3, 0x62, 0xbb,
	0x0c, 0x50, 0x24, 0xb8, 0xe2, 0xf0, 0x7e, 0x91, 0x8e, 0xf2, 0x74, 0x54, 0x66, 0xc4, 0x76, 0xeb,
	0xe3, 0x92, 0x8d, 0x0b, 0x62, 0xb9, 0x7c, 0x12, 0x71, 0x46, 0x98, 0xb2, 0x7c, 0x1e, 0x13, 0xc1,
	0x30, 0x73, 0x49, 0xc2, 0x5a, 0x46, 0x19, 0x6d, 0xeb, 0xc3, 0xeb, 0x70, 0x52, 0xe1, 0x20, 0x85,
	0xa4, 0x0f, 0x79, 0x36, 0x9a, 0xcf, 0x56, 0x02, 0x33, 0x89, 0x5d, 0x45, 0x39, 0x4b, 0x25, 0x97,
	0x61, 0x9e, 0x5f, 0x51, 0x25, 0x66, 0x91, 0xe2, 0x96, 0x47, 0x5c, 0x3c, 0xda, 0x7d, 0xfc, 0xf8,
	0x74, 0x24, 0xb8, 0x54, 0x09, 0x68, 0xfe, 0x24, 0xc3, 0x75, 0xde, 0x07, 0xeb, 0x43, 0x22, 0xe8,
	0x88, 0xba, 0x38, 0x61, 0x7b, 0x4e, 0x66, 0x70, 0x0b, 0xdc, 0xa6, 0x8c, 0x11, 0xd1, 0x34, 0xb6,
	0x8d, 0x9d, 0x35, 0x27, 0x0b, 0x3a, 0x0f, 0xc0, 0xca, 0x11, 0xf5, 0x19, 0x56, 0x53, 0x41, 0xae,
	0x49, 0xf9, 0xc9, 0x04, 0x9b, 0x7d, 0xce, 0x85, 0x47, 0x19, 0x56, 0x5c, 0x38, 0x7c, 0xca, 0x3c,
	0x1b, 0xf6, 0xc1, 0xad, 0x28, 0xc4, 0x2c, 0x4d, 0x5d, 0xed, 0x3e, 0x42, 0xa5, 0xbb, 0x5c, 0x10,
	0x54, 0x7d, 0x93, 0xd8, 0x46, 0xc7, 0x65, 0x38, 0x08, 0x31, 0x3b, 0xa8, 0x39, 0x29, 0x18, 0xbe,
	0x00, 0x5b, 0x31, 0x0e, 0xa9, 0x97, 0xf0, 0x9e, 0x7a, 0x64, 0x44, 0x19, 0x4d, 0x72, 0x9a, 0x66,
	0x4a, 0xfa, 0x70, 0x81, 0x54, 0x7b, 0x8b, 0x32, 0x4b, 0x63, 0x1b, 0x0d, 0x0b, 0xf4, 0x41, 0xcd,
	0xb9, 0xab, 0xa9, 0xf6, 0x35, 0x13, 0xc4, 0xa0, 0x51, 0x56, 0x88, 0xb9, 0x22, 0xcd, 0x7a, 0xca,
	0xfd, 0xe4, 0x5a, 0xee, 0x4a, 0x87, 0xab, 0x05, 0x86, 0x5c, 0x91, 0x3d, 0xee, 0xcd, 0x0e, 0x6a,
	0xce, 0xbb, 0xf1, 0xdc, 0xe1, 0x0a, 0x78, 0x47, 0x90, 0x97, 0x53, 0x22, 0x55, 0xe7, 0x87, 0xfa,
	0x65, 0xab, 0xba, 0xf0, 0x25, 0xd8, 0x90, 0xd4, 0x67, 0x94, 0xf9, 0xa7, 0x11, 0x76, 0x03, 0xec,
	0x13, 0xd9, 0x34, 0xb6, 0xeb, 0x3b, 0xab, 0xdd, 0xa7, 0xe8, 0xc6, 0xa1, 0x44, 0x97, 0xb8, 0xd0,
	0x00, 0x0b, 0x45, 0x71, 0x78, 0x94, 0xf1, 0x0d, 0x32, 0x3a, 0x67, 0x5d, 0xce, 0xc5, 0xb2, 0xf5,
	0xca, 0x00, 0xf7, 0x0e, 0x3d, 0xc2, 0x14, 0x1d, 0x51, 0xe2, 0xf5, 0xf9, 0x64, 0x42, 0xd5, 0x84,
	0x30, 0x25, 0x61, 0x1b, 0x00, 0x5a, 0x5c, 0x14, 0x8d, 0xae, 0x9c, 0xc0, 0xaf, 0xc0, 0xaa, 0x5b,
	0xa6, 0xe7, 0x9d, 0xf8, 0xa8, 0xa2, 0x33, 0x9d, 0x43, 0xb4, 0x30, 0x75, 0xb1, 0x8d, 0x72, 0x49,
	0x95, 0x5a, 0x4e, 0x95, 0xa9, 0xf5, 0xad, 0x01, 0xee, 0x5d, 0xa9, 0x1e, 0x72, 0xb0, 0x8e, 0xc3,
	0xf0, 0xb4, 0x5a, 0xf6, 0x9f, 0xda, 0x73, 0xe5, 0x3b, 0x3b, 0x0d, 0x1c, 0x86, 0x95, 0xb8, 0xf3,
	0xda, 0x04, 0x8d, 0xa7, 0x3c, 0x0c, 0xf9, 0x37, 0xa4, 0x18, 0xe7, 0xc3, 0xea, 0xe8, 0xaf, 0x76,
	0x77, 0x97, 0x54, 0x9e, 0x47, 0xa3, 0xc3, 0x04, 0x9a, 0xef, 0x0b, 0xfc, 0x14, 0x98, 0x51, 0x90,
	0x1b, 0x87, 0x96, 0xf0, 0x2c, 0x2c, 0xa9, 0x63, 0x46, 0x01, 0xec, 0x81, 0xba, 0xa4, 0x7e, 0x3e,
	0xa7, 0x3b, 0x4b, 0x08, 0xf4, 0xf2, 0x3a, 0x09, 0xa8, 0xf5, 0x02, 0xdc, 0x4e, 0xb5, 0x2c, 0xb6,
	0x31, 0xf3, 0xf3, 0x3f, 0x68, 0x63, 0xe7, 0x97, 0x45, 0xef, 0xba, 0xff, 0xca, 0xbb, 0xee, 0xff,
	0xc7, 0x3b, 0xa7, 0xf0, 0xee, 0x10, 0xdc, 0x91, 0x63, 0x2c, 0xf4, 0x96, 0xda, 0x6f, 0x69, 0x5b,
	0xca, 0x75, 0x94, 0x20, 0x9d, 0x9c, 0xa0, 0xf3, 0xa3, 0x01, 0x56, 0xf6, 0x9f, 0x3f, 0xcb, 0x87,
	0xec, 0x33, 0x50, 0x8f, 0x02, 0xff, 0x0a, 0x9b, 0xae, 0x63, 0xd5, 0xd0, 0x62, 0xd1, 0x13, 0x3c,
	0xb4, 0xc1, 0x16, 0x9b, 0x86, 0x61, 0xba, 0xaf, 0x95, 0xad, 0x49, 0x6d, 0x5b, 0x73, 0xee, 0xea,
	0xbb, 0xb2, 0x87, 0x70, 0x03, 0xd4, 0x49, 0x14, 0xa4, 0xbe, 0xac, 0x39, 0xc9, 0x23, 0x6c, 0x00,
	0x33, 0x0e, 0x9a, 0xb7, 0xd2, 0x03, 0x33, 0x0e, 0x3a, 0xbf, 0x9b, 0xa5, 0xd2, 0x2e, 0xdc, 0x9f,
	0x6f, 0xe9, 0xb2, 0x56, 0x68, 0xe0, 0x7c, 0x37, 0xb3, 0x1a, 0x66, 0x51, 0x23, 0x51, 0x51, 0x74,
	0x67, 0x2d, 0xf3, 0xfc, 0x0b, 0xb0, 0x7e, 0x8c, 0x85, 0x4f, 0x14, 0xf1, 0x8a, 0x5f, 0x83, 0x0c,
	0x64, 0x68, 0xd0, 0x43, 0xb0, 0x49, 0x58, 0xea, 0x10, 0xf1, 0x8a, 0xdf, 0xcf, 0x9c, 0x73, 0x43,
	0x5f, 0xe4, 0xe0, 0xd6, 0x77, 0x46, 0xd1, 0x44, 0x1f, 0xc0, 0x4b, 0xb0, 0xa2, 0xa1, 0x4f, 0xde,
	0xfa, 0x75, 0x16, 0xc4, 0x39, 0x9b, 0x8b, 0x15, 0x25, 0x7c, 0x0f, 0xac, 0x68, 0xc7, 0x73, 0x5d,
	0xe5, 0xc1, 0xde, 0x6b, 0xf3, 0xd7, 0xf3, 0xb6, 0xf1, 0xe6, 0xbc, 0x6d, 0xfc, 0x79, 0xde, 0x36,
	0x5e, 0x5d, 0xb4, 0x6b, 0x6f, 0x2e, 0xda, 0xb5, 0x3f, 0x2e, 0xda, 0x35, 0xf0, 0xc0, 0xe5, 0x93,
	0x9b, 0x85, 0xec, 0x35, 0x8e, 0x8b, 0x68, 0x90, 0xfc, 0xad, 0x0f, 0x8c, 0xaf, 0xbf, 0xf4, 0xa9,
	0x1a, 0x4f, 0xcf, 0x92, 0xff, 0x2b, 0xcb, 0xe5, 0x72, 0xc2, 0xa5, 0x25, 0x48, 0x88, 0x67, 0x44,
	0x58, 0x71, 0x57, 0x3f, 0xba, 0x63, 0x4c, 0x99, 0xb4, 0x6e, 0xfc, 0x40, 0xfa, 0x44, 0x07, 0xb1,
	0xfd, 0xbd, 0x59, 0x1f, 0xf4, 0x8f, 0x7f, 0x36, 0xef, 0x0f, 0x0a, 0x39, 0xfd, 0x5c, 0x8e, 0x16,
	0x80, 0x86, 0xf6, 0x6f, 0xe5, 0xfd, 0x49, 0x7e, 0x7f, 0xa2, 0xef, 0x4f, 0x86, 0xf6, 0xb9, 0xf9,
	0xc1, 0x8d, 0xf7, 0x27, 0xcf, 0x06, 0x7b, 0x9f, 0x13, 0x85, 0x3d, 0xac, 0xf0, 0x5f, 0xe6, 0x76,
	0x91, 0xdb, 0xeb, 0xe5, 0xc9, 0xbd, 0x9e, 0xce, 0xee, 0xf5, 0x86, 0xf6, 0xd9, 0x9d, 0xf4, 0x5b,
	0x66, 0xf7, 0xef, 0x00, 0x00, 0x00, 0xff, 0xff, 0xaf, 0x71, 0x2a, 0x4c, 0xe9, 0x09, 0x00, 0x00,
}

func (m *VerificationKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerificationKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerificationKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Inner) > 0 {
		i -= len(m.Inner)
		copy(dAtA[i:], m.Inner)
		i = encodeVarintThreshold(dAtA, i, uint64(len(m.Inner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Signature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Signature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Signature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Inner) > 0 {
		i -= len(m.Inner)
		copy(dAtA[i:], m.Inner)
		i = encodeVarintThreshold(dAtA, i, uint64(len(m.Inner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CoordinatorRound1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoordinatorRound1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CoordinatorRound1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Request != nil {
		{
			size := m.Request.Size()
			i -= size
			if _, err := m.Request.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CoordinatorRound1_Plan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CoordinatorRound1_Plan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Plan != nil {
		{
			size, err := m.Plan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintThreshold(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *CoordinatorRound1_ValidatorDefinition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CoordinatorRound1_ValidatorDefinition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ValidatorDefinition != nil {
		{
			size, err := m.ValidatorDefinition.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintThreshold(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *CoordinatorRound1_ValidatorVote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CoordinatorRound1_ValidatorVote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ValidatorVote != nil {
		{
			size, err := m.ValidatorVote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintThreshold(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *CoordinatorRound2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoordinatorRound2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CoordinatorRound2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SigningPackages) > 0 {
		for iNdEx := len(m.SigningPackages) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SigningPackages[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintThreshold(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CoordinatorRound2_IdentifiedCommitments) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoordinatorRound2_IdentifiedCommitments) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CoordinatorRound2_IdentifiedCommitments) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Commitments != nil {
		{
			size, err := m.Commitments.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintThreshold(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Identifier) > 0 {
		i -= len(m.Identifier)
		copy(dAtA[i:], m.Identifier)
		i = encodeVarintThreshold(dAtA, i, uint64(len(m.Identifier)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CoordinatorRound2_PartialSigningPackage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoordinatorRound2_PartialSigningPackage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CoordinatorRound2_PartialSigningPackage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AllCommitments) > 0 {
		for iNdEx := len(m.AllCommitments) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AllCommitments[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintThreshold(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FollowerRound1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FollowerRound1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FollowerRound1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sig != nil {
		{
			size, err := m.Sig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintThreshold(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Pk != nil {
		{
			size, err := m.Pk.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintThreshold(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Inner != nil {
		{
			size, err := m.Inner.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintThreshold(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FollowerRound1_Inner) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FollowerRound1_Inner) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FollowerRound1_Inner) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Commitments) > 0 {
		for iNdEx := len(m.Commitments) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Commitments[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintThreshold(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FollowerRound2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FollowerRound2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FollowerRound2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sig != nil {
		{
			size, err := m.Sig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintThreshold(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Pk != nil {
		{
			size, err := m.Pk.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintThreshold(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Inner != nil {
		{
			size, err := m.Inner.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintThreshold(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FollowerRound2_Inner) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FollowerRound2_Inner) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FollowerRound2_Inner) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Shares) > 0 {
		for iNdEx := len(m.Shares) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Shares[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintThreshold(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DKGRound1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DKGRound1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DKGRound1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Vk) > 0 {
		i -= len(m.Vk)
		copy(dAtA[i:], m.Vk)
		i = encodeVarintThreshold(dAtA, i, uint64(len(m.Vk)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Epk) > 0 {
		i -= len(m.Epk)
		copy(dAtA[i:], m.Epk)
		i = encodeVarintThreshold(dAtA, i, uint64(len(m.Epk)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.NullifierCommitment) > 0 {
		i -= len(m.NullifierCommitment)
		copy(dAtA[i:], m.NullifierCommitment)
		i = encodeVarintThreshold(dAtA, i, uint64(len(m.NullifierCommitment)))
		i--
		dAtA[i] = 0x12
	}
	if m.Pkg != nil {
		{
			size, err := m.Pkg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintThreshold(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DKGRound2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DKGRound2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DKGRound2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sig) > 0 {
		i -= len(m.Sig)
		copy(dAtA[i:], m.Sig)
		i = encodeVarintThreshold(dAtA, i, uint64(len(m.Sig)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Vk) > 0 {
		i -= len(m.Vk)
		copy(dAtA[i:], m.Vk)
		i = encodeVarintThreshold(dAtA, i, uint64(len(m.Vk)))
		i--
		dAtA[i] = 0x12
	}
	if m.Inner != nil {
		{
			size, err := m.Inner.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintThreshold(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DKGRound2_TargetedPackage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DKGRound2_TargetedPackage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DKGRound2_TargetedPackage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EncryptedPackage) > 0 {
		i -= len(m.EncryptedPackage)
		copy(dAtA[i:], m.EncryptedPackage)
		i = encodeVarintThreshold(dAtA, i, uint64(len(m.EncryptedPackage)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Vk) > 0 {
		i -= len(m.Vk)
		copy(dAtA[i:], m.Vk)
		i = encodeVarintThreshold(dAtA, i, uint64(len(m.Vk)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DKGRound2_Inner) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DKGRound2_Inner) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DKGRound2_Inner) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Nullifier) > 0 {
		i -= len(m.Nullifier)
		copy(dAtA[i:], m.Nullifier)
		i = encodeVarintThreshold(dAtA, i, uint64(len(m.Nullifier)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.EncryptedPackages) > 0 {
		for iNdEx := len(m.EncryptedPackages) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EncryptedPackages[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintThreshold(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintThreshold(dAtA []byte, offset int, v uint64) int {
	offset -= sovThreshold(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *VerificationKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Inner)
	if l > 0 {
		n += 1 + l + sovThreshold(uint64(l))
	}
	return n
}

func (m *Signature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Inner)
	if l > 0 {
		n += 1 + l + sovThreshold(uint64(l))
	}
	return n
}

func (m *CoordinatorRound1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Request != nil {
		n += m.Request.Size()
	}
	return n
}

func (m *CoordinatorRound1_Plan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Plan != nil {
		l = m.Plan.Size()
		n += 1 + l + sovThreshold(uint64(l))
	}
	return n
}
func (m *CoordinatorRound1_ValidatorDefinition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ValidatorDefinition != nil {
		l = m.ValidatorDefinition.Size()
		n += 1 + l + sovThreshold(uint64(l))
	}
	return n
}
func (m *CoordinatorRound1_ValidatorVote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ValidatorVote != nil {
		l = m.ValidatorVote.Size()
		n += 1 + l + sovThreshold(uint64(l))
	}
	return n
}
func (m *CoordinatorRound2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SigningPackages) > 0 {
		for _, e := range m.SigningPackages {
			l = e.Size()
			n += 1 + l + sovThreshold(uint64(l))
		}
	}
	return n
}

func (m *CoordinatorRound2_IdentifiedCommitments) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Identifier)
	if l > 0 {
		n += 1 + l + sovThreshold(uint64(l))
	}
	if m.Commitments != nil {
		l = m.Commitments.Size()
		n += 1 + l + sovThreshold(uint64(l))
	}
	return n
}

func (m *CoordinatorRound2_PartialSigningPackage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AllCommitments) > 0 {
		for _, e := range m.AllCommitments {
			l = e.Size()
			n += 1 + l + sovThreshold(uint64(l))
		}
	}
	return n
}

func (m *FollowerRound1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Inner != nil {
		l = m.Inner.Size()
		n += 1 + l + sovThreshold(uint64(l))
	}
	if m.Pk != nil {
		l = m.Pk.Size()
		n += 1 + l + sovThreshold(uint64(l))
	}
	if m.Sig != nil {
		l = m.Sig.Size()
		n += 1 + l + sovThreshold(uint64(l))
	}
	return n
}

func (m *FollowerRound1_Inner) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Commitments) > 0 {
		for _, e := range m.Commitments {
			l = e.Size()
			n += 1 + l + sovThreshold(uint64(l))
		}
	}
	return n
}

func (m *FollowerRound2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Inner != nil {
		l = m.Inner.Size()
		n += 1 + l + sovThreshold(uint64(l))
	}
	if m.Pk != nil {
		l = m.Pk.Size()
		n += 1 + l + sovThreshold(uint64(l))
	}
	if m.Sig != nil {
		l = m.Sig.Size()
		n += 1 + l + sovThreshold(uint64(l))
	}
	return n
}

func (m *FollowerRound2_Inner) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Shares) > 0 {
		for _, e := range m.Shares {
			l = e.Size()
			n += 1 + l + sovThreshold(uint64(l))
		}
	}
	return n
}

func (m *DKGRound1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pkg != nil {
		l = m.Pkg.Size()
		n += 1 + l + sovThreshold(uint64(l))
	}
	l = len(m.NullifierCommitment)
	if l > 0 {
		n += 1 + l + sovThreshold(uint64(l))
	}
	l = len(m.Epk)
	if l > 0 {
		n += 1 + l + sovThreshold(uint64(l))
	}
	l = len(m.Vk)
	if l > 0 {
		n += 1 + l + sovThreshold(uint64(l))
	}
	return n
}

func (m *DKGRound2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Inner != nil {
		l = m.Inner.Size()
		n += 1 + l + sovThreshold(uint64(l))
	}
	l = len(m.Vk)
	if l > 0 {
		n += 1 + l + sovThreshold(uint64(l))
	}
	l = len(m.Sig)
	if l > 0 {
		n += 1 + l + sovThreshold(uint64(l))
	}
	return n
}

func (m *DKGRound2_TargetedPackage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Vk)
	if l > 0 {
		n += 1 + l + sovThreshold(uint64(l))
	}
	l = len(m.EncryptedPackage)
	if l > 0 {
		n += 1 + l + sovThreshold(uint64(l))
	}
	return n
}

func (m *DKGRound2_Inner) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.EncryptedPackages) > 0 {
		for _, e := range m.EncryptedPackages {
			l = e.Size()
			n += 1 + l + sovThreshold(uint64(l))
		}
	}
	l = len(m.Nullifier)
	if l > 0 {
		n += 1 + l + sovThreshold(uint64(l))
	}
	return n
}

func sovThreshold(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozThreshold(x uint64) (n int) {
	return sovThreshold(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *VerificationKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowThreshold
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerificationKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerificationKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreshold
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthThreshold
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthThreshold
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inner = append(m.Inner[:0], dAtA[iNdEx:postIndex]...)
			if m.Inner == nil {
				m.Inner = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipThreshold(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthThreshold
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Signature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowThreshold
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Signature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Signature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreshold
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthThreshold
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthThreshold
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inner = append(m.Inner[:0], dAtA[iNdEx:postIndex]...)
			if m.Inner == nil {
				m.Inner = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipThreshold(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthThreshold
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoordinatorRound1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowThreshold
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoordinatorRound1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoordinatorRound1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreshold
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthThreshold
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthThreshold
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1.TransactionPlan{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &CoordinatorRound1_Plan{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorDefinition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreshold
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthThreshold
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthThreshold
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v11.Validator{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &CoordinatorRound1_ValidatorDefinition{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorVote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreshold
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthThreshold
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthThreshold
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v12.ValidatorVoteBody{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &CoordinatorRound1_ValidatorVote{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipThreshold(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthThreshold
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoordinatorRound2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowThreshold
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoordinatorRound2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoordinatorRound2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigningPackages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreshold
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthThreshold
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthThreshold
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SigningPackages = append(m.SigningPackages, &CoordinatorRound2_PartialSigningPackage{})
			if err := m.SigningPackages[len(m.SigningPackages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipThreshold(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthThreshold
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoordinatorRound2_IdentifiedCommitments) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowThreshold
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IdentifiedCommitments: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IdentifiedCommitments: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identifier", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreshold
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthThreshold
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthThreshold
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identifier = append(m.Identifier[:0], dAtA[iNdEx:postIndex]...)
			if m.Identifier == nil {
				m.Identifier = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commitments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreshold
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthThreshold
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthThreshold
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commitments == nil {
				m.Commitments = &v13.SigningCommitments{}
			}
			if err := m.Commitments.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipThreshold(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthThreshold
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoordinatorRound2_PartialSigningPackage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowThreshold
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartialSigningPackage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartialSigningPackage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllCommitments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreshold
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthThreshold
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthThreshold
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllCommitments = append(m.AllCommitments, &CoordinatorRound2_IdentifiedCommitments{})
			if err := m.AllCommitments[len(m.AllCommitments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipThreshold(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthThreshold
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FollowerRound1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowThreshold
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FollowerRound1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FollowerRound1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreshold
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthThreshold
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthThreshold
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Inner == nil {
				m.Inner = &FollowerRound1_Inner{}
			}
			if err := m.Inner.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreshold
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthThreshold
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthThreshold
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pk == nil {
				m.Pk = &VerificationKey{}
			}
			if err := m.Pk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreshold
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthThreshold
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthThreshold
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sig == nil {
				m.Sig = &Signature{}
			}
			if err := m.Sig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipThreshold(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthThreshold
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FollowerRound1_Inner) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowThreshold
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Inner: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Inner: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commitments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreshold
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthThreshold
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthThreshold
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commitments = append(m.Commitments, &v13.SigningCommitments{})
			if err := m.Commitments[len(m.Commitments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipThreshold(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthThreshold
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FollowerRound2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowThreshold
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FollowerRound2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FollowerRound2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreshold
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthThreshold
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthThreshold
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Inner == nil {
				m.Inner = &FollowerRound2_Inner{}
			}
			if err := m.Inner.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreshold
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthThreshold
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthThreshold
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pk == nil {
				m.Pk = &VerificationKey{}
			}
			if err := m.Pk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreshold
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthThreshold
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthThreshold
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sig == nil {
				m.Sig = &Signature{}
			}
			if err := m.Sig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipThreshold(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthThreshold
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FollowerRound2_Inner) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowThreshold
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Inner: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Inner: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shares", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreshold
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthThreshold
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthThreshold
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shares = append(m.Shares, &v13.SignatureShare{})
			if err := m.Shares[len(m.Shares)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipThreshold(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthThreshold
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DKGRound1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowThreshold
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DKGRound1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DKGRound1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pkg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreshold
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthThreshold
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthThreshold
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pkg == nil {
				m.Pkg = &v13.DKGRound1Package{}
			}
			if err := m.Pkg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NullifierCommitment", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreshold
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthThreshold
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthThreshold
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NullifierCommitment = append(m.NullifierCommitment[:0], dAtA[iNdEx:postIndex]...)
			if m.NullifierCommitment == nil {
				m.NullifierCommitment = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreshold
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthThreshold
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthThreshold
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Epk = append(m.Epk[:0], dAtA[iNdEx:postIndex]...)
			if m.Epk == nil {
				m.Epk = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreshold
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthThreshold
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthThreshold
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vk = append(m.Vk[:0], dAtA[iNdEx:postIndex]...)
			if m.Vk == nil {
				m.Vk = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipThreshold(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthThreshold
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DKGRound2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowThreshold
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DKGRound2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DKGRound2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreshold
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthThreshold
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthThreshold
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Inner == nil {
				m.Inner = &DKGRound2_Inner{}
			}
			if err := m.Inner.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreshold
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthThreshold
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthThreshold
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vk = append(m.Vk[:0], dAtA[iNdEx:postIndex]...)
			if m.Vk == nil {
				m.Vk = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreshold
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthThreshold
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthThreshold
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sig = append(m.Sig[:0], dAtA[iNdEx:postIndex]...)
			if m.Sig == nil {
				m.Sig = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipThreshold(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthThreshold
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DKGRound2_TargetedPackage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowThreshold
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TargetedPackage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TargetedPackage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreshold
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthThreshold
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthThreshold
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vk = append(m.Vk[:0], dAtA[iNdEx:postIndex]...)
			if m.Vk == nil {
				m.Vk = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedPackage", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreshold
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthThreshold
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthThreshold
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedPackage = append(m.EncryptedPackage[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedPackage == nil {
				m.EncryptedPackage = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipThreshold(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthThreshold
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DKGRound2_Inner) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowThreshold
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Inner: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Inner: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedPackages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreshold
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthThreshold
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthThreshold
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedPackages = append(m.EncryptedPackages, &DKGRound2_TargetedPackage{})
			if err := m.EncryptedPackages[len(m.EncryptedPackages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nullifier", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreshold
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthThreshold
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthThreshold
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nullifier = append(m.Nullifier[:0], dAtA[iNdEx:postIndex]...)
			if m.Nullifier == nil {
				m.Nullifier = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipThreshold(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthThreshold
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipThreshold(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowThreshold
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowThreshold
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowThreshold
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthThreshold
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupThreshold
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthThreshold
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthThreshold        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowThreshold          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupThreshold = fmt.Errorf("proto: unexpected end of group")
)
