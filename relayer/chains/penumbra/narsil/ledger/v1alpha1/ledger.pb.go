// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: penumbra/narsil/ledger/v1alpha1/ledger.proto

package ledgerv1alpha1

import (
	context "context"
	fmt "fmt"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	v1alpha11 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/component/chain/v1alpha1"
	v1alpha1 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/keys/v1alpha1"
	v1alpha12 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/transaction/v1alpha1"
	v1alpha13 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/custody/v1alpha1"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Requests information about the chain state as known by the node.
type InfoRequest struct {
	// The Tendermint software semantic version.
	Version string `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	// The Tendermint block protocol version.
	BlockVersion uint64 `protobuf:"varint,2,opt,name=block_version,json=blockVersion,proto3" json:"block_version,omitempty"`
	// The Tendermint p2p protocol version.
	P2PVersion uint64 `protobuf:"varint,3,opt,name=p2p_version,json=p2pVersion,proto3" json:"p2p_version,omitempty"`
	// The ABCI semantic version number.
	AbciVersion string `protobuf:"bytes,4,opt,name=abci_version,json=abciVersion,proto3" json:"abci_version,omitempty"`
}

func (m *InfoRequest) Reset()         { *m = InfoRequest{} }
func (m *InfoRequest) String() string { return proto.CompactTextString(m) }
func (*InfoRequest) ProtoMessage()    {}
func (*InfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e17e78e0f19a1ac0, []int{0}
}
func (m *InfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InfoRequest.Merge(m, src)
}
func (m *InfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *InfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InfoRequest proto.InternalMessageInfo

func (m *InfoRequest) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *InfoRequest) GetBlockVersion() uint64 {
	if m != nil {
		return m.BlockVersion
	}
	return 0
}

func (m *InfoRequest) GetP2PVersion() uint64 {
	if m != nil {
		return m.P2PVersion
	}
	return 0
}

func (m *InfoRequest) GetAbciVersion() string {
	if m != nil {
		return m.AbciVersion
	}
	return ""
}

// Contains information about the chain state as known by the node.
type InfoResponse struct {
	// Some arbitrary information.
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	// The application software semantic version.
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// The application protocol version.
	AppVersion uint64 `protobuf:"varint,3,opt,name=app_version,json=appVersion,proto3" json:"app_version,omitempty"`
	// The latest block for which the app has called [`Commit`](super::super::Request::Commit).
	LastBlockHeight uint64 `protobuf:"varint,4,opt,name=last_block_height,json=lastBlockHeight,proto3" json:"last_block_height,omitempty"`
	// The latest result of [`Commit`](super::super::Request::Commit).
	LastBlockAppHash []byte `protobuf:"bytes,5,opt,name=last_block_app_hash,json=lastBlockAppHash,proto3" json:"last_block_app_hash,omitempty"`
}

func (m *InfoResponse) Reset()         { *m = InfoResponse{} }
func (m *InfoResponse) String() string { return proto.CompactTextString(m) }
func (*InfoResponse) ProtoMessage()    {}
func (*InfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e17e78e0f19a1ac0, []int{1}
}
func (m *InfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InfoResponse.Merge(m, src)
}
func (m *InfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *InfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_InfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_InfoResponse proto.InternalMessageInfo

func (m *InfoResponse) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *InfoResponse) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *InfoResponse) GetAppVersion() uint64 {
	if m != nil {
		return m.AppVersion
	}
	return 0
}

func (m *InfoResponse) GetLastBlockHeight() uint64 {
	if m != nil {
		return m.LastBlockHeight
	}
	return 0
}

func (m *InfoResponse) GetLastBlockAppHash() []byte {
	if m != nil {
		return m.LastBlockAppHash
	}
	return nil
}

// The root identity key material for a shard operator.
type ShardIdentityKey struct {
	// An Ed25519 key.
	Inner []byte `protobuf:"bytes,1,opt,name=inner,proto3" json:"inner,omitempty"`
}

func (m *ShardIdentityKey) Reset()         { *m = ShardIdentityKey{} }
func (m *ShardIdentityKey) String() string { return proto.CompactTextString(m) }
func (*ShardIdentityKey) ProtoMessage()    {}
func (*ShardIdentityKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_e17e78e0f19a1ac0, []int{2}
}
func (m *ShardIdentityKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardIdentityKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardIdentityKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardIdentityKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardIdentityKey.Merge(m, src)
}
func (m *ShardIdentityKey) XXX_Size() int {
	return m.Size()
}
func (m *ShardIdentityKey) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardIdentityKey.DiscardUnknown(m)
}

var xxx_messageInfo_ShardIdentityKey proto.InternalMessageInfo

func (m *ShardIdentityKey) GetInner() []byte {
	if m != nil {
		return m.Inner
	}
	return nil
}

// The key that Tendermint will use to identify a validator.
type ConsensusKey struct {
	// An Ed25519 key.
	Inner []byte `protobuf:"bytes,1,opt,name=inner,proto3" json:"inner,omitempty"`
}

func (m *ConsensusKey) Reset()         { *m = ConsensusKey{} }
func (m *ConsensusKey) String() string { return proto.CompactTextString(m) }
func (*ConsensusKey) ProtoMessage()    {}
func (*ConsensusKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_e17e78e0f19a1ac0, []int{3}
}
func (m *ConsensusKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConsensusKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusKey.Merge(m, src)
}
func (m *ConsensusKey) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusKey) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusKey.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusKey proto.InternalMessageInfo

func (m *ConsensusKey) GetInner() []byte {
	if m != nil {
		return m.Inner
	}
	return nil
}

// A subkey a shard uses to sign messages sent to the ledger.
type ShardMessageKey struct {
	// An Ed25519 key.
	Inner []byte `protobuf:"bytes,1,opt,name=inner,proto3" json:"inner,omitempty"`
}

func (m *ShardMessageKey) Reset()         { *m = ShardMessageKey{} }
func (m *ShardMessageKey) String() string { return proto.CompactTextString(m) }
func (*ShardMessageKey) ProtoMessage()    {}
func (*ShardMessageKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_e17e78e0f19a1ac0, []int{4}
}
func (m *ShardMessageKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardMessageKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardMessageKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardMessageKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardMessageKey.Merge(m, src)
}
func (m *ShardMessageKey) XXX_Size() int {
	return m.Size()
}
func (m *ShardMessageKey) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardMessageKey.DiscardUnknown(m)
}

var xxx_messageInfo_ShardMessageKey proto.InternalMessageInfo

func (m *ShardMessageKey) GetInner() []byte {
	if m != nil {
		return m.Inner
	}
	return nil
}

// The threshold key share controlled by a shard operator.
type ShardKey struct {
	// A decaf377 scalar.
	Inner []byte `protobuf:"bytes,1,opt,name=inner,proto3" json:"inner,omitempty"`
}

func (m *ShardKey) Reset()         { *m = ShardKey{} }
func (m *ShardKey) String() string { return proto.CompactTextString(m) }
func (*ShardKey) ProtoMessage()    {}
func (*ShardKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_e17e78e0f19a1ac0, []int{5}
}
func (m *ShardKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardKey.Merge(m, src)
}
func (m *ShardKey) XXX_Size() int {
	return m.Size()
}
func (m *ShardKey) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardKey.DiscardUnknown(m)
}

var xxx_messageInfo_ShardKey proto.InternalMessageInfo

func (m *ShardKey) GetInner() []byte {
	if m != nil {
		return m.Inner
	}
	return nil
}

// A signature over a message sent to the ledger by a shard.
type ShardMessageSignature struct {
	// An Ed25519 signature.
	Inner []byte `protobuf:"bytes,1,opt,name=inner,proto3" json:"inner,omitempty"`
}

func (m *ShardMessageSignature) Reset()         { *m = ShardMessageSignature{} }
func (m *ShardMessageSignature) String() string { return proto.CompactTextString(m) }
func (*ShardMessageSignature) ProtoMessage()    {}
func (*ShardMessageSignature) Descriptor() ([]byte, []int) {
	return fileDescriptor_e17e78e0f19a1ac0, []int{6}
}
func (m *ShardMessageSignature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardMessageSignature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardMessageSignature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardMessageSignature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardMessageSignature.Merge(m, src)
}
func (m *ShardMessageSignature) XXX_Size() int {
	return m.Size()
}
func (m *ShardMessageSignature) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardMessageSignature.DiscardUnknown(m)
}

var xxx_messageInfo_ShardMessageSignature proto.InternalMessageInfo

func (m *ShardMessageSignature) GetInner() []byte {
	if m != nil {
		return m.Inner
	}
	return nil
}

// A description of one of the operators of a threshold key share (shard).
//
// The `ShardOperator` message doesn't have the threshold key share itself,
// because the workflow is that the set of operators is going to be configured
// first, as part of the genesis / chain configuration, and then the shards
// perform DKG as the chain boots, using the chain as the messaging layer for
// the DKG messages.  This means there's no interactive setup procedure for the
// shard operators.
type ShardDescription struct {
	// The shard operator's offline identity key material which is the root of their authority.
	IdentityKey *ShardIdentityKey `protobuf:"bytes,1,opt,name=identity_key,json=identityKey,proto3" json:"identity_key,omitempty"`
	// A subkey used for signing messages sent to the ledger.
	MessageKey *ShardMessageKey `protobuf:"bytes,2,opt,name=message_key,json=messageKey,proto3" json:"message_key,omitempty"`
	// The validator's consensus pubkey for use in Tendermint (ed25519)
	ConsensusKey *ConsensusKey `protobuf:"bytes,3,opt,name=consensus_key,json=consensusKey,proto3" json:"consensus_key,omitempty"`
	// A label for the shard.
	Label string `protobuf:"bytes,4,opt,name=label,proto3" json:"label,omitempty"`
}

func (m *ShardDescription) Reset()         { *m = ShardDescription{} }
func (m *ShardDescription) String() string { return proto.CompactTextString(m) }
func (*ShardDescription) ProtoMessage()    {}
func (*ShardDescription) Descriptor() ([]byte, []int) {
	return fileDescriptor_e17e78e0f19a1ac0, []int{7}
}
func (m *ShardDescription) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardDescription) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardDescription.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardDescription) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardDescription.Merge(m, src)
}
func (m *ShardDescription) XXX_Size() int {
	return m.Size()
}
func (m *ShardDescription) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardDescription.DiscardUnknown(m)
}

var xxx_messageInfo_ShardDescription proto.InternalMessageInfo

func (m *ShardDescription) GetIdentityKey() *ShardIdentityKey {
	if m != nil {
		return m.IdentityKey
	}
	return nil
}

func (m *ShardDescription) GetMessageKey() *ShardMessageKey {
	if m != nil {
		return m.MessageKey
	}
	return nil
}

func (m *ShardDescription) GetConsensusKey() *ConsensusKey {
	if m != nil {
		return m.ConsensusKey
	}
	return nil
}

func (m *ShardDescription) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

// A self-authenticating `ShardDescription`, signed with the `ShardIdentityKey`.
type ShardOperator struct {
	Description *ShardDescription `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	Sig         []byte            `protobuf:"bytes,2,opt,name=sig,proto3" json:"sig,omitempty"`
}

func (m *ShardOperator) Reset()         { *m = ShardOperator{} }
func (m *ShardOperator) String() string { return proto.CompactTextString(m) }
func (*ShardOperator) ProtoMessage()    {}
func (*ShardOperator) Descriptor() ([]byte, []int) {
	return fileDescriptor_e17e78e0f19a1ac0, []int{8}
}
func (m *ShardOperator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardOperator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardOperator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardOperator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardOperator.Merge(m, src)
}
func (m *ShardOperator) XXX_Size() int {
	return m.Size()
}
func (m *ShardOperator) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardOperator.DiscardUnknown(m)
}

var xxx_messageInfo_ShardOperator proto.InternalMessageInfo

func (m *ShardOperator) GetDescription() *ShardDescription {
	if m != nil {
		return m.Description
	}
	return nil
}

func (m *ShardOperator) GetSig() []byte {
	if m != nil {
		return m.Sig
	}
	return nil
}

// The genesis data describing the set of shard operators who jointly control
// the Narsil instance.
//
// The genesis data does not specify the threshold key shares themselves,
// because these will be computed as the ledger boots up and the shard operators
// perform the DKG to generate the shared key, described by the `ShardInfo`.
type GenesisData struct {
	// The set of shard operators (implicitly specifying the `n` in `t-of-n`).
	Operators []*ShardOperator `protobuf:"bytes,1,rep,name=operators,proto3" json:"operators,omitempty"`
	// The number of shards required to sign a message (the `t` in `t-of-n`).
	Threshold uint32 `protobuf:"varint,2,opt,name=threshold,proto3" json:"threshold,omitempty"`
}

func (m *GenesisData) Reset()         { *m = GenesisData{} }
func (m *GenesisData) String() string { return proto.CompactTextString(m) }
func (*GenesisData) ProtoMessage()    {}
func (*GenesisData) Descriptor() ([]byte, []int) {
	return fileDescriptor_e17e78e0f19a1ac0, []int{9}
}
func (m *GenesisData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenesisData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenesisData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenesisData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenesisData.Merge(m, src)
}
func (m *GenesisData) XXX_Size() int {
	return m.Size()
}
func (m *GenesisData) XXX_DiscardUnknown() {
	xxx_messageInfo_GenesisData.DiscardUnknown(m)
}

var xxx_messageInfo_GenesisData proto.InternalMessageInfo

func (m *GenesisData) GetOperators() []*ShardOperator {
	if m != nil {
		return m.Operators
	}
	return nil
}

func (m *GenesisData) GetThreshold() uint32 {
	if m != nil {
		return m.Threshold
	}
	return 0
}

// Describes the Penumbra account group jointly controlled by the Narsil instance.
type AccountGroupInfo struct {
	// The full viewing key for the shared account.
	//
	// In the Penumbra key hierarchy, this is the highest-authority key below
	// spend authority, and allows deriving all subkeys for all accounts in the
	// account group.  It is replicated across all shards.
	//
	// The spend verification key component is the `PK` in the FROST I-D.
	FullViewingKey *v1alpha1.FullViewingKey `protobuf:"bytes,1,opt,name=full_viewing_key,json=fullViewingKey,proto3" json:"full_viewing_key,omitempty"`
	// Describes the participants in the account group.
	Participants []*ShardInfo `protobuf:"bytes,2,rep,name=participants,proto3" json:"participants,omitempty"`
}

func (m *AccountGroupInfo) Reset()         { *m = AccountGroupInfo{} }
func (m *AccountGroupInfo) String() string { return proto.CompactTextString(m) }
func (*AccountGroupInfo) ProtoMessage()    {}
func (*AccountGroupInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e17e78e0f19a1ac0, []int{10}
}
func (m *AccountGroupInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountGroupInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountGroupInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountGroupInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountGroupInfo.Merge(m, src)
}
func (m *AccountGroupInfo) XXX_Size() int {
	return m.Size()
}
func (m *AccountGroupInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountGroupInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AccountGroupInfo proto.InternalMessageInfo

func (m *AccountGroupInfo) GetFullViewingKey() *v1alpha1.FullViewingKey {
	if m != nil {
		return m.FullViewingKey
	}
	return nil
}

func (m *AccountGroupInfo) GetParticipants() []*ShardInfo {
	if m != nil {
		return m.Participants
	}
	return nil
}

// Describes a single shard of the Narsil instance.
type ShardInfo struct {
	// The index of the shard, used for FROST accounting purposes.
	Index uint32 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	// The shard verification key, corresponding to `PK_i` in the FROST I-D.
	ShardVerificationKey *v1alpha1.SpendVerificationKey `protobuf:"bytes,2,opt,name=shard_verification_key,json=shardVerificationKey,proto3" json:"shard_verification_key,omitempty"`
	// The shard operator's identity key, used to identify the operator of this shard.
	IdentityKey *ShardIdentityKey `protobuf:"bytes,3,opt,name=identity_key,json=identityKey,proto3" json:"identity_key,omitempty"`
}

func (m *ShardInfo) Reset()         { *m = ShardInfo{} }
func (m *ShardInfo) String() string { return proto.CompactTextString(m) }
func (*ShardInfo) ProtoMessage()    {}
func (*ShardInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e17e78e0f19a1ac0, []int{11}
}
func (m *ShardInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardInfo.Merge(m, src)
}
func (m *ShardInfo) XXX_Size() int {
	return m.Size()
}
func (m *ShardInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ShardInfo proto.InternalMessageInfo

func (m *ShardInfo) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *ShardInfo) GetShardVerificationKey() *v1alpha1.SpendVerificationKey {
	if m != nil {
		return m.ShardVerificationKey
	}
	return nil
}

func (m *ShardInfo) GetIdentityKey() *ShardIdentityKey {
	if m != nil {
		return m.IdentityKey
	}
	return nil
}

// Transaction authorization requests are identified by the proposed
// transaction's effect hash.
//
// This acts as a form of content addressing, providing a number of useful
// behaviors:
//
//   - Multiple users can request authorization of the same `TransactionPlan`, and
//     the ledger can stack their pre-authorizations until some threshold is met.
//   - Rather than having to hold open a connection, clients can re-request
//     authorization of the same `TransactionPlan` after it has been signed, and the
//     ledger can immediately return the already-existing authorization data.
type RequestIndex struct {
	EffectHash *v1alpha11.EffectHash `protobuf:"bytes,1,opt,name=effect_hash,json=effectHash,proto3" json:"effect_hash,omitempty"`
}

func (m *RequestIndex) Reset()         { *m = RequestIndex{} }
func (m *RequestIndex) String() string { return proto.CompactTextString(m) }
func (*RequestIndex) ProtoMessage()    {}
func (*RequestIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_e17e78e0f19a1ac0, []int{12}
}
func (m *RequestIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestIndex.Merge(m, src)
}
func (m *RequestIndex) XXX_Size() int {
	return m.Size()
}
func (m *RequestIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestIndex.DiscardUnknown(m)
}

var xxx_messageInfo_RequestIndex proto.InternalMessageInfo

func (m *RequestIndex) GetEffectHash() *v1alpha11.EffectHash {
	if m != nil {
		return m.EffectHash
	}
	return nil
}

// Identifies a particular signing ceremony.
//
// Ceremonies are identified first by request index and then by a sub-index for
// the ceremony.  This allows failed or timed-out ceremonies to be repeated.
type CeremonyIndex struct {
	RequestIndex  *RequestIndex `protobuf:"bytes,1,opt,name=request_index,json=requestIndex,proto3" json:"request_index,omitempty"`
	CeremonyIndex uint64        `protobuf:"varint,2,opt,name=ceremony_index,json=ceremonyIndex,proto3" json:"ceremony_index,omitempty"`
}

func (m *CeremonyIndex) Reset()         { *m = CeremonyIndex{} }
func (m *CeremonyIndex) String() string { return proto.CompactTextString(m) }
func (*CeremonyIndex) ProtoMessage()    {}
func (*CeremonyIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_e17e78e0f19a1ac0, []int{13}
}
func (m *CeremonyIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CeremonyIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CeremonyIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CeremonyIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CeremonyIndex.Merge(m, src)
}
func (m *CeremonyIndex) XXX_Size() int {
	return m.Size()
}
func (m *CeremonyIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_CeremonyIndex.DiscardUnknown(m)
}

var xxx_messageInfo_CeremonyIndex proto.InternalMessageInfo

func (m *CeremonyIndex) GetRequestIndex() *RequestIndex {
	if m != nil {
		return m.RequestIndex
	}
	return nil
}

func (m *CeremonyIndex) GetCeremonyIndex() uint64 {
	if m != nil {
		return m.CeremonyIndex
	}
	return 0
}

// A committee of shards assigned to carry out a particular signing ceremony.
type Committee struct {
	Ceremony     *CeremonyIndex `protobuf:"bytes,1,opt,name=ceremony,proto3" json:"ceremony,omitempty"`
	Participants []*ShardInfo   `protobuf:"bytes,2,rep,name=participants,proto3" json:"participants,omitempty"`
}

func (m *Committee) Reset()         { *m = Committee{} }
func (m *Committee) String() string { return proto.CompactTextString(m) }
func (*Committee) ProtoMessage()    {}
func (*Committee) Descriptor() ([]byte, []int) {
	return fileDescriptor_e17e78e0f19a1ac0, []int{14}
}
func (m *Committee) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Committee) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Committee.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Committee) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Committee.Merge(m, src)
}
func (m *Committee) XXX_Size() int {
	return m.Size()
}
func (m *Committee) XXX_DiscardUnknown() {
	xxx_messageInfo_Committee.DiscardUnknown(m)
}

var xxx_messageInfo_Committee proto.InternalMessageInfo

func (m *Committee) GetCeremony() *CeremonyIndex {
	if m != nil {
		return m.Ceremony
	}
	return nil
}

func (m *Committee) GetParticipants() []*ShardInfo {
	if m != nil {
		return m.Participants
	}
	return nil
}

// Records a failed ceremony and the reason why it failed.
//
// TODO: consider filling these in with structured info about the failure
type CeremonyFailure struct {
	// Types that are valid to be assigned to Failure:
	//	*CeremonyFailure_Timeout_
	//	*CeremonyFailure_BadCommitment_
	//	*CeremonyFailure_BadShare_
	//	*CeremonyFailure_Canceled_
	Failure isCeremonyFailure_Failure `protobuf_oneof:"failure"`
}

func (m *CeremonyFailure) Reset()         { *m = CeremonyFailure{} }
func (m *CeremonyFailure) String() string { return proto.CompactTextString(m) }
func (*CeremonyFailure) ProtoMessage()    {}
func (*CeremonyFailure) Descriptor() ([]byte, []int) {
	return fileDescriptor_e17e78e0f19a1ac0, []int{15}
}
func (m *CeremonyFailure) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CeremonyFailure) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CeremonyFailure.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CeremonyFailure) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CeremonyFailure.Merge(m, src)
}
func (m *CeremonyFailure) XXX_Size() int {
	return m.Size()
}
func (m *CeremonyFailure) XXX_DiscardUnknown() {
	xxx_messageInfo_CeremonyFailure.DiscardUnknown(m)
}

var xxx_messageInfo_CeremonyFailure proto.InternalMessageInfo

type isCeremonyFailure_Failure interface {
	isCeremonyFailure_Failure()
	MarshalTo([]byte) (int, error)
	Size() int
}

type CeremonyFailure_Timeout_ struct {
	Timeout *CeremonyFailure_Timeout `protobuf:"bytes,1,opt,name=timeout,proto3,oneof" json:"timeout,omitempty"`
}
type CeremonyFailure_BadCommitment_ struct {
	BadCommitment *CeremonyFailure_BadCommitment `protobuf:"bytes,2,opt,name=bad_commitment,json=badCommitment,proto3,oneof" json:"bad_commitment,omitempty"`
}
type CeremonyFailure_BadShare_ struct {
	BadShare *CeremonyFailure_BadShare `protobuf:"bytes,3,opt,name=bad_share,json=badShare,proto3,oneof" json:"bad_share,omitempty"`
}
type CeremonyFailure_Canceled_ struct {
	Canceled *CeremonyFailure_Canceled `protobuf:"bytes,4,opt,name=canceled,proto3,oneof" json:"canceled,omitempty"`
}

func (*CeremonyFailure_Timeout_) isCeremonyFailure_Failure()       {}
func (*CeremonyFailure_BadCommitment_) isCeremonyFailure_Failure() {}
func (*CeremonyFailure_BadShare_) isCeremonyFailure_Failure()      {}
func (*CeremonyFailure_Canceled_) isCeremonyFailure_Failure()      {}

func (m *CeremonyFailure) GetFailure() isCeremonyFailure_Failure {
	if m != nil {
		return m.Failure
	}
	return nil
}

func (m *CeremonyFailure) GetTimeout() *CeremonyFailure_Timeout {
	if x, ok := m.GetFailure().(*CeremonyFailure_Timeout_); ok {
		return x.Timeout
	}
	return nil
}

func (m *CeremonyFailure) GetBadCommitment() *CeremonyFailure_BadCommitment {
	if x, ok := m.GetFailure().(*CeremonyFailure_BadCommitment_); ok {
		return x.BadCommitment
	}
	return nil
}

func (m *CeremonyFailure) GetBadShare() *CeremonyFailure_BadShare {
	if x, ok := m.GetFailure().(*CeremonyFailure_BadShare_); ok {
		return x.BadShare
	}
	return nil
}

func (m *CeremonyFailure) GetCanceled() *CeremonyFailure_Canceled {
	if x, ok := m.GetFailure().(*CeremonyFailure_Canceled_); ok {
		return x.Canceled
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CeremonyFailure) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CeremonyFailure_Timeout_)(nil),
		(*CeremonyFailure_BadCommitment_)(nil),
		(*CeremonyFailure_BadShare_)(nil),
		(*CeremonyFailure_Canceled_)(nil),
	}
}

type CeremonyFailure_Timeout struct {
}

func (m *CeremonyFailure_Timeout) Reset()         { *m = CeremonyFailure_Timeout{} }
func (m *CeremonyFailure_Timeout) String() string { return proto.CompactTextString(m) }
func (*CeremonyFailure_Timeout) ProtoMessage()    {}
func (*CeremonyFailure_Timeout) Descriptor() ([]byte, []int) {
	return fileDescriptor_e17e78e0f19a1ac0, []int{15, 0}
}
func (m *CeremonyFailure_Timeout) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CeremonyFailure_Timeout) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CeremonyFailure_Timeout.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CeremonyFailure_Timeout) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CeremonyFailure_Timeout.Merge(m, src)
}
func (m *CeremonyFailure_Timeout) XXX_Size() int {
	return m.Size()
}
func (m *CeremonyFailure_Timeout) XXX_DiscardUnknown() {
	xxx_messageInfo_CeremonyFailure_Timeout.DiscardUnknown(m)
}

var xxx_messageInfo_CeremonyFailure_Timeout proto.InternalMessageInfo

type CeremonyFailure_BadCommitment struct {
}

func (m *CeremonyFailure_BadCommitment) Reset()         { *m = CeremonyFailure_BadCommitment{} }
func (m *CeremonyFailure_BadCommitment) String() string { return proto.CompactTextString(m) }
func (*CeremonyFailure_BadCommitment) ProtoMessage()    {}
func (*CeremonyFailure_BadCommitment) Descriptor() ([]byte, []int) {
	return fileDescriptor_e17e78e0f19a1ac0, []int{15, 1}
}
func (m *CeremonyFailure_BadCommitment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CeremonyFailure_BadCommitment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CeremonyFailure_BadCommitment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CeremonyFailure_BadCommitment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CeremonyFailure_BadCommitment.Merge(m, src)
}
func (m *CeremonyFailure_BadCommitment) XXX_Size() int {
	return m.Size()
}
func (m *CeremonyFailure_BadCommitment) XXX_DiscardUnknown() {
	xxx_messageInfo_CeremonyFailure_BadCommitment.DiscardUnknown(m)
}

var xxx_messageInfo_CeremonyFailure_BadCommitment proto.InternalMessageInfo

type CeremonyFailure_BadShare struct {
}

func (m *CeremonyFailure_BadShare) Reset()         { *m = CeremonyFailure_BadShare{} }
func (m *CeremonyFailure_BadShare) String() string { return proto.CompactTextString(m) }
func (*CeremonyFailure_BadShare) ProtoMessage()    {}
func (*CeremonyFailure_BadShare) Descriptor() ([]byte, []int) {
	return fileDescriptor_e17e78e0f19a1ac0, []int{15, 2}
}
func (m *CeremonyFailure_BadShare) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CeremonyFailure_BadShare) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CeremonyFailure_BadShare.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CeremonyFailure_BadShare) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CeremonyFailure_BadShare.Merge(m, src)
}
func (m *CeremonyFailure_BadShare) XXX_Size() int {
	return m.Size()
}
func (m *CeremonyFailure_BadShare) XXX_DiscardUnknown() {
	xxx_messageInfo_CeremonyFailure_BadShare.DiscardUnknown(m)
}

var xxx_messageInfo_CeremonyFailure_BadShare proto.InternalMessageInfo

type CeremonyFailure_Canceled struct {
}

func (m *CeremonyFailure_Canceled) Reset()         { *m = CeremonyFailure_Canceled{} }
func (m *CeremonyFailure_Canceled) String() string { return proto.CompactTextString(m) }
func (*CeremonyFailure_Canceled) ProtoMessage()    {}
func (*CeremonyFailure_Canceled) Descriptor() ([]byte, []int) {
	return fileDescriptor_e17e78e0f19a1ac0, []int{15, 3}
}
func (m *CeremonyFailure_Canceled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CeremonyFailure_Canceled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CeremonyFailure_Canceled.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CeremonyFailure_Canceled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CeremonyFailure_Canceled.Merge(m, src)
}
func (m *CeremonyFailure_Canceled) XXX_Size() int {
	return m.Size()
}
func (m *CeremonyFailure_Canceled) XXX_DiscardUnknown() {
	xxx_messageInfo_CeremonyFailure_Canceled.DiscardUnknown(m)
}

var xxx_messageInfo_CeremonyFailure_Canceled proto.InternalMessageInfo

// The data recorded on-chain about the current state of a signing ceremony.
//
// The state machine of a signing ceremony is depicted in the following diagram:
// ```
// ┌───────┐   ┌─────────────┐   ┌─────────────┐   ┌────────┐
// │Pending│──▶│StartedRound1│──▶│StartedRound2│──▶│Finished│
// └───────┘   └─────────────┘   └─────────────┘   ├────────┤
//
//	│              │                 │          │AuthData│
//	│              │                 │          └────────┘
//	│              │                 │
//	│              │                 │          ┌────────┐
//	└──────────────┴─────────────────┴─────────▶│ Failed │
//	                                            └────────┘
//
// ```
//
// The ceremony steps are described in the FROST I-D:
// https://www.ietf.org/archive/id/draft-irtf-cfrg-frost-11.html
type CeremonyState struct {
	// Types that are valid to be assigned to State:
	//	*CeremonyState_Pending_
	//	*CeremonyState_StartedRound_1
	//	*CeremonyState_StartedRound_2
	//	*CeremonyState_Finished_
	//	*CeremonyState_Failed_
	State isCeremonyState_State `protobuf_oneof:"state"`
}

func (m *CeremonyState) Reset()         { *m = CeremonyState{} }
func (m *CeremonyState) String() string { return proto.CompactTextString(m) }
func (*CeremonyState) ProtoMessage()    {}
func (*CeremonyState) Descriptor() ([]byte, []int) {
	return fileDescriptor_e17e78e0f19a1ac0, []int{16}
}
func (m *CeremonyState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CeremonyState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CeremonyState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CeremonyState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CeremonyState.Merge(m, src)
}
func (m *CeremonyState) XXX_Size() int {
	return m.Size()
}
func (m *CeremonyState) XXX_DiscardUnknown() {
	xxx_messageInfo_CeremonyState.DiscardUnknown(m)
}

var xxx_messageInfo_CeremonyState proto.InternalMessageInfo

type isCeremonyState_State interface {
	isCeremonyState_State()
	MarshalTo([]byte) (int, error)
	Size() int
}

type CeremonyState_Pending_ struct {
	Pending *CeremonyState_Pending `protobuf:"bytes,1,opt,name=pending,proto3,oneof" json:"pending,omitempty"`
}
type CeremonyState_StartedRound_1 struct {
	StartedRound_1 *CeremonyState_StartedRound1 `protobuf:"bytes,2,opt,name=started_round_1,json=startedRound1,proto3,oneof" json:"started_round_1,omitempty"`
}
type CeremonyState_StartedRound_2 struct {
	StartedRound_2 *CeremonyState_StartedRound2 `protobuf:"bytes,3,opt,name=started_round_2,json=startedRound2,proto3,oneof" json:"started_round_2,omitempty"`
}
type CeremonyState_Finished_ struct {
	Finished *CeremonyState_Finished `protobuf:"bytes,4,opt,name=finished,proto3,oneof" json:"finished,omitempty"`
}
type CeremonyState_Failed_ struct {
	Failed *CeremonyState_Failed `protobuf:"bytes,5,opt,name=failed,proto3,oneof" json:"failed,omitempty"`
}

func (*CeremonyState_Pending_) isCeremonyState_State()       {}
func (*CeremonyState_StartedRound_1) isCeremonyState_State() {}
func (*CeremonyState_StartedRound_2) isCeremonyState_State() {}
func (*CeremonyState_Finished_) isCeremonyState_State()      {}
func (*CeremonyState_Failed_) isCeremonyState_State()        {}

func (m *CeremonyState) GetState() isCeremonyState_State {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *CeremonyState) GetPending() *CeremonyState_Pending {
	if x, ok := m.GetState().(*CeremonyState_Pending_); ok {
		return x.Pending
	}
	return nil
}

func (m *CeremonyState) GetStartedRound_1() *CeremonyState_StartedRound1 {
	if x, ok := m.GetState().(*CeremonyState_StartedRound_1); ok {
		return x.StartedRound_1
	}
	return nil
}

func (m *CeremonyState) GetStartedRound_2() *CeremonyState_StartedRound2 {
	if x, ok := m.GetState().(*CeremonyState_StartedRound_2); ok {
		return x.StartedRound_2
	}
	return nil
}

func (m *CeremonyState) GetFinished() *CeremonyState_Finished {
	if x, ok := m.GetState().(*CeremonyState_Finished_); ok {
		return x.Finished
	}
	return nil
}

func (m *CeremonyState) GetFailed() *CeremonyState_Failed {
	if x, ok := m.GetState().(*CeremonyState_Failed_); ok {
		return x.Failed
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CeremonyState) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CeremonyState_Pending_)(nil),
		(*CeremonyState_StartedRound_1)(nil),
		(*CeremonyState_StartedRound_2)(nil),
		(*CeremonyState_Finished_)(nil),
		(*CeremonyState_Failed_)(nil),
	}
}

// A ceremony that has not yet started.
//
// For instance, a request could be queued until sufficient pre-authorizations were recorded on the ledger.
type CeremonyState_Pending struct {
}

func (m *CeremonyState_Pending) Reset()         { *m = CeremonyState_Pending{} }
func (m *CeremonyState_Pending) String() string { return proto.CompactTextString(m) }
func (*CeremonyState_Pending) ProtoMessage()    {}
func (*CeremonyState_Pending) Descriptor() ([]byte, []int) {
	return fileDescriptor_e17e78e0f19a1ac0, []int{16, 0}
}
func (m *CeremonyState_Pending) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CeremonyState_Pending) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CeremonyState_Pending.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CeremonyState_Pending) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CeremonyState_Pending.Merge(m, src)
}
func (m *CeremonyState_Pending) XXX_Size() int {
	return m.Size()
}
func (m *CeremonyState_Pending) XXX_DiscardUnknown() {
	xxx_messageInfo_CeremonyState_Pending.DiscardUnknown(m)
}

var xxx_messageInfo_CeremonyState_Pending proto.InternalMessageInfo

// A ceremony that has started round 1.
//
// The committee has been chosen and the ledger is waiting to record round 1 contributions from all committee members.
type CeremonyState_StartedRound1 struct {
	// The committee performing the ceremony.
	Committee *Committee `protobuf:"bytes,1,opt,name=committee,proto3" json:"committee,omitempty"`
	// A list of commitment messages received so far (begins empty).
	Commitments []*AuthorizeCommitment `protobuf:"bytes,2,rep,name=commitments,proto3" json:"commitments,omitempty"`
}

func (m *CeremonyState_StartedRound1) Reset()         { *m = CeremonyState_StartedRound1{} }
func (m *CeremonyState_StartedRound1) String() string { return proto.CompactTextString(m) }
func (*CeremonyState_StartedRound1) ProtoMessage()    {}
func (*CeremonyState_StartedRound1) Descriptor() ([]byte, []int) {
	return fileDescriptor_e17e78e0f19a1ac0, []int{16, 1}
}
func (m *CeremonyState_StartedRound1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CeremonyState_StartedRound1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CeremonyState_StartedRound1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CeremonyState_StartedRound1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CeremonyState_StartedRound1.Merge(m, src)
}
func (m *CeremonyState_StartedRound1) XXX_Size() int {
	return m.Size()
}
func (m *CeremonyState_StartedRound1) XXX_DiscardUnknown() {
	xxx_messageInfo_CeremonyState_StartedRound1.DiscardUnknown(m)
}

var xxx_messageInfo_CeremonyState_StartedRound1 proto.InternalMessageInfo

func (m *CeremonyState_StartedRound1) GetCommittee() *Committee {
	if m != nil {
		return m.Committee
	}
	return nil
}

func (m *CeremonyState_StartedRound1) GetCommitments() []*AuthorizeCommitment {
	if m != nil {
		return m.Commitments
	}
	return nil
}

// A ceremony that has started round 2.
//
// The committee has been chosen, all round 1 commitments have been recorded, and the ledger is waiting to record round 1 contributions from all committee members.
type CeremonyState_StartedRound2 struct {
	// The committee performing the ceremony.
	Committee *Committee `protobuf:"bytes,1,opt,name=committee,proto3" json:"committee,omitempty"`
	// A list of commitment messages received in round 1.
	Commitments []*AuthorizeCommitment `protobuf:"bytes,2,rep,name=commitments,proto3" json:"commitments,omitempty"`
	// A list of authorization share messages received so far (begins empty).
	Shares []*AuthorizeShare `protobuf:"bytes,3,rep,name=shares,proto3" json:"shares,omitempty"`
}

func (m *CeremonyState_StartedRound2) Reset()         { *m = CeremonyState_StartedRound2{} }
func (m *CeremonyState_StartedRound2) String() string { return proto.CompactTextString(m) }
func (*CeremonyState_StartedRound2) ProtoMessage()    {}
func (*CeremonyState_StartedRound2) Descriptor() ([]byte, []int) {
	return fileDescriptor_e17e78e0f19a1ac0, []int{16, 2}
}
func (m *CeremonyState_StartedRound2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CeremonyState_StartedRound2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CeremonyState_StartedRound2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CeremonyState_StartedRound2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CeremonyState_StartedRound2.Merge(m, src)
}
func (m *CeremonyState_StartedRound2) XXX_Size() int {
	return m.Size()
}
func (m *CeremonyState_StartedRound2) XXX_DiscardUnknown() {
	xxx_messageInfo_CeremonyState_StartedRound2.DiscardUnknown(m)
}

var xxx_messageInfo_CeremonyState_StartedRound2 proto.InternalMessageInfo

func (m *CeremonyState_StartedRound2) GetCommittee() *Committee {
	if m != nil {
		return m.Committee
	}
	return nil
}

func (m *CeremonyState_StartedRound2) GetCommitments() []*AuthorizeCommitment {
	if m != nil {
		return m.Commitments
	}
	return nil
}

func (m *CeremonyState_StartedRound2) GetShares() []*AuthorizeShare {
	if m != nil {
		return m.Shares
	}
	return nil
}

// A ceremony that has successfully finished.
//
// The transcript of the ceremony is recorded along with the resulting `AuthorizationData`.
type CeremonyState_Finished struct {
	// The committee performing the ceremony.
	Committee *Committee `protobuf:"bytes,1,opt,name=committee,proto3" json:"committee,omitempty"`
	// A list of commitment messages received in round 1.
	Commitments []*AuthorizeCommitment `protobuf:"bytes,2,rep,name=commitments,proto3" json:"commitments,omitempty"`
	// A list of authorization share messages received in round 2.
	Shares []*AuthorizeShare `protobuf:"bytes,3,rep,name=shares,proto3" json:"shares,omitempty"`
	// The authorization data resulting from the ceremony.
	AuthData *v1alpha12.AuthorizationData `protobuf:"bytes,4,opt,name=auth_data,json=authData,proto3" json:"auth_data,omitempty"`
}

func (m *CeremonyState_Finished) Reset()         { *m = CeremonyState_Finished{} }
func (m *CeremonyState_Finished) String() string { return proto.CompactTextString(m) }
func (*CeremonyState_Finished) ProtoMessage()    {}
func (*CeremonyState_Finished) Descriptor() ([]byte, []int) {
	return fileDescriptor_e17e78e0f19a1ac0, []int{16, 3}
}
func (m *CeremonyState_Finished) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CeremonyState_Finished) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CeremonyState_Finished.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CeremonyState_Finished) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CeremonyState_Finished.Merge(m, src)
}
func (m *CeremonyState_Finished) XXX_Size() int {
	return m.Size()
}
func (m *CeremonyState_Finished) XXX_DiscardUnknown() {
	xxx_messageInfo_CeremonyState_Finished.DiscardUnknown(m)
}

var xxx_messageInfo_CeremonyState_Finished proto.InternalMessageInfo

func (m *CeremonyState_Finished) GetCommittee() *Committee {
	if m != nil {
		return m.Committee
	}
	return nil
}

func (m *CeremonyState_Finished) GetCommitments() []*AuthorizeCommitment {
	if m != nil {
		return m.Commitments
	}
	return nil
}

func (m *CeremonyState_Finished) GetShares() []*AuthorizeShare {
	if m != nil {
		return m.Shares
	}
	return nil
}

func (m *CeremonyState_Finished) GetAuthData() *v1alpha12.AuthorizationData {
	if m != nil {
		return m.AuthData
	}
	return nil
}

// A ceremony that failed.
//
// The transcript of the ceremony is recorded along with the reason for the failure.
type CeremonyState_Failed struct {
	// The committee performing the ceremony.
	Committee *Committee `protobuf:"bytes,1,opt,name=committee,proto3" json:"committee,omitempty"`
	// A list of commitment messages received in round 1, if any.
	Commitments []*AuthorizeCommitment `protobuf:"bytes,2,rep,name=commitments,proto3" json:"commitments,omitempty"`
	// A list of authorization share messages received in round 2, if any.
	Shares []*AuthorizeShare `protobuf:"bytes,3,rep,name=shares,proto3" json:"shares,omitempty"`
	// A description of the failure.
	Failure *CeremonyFailure `protobuf:"bytes,4,opt,name=failure,proto3" json:"failure,omitempty"`
}

func (m *CeremonyState_Failed) Reset()         { *m = CeremonyState_Failed{} }
func (m *CeremonyState_Failed) String() string { return proto.CompactTextString(m) }
func (*CeremonyState_Failed) ProtoMessage()    {}
func (*CeremonyState_Failed) Descriptor() ([]byte, []int) {
	return fileDescriptor_e17e78e0f19a1ac0, []int{16, 4}
}
func (m *CeremonyState_Failed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CeremonyState_Failed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CeremonyState_Failed.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CeremonyState_Failed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CeremonyState_Failed.Merge(m, src)
}
func (m *CeremonyState_Failed) XXX_Size() int {
	return m.Size()
}
func (m *CeremonyState_Failed) XXX_DiscardUnknown() {
	xxx_messageInfo_CeremonyState_Failed.DiscardUnknown(m)
}

var xxx_messageInfo_CeremonyState_Failed proto.InternalMessageInfo

func (m *CeremonyState_Failed) GetCommittee() *Committee {
	if m != nil {
		return m.Committee
	}
	return nil
}

func (m *CeremonyState_Failed) GetCommitments() []*AuthorizeCommitment {
	if m != nil {
		return m.Commitments
	}
	return nil
}

func (m *CeremonyState_Failed) GetShares() []*AuthorizeShare {
	if m != nil {
		return m.Shares
	}
	return nil
}

func (m *CeremonyState_Failed) GetFailure() *CeremonyFailure {
	if m != nil {
		return m.Failure
	}
	return nil
}

// A packet of data sent to the Narsil ledger.
//
// This structure is what Narsil uses as a Tendermint transaction.  However, we
// use the word "packet" rather than "transaction" here so that it's always
// unambiguous whether we're referring to data posted to the Penumbra chain or
// to a Narsil instance.
type NarsilPacket struct {
	// Types that are valid to be assigned to Packet:
	//	*NarsilPacket_AuthorizeRequest
	//	*NarsilPacket_AuthorizeCommitment
	//	*NarsilPacket_AuthorizeShare
	//	*NarsilPacket_DkgRound_1
	//	*NarsilPacket_DkgRound_2
	Packet isNarsilPacket_Packet `protobuf_oneof:"packet"`
}

func (m *NarsilPacket) Reset()         { *m = NarsilPacket{} }
func (m *NarsilPacket) String() string { return proto.CompactTextString(m) }
func (*NarsilPacket) ProtoMessage()    {}
func (*NarsilPacket) Descriptor() ([]byte, []int) {
	return fileDescriptor_e17e78e0f19a1ac0, []int{17}
}
func (m *NarsilPacket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NarsilPacket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NarsilPacket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NarsilPacket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NarsilPacket.Merge(m, src)
}
func (m *NarsilPacket) XXX_Size() int {
	return m.Size()
}
func (m *NarsilPacket) XXX_DiscardUnknown() {
	xxx_messageInfo_NarsilPacket.DiscardUnknown(m)
}

var xxx_messageInfo_NarsilPacket proto.InternalMessageInfo

type isNarsilPacket_Packet interface {
	isNarsilPacket_Packet()
	MarshalTo([]byte) (int, error)
	Size() int
}

type NarsilPacket_AuthorizeRequest struct {
	AuthorizeRequest *v1alpha13.AuthorizeRequest `protobuf:"bytes,1,opt,name=authorize_request,json=authorizeRequest,proto3,oneof" json:"authorize_request,omitempty"`
}
type NarsilPacket_AuthorizeCommitment struct {
	AuthorizeCommitment *AuthorizeCommitment `protobuf:"bytes,2,opt,name=authorize_commitment,json=authorizeCommitment,proto3,oneof" json:"authorize_commitment,omitempty"`
}
type NarsilPacket_AuthorizeShare struct {
	AuthorizeShare *AuthorizeShare `protobuf:"bytes,3,opt,name=authorize_share,json=authorizeShare,proto3,oneof" json:"authorize_share,omitempty"`
}
type NarsilPacket_DkgRound_1 struct {
	DkgRound_1 *DkgRound1 `protobuf:"bytes,1000,opt,name=dkg_round_1,json=dkgRound1,proto3,oneof" json:"dkg_round_1,omitempty"`
}
type NarsilPacket_DkgRound_2 struct {
	DkgRound_2 *DkgRound2 `protobuf:"bytes,1001,opt,name=dkg_round_2,json=dkgRound2,proto3,oneof" json:"dkg_round_2,omitempty"`
}

func (*NarsilPacket_AuthorizeRequest) isNarsilPacket_Packet()    {}
func (*NarsilPacket_AuthorizeCommitment) isNarsilPacket_Packet() {}
func (*NarsilPacket_AuthorizeShare) isNarsilPacket_Packet()      {}
func (*NarsilPacket_DkgRound_1) isNarsilPacket_Packet()          {}
func (*NarsilPacket_DkgRound_2) isNarsilPacket_Packet()          {}

func (m *NarsilPacket) GetPacket() isNarsilPacket_Packet {
	if m != nil {
		return m.Packet
	}
	return nil
}

func (m *NarsilPacket) GetAuthorizeRequest() *v1alpha13.AuthorizeRequest {
	if x, ok := m.GetPacket().(*NarsilPacket_AuthorizeRequest); ok {
		return x.AuthorizeRequest
	}
	return nil
}

func (m *NarsilPacket) GetAuthorizeCommitment() *AuthorizeCommitment {
	if x, ok := m.GetPacket().(*NarsilPacket_AuthorizeCommitment); ok {
		return x.AuthorizeCommitment
	}
	return nil
}

func (m *NarsilPacket) GetAuthorizeShare() *AuthorizeShare {
	if x, ok := m.GetPacket().(*NarsilPacket_AuthorizeShare); ok {
		return x.AuthorizeShare
	}
	return nil
}

func (m *NarsilPacket) GetDkgRound_1() *DkgRound1 {
	if x, ok := m.GetPacket().(*NarsilPacket_DkgRound_1); ok {
		return x.DkgRound_1
	}
	return nil
}

func (m *NarsilPacket) GetDkgRound_2() *DkgRound2 {
	if x, ok := m.GetPacket().(*NarsilPacket_DkgRound_2); ok {
		return x.DkgRound_2
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*NarsilPacket) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*NarsilPacket_AuthorizeRequest)(nil),
		(*NarsilPacket_AuthorizeCommitment)(nil),
		(*NarsilPacket_AuthorizeShare)(nil),
		(*NarsilPacket_DkgRound_1)(nil),
		(*NarsilPacket_DkgRound_2)(nil),
	}
}

// A wrapper around the FROST commitment message, exchanged in round 1 of the
// signing protocol for a single signature.
type FrostCommitment struct {
	Payload []byte `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *FrostCommitment) Reset()         { *m = FrostCommitment{} }
func (m *FrostCommitment) String() string { return proto.CompactTextString(m) }
func (*FrostCommitment) ProtoMessage()    {}
func (*FrostCommitment) Descriptor() ([]byte, []int) {
	return fileDescriptor_e17e78e0f19a1ac0, []int{18}
}
func (m *FrostCommitment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FrostCommitment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FrostCommitment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FrostCommitment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FrostCommitment.Merge(m, src)
}
func (m *FrostCommitment) XXX_Size() int {
	return m.Size()
}
func (m *FrostCommitment) XXX_DiscardUnknown() {
	xxx_messageInfo_FrostCommitment.DiscardUnknown(m)
}

var xxx_messageInfo_FrostCommitment proto.InternalMessageInfo

func (m *FrostCommitment) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

// A wrapper around the FROST signature share, exchanged in round 2 of the
// signing protocol for a single signature.
type FrostSignatureShare struct {
	Payload []byte `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *FrostSignatureShare) Reset()         { *m = FrostSignatureShare{} }
func (m *FrostSignatureShare) String() string { return proto.CompactTextString(m) }
func (*FrostSignatureShare) ProtoMessage()    {}
func (*FrostSignatureShare) Descriptor() ([]byte, []int) {
	return fileDescriptor_e17e78e0f19a1ac0, []int{19}
}
func (m *FrostSignatureShare) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FrostSignatureShare) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FrostSignatureShare.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FrostSignatureShare) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FrostSignatureShare.Merge(m, src)
}
func (m *FrostSignatureShare) XXX_Size() int {
	return m.Size()
}
func (m *FrostSignatureShare) XXX_DiscardUnknown() {
	xxx_messageInfo_FrostSignatureShare.DiscardUnknown(m)
}

var xxx_messageInfo_FrostSignatureShare proto.InternalMessageInfo

func (m *FrostSignatureShare) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

// A Narsil shard's commitment message for a single ceremony, which may perform
// multiple signatures (one for each spend in the `AuthorizeRequest`'s
// `TransactionPlan`).
//
// This bundle of messages is signed with the shard's `ShardMessageKey` to
// prevent tampering (e.g., reordering of the internal FROST messages, etc).
type AuthorizeCommitment struct {
	Body      *AuthorizeCommitment_Body `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	Signer    *ShardMessageKey          `protobuf:"bytes,2,opt,name=signer,proto3" json:"signer,omitempty"`
	Signature *ShardMessageSignature    `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *AuthorizeCommitment) Reset()         { *m = AuthorizeCommitment{} }
func (m *AuthorizeCommitment) String() string { return proto.CompactTextString(m) }
func (*AuthorizeCommitment) ProtoMessage()    {}
func (*AuthorizeCommitment) Descriptor() ([]byte, []int) {
	return fileDescriptor_e17e78e0f19a1ac0, []int{20}
}
func (m *AuthorizeCommitment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthorizeCommitment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthorizeCommitment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthorizeCommitment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthorizeCommitment.Merge(m, src)
}
func (m *AuthorizeCommitment) XXX_Size() int {
	return m.Size()
}
func (m *AuthorizeCommitment) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthorizeCommitment.DiscardUnknown(m)
}

var xxx_messageInfo_AuthorizeCommitment proto.InternalMessageInfo

func (m *AuthorizeCommitment) GetBody() *AuthorizeCommitment_Body {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *AuthorizeCommitment) GetSigner() *ShardMessageKey {
	if m != nil {
		return m.Signer
	}
	return nil
}

func (m *AuthorizeCommitment) GetSignature() *ShardMessageSignature {
	if m != nil {
		return m.Signature
	}
	return nil
}

type AuthorizeCommitment_Body struct {
	CeremonyIndex *CeremonyIndex     `protobuf:"bytes,1,opt,name=ceremony_index,json=ceremonyIndex,proto3" json:"ceremony_index,omitempty"`
	Commitments   []*FrostCommitment `protobuf:"bytes,2,rep,name=commitments,proto3" json:"commitments,omitempty"`
}

func (m *AuthorizeCommitment_Body) Reset()         { *m = AuthorizeCommitment_Body{} }
func (m *AuthorizeCommitment_Body) String() string { return proto.CompactTextString(m) }
func (*AuthorizeCommitment_Body) ProtoMessage()    {}
func (*AuthorizeCommitment_Body) Descriptor() ([]byte, []int) {
	return fileDescriptor_e17e78e0f19a1ac0, []int{20, 0}
}
func (m *AuthorizeCommitment_Body) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthorizeCommitment_Body) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthorizeCommitment_Body.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthorizeCommitment_Body) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthorizeCommitment_Body.Merge(m, src)
}
func (m *AuthorizeCommitment_Body) XXX_Size() int {
	return m.Size()
}
func (m *AuthorizeCommitment_Body) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthorizeCommitment_Body.DiscardUnknown(m)
}

var xxx_messageInfo_AuthorizeCommitment_Body proto.InternalMessageInfo

func (m *AuthorizeCommitment_Body) GetCeremonyIndex() *CeremonyIndex {
	if m != nil {
		return m.CeremonyIndex
	}
	return nil
}

func (m *AuthorizeCommitment_Body) GetCommitments() []*FrostCommitment {
	if m != nil {
		return m.Commitments
	}
	return nil
}

// A Narsil shard's signature share message for a single ceremony, which may perform
// multiple signatures (one for each spend in the `AuthorizeRequest`'s
// `TransactionPlan`).
//
// This bundle of messages is signed with the shard's `ShardMessageKey` to
// prevent tampering (e.g., reordering of the internal FROST messages, etc).
type AuthorizeShare struct {
	Body      *AuthorizeShare_Body   `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	Signer    *ShardMessageKey       `protobuf:"bytes,2,opt,name=signer,proto3" json:"signer,omitempty"`
	Signature *ShardMessageSignature `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *AuthorizeShare) Reset()         { *m = AuthorizeShare{} }
func (m *AuthorizeShare) String() string { return proto.CompactTextString(m) }
func (*AuthorizeShare) ProtoMessage()    {}
func (*AuthorizeShare) Descriptor() ([]byte, []int) {
	return fileDescriptor_e17e78e0f19a1ac0, []int{21}
}
func (m *AuthorizeShare) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthorizeShare) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthorizeShare.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthorizeShare) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthorizeShare.Merge(m, src)
}
func (m *AuthorizeShare) XXX_Size() int {
	return m.Size()
}
func (m *AuthorizeShare) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthorizeShare.DiscardUnknown(m)
}

var xxx_messageInfo_AuthorizeShare proto.InternalMessageInfo

func (m *AuthorizeShare) GetBody() *AuthorizeShare_Body {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *AuthorizeShare) GetSigner() *ShardMessageKey {
	if m != nil {
		return m.Signer
	}
	return nil
}

func (m *AuthorizeShare) GetSignature() *ShardMessageSignature {
	if m != nil {
		return m.Signature
	}
	return nil
}

type AuthorizeShare_Body struct {
	CeremonyIndex *CeremonyIndex     `protobuf:"bytes,1,opt,name=ceremony_index,json=ceremonyIndex,proto3" json:"ceremony_index,omitempty"`
	Commitments   []*FrostCommitment `protobuf:"bytes,2,rep,name=commitments,proto3" json:"commitments,omitempty"`
}

func (m *AuthorizeShare_Body) Reset()         { *m = AuthorizeShare_Body{} }
func (m *AuthorizeShare_Body) String() string { return proto.CompactTextString(m) }
func (*AuthorizeShare_Body) ProtoMessage()    {}
func (*AuthorizeShare_Body) Descriptor() ([]byte, []int) {
	return fileDescriptor_e17e78e0f19a1ac0, []int{21, 0}
}
func (m *AuthorizeShare_Body) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthorizeShare_Body) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthorizeShare_Body.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthorizeShare_Body) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthorizeShare_Body.Merge(m, src)
}
func (m *AuthorizeShare_Body) XXX_Size() int {
	return m.Size()
}
func (m *AuthorizeShare_Body) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthorizeShare_Body.DiscardUnknown(m)
}

var xxx_messageInfo_AuthorizeShare_Body proto.InternalMessageInfo

func (m *AuthorizeShare_Body) GetCeremonyIndex() *CeremonyIndex {
	if m != nil {
		return m.CeremonyIndex
	}
	return nil
}

func (m *AuthorizeShare_Body) GetCommitments() []*FrostCommitment {
	if m != nil {
		return m.Commitments
	}
	return nil
}

// A shard operator's round 1 contribution to the DKG ceremony.
type DkgRound1 struct {
	Payload   []byte                 `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	Signer    *ShardMessageKey       `protobuf:"bytes,2,opt,name=signer,proto3" json:"signer,omitempty"`
	Signature *ShardMessageSignature `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *DkgRound1) Reset()         { *m = DkgRound1{} }
func (m *DkgRound1) String() string { return proto.CompactTextString(m) }
func (*DkgRound1) ProtoMessage()    {}
func (*DkgRound1) Descriptor() ([]byte, []int) {
	return fileDescriptor_e17e78e0f19a1ac0, []int{22}
}
func (m *DkgRound1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DkgRound1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DkgRound1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DkgRound1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DkgRound1.Merge(m, src)
}
func (m *DkgRound1) XXX_Size() int {
	return m.Size()
}
func (m *DkgRound1) XXX_DiscardUnknown() {
	xxx_messageInfo_DkgRound1.DiscardUnknown(m)
}

var xxx_messageInfo_DkgRound1 proto.InternalMessageInfo

func (m *DkgRound1) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *DkgRound1) GetSigner() *ShardMessageKey {
	if m != nil {
		return m.Signer
	}
	return nil
}

func (m *DkgRound1) GetSignature() *ShardMessageSignature {
	if m != nil {
		return m.Signature
	}
	return nil
}

// A shard operator's round 2 contribution to the DKG ceremony.
type DkgRound2 struct {
	Payload   []byte                 `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	Signer    *ShardMessageKey       `protobuf:"bytes,2,opt,name=signer,proto3" json:"signer,omitempty"`
	Signature *ShardMessageSignature `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *DkgRound2) Reset()         { *m = DkgRound2{} }
func (m *DkgRound2) String() string { return proto.CompactTextString(m) }
func (*DkgRound2) ProtoMessage()    {}
func (*DkgRound2) Descriptor() ([]byte, []int) {
	return fileDescriptor_e17e78e0f19a1ac0, []int{23}
}
func (m *DkgRound2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DkgRound2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DkgRound2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DkgRound2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DkgRound2.Merge(m, src)
}
func (m *DkgRound2) XXX_Size() int {
	return m.Size()
}
func (m *DkgRound2) XXX_DiscardUnknown() {
	xxx_messageInfo_DkgRound2.DiscardUnknown(m)
}

var xxx_messageInfo_DkgRound2 proto.InternalMessageInfo

func (m *DkgRound2) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *DkgRound2) GetSigner() *ShardMessageKey {
	if m != nil {
		return m.Signer
	}
	return nil
}

func (m *DkgRound2) GetSignature() *ShardMessageSignature {
	if m != nil {
		return m.Signature
	}
	return nil
}

// The data recorded on-chain about the current state of the DKG ceremony.
type DkgState struct {
}

func (m *DkgState) Reset()         { *m = DkgState{} }
func (m *DkgState) String() string { return proto.CompactTextString(m) }
func (*DkgState) ProtoMessage()    {}
func (*DkgState) Descriptor() ([]byte, []int) {
	return fileDescriptor_e17e78e0f19a1ac0, []int{24}
}
func (m *DkgState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DkgState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DkgState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DkgState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DkgState.Merge(m, src)
}
func (m *DkgState) XXX_Size() int {
	return m.Size()
}
func (m *DkgState) XXX_DiscardUnknown() {
	xxx_messageInfo_DkgState.DiscardUnknown(m)
}

var xxx_messageInfo_DkgState proto.InternalMessageInfo

// The DKG has started round 1, and the ledger is waiting to record contributions from shard operators.
type DkgState_StartedRound1 struct {
	// A list of round 1 messages received so far (begins empty).
	Round_1Messages []*DkgRound1 `protobuf:"bytes,1,rep,name=round_1_messages,json=round1Messages,proto3" json:"round_1_messages,omitempty"`
}

func (m *DkgState_StartedRound1) Reset()         { *m = DkgState_StartedRound1{} }
func (m *DkgState_StartedRound1) String() string { return proto.CompactTextString(m) }
func (*DkgState_StartedRound1) ProtoMessage()    {}
func (*DkgState_StartedRound1) Descriptor() ([]byte, []int) {
	return fileDescriptor_e17e78e0f19a1ac0, []int{24, 0}
}
func (m *DkgState_StartedRound1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DkgState_StartedRound1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DkgState_StartedRound1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DkgState_StartedRound1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DkgState_StartedRound1.Merge(m, src)
}
func (m *DkgState_StartedRound1) XXX_Size() int {
	return m.Size()
}
func (m *DkgState_StartedRound1) XXX_DiscardUnknown() {
	xxx_messageInfo_DkgState_StartedRound1.DiscardUnknown(m)
}

var xxx_messageInfo_DkgState_StartedRound1 proto.InternalMessageInfo

func (m *DkgState_StartedRound1) GetRound_1Messages() []*DkgRound1 {
	if m != nil {
		return m.Round_1Messages
	}
	return nil
}

// The DKG has started round 2, and the ledger is waiting to record contributions from shard operators.
type DkgState_StartedRound2 struct {
	// A list of messages received during round 1.
	Round_1Messages []*DkgRound1 `protobuf:"bytes,1,rep,name=round_1_messages,json=round1Messages,proto3" json:"round_1_messages,omitempty"`
	// A list of round 2 messages received so far (begins empty).
	Round_2Messages []*DkgRound2 `protobuf:"bytes,2,rep,name=round_2_messages,json=round2Messages,proto3" json:"round_2_messages,omitempty"`
}

func (m *DkgState_StartedRound2) Reset()         { *m = DkgState_StartedRound2{} }
func (m *DkgState_StartedRound2) String() string { return proto.CompactTextString(m) }
func (*DkgState_StartedRound2) ProtoMessage()    {}
func (*DkgState_StartedRound2) Descriptor() ([]byte, []int) {
	return fileDescriptor_e17e78e0f19a1ac0, []int{24, 1}
}
func (m *DkgState_StartedRound2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DkgState_StartedRound2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DkgState_StartedRound2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DkgState_StartedRound2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DkgState_StartedRound2.Merge(m, src)
}
func (m *DkgState_StartedRound2) XXX_Size() int {
	return m.Size()
}
func (m *DkgState_StartedRound2) XXX_DiscardUnknown() {
	xxx_messageInfo_DkgState_StartedRound2.DiscardUnknown(m)
}

var xxx_messageInfo_DkgState_StartedRound2 proto.InternalMessageInfo

func (m *DkgState_StartedRound2) GetRound_1Messages() []*DkgRound1 {
	if m != nil {
		return m.Round_1Messages
	}
	return nil
}

func (m *DkgState_StartedRound2) GetRound_2Messages() []*DkgRound2 {
	if m != nil {
		return m.Round_2Messages
	}
	return nil
}

// The DKG has finished successfully, producing the jointly-controlled `AccountGroupInfo`.
//
// Unlike the signing ceremony, we don't record a failure case here: if the DKG fails, we abort the entire ledger.
type DkgState_Finished struct {
	// A list of messages received during round 1.
	Round_1Messages []*DkgRound1 `protobuf:"bytes,1,rep,name=round_1_messages,json=round1Messages,proto3" json:"round_1_messages,omitempty"`
	// A list of messages received during round 2.
	Round_2Messages []*DkgRound2 `protobuf:"bytes,2,rep,name=round_2_messages,json=round2Messages,proto3" json:"round_2_messages,omitempty"`
	// The jointly-controlled `AccountGroupInfo` resulting from the DKG.
	AccountGroupInfo *AccountGroupInfo `protobuf:"bytes,3,opt,name=account_group_info,json=accountGroupInfo,proto3" json:"account_group_info,omitempty"`
}

func (m *DkgState_Finished) Reset()         { *m = DkgState_Finished{} }
func (m *DkgState_Finished) String() string { return proto.CompactTextString(m) }
func (*DkgState_Finished) ProtoMessage()    {}
func (*DkgState_Finished) Descriptor() ([]byte, []int) {
	return fileDescriptor_e17e78e0f19a1ac0, []int{24, 2}
}
func (m *DkgState_Finished) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DkgState_Finished) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DkgState_Finished.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DkgState_Finished) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DkgState_Finished.Merge(m, src)
}
func (m *DkgState_Finished) XXX_Size() int {
	return m.Size()
}
func (m *DkgState_Finished) XXX_DiscardUnknown() {
	xxx_messageInfo_DkgState_Finished.DiscardUnknown(m)
}

var xxx_messageInfo_DkgState_Finished proto.InternalMessageInfo

func (m *DkgState_Finished) GetRound_1Messages() []*DkgRound1 {
	if m != nil {
		return m.Round_1Messages
	}
	return nil
}

func (m *DkgState_Finished) GetRound_2Messages() []*DkgRound2 {
	if m != nil {
		return m.Round_2Messages
	}
	return nil
}

func (m *DkgState_Finished) GetAccountGroupInfo() *AccountGroupInfo {
	if m != nil {
		return m.AccountGroupInfo
	}
	return nil
}

func init() {
	proto.RegisterType((*InfoRequest)(nil), "penumbra.narsil.ledger.v1alpha1.InfoRequest")
	proto.RegisterType((*InfoResponse)(nil), "penumbra.narsil.ledger.v1alpha1.InfoResponse")
	proto.RegisterType((*ShardIdentityKey)(nil), "penumbra.narsil.ledger.v1alpha1.ShardIdentityKey")
	proto.RegisterType((*ConsensusKey)(nil), "penumbra.narsil.ledger.v1alpha1.ConsensusKey")
	proto.RegisterType((*ShardMessageKey)(nil), "penumbra.narsil.ledger.v1alpha1.ShardMessageKey")
	proto.RegisterType((*ShardKey)(nil), "penumbra.narsil.ledger.v1alpha1.ShardKey")
	proto.RegisterType((*ShardMessageSignature)(nil), "penumbra.narsil.ledger.v1alpha1.ShardMessageSignature")
	proto.RegisterType((*ShardDescription)(nil), "penumbra.narsil.ledger.v1alpha1.ShardDescription")
	proto.RegisterType((*ShardOperator)(nil), "penumbra.narsil.ledger.v1alpha1.ShardOperator")
	proto.RegisterType((*GenesisData)(nil), "penumbra.narsil.ledger.v1alpha1.GenesisData")
	proto.RegisterType((*AccountGroupInfo)(nil), "penumbra.narsil.ledger.v1alpha1.AccountGroupInfo")
	proto.RegisterType((*ShardInfo)(nil), "penumbra.narsil.ledger.v1alpha1.ShardInfo")
	proto.RegisterType((*RequestIndex)(nil), "penumbra.narsil.ledger.v1alpha1.RequestIndex")
	proto.RegisterType((*CeremonyIndex)(nil), "penumbra.narsil.ledger.v1alpha1.CeremonyIndex")
	proto.RegisterType((*Committee)(nil), "penumbra.narsil.ledger.v1alpha1.Committee")
	proto.RegisterType((*CeremonyFailure)(nil), "penumbra.narsil.ledger.v1alpha1.CeremonyFailure")
	proto.RegisterType((*CeremonyFailure_Timeout)(nil), "penumbra.narsil.ledger.v1alpha1.CeremonyFailure.Timeout")
	proto.RegisterType((*CeremonyFailure_BadCommitment)(nil), "penumbra.narsil.ledger.v1alpha1.CeremonyFailure.BadCommitment")
	proto.RegisterType((*CeremonyFailure_BadShare)(nil), "penumbra.narsil.ledger.v1alpha1.CeremonyFailure.BadShare")
	proto.RegisterType((*CeremonyFailure_Canceled)(nil), "penumbra.narsil.ledger.v1alpha1.CeremonyFailure.Canceled")
	proto.RegisterType((*CeremonyState)(nil), "penumbra.narsil.ledger.v1alpha1.CeremonyState")
	proto.RegisterType((*CeremonyState_Pending)(nil), "penumbra.narsil.ledger.v1alpha1.CeremonyState.Pending")
	proto.RegisterType((*CeremonyState_StartedRound1)(nil), "penumbra.narsil.ledger.v1alpha1.CeremonyState.StartedRound1")
	proto.RegisterType((*CeremonyState_StartedRound2)(nil), "penumbra.narsil.ledger.v1alpha1.CeremonyState.StartedRound2")
	proto.RegisterType((*CeremonyState_Finished)(nil), "penumbra.narsil.ledger.v1alpha1.CeremonyState.Finished")
	proto.RegisterType((*CeremonyState_Failed)(nil), "penumbra.narsil.ledger.v1alpha1.CeremonyState.Failed")
	proto.RegisterType((*NarsilPacket)(nil), "penumbra.narsil.ledger.v1alpha1.NarsilPacket")
	proto.RegisterType((*FrostCommitment)(nil), "penumbra.narsil.ledger.v1alpha1.FrostCommitment")
	proto.RegisterType((*FrostSignatureShare)(nil), "penumbra.narsil.ledger.v1alpha1.FrostSignatureShare")
	proto.RegisterType((*AuthorizeCommitment)(nil), "penumbra.narsil.ledger.v1alpha1.AuthorizeCommitment")
	proto.RegisterType((*AuthorizeCommitment_Body)(nil), "penumbra.narsil.ledger.v1alpha1.AuthorizeCommitment.Body")
	proto.RegisterType((*AuthorizeShare)(nil), "penumbra.narsil.ledger.v1alpha1.AuthorizeShare")
	proto.RegisterType((*AuthorizeShare_Body)(nil), "penumbra.narsil.ledger.v1alpha1.AuthorizeShare.Body")
	proto.RegisterType((*DkgRound1)(nil), "penumbra.narsil.ledger.v1alpha1.DkgRound1")
	proto.RegisterType((*DkgRound2)(nil), "penumbra.narsil.ledger.v1alpha1.DkgRound2")
	proto.RegisterType((*DkgState)(nil), "penumbra.narsil.ledger.v1alpha1.DkgState")
	proto.RegisterType((*DkgState_StartedRound1)(nil), "penumbra.narsil.ledger.v1alpha1.DkgState.StartedRound1")
	proto.RegisterType((*DkgState_StartedRound2)(nil), "penumbra.narsil.ledger.v1alpha1.DkgState.StartedRound2")
	proto.RegisterType((*DkgState_Finished)(nil), "penumbra.narsil.ledger.v1alpha1.DkgState.Finished")
}

func init() {
	proto.RegisterFile("penumbra/narsil/ledger/v1alpha1/ledger.proto", fileDescriptor_e17e78e0f19a1ac0)
}

var fileDescriptor_e17e78e0f19a1ac0 = []byte{
	// 1781 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x59, 0xcd, 0x8f, 0x1b, 0x49,
	0x15, 0xf7, 0x57, 0x66, 0xec, 0x67, 0x7b, 0x66, 0xb6, 0x12, 0xd0, 0xc8, 0x42, 0x93, 0xd0, 0x0b,
	0x6c, 0x94, 0x6c, 0xec, 0x9d, 0x26, 0x2c, 0xec, 0x80, 0x90, 0xe2, 0x09, 0x89, 0xb3, 0x24, 0xd9,
	0xa1, 0x3c, 0x19, 0x50, 0x14, 0xc9, 0x2a, 0x77, 0x97, 0xed, 0xd6, 0xb4, 0xbb, 0x9a, 0xae, 0xf2,
	0x80, 0xf9, 0x13, 0x38, 0xed, 0x8d, 0x3b, 0x12, 0x42, 0xe2, 0xb0, 0x12, 0xb7, 0x45, 0x1c, 0x90,
	0x90, 0x56, 0x62, 0x39, 0xed, 0x11, 0x6e, 0xab, 0xe4, 0x02, 0xfc, 0x09, 0x9c, 0x50, 0x7d, 0xf4,
	0x87, 0xed, 0x0c, 0xb6, 0x87, 0x5d, 0x69, 0x57, 0xcb, 0xad, 0xab, 0xfa, 0xbd, 0xdf, 0xfb, 0xbd,
	0x8f, 0x7a, 0x55, 0xd5, 0x0d, 0xaf, 0x87, 0x34, 0x98, 0x8c, 0xfb, 0x11, 0x69, 0x05, 0x24, 0xe2,
	0x9e, 0xdf, 0xf2, 0xa9, 0x3b, 0xa4, 0x51, 0xeb, 0x6c, 0x9f, 0xf8, 0xe1, 0x88, 0xec, 0x9b, 0x71,
	0x33, 0x8c, 0x98, 0x60, 0xe8, 0x6a, 0x2c, 0xdd, 0xd4, 0xd2, 0x4d, 0xf3, 0x36, 0x96, 0x6e, 0x7c,
	0x23, 0x81, 0x73, 0x58, 0x44, 0x5b, 0xa7, 0x74, 0xca, 0x53, 0x28, 0x39, 0xd2, 0x40, 0x8d, 0xdb,
	0xb3, 0x72, 0x22, 0x22, 0x01, 0x27, 0x8e, 0xf0, 0x58, 0x90, 0x8a, 0x67, 0x26, 0x8d, 0x96, 0x3d,
	0xab, 0xe5, 0xb0, 0x71, 0xc8, 0x02, 0x1a, 0x88, 0x96, 0x33, 0x22, 0x5e, 0x46, 0x53, 0x0d, 0x8d,
	0xce, 0x6b, 0xa9, 0xce, 0x84, 0x0b, 0xe6, 0x4e, 0x33, 0x62, 0x7a, 0x42, 0x0b, 0x5a, 0xef, 0xe6,
	0xa1, 0xfa, 0x20, 0x18, 0x30, 0x4c, 0x7f, 0x3a, 0xa1, 0x5c, 0xa0, 0x5d, 0xd8, 0x3c, 0xa3, 0x11,
	0xf7, 0x58, 0xb0, 0x9b, 0xbf, 0x96, 0xbf, 0x5e, 0xc1, 0xf1, 0x10, 0xbd, 0x0a, 0xf5, 0xbe, 0xcf,
	0x9c, 0xd3, 0x5e, 0xfc, 0xbe, 0x70, 0x2d, 0x7f, 0xbd, 0x84, 0x6b, 0x6a, 0xf2, 0xc4, 0x08, 0x5d,
	0x85, 0x6a, 0x68, 0x87, 0x89, 0x48, 0x51, 0x89, 0x40, 0x68, 0x87, 0xb1, 0xc0, 0x57, 0xa1, 0x46,
	0xfa, 0x8e, 0x97, 0x48, 0x94, 0x94, 0x91, 0xaa, 0x9c, 0x33, 0x22, 0xd6, 0xfb, 0x79, 0xa8, 0x69,
	0x4a, 0x3c, 0x64, 0x01, 0xa7, 0x08, 0x41, 0xc9, 0x25, 0x82, 0x28, 0x42, 0x35, 0xac, 0x9e, 0xb3,
	0x3c, 0x0b, 0xb3, 0x3c, 0xaf, 0x42, 0x95, 0x84, 0x0b, 0x14, 0x48, 0x98, 0x50, 0xb8, 0x01, 0xaf,
	0xf8, 0x84, 0x8b, 0x9e, 0xf6, 0x66, 0x44, 0xbd, 0xe1, 0x48, 0x28, 0x1e, 0x25, 0xbc, 0x2d, 0x5f,
	0xb4, 0xe5, 0x7c, 0x47, 0x4d, 0xa3, 0x5b, 0x70, 0x39, 0x23, 0x2b, 0x71, 0x47, 0x84, 0x8f, 0x76,
	0x2f, 0x29, 0x26, 0x3b, 0x89, 0xf4, 0x9d, 0x30, 0xec, 0x10, 0x3e, 0xb2, 0xae, 0xc3, 0x4e, 0x77,
	0x44, 0x22, 0xf7, 0x81, 0x4b, 0x03, 0xe1, 0x89, 0xe9, 0x0f, 0xe9, 0x14, 0x5d, 0x81, 0x4b, 0x5e,
	0x10, 0xd0, 0xc8, 0xd0, 0xd7, 0x03, 0xeb, 0x6b, 0x50, 0x3b, 0x94, 0xce, 0x05, 0x7c, 0xc2, 0xcf,
	0x97, 0x7a, 0x0d, 0xb6, 0x15, 0xde, 0x23, 0xca, 0x39, 0x19, 0xd2, 0xf3, 0x05, 0xaf, 0x41, 0x59,
	0x09, 0x9e, 0x2f, 0x71, 0x0b, 0xbe, 0x94, 0x85, 0xea, 0x7a, 0xc3, 0x80, 0x88, 0x49, 0x44, 0xcf,
	0x11, 0xff, 0x4d, 0xc1, 0xb8, 0x72, 0x97, 0x72, 0x27, 0xf2, 0x42, 0x59, 0x8f, 0xe8, 0x18, 0x6a,
	0x9e, 0xf1, 0xac, 0x77, 0x4a, 0xa7, 0x4a, 0xa3, 0x6a, 0xef, 0x37, 0x97, 0xac, 0x8f, 0xe6, 0x7c,
	0x4c, 0x70, 0xd5, 0xcb, 0x04, 0xe8, 0x47, 0x50, 0x1d, 0x6b, 0x52, 0x0a, 0xb4, 0xa0, 0x40, 0xdf,
	0x58, 0x0d, 0x34, 0x0d, 0x0c, 0x86, 0x71, 0x1a, 0x24, 0x0c, 0x75, 0x27, 0x8e, 0xae, 0x02, 0x2d,
	0x2a, 0xd0, 0x5b, 0x4b, 0x41, 0xb3, 0x39, 0xc1, 0x35, 0x67, 0x2e, 0x43, 0x3e, 0xe9, 0x53, 0xdf,
	0x94, 0xac, 0x1e, 0x58, 0x67, 0x50, 0x57, 0x44, 0xde, 0x09, 0x69, 0x44, 0x04, 0x8b, 0x50, 0x17,
	0xaa, 0x6e, 0x1a, 0xb2, 0xf5, 0x42, 0x94, 0x89, 0x35, 0xce, 0xa2, 0xa0, 0x1d, 0x28, 0x72, 0x6f,
	0xa8, 0x42, 0x53, 0xc3, 0xf2, 0xd1, 0x9a, 0x42, 0xf5, 0x3e, 0x0d, 0x28, 0xf7, 0xf8, 0x5d, 0xb9,
	0x1c, 0x1e, 0x42, 0x85, 0x19, 0x06, 0x7c, 0x37, 0x7f, 0xad, 0x78, 0xbd, 0x6a, 0x37, 0x57, 0xb3,
	0x19, 0x13, 0xc7, 0x29, 0x00, 0xfa, 0x0a, 0x54, 0xc4, 0x28, 0xa2, 0x7c, 0xc4, 0x7c, 0x57, 0x19,
	0xad, 0xe3, 0x74, 0xc2, 0xfa, 0x43, 0x1e, 0x76, 0xee, 0x38, 0x0e, 0x9b, 0x04, 0xe2, 0x7e, 0xc4,
	0x26, 0xa1, 0x5c, 0xab, 0xe8, 0x09, 0xec, 0x0c, 0x26, 0xbe, 0xdf, 0x3b, 0xf3, 0xe8, 0xcf, 0xbc,
	0x60, 0x98, 0x29, 0x8f, 0x9b, 0x29, 0x0f, 0xd9, 0xbf, 0x9a, 0xaa, 0x1f, 0x26, 0x1c, 0xee, 0x4d,
	0x7c, 0xff, 0x44, 0xeb, 0xc8, 0x90, 0x6f, 0x0d, 0x66, 0xc6, 0xe8, 0x31, 0xd4, 0x42, 0x12, 0x09,
	0xcf, 0xf1, 0x42, 0x12, 0x08, 0xbe, 0x5b, 0x50, 0xae, 0xdd, 0x58, 0xb1, 0xe2, 0x64, 0x13, 0x99,
	0xd1, 0xb7, 0x3e, 0xce, 0x43, 0x25, 0x79, 0xa7, 0x4b, 0xdf, 0xa5, 0x3f, 0x57, 0x4c, 0xeb, 0x58,
	0x0f, 0xd0, 0x10, 0xbe, 0xcc, 0xa5, 0x88, 0x6c, 0x21, 0xde, 0xc0, 0x73, 0x88, 0x4c, 0x41, 0xa6,
	0x34, 0xf7, 0xff, 0xab, 0x43, 0xdd, 0x90, 0x06, 0xee, 0x49, 0x46, 0x53, 0xba, 0x75, 0x45, 0x01,
	0xce, 0xcd, 0x2e, 0x2c, 0xa7, 0xe2, 0x27, 0xb1, 0x9c, 0x2c, 0x07, 0x6a, 0xa6, 0x99, 0x3f, 0x50,
	0xee, 0x74, 0xa1, 0x4a, 0x07, 0x03, 0xea, 0x08, 0xdd, 0xba, 0x74, 0x52, 0xec, 0x39, 0x1f, 0x92,
	0x4d, 0xa5, 0xa9, 0x77, 0x91, 0xc4, 0xd6, 0x0f, 0x94, 0xaa, 0x6c, 0x6e, 0x18, 0x68, 0xf2, 0x6c,
	0xfd, 0x32, 0x0f, 0xf5, 0x43, 0x1a, 0xd1, 0x31, 0x0b, 0xa6, 0xda, 0x0c, 0x86, 0x7a, 0xa4, 0xcd,
	0xf6, 0xd2, 0x98, 0xae, 0xb2, 0xe4, 0xb2, 0x64, 0x71, 0x2d, 0xca, 0x52, 0xff, 0x3a, 0x6c, 0x39,
	0xc6, 0x88, 0x01, 0xd5, 0x7b, 0x4e, 0xdd, 0xc9, 0x9a, 0xb6, 0x7e, 0x9b, 0x87, 0xca, 0x21, 0x1b,
	0x8f, 0x3d, 0x21, 0x28, 0x45, 0x6f, 0x43, 0x39, 0x7e, 0x6d, 0x38, 0x2c, 0x5f, 0x09, 0x33, 0xae,
	0xe0, 0x44, 0xff, 0x13, 0x2f, 0xbf, 0x3f, 0x17, 0x61, 0x3b, 0xb6, 0x75, 0x8f, 0x78, 0xbe, 0xec,
	0xbf, 0xc7, 0xb0, 0x29, 0xbc, 0x31, 0x65, 0x13, 0x61, 0xe8, 0x7e, 0x67, 0x65, 0xba, 0x06, 0xa2,
	0x79, 0xac, 0xf5, 0x3b, 0x39, 0x1c, 0x43, 0xa1, 0x21, 0x6c, 0xf5, 0x89, 0xdb, 0x73, 0x54, 0x58,
	0xc6, 0x34, 0x10, 0xa6, 0x78, 0xbf, 0xbf, 0x36, 0x78, 0x9b, 0xb8, 0x87, 0x09, 0x4a, 0x27, 0x87,
	0xeb, 0xfd, 0xec, 0x04, 0xfa, 0x09, 0x54, 0xa4, 0x21, 0x59, 0xe0, 0xd4, 0x54, 0xf0, 0x5b, 0x17,
	0xb1, 0x21, 0x43, 0x46, 0x3b, 0x39, 0x5c, 0xee, 0x9b, 0x67, 0xf4, 0x63, 0x28, 0x3b, 0x24, 0x70,
	0xa8, 0x4f, 0x5d, 0xd5, 0x73, 0x2f, 0x02, 0x7c, 0x68, 0x00, 0x24, 0x70, 0x0c, 0xd6, 0xa8, 0xc0,
	0xa6, 0x89, 0x58, 0x63, 0x1b, 0xea, 0x33, 0xfe, 0x35, 0x00, 0xca, 0x31, 0x19, 0xf9, 0x1c, 0xeb,
	0xb7, 0x2b, 0xb0, 0x39, 0xd0, 0x98, 0xd6, 0x7b, 0xb5, 0xb4, 0xf6, 0xbb, 0x82, 0x08, 0x8a, 0x30,
	0x6c, 0xca, 0x55, 0xef, 0x05, 0x43, 0x93, 0xc2, 0x37, 0x57, 0x26, 0xaa, 0x00, 0x9a, 0x47, 0x5a,
	0x5b, 0x26, 0xd0, 0x00, 0xa1, 0x01, 0x6c, 0x73, 0x41, 0x22, 0x41, 0xdd, 0x5e, 0xc4, 0x26, 0x81,
	0xdb, 0xdb, 0x37, 0x19, 0xfc, 0xde, 0x9a, 0xd8, 0x5d, 0x8d, 0x82, 0x25, 0xc8, 0xbe, 0xcc, 0x1f,
	0xcf, 0x4e, 0x2c, 0xda, 0xb1, 0x4d, 0x16, 0xff, 0x17, 0x3b, 0xf6, 0xbc, 0x1d, 0x1b, 0x3d, 0x81,
	0xf2, 0xc0, 0x0b, 0x3c, 0x3e, 0x4a, 0xb2, 0xf9, 0xed, 0x35, 0x0d, 0xdc, 0x33, 0xea, 0x32, 0x97,
	0x31, 0x14, 0x7a, 0x07, 0x36, 0x64, 0x5e, 0xa8, 0xab, 0xce, 0x64, 0x55, 0xfb, 0x5b, 0xeb, 0x82,
	0x2a, 0xe5, 0x4e, 0x0e, 0x1b, 0x18, 0x59, 0x1c, 0x26, 0x1b, 0x8d, 0xdf, 0xe7, 0xa1, 0x3e, 0x13,
	0x3d, 0xd4, 0x81, 0x8a, 0x13, 0x37, 0x1a, 0x93, 0xea, 0x1b, 0x2b, 0x9c, 0x29, 0x8c, 0x06, 0x4e,
	0x95, 0xd1, 0x09, 0x54, 0xd3, 0xb5, 0x19, 0x37, 0x96, 0xdb, 0x4b, 0xb1, 0xee, 0x4c, 0xc4, 0x88,
	0x45, 0xde, 0x2f, 0x68, 0x5a, 0xb2, 0x38, 0x0b, 0xd4, 0xf8, 0xf7, 0x1c, 0x67, 0xfb, 0xb3, 0xcf,
	0x19, 0xdd, 0x87, 0x0d, 0xd5, 0x3e, 0xf8, 0x6e, 0x51, 0x41, 0xb6, 0x56, 0x87, 0x54, 0x0b, 0x15,
	0x1b, 0xf5, 0xc6, 0x87, 0x05, 0x28, 0xc7, 0x55, 0xf2, 0x05, 0xf2, 0x1b, 0x61, 0xa8, 0x90, 0x89,
	0x18, 0xf5, 0xd4, 0x2d, 0xa9, 0x34, 0xbf, 0x0e, 0xd4, 0x06, 0x9f, 0xbd, 0x56, 0x2e, 0xc0, 0xa9,
	0x13, 0x89, 0x3c, 0x47, 0xe2, 0xb2, 0xc4, 0x91, 0x4f, 0x8d, 0x3f, 0x15, 0x60, 0x43, 0x2f, 0x8e,
	0x2f, 0x52, 0x24, 0xdf, 0x4e, 0xda, 0xbc, 0x89, 0xe3, 0x1b, 0xeb, 0x6e, 0x39, 0x38, 0x06, 0x68,
	0x6f, 0xc2, 0x25, 0x2e, 0x7b, 0x8c, 0xf5, 0xf7, 0x22, 0xd4, 0x1e, 0x2b, 0xe5, 0x23, 0xe2, 0x9c,
	0x52, 0x81, 0x9e, 0xc2, 0x2b, 0x24, 0xb6, 0xdf, 0x33, 0x27, 0x9e, 0x97, 0x9c, 0x96, 0xcd, 0x45,
	0x7d, 0x91, 0xb3, 0x39, 0x32, 0x75, 0x72, 0x78, 0x87, 0xcc, 0xcd, 0x21, 0x0f, 0xae, 0xa4, 0xd8,
	0x0b, 0xdb, 0xff, 0x85, 0x62, 0xdd, 0xc9, 0xe1, 0xcb, 0x64, 0x71, 0x1a, 0x3d, 0x85, 0xed, 0xd4,
	0x54, 0xf6, 0x00, 0xb0, 0x6e, 0xf8, 0x3b, 0x39, 0xbc, 0x45, 0x66, 0x66, 0xd0, 0x23, 0xa8, 0xba,
	0xa7, 0xc3, 0x64, 0xeb, 0xfb, 0xc7, 0xe6, 0x8a, 0x65, 0x77, 0xf7, 0x74, 0x98, 0xec, 0x74, 0x15,
	0x37, 0x1e, 0xcc, 0xc2, 0xd9, 0xbb, 0xff, 0x5c, 0x17, 0xce, 0xce, 0xc2, 0xd9, 0xed, 0x32, 0x6c,
	0x84, 0x2a, 0x95, 0xd6, 0x4d, 0xd8, 0xbe, 0x17, 0x31, 0x2e, 0x32, 0x61, 0xd9, 0x85, 0xcd, 0x90,
	0x4c, 0x7d, 0x46, 0x5c, 0x73, 0xa5, 0x8e, 0x87, 0x56, 0x0b, 0x2e, 0x2b, 0xe1, 0xe4, 0xf2, 0xad,
	0x7d, 0x3d, 0x5f, 0xe1, 0xfd, 0x22, 0x5c, 0x7e, 0x49, 0x42, 0xd0, 0x23, 0x28, 0xf5, 0x99, 0x1b,
	0x9f, 0x6f, 0xdf, 0xba, 0x48, 0x52, 0x9b, 0x6d, 0xe6, 0x4e, 0xb1, 0x82, 0x41, 0x1d, 0xd8, 0xe0,
	0xde, 0x30, 0xa0, 0xd1, 0x85, 0x2f, 0xdf, 0x46, 0x1f, 0x1d, 0x43, 0x85, 0xc7, 0xce, 0x99, 0x62,
	0x78, 0x73, 0x2d, 0xb0, 0x24, 0x34, 0x38, 0x05, 0x92, 0x1b, 0x71, 0x49, 0xd2, 0x45, 0x4f, 0x16,
	0x2e, 0x04, 0x17, 0x3b, 0xe1, 0xcf, 0x5e, 0x20, 0x10, 0x7e, 0x59, 0x5b, 0x5a, 0x1e, 0x84, 0xb9,
	0xc4, 0xcf, 0xb4, 0x24, 0xeb, 0xbd, 0x22, 0x6c, 0xcd, 0x56, 0x39, 0xea, 0xcc, 0x64, 0xed, 0xf6,
	0x9a, 0x8b, 0xe4, 0xff, 0x09, 0xfb, 0x74, 0x13, 0xf6, 0x41, 0x1e, 0x2a, 0x49, 0xf7, 0x38, 0x7f,
	0x4d, 0x7e, 0xd6, 0x63, 0x3f, 0xe3, 0x87, 0xfd, 0x39, 0xf6, 0xe3, 0xc3, 0x12, 0x94, 0xef, 0x9e,
	0x0e, 0xd5, 0x31, 0xbd, 0x41, 0xe7, 0x4f, 0xe2, 0xc7, 0xb0, 0x63, 0xf6, 0x86, 0x9e, 0xf9, 0xee,
	0x17, 0x7f, 0xf7, 0x5a, 0x63, 0x8f, 0xc0, 0x5b, 0x0a, 0x63, 0xdf, 0xd0, 0xe0, 0x8d, 0x3f, 0x2e,
	0x9c, 0x9e, 0x3f, 0x15, 0x3b, 0x29, 0xaa, 0x9d, 0xa2, 0x16, 0xd6, 0x44, 0xb5, 0x0d, 0xaa, 0x9d,
	0xb0, 0xff, 0x55, 0xf6, 0xf8, 0xfb, 0x39, 0x22, 0x8e, 0x7a, 0x80, 0x88, 0xfe, 0xa0, 0xd8, 0x1b,
	0x46, 0x6c, 0x12, 0xf6, 0xbc, 0x60, 0xc0, 0x56, 0xfe, 0x1c, 0x36, 0xff, 0x2d, 0x12, 0xef, 0x90,
	0xb9, 0x19, 0x5b, 0x40, 0xfd, 0xa1, 0xd2, 0xea, 0xd2, 0xe8, 0xcc, 0x73, 0x28, 0x72, 0xa0, 0xa4,
	0xbe, 0x00, 0xbe, 0xbe, 0x14, 0x3d, 0xf3, 0x73, 0xa4, 0x71, 0x6b, 0x45, 0x69, 0xfd, 0xdf, 0xa2,
	0xfd, 0x41, 0xe1, 0x2f, 0xcf, 0xf7, 0xf2, 0x1f, 0x3d, 0xdf, 0xcb, 0x7f, 0xfc, 0x7c, 0x2f, 0xff,
	0xee, 0x8b, 0xbd, 0xdc, 0x47, 0x2f, 0xf6, 0x72, 0x7f, 0x7b, 0xb1, 0x97, 0x83, 0x57, 0x1d, 0x36,
	0x5e, 0x06, 0xd6, 0xae, 0x6a, 0xce, 0x47, 0x11, 0x13, 0xec, 0x28, 0xff, 0xf4, 0xe9, 0xd0, 0x13,
	0xa3, 0x49, 0xbf, 0xe9, 0xb0, 0x71, 0xcb, 0x61, 0x7c, 0xcc, 0x78, 0x2b, 0xa2, 0x3e, 0x99, 0xd2,
	0xa8, 0x75, 0x66, 0x27, 0x8f, 0xea, 0xfb, 0x1d, 0x6f, 0x2d, 0xf9, 0xc1, 0xf5, 0x5d, 0x3d, 0x8e,
	0x87, 0xbf, 0x2e, 0x14, 0x8f, 0x1e, 0x3f, 0xfc, 0x5d, 0xe1, 0xea, 0x51, 0x4c, 0x49, 0x9f, 0x57,
	0x9b, 0x9a, 0x41, 0xf3, 0xc4, 0xc8, 0xfd, 0x35, 0x95, 0x78, 0xa6, 0x25, 0x9e, 0x69, 0x89, 0x67,
	0xb1, 0xc4, 0xf3, 0xc2, 0xcd, 0x25, 0x12, 0xcf, 0xee, 0x1f, 0xb5, 0x1f, 0x51, 0x41, 0xe4, 0x65,
	0xe5, 0x5f, 0x05, 0x2b, 0x96, 0x3e, 0x38, 0xd0, 0xe2, 0x07, 0x07, 0x5a, 0xfe, 0xe0, 0x20, 0x56,
	0xe8, 0x6f, 0xa8, 0x5f, 0x55, 0xdf, 0xfc, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x4f, 0xd8, 0xd6,
	0x4a, 0xb6, 0x1b, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// LedgerServiceClient is the client API for LedgerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type LedgerServiceClient interface {
	Info(ctx context.Context, in *InfoRequest, opts ...grpc.CallOption) (*InfoResponse, error)
}

type ledgerServiceClient struct {
	cc grpc1.ClientConn
}

func NewLedgerServiceClient(cc grpc1.ClientConn) LedgerServiceClient {
	return &ledgerServiceClient{cc}
}

func (c *ledgerServiceClient) Info(ctx context.Context, in *InfoRequest, opts ...grpc.CallOption) (*InfoResponse, error) {
	out := new(InfoResponse)
	err := c.cc.Invoke(ctx, "/penumbra.narsil.ledger.v1alpha1.LedgerService/Info", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LedgerServiceServer is the server API for LedgerService service.
type LedgerServiceServer interface {
	Info(context.Context, *InfoRequest) (*InfoResponse, error)
}

// UnimplementedLedgerServiceServer can be embedded to have forward compatible implementations.
type UnimplementedLedgerServiceServer struct {
}

func (*UnimplementedLedgerServiceServer) Info(ctx context.Context, req *InfoRequest) (*InfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Info not implemented")
}

func RegisterLedgerServiceServer(s grpc1.Server, srv LedgerServiceServer) {
	s.RegisterService(&_LedgerService_serviceDesc, srv)
}

func _LedgerService_Info_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LedgerServiceServer).Info(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/penumbra.narsil.ledger.v1alpha1.LedgerService/Info",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LedgerServiceServer).Info(ctx, req.(*InfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _LedgerService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "penumbra.narsil.ledger.v1alpha1.LedgerService",
	HandlerType: (*LedgerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Info",
			Handler:    _LedgerService_Info_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "penumbra/narsil/ledger/v1alpha1/ledger.proto",
}

func (m *InfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AbciVersion) > 0 {
		i -= len(m.AbciVersion)
		copy(dAtA[i:], m.AbciVersion)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.AbciVersion)))
		i--
		dAtA[i] = 0x22
	}
	if m.P2PVersion != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.P2PVersion))
		i--
		dAtA[i] = 0x18
	}
	if m.BlockVersion != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.BlockVersion))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LastBlockAppHash) > 0 {
		i -= len(m.LastBlockAppHash)
		copy(dAtA[i:], m.LastBlockAppHash)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.LastBlockAppHash)))
		i--
		dAtA[i] = 0x2a
	}
	if m.LastBlockHeight != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.LastBlockHeight))
		i--
		dAtA[i] = 0x20
	}
	if m.AppVersion != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.AppVersion))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ShardIdentityKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardIdentityKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardIdentityKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Inner) > 0 {
		i -= len(m.Inner)
		copy(dAtA[i:], m.Inner)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.Inner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConsensusKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsensusKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Inner) > 0 {
		i -= len(m.Inner)
		copy(dAtA[i:], m.Inner)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.Inner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ShardMessageKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardMessageKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardMessageKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Inner) > 0 {
		i -= len(m.Inner)
		copy(dAtA[i:], m.Inner)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.Inner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ShardKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Inner) > 0 {
		i -= len(m.Inner)
		copy(dAtA[i:], m.Inner)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.Inner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ShardMessageSignature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardMessageSignature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardMessageSignature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Inner) > 0 {
		i -= len(m.Inner)
		copy(dAtA[i:], m.Inner)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.Inner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ShardDescription) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardDescription) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardDescription) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Label) > 0 {
		i -= len(m.Label)
		copy(dAtA[i:], m.Label)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.Label)))
		i--
		dAtA[i] = 0x22
	}
	if m.ConsensusKey != nil {
		{
			size, err := m.ConsensusKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.MessageKey != nil {
		{
			size, err := m.MessageKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.IdentityKey != nil {
		{
			size, err := m.IdentityKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ShardOperator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardOperator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardOperator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sig) > 0 {
		i -= len(m.Sig)
		copy(dAtA[i:], m.Sig)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.Sig)))
		i--
		dAtA[i] = 0x12
	}
	if m.Description != nil {
		{
			size, err := m.Description.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GenesisData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenesisData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenesisData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Threshold != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.Threshold))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Operators) > 0 {
		for iNdEx := len(m.Operators) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Operators[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLedger(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AccountGroupInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountGroupInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccountGroupInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Participants) > 0 {
		for iNdEx := len(m.Participants) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Participants[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLedger(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.FullViewingKey != nil {
		{
			size, err := m.FullViewingKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ShardInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IdentityKey != nil {
		{
			size, err := m.IdentityKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ShardVerificationKey != nil {
		{
			size, err := m.ShardVerificationKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Index != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RequestIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EffectHash != nil {
		{
			size, err := m.EffectHash.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CeremonyIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CeremonyIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CeremonyIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CeremonyIndex != 0 {
		i = encodeVarintLedger(dAtA, i, uint64(m.CeremonyIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.RequestIndex != nil {
		{
			size, err := m.RequestIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Committee) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Committee) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Committee) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Participants) > 0 {
		for iNdEx := len(m.Participants) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Participants[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLedger(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Ceremony != nil {
		{
			size, err := m.Ceremony.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CeremonyFailure) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CeremonyFailure) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CeremonyFailure) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Failure != nil {
		{
			size := m.Failure.Size()
			i -= size
			if _, err := m.Failure.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CeremonyFailure_Timeout_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CeremonyFailure_Timeout_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Timeout != nil {
		{
			size, err := m.Timeout.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *CeremonyFailure_BadCommitment_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CeremonyFailure_BadCommitment_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BadCommitment != nil {
		{
			size, err := m.BadCommitment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *CeremonyFailure_BadShare_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CeremonyFailure_BadShare_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BadShare != nil {
		{
			size, err := m.BadShare.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *CeremonyFailure_Canceled_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CeremonyFailure_Canceled_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Canceled != nil {
		{
			size, err := m.Canceled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *CeremonyFailure_Timeout) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CeremonyFailure_Timeout) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CeremonyFailure_Timeout) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *CeremonyFailure_BadCommitment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CeremonyFailure_BadCommitment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CeremonyFailure_BadCommitment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *CeremonyFailure_BadShare) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CeremonyFailure_BadShare) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CeremonyFailure_BadShare) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *CeremonyFailure_Canceled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CeremonyFailure_Canceled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CeremonyFailure_Canceled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *CeremonyState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CeremonyState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CeremonyState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != nil {
		{
			size := m.State.Size()
			i -= size
			if _, err := m.State.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CeremonyState_Pending_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CeremonyState_Pending_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Pending != nil {
		{
			size, err := m.Pending.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *CeremonyState_StartedRound_1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CeremonyState_StartedRound_1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StartedRound_1 != nil {
		{
			size, err := m.StartedRound_1.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *CeremonyState_StartedRound_2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CeremonyState_StartedRound_2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StartedRound_2 != nil {
		{
			size, err := m.StartedRound_2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *CeremonyState_Finished_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CeremonyState_Finished_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Finished != nil {
		{
			size, err := m.Finished.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *CeremonyState_Failed_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CeremonyState_Failed_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Failed != nil {
		{
			size, err := m.Failed.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *CeremonyState_Pending) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CeremonyState_Pending) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CeremonyState_Pending) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *CeremonyState_StartedRound1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CeremonyState_StartedRound1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CeremonyState_StartedRound1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Commitments) > 0 {
		for iNdEx := len(m.Commitments) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Commitments[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLedger(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Committee != nil {
		{
			size, err := m.Committee.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CeremonyState_StartedRound2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CeremonyState_StartedRound2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CeremonyState_StartedRound2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Shares) > 0 {
		for iNdEx := len(m.Shares) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Shares[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLedger(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Commitments) > 0 {
		for iNdEx := len(m.Commitments) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Commitments[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLedger(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Committee != nil {
		{
			size, err := m.Committee.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CeremonyState_Finished) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CeremonyState_Finished) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CeremonyState_Finished) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AuthData != nil {
		{
			size, err := m.AuthData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Shares) > 0 {
		for iNdEx := len(m.Shares) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Shares[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLedger(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Commitments) > 0 {
		for iNdEx := len(m.Commitments) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Commitments[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLedger(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Committee != nil {
		{
			size, err := m.Committee.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CeremonyState_Failed) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CeremonyState_Failed) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CeremonyState_Failed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Failure != nil {
		{
			size, err := m.Failure.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Shares) > 0 {
		for iNdEx := len(m.Shares) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Shares[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLedger(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Commitments) > 0 {
		for iNdEx := len(m.Commitments) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Commitments[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLedger(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Committee != nil {
		{
			size, err := m.Committee.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NarsilPacket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NarsilPacket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NarsilPacket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Packet != nil {
		{
			size := m.Packet.Size()
			i -= size
			if _, err := m.Packet.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *NarsilPacket_AuthorizeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NarsilPacket_AuthorizeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AuthorizeRequest != nil {
		{
			size, err := m.AuthorizeRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *NarsilPacket_AuthorizeCommitment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NarsilPacket_AuthorizeCommitment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AuthorizeCommitment != nil {
		{
			size, err := m.AuthorizeCommitment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *NarsilPacket_AuthorizeShare) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NarsilPacket_AuthorizeShare) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AuthorizeShare != nil {
		{
			size, err := m.AuthorizeShare.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *NarsilPacket_DkgRound_1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NarsilPacket_DkgRound_1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DkgRound_1 != nil {
		{
			size, err := m.DkgRound_1.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *NarsilPacket_DkgRound_2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NarsilPacket_DkgRound_2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DkgRound_2 != nil {
		{
			size, err := m.DkgRound_2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *FrostCommitment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FrostCommitment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FrostCommitment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FrostSignatureShare) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FrostSignatureShare) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FrostSignatureShare) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuthorizeCommitment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthorizeCommitment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthorizeCommitment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Signature != nil {
		{
			size, err := m.Signature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Signer != nil {
		{
			size, err := m.Signer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Body != nil {
		{
			size, err := m.Body.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuthorizeCommitment_Body) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthorizeCommitment_Body) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthorizeCommitment_Body) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Commitments) > 0 {
		for iNdEx := len(m.Commitments) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Commitments[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLedger(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.CeremonyIndex != nil {
		{
			size, err := m.CeremonyIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuthorizeShare) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthorizeShare) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthorizeShare) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Signature != nil {
		{
			size, err := m.Signature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Signer != nil {
		{
			size, err := m.Signer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Body != nil {
		{
			size, err := m.Body.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuthorizeShare_Body) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthorizeShare_Body) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthorizeShare_Body) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Commitments) > 0 {
		for iNdEx := len(m.Commitments) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Commitments[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLedger(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.CeremonyIndex != nil {
		{
			size, err := m.CeremonyIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DkgRound1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DkgRound1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DkgRound1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Signature != nil {
		{
			size, err := m.Signature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Signer != nil {
		{
			size, err := m.Signer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DkgRound2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DkgRound2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DkgRound2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Signature != nil {
		{
			size, err := m.Signature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Signer != nil {
		{
			size, err := m.Signer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintLedger(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DkgState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DkgState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DkgState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *DkgState_StartedRound1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DkgState_StartedRound1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DkgState_StartedRound1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Round_1Messages) > 0 {
		for iNdEx := len(m.Round_1Messages) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Round_1Messages[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLedger(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DkgState_StartedRound2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DkgState_StartedRound2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DkgState_StartedRound2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Round_2Messages) > 0 {
		for iNdEx := len(m.Round_2Messages) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Round_2Messages[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLedger(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Round_1Messages) > 0 {
		for iNdEx := len(m.Round_1Messages) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Round_1Messages[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLedger(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DkgState_Finished) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DkgState_Finished) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DkgState_Finished) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AccountGroupInfo != nil {
		{
			size, err := m.AccountGroupInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLedger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Round_2Messages) > 0 {
		for iNdEx := len(m.Round_2Messages) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Round_2Messages[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLedger(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Round_1Messages) > 0 {
		for iNdEx := len(m.Round_1Messages) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Round_1Messages[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLedger(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintLedger(dAtA []byte, offset int, v uint64) int {
	offset -= sovLedger(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *InfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	if m.BlockVersion != 0 {
		n += 1 + sovLedger(uint64(m.BlockVersion))
	}
	if m.P2PVersion != 0 {
		n += 1 + sovLedger(uint64(m.P2PVersion))
	}
	l = len(m.AbciVersion)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}

func (m *InfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	if m.AppVersion != 0 {
		n += 1 + sovLedger(uint64(m.AppVersion))
	}
	if m.LastBlockHeight != 0 {
		n += 1 + sovLedger(uint64(m.LastBlockHeight))
	}
	l = len(m.LastBlockAppHash)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}

func (m *ShardIdentityKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Inner)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}

func (m *ConsensusKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Inner)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}

func (m *ShardMessageKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Inner)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}

func (m *ShardKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Inner)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}

func (m *ShardMessageSignature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Inner)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}

func (m *ShardDescription) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IdentityKey != nil {
		l = m.IdentityKey.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	if m.MessageKey != nil {
		l = m.MessageKey.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	if m.ConsensusKey != nil {
		l = m.ConsensusKey.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}

func (m *ShardOperator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Description != nil {
		l = m.Description.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	l = len(m.Sig)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}

func (m *GenesisData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Operators) > 0 {
		for _, e := range m.Operators {
			l = e.Size()
			n += 1 + l + sovLedger(uint64(l))
		}
	}
	if m.Threshold != 0 {
		n += 1 + sovLedger(uint64(m.Threshold))
	}
	return n
}

func (m *AccountGroupInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FullViewingKey != nil {
		l = m.FullViewingKey.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	if len(m.Participants) > 0 {
		for _, e := range m.Participants {
			l = e.Size()
			n += 1 + l + sovLedger(uint64(l))
		}
	}
	return n
}

func (m *ShardInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovLedger(uint64(m.Index))
	}
	if m.ShardVerificationKey != nil {
		l = m.ShardVerificationKey.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	if m.IdentityKey != nil {
		l = m.IdentityKey.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}

func (m *RequestIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EffectHash != nil {
		l = m.EffectHash.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}

func (m *CeremonyIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestIndex != nil {
		l = m.RequestIndex.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	if m.CeremonyIndex != 0 {
		n += 1 + sovLedger(uint64(m.CeremonyIndex))
	}
	return n
}

func (m *Committee) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ceremony != nil {
		l = m.Ceremony.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	if len(m.Participants) > 0 {
		for _, e := range m.Participants {
			l = e.Size()
			n += 1 + l + sovLedger(uint64(l))
		}
	}
	return n
}

func (m *CeremonyFailure) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Failure != nil {
		n += m.Failure.Size()
	}
	return n
}

func (m *CeremonyFailure_Timeout_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timeout != nil {
		l = m.Timeout.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}
func (m *CeremonyFailure_BadCommitment_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BadCommitment != nil {
		l = m.BadCommitment.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}
func (m *CeremonyFailure_BadShare_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BadShare != nil {
		l = m.BadShare.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}
func (m *CeremonyFailure_Canceled_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Canceled != nil {
		l = m.Canceled.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}
func (m *CeremonyFailure_Timeout) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *CeremonyFailure_BadCommitment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *CeremonyFailure_BadShare) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *CeremonyFailure_Canceled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *CeremonyState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != nil {
		n += m.State.Size()
	}
	return n
}

func (m *CeremonyState_Pending_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pending != nil {
		l = m.Pending.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}
func (m *CeremonyState_StartedRound_1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartedRound_1 != nil {
		l = m.StartedRound_1.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}
func (m *CeremonyState_StartedRound_2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartedRound_2 != nil {
		l = m.StartedRound_2.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}
func (m *CeremonyState_Finished_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Finished != nil {
		l = m.Finished.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}
func (m *CeremonyState_Failed_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Failed != nil {
		l = m.Failed.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}
func (m *CeremonyState_Pending) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *CeremonyState_StartedRound1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Committee != nil {
		l = m.Committee.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	if len(m.Commitments) > 0 {
		for _, e := range m.Commitments {
			l = e.Size()
			n += 1 + l + sovLedger(uint64(l))
		}
	}
	return n
}

func (m *CeremonyState_StartedRound2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Committee != nil {
		l = m.Committee.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	if len(m.Commitments) > 0 {
		for _, e := range m.Commitments {
			l = e.Size()
			n += 1 + l + sovLedger(uint64(l))
		}
	}
	if len(m.Shares) > 0 {
		for _, e := range m.Shares {
			l = e.Size()
			n += 1 + l + sovLedger(uint64(l))
		}
	}
	return n
}

func (m *CeremonyState_Finished) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Committee != nil {
		l = m.Committee.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	if len(m.Commitments) > 0 {
		for _, e := range m.Commitments {
			l = e.Size()
			n += 1 + l + sovLedger(uint64(l))
		}
	}
	if len(m.Shares) > 0 {
		for _, e := range m.Shares {
			l = e.Size()
			n += 1 + l + sovLedger(uint64(l))
		}
	}
	if m.AuthData != nil {
		l = m.AuthData.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}

func (m *CeremonyState_Failed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Committee != nil {
		l = m.Committee.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	if len(m.Commitments) > 0 {
		for _, e := range m.Commitments {
			l = e.Size()
			n += 1 + l + sovLedger(uint64(l))
		}
	}
	if len(m.Shares) > 0 {
		for _, e := range m.Shares {
			l = e.Size()
			n += 1 + l + sovLedger(uint64(l))
		}
	}
	if m.Failure != nil {
		l = m.Failure.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}

func (m *NarsilPacket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Packet != nil {
		n += m.Packet.Size()
	}
	return n
}

func (m *NarsilPacket_AuthorizeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AuthorizeRequest != nil {
		l = m.AuthorizeRequest.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}
func (m *NarsilPacket_AuthorizeCommitment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AuthorizeCommitment != nil {
		l = m.AuthorizeCommitment.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}
func (m *NarsilPacket_AuthorizeShare) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AuthorizeShare != nil {
		l = m.AuthorizeShare.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}
func (m *NarsilPacket_DkgRound_1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DkgRound_1 != nil {
		l = m.DkgRound_1.Size()
		n += 2 + l + sovLedger(uint64(l))
	}
	return n
}
func (m *NarsilPacket_DkgRound_2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DkgRound_2 != nil {
		l = m.DkgRound_2.Size()
		n += 2 + l + sovLedger(uint64(l))
	}
	return n
}
func (m *FrostCommitment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}

func (m *FrostSignatureShare) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}

func (m *AuthorizeCommitment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Body != nil {
		l = m.Body.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	if m.Signer != nil {
		l = m.Signer.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	if m.Signature != nil {
		l = m.Signature.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}

func (m *AuthorizeCommitment_Body) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CeremonyIndex != nil {
		l = m.CeremonyIndex.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	if len(m.Commitments) > 0 {
		for _, e := range m.Commitments {
			l = e.Size()
			n += 1 + l + sovLedger(uint64(l))
		}
	}
	return n
}

func (m *AuthorizeShare) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Body != nil {
		l = m.Body.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	if m.Signer != nil {
		l = m.Signer.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	if m.Signature != nil {
		l = m.Signature.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}

func (m *AuthorizeShare_Body) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CeremonyIndex != nil {
		l = m.CeremonyIndex.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	if len(m.Commitments) > 0 {
		for _, e := range m.Commitments {
			l = e.Size()
			n += 1 + l + sovLedger(uint64(l))
		}
	}
	return n
}

func (m *DkgRound1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	if m.Signer != nil {
		l = m.Signer.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	if m.Signature != nil {
		l = m.Signature.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}

func (m *DkgRound2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovLedger(uint64(l))
	}
	if m.Signer != nil {
		l = m.Signer.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	if m.Signature != nil {
		l = m.Signature.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}

func (m *DkgState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *DkgState_StartedRound1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Round_1Messages) > 0 {
		for _, e := range m.Round_1Messages {
			l = e.Size()
			n += 1 + l + sovLedger(uint64(l))
		}
	}
	return n
}

func (m *DkgState_StartedRound2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Round_1Messages) > 0 {
		for _, e := range m.Round_1Messages {
			l = e.Size()
			n += 1 + l + sovLedger(uint64(l))
		}
	}
	if len(m.Round_2Messages) > 0 {
		for _, e := range m.Round_2Messages {
			l = e.Size()
			n += 1 + l + sovLedger(uint64(l))
		}
	}
	return n
}

func (m *DkgState_Finished) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Round_1Messages) > 0 {
		for _, e := range m.Round_1Messages {
			l = e.Size()
			n += 1 + l + sovLedger(uint64(l))
		}
	}
	if len(m.Round_2Messages) > 0 {
		for _, e := range m.Round_2Messages {
			l = e.Size()
			n += 1 + l + sovLedger(uint64(l))
		}
	}
	if m.AccountGroupInfo != nil {
		l = m.AccountGroupInfo.Size()
		n += 1 + l + sovLedger(uint64(l))
	}
	return n
}

func sovLedger(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozLedger(x uint64) (n int) {
	return sovLedger(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *InfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockVersion", wireType)
			}
			m.BlockVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field P2PVersion", wireType)
			}
			m.P2PVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.P2PVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbciVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AbciVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVersion", wireType)
			}
			m.AppVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastBlockHeight", wireType)
			}
			m.LastBlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastBlockHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastBlockAppHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastBlockAppHash = append(m.LastBlockAppHash[:0], dAtA[iNdEx:postIndex]...)
			if m.LastBlockAppHash == nil {
				m.LastBlockAppHash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardIdentityKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardIdentityKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardIdentityKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inner = append(m.Inner[:0], dAtA[iNdEx:postIndex]...)
			if m.Inner == nil {
				m.Inner = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inner = append(m.Inner[:0], dAtA[iNdEx:postIndex]...)
			if m.Inner == nil {
				m.Inner = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardMessageKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardMessageKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardMessageKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inner = append(m.Inner[:0], dAtA[iNdEx:postIndex]...)
			if m.Inner == nil {
				m.Inner = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inner = append(m.Inner[:0], dAtA[iNdEx:postIndex]...)
			if m.Inner == nil {
				m.Inner = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardMessageSignature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardMessageSignature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardMessageSignature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inner = append(m.Inner[:0], dAtA[iNdEx:postIndex]...)
			if m.Inner == nil {
				m.Inner = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardDescription) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardDescription: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardDescription: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdentityKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdentityKey == nil {
				m.IdentityKey = &ShardIdentityKey{}
			}
			if err := m.IdentityKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MessageKey == nil {
				m.MessageKey = &ShardMessageKey{}
			}
			if err := m.MessageKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsensusKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConsensusKey == nil {
				m.ConsensusKey = &ConsensusKey{}
			}
			if err := m.ConsensusKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardOperator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardOperator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardOperator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Description == nil {
				m.Description = &ShardDescription{}
			}
			if err := m.Description.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sig = append(m.Sig[:0], dAtA[iNdEx:postIndex]...)
			if m.Sig == nil {
				m.Sig = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenesisData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenesisData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenesisData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operators", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operators = append(m.Operators, &ShardOperator{})
			if err := m.Operators[len(m.Operators)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			m.Threshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Threshold |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountGroupInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountGroupInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountGroupInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullViewingKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FullViewingKey == nil {
				m.FullViewingKey = &v1alpha1.FullViewingKey{}
			}
			if err := m.FullViewingKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Participants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Participants = append(m.Participants, &ShardInfo{})
			if err := m.Participants[len(m.Participants)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardVerificationKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardVerificationKey == nil {
				m.ShardVerificationKey = &v1alpha1.SpendVerificationKey{}
			}
			if err := m.ShardVerificationKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdentityKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdentityKey == nil {
				m.IdentityKey = &ShardIdentityKey{}
			}
			if err := m.IdentityKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectHash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EffectHash == nil {
				m.EffectHash = &v1alpha11.EffectHash{}
			}
			if err := m.EffectHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CeremonyIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CeremonyIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CeremonyIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequestIndex == nil {
				m.RequestIndex = &RequestIndex{}
			}
			if err := m.RequestIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CeremonyIndex", wireType)
			}
			m.CeremonyIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CeremonyIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Committee) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Committee: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Committee: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ceremony", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ceremony == nil {
				m.Ceremony = &CeremonyIndex{}
			}
			if err := m.Ceremony.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Participants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Participants = append(m.Participants, &ShardInfo{})
			if err := m.Participants[len(m.Participants)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CeremonyFailure) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CeremonyFailure: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CeremonyFailure: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CeremonyFailure_Timeout{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Failure = &CeremonyFailure_Timeout_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadCommitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CeremonyFailure_BadCommitment{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Failure = &CeremonyFailure_BadCommitment_{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadShare", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CeremonyFailure_BadShare{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Failure = &CeremonyFailure_BadShare_{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Canceled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CeremonyFailure_Canceled{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Failure = &CeremonyFailure_Canceled_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CeremonyFailure_Timeout) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Timeout: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Timeout: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CeremonyFailure_BadCommitment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BadCommitment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BadCommitment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CeremonyFailure_BadShare) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BadShare: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BadShare: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CeremonyFailure_Canceled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Canceled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Canceled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CeremonyState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CeremonyState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CeremonyState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pending", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CeremonyState_Pending{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.State = &CeremonyState_Pending_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedRound_1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CeremonyState_StartedRound1{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.State = &CeremonyState_StartedRound_1{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedRound_2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CeremonyState_StartedRound2{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.State = &CeremonyState_StartedRound_2{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Finished", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CeremonyState_Finished{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.State = &CeremonyState_Finished_{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CeremonyState_Failed{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.State = &CeremonyState_Failed_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CeremonyState_Pending) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pending: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pending: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CeremonyState_StartedRound1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartedRound1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartedRound1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Committee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Committee == nil {
				m.Committee = &Committee{}
			}
			if err := m.Committee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commitments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commitments = append(m.Commitments, &AuthorizeCommitment{})
			if err := m.Commitments[len(m.Commitments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CeremonyState_StartedRound2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartedRound2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartedRound2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Committee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Committee == nil {
				m.Committee = &Committee{}
			}
			if err := m.Committee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commitments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commitments = append(m.Commitments, &AuthorizeCommitment{})
			if err := m.Commitments[len(m.Commitments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shares", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shares = append(m.Shares, &AuthorizeShare{})
			if err := m.Shares[len(m.Shares)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CeremonyState_Finished) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Finished: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Finished: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Committee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Committee == nil {
				m.Committee = &Committee{}
			}
			if err := m.Committee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commitments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commitments = append(m.Commitments, &AuthorizeCommitment{})
			if err := m.Commitments[len(m.Commitments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shares", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shares = append(m.Shares, &AuthorizeShare{})
			if err := m.Shares[len(m.Shares)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuthData == nil {
				m.AuthData = &v1alpha12.AuthorizationData{}
			}
			if err := m.AuthData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CeremonyState_Failed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Failed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Failed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Committee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Committee == nil {
				m.Committee = &Committee{}
			}
			if err := m.Committee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commitments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commitments = append(m.Commitments, &AuthorizeCommitment{})
			if err := m.Commitments[len(m.Commitments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shares", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shares = append(m.Shares, &AuthorizeShare{})
			if err := m.Shares[len(m.Shares)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failure", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Failure == nil {
				m.Failure = &CeremonyFailure{}
			}
			if err := m.Failure.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NarsilPacket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NarsilPacket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NarsilPacket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorizeRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha13.AuthorizeRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Packet = &NarsilPacket_AuthorizeRequest{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorizeCommitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AuthorizeCommitment{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Packet = &NarsilPacket_AuthorizeCommitment{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorizeShare", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AuthorizeShare{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Packet = &NarsilPacket_AuthorizeShare{v}
			iNdEx = postIndex
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DkgRound_1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DkgRound1{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Packet = &NarsilPacket_DkgRound_1{v}
			iNdEx = postIndex
		case 1001:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DkgRound_2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DkgRound2{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Packet = &NarsilPacket_DkgRound_2{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FrostCommitment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FrostCommitment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FrostCommitment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FrostSignatureShare) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FrostSignatureShare: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FrostSignatureShare: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthorizeCommitment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthorizeCommitment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthorizeCommitment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Body == nil {
				m.Body = &AuthorizeCommitment_Body{}
			}
			if err := m.Body.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signer == nil {
				m.Signer = &ShardMessageKey{}
			}
			if err := m.Signer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signature == nil {
				m.Signature = &ShardMessageSignature{}
			}
			if err := m.Signature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthorizeCommitment_Body) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Body: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Body: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CeremonyIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CeremonyIndex == nil {
				m.CeremonyIndex = &CeremonyIndex{}
			}
			if err := m.CeremonyIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commitments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commitments = append(m.Commitments, &FrostCommitment{})
			if err := m.Commitments[len(m.Commitments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthorizeShare) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthorizeShare: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthorizeShare: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Body == nil {
				m.Body = &AuthorizeShare_Body{}
			}
			if err := m.Body.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signer == nil {
				m.Signer = &ShardMessageKey{}
			}
			if err := m.Signer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signature == nil {
				m.Signature = &ShardMessageSignature{}
			}
			if err := m.Signature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthorizeShare_Body) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Body: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Body: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CeremonyIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CeremonyIndex == nil {
				m.CeremonyIndex = &CeremonyIndex{}
			}
			if err := m.CeremonyIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commitments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commitments = append(m.Commitments, &FrostCommitment{})
			if err := m.Commitments[len(m.Commitments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DkgRound1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DkgRound1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DkgRound1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signer == nil {
				m.Signer = &ShardMessageKey{}
			}
			if err := m.Signer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signature == nil {
				m.Signature = &ShardMessageSignature{}
			}
			if err := m.Signature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DkgRound2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DkgRound2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DkgRound2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signer == nil {
				m.Signer = &ShardMessageKey{}
			}
			if err := m.Signer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signature == nil {
				m.Signature = &ShardMessageSignature{}
			}
			if err := m.Signature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DkgState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DkgState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DkgState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DkgState_StartedRound1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartedRound1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartedRound1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round_1Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Round_1Messages = append(m.Round_1Messages, &DkgRound1{})
			if err := m.Round_1Messages[len(m.Round_1Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DkgState_StartedRound2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartedRound2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartedRound2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round_1Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Round_1Messages = append(m.Round_1Messages, &DkgRound1{})
			if err := m.Round_1Messages[len(m.Round_1Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round_2Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Round_2Messages = append(m.Round_2Messages, &DkgRound2{})
			if err := m.Round_2Messages[len(m.Round_2Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DkgState_Finished) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Finished: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Finished: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round_1Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Round_1Messages = append(m.Round_1Messages, &DkgRound1{})
			if err := m.Round_1Messages[len(m.Round_1Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round_2Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Round_2Messages = append(m.Round_2Messages, &DkgRound2{})
			if err := m.Round_2Messages[len(m.Round_2Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountGroupInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccountGroupInfo == nil {
				m.AccountGroupInfo = &AccountGroupInfo{}
			}
			if err := m.AccountGroupInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLedger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipLedger(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowLedger
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLedger
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthLedger
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupLedger
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthLedger
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthLedger        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowLedger          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupLedger = fmt.Errorf("proto: unexpected end of group")
)
