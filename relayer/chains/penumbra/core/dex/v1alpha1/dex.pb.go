// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: penumbra/core/dex/v1alpha1/dex.proto

package dexv1alpha1

import (
	fmt "fmt"
	proto "github.com/cosmos/gogoproto/proto"
	v1alpha1 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/crypto/v1alpha1"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type PositionState_PositionStateEnum int32

const (
	PositionState_POSITION_STATE_ENUM_UNSPECIFIED PositionState_PositionStateEnum = 0
	// The position has been opened, is active, has reserves and accumulated
	// fees, and can be traded against.
	PositionState_POSITION_STATE_ENUM_OPENED PositionState_PositionStateEnum = 1
	// The position has been closed, is inactive and can no longer be traded
	// against, but still has reserves and accumulated fees.
	PositionState_POSITION_STATE_ENUM_CLOSED PositionState_PositionStateEnum = 2
	// The final reserves and accumulated fees have been withdrawn, leaving an
	// empty, inactive position awaiting (possible) retroactive rewards.
	PositionState_POSITION_STATE_ENUM_WITHDRAWN PositionState_PositionStateEnum = 3
	// Any retroactive rewards have been claimed. The position is now an inert,
	// historical artefact.
	PositionState_POSITION_STATE_ENUM_CLAIMED PositionState_PositionStateEnum = 4
)

var PositionState_PositionStateEnum_name = map[int32]string{
	0: "POSITION_STATE_ENUM_UNSPECIFIED",
	1: "POSITION_STATE_ENUM_OPENED",
	2: "POSITION_STATE_ENUM_CLOSED",
	3: "POSITION_STATE_ENUM_WITHDRAWN",
	4: "POSITION_STATE_ENUM_CLAIMED",
}

var PositionState_PositionStateEnum_value = map[string]int32{
	"POSITION_STATE_ENUM_UNSPECIFIED": 0,
	"POSITION_STATE_ENUM_OPENED":      1,
	"POSITION_STATE_ENUM_CLOSED":      2,
	"POSITION_STATE_ENUM_WITHDRAWN":   3,
	"POSITION_STATE_ENUM_CLAIMED":     4,
}

func (x PositionState_PositionStateEnum) String() string {
	return proto.EnumName(PositionState_PositionStateEnum_name, int32(x))
}

func (PositionState_PositionStateEnum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d1eba752ca2f0d70, []int{19, 0}
}

// A transaction action that submits a swap to the dex.
type Swap struct {
	// Contains the Swap proof.
	Proof *v1alpha1.ZKSwapProof `protobuf:"bytes,1,opt,name=proof,proto3" json:"proof,omitempty"`
	// MockFlowCiphertext dropped until flow encryption/ABCI++ available
	// // Encrypted amount of asset 1 of the trading pair.
	// MockFlowCiphertext enc_amount_1 = 2;
	// // Encrypted amount of asset 2 of the trading pair.
	// MockFlowCiphertext enc_amount_2 = 3;
	// Encapsulates the authorized fields of the Swap action, used in signing.
	Body *SwapBody `protobuf:"bytes,4,opt,name=body,proto3" json:"body,omitempty"`
}

func (m *Swap) Reset()         { *m = Swap{} }
func (m *Swap) String() string { return proto.CompactTextString(m) }
func (*Swap) ProtoMessage()    {}
func (*Swap) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1eba752ca2f0d70, []int{0}
}
func (m *Swap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Swap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Swap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Swap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Swap.Merge(m, src)
}
func (m *Swap) XXX_Size() int {
	return m.Size()
}
func (m *Swap) XXX_DiscardUnknown() {
	xxx_messageInfo_Swap.DiscardUnknown(m)
}

var xxx_messageInfo_Swap proto.InternalMessageInfo

func (m *Swap) GetProof() *v1alpha1.ZKSwapProof {
	if m != nil {
		return m.Proof
	}
	return nil
}

func (m *Swap) GetBody() *SwapBody {
	if m != nil {
		return m.Body
	}
	return nil
}

// A transaction action that obtains assets previously confirmed
// via a Swap transaction. Does not include a spend authorization
// signature, as it is only capable of consuming the NFT from a
// Swap transaction.
type SwapClaim struct {
	// Contains the SwapClaim proof.
	Proof []byte `protobuf:"bytes,1,opt,name=proof,proto3" json:"proof,omitempty"`
	// Encapsulates the authorized fields of the SwapClaim action, used in signing.
	Body *SwapClaimBody `protobuf:"bytes,2,opt,name=body,proto3" json:"body,omitempty"`
	// The epoch duration of the chain when the swap claim took place.
	EpochDuration uint64 `protobuf:"varint,7,opt,name=epoch_duration,json=epochDuration,proto3" json:"epoch_duration,omitempty"`
}

func (m *SwapClaim) Reset()         { *m = SwapClaim{} }
func (m *SwapClaim) String() string { return proto.CompactTextString(m) }
func (*SwapClaim) ProtoMessage()    {}
func (*SwapClaim) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1eba752ca2f0d70, []int{1}
}
func (m *SwapClaim) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapClaim) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapClaim.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapClaim) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapClaim.Merge(m, src)
}
func (m *SwapClaim) XXX_Size() int {
	return m.Size()
}
func (m *SwapClaim) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapClaim.DiscardUnknown(m)
}

var xxx_messageInfo_SwapClaim proto.InternalMessageInfo

func (m *SwapClaim) GetProof() []byte {
	if m != nil {
		return m.Proof
	}
	return nil
}

func (m *SwapClaim) GetBody() *SwapClaimBody {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *SwapClaim) GetEpochDuration() uint64 {
	if m != nil {
		return m.EpochDuration
	}
	return 0
}

// Encapsulates the authorized fields of the SwapClaim action, used in signing.
type SwapClaimBody struct {
	// The nullifier for the Swap commitment to be consumed.
	Nullifier *v1alpha1.Nullifier `protobuf:"bytes,1,opt,name=nullifier,proto3" json:"nullifier,omitempty"`
	// The fee allows `SwapClaim` without an additional `Spend`.
	Fee *v1alpha1.Fee `protobuf:"bytes,2,opt,name=fee,proto3" json:"fee,omitempty"`
	// Note output for asset 1.
	Output_1Commitment *v1alpha1.StateCommitment `protobuf:"bytes,3,opt,name=output_1_commitment,json=output1Commitment,proto3" json:"output_1_commitment,omitempty"`
	// Note output for asset 2.
	Output_2Commitment *v1alpha1.StateCommitment `protobuf:"bytes,4,opt,name=output_2_commitment,json=output2Commitment,proto3" json:"output_2_commitment,omitempty"`
	// Input and output amounts, and asset IDs for the assets in the swap.
	OutputData *BatchSwapOutputData `protobuf:"bytes,6,opt,name=output_data,json=outputData,proto3" json:"output_data,omitempty"`
}

func (m *SwapClaimBody) Reset()         { *m = SwapClaimBody{} }
func (m *SwapClaimBody) String() string { return proto.CompactTextString(m) }
func (*SwapClaimBody) ProtoMessage()    {}
func (*SwapClaimBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1eba752ca2f0d70, []int{2}
}
func (m *SwapClaimBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapClaimBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapClaimBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapClaimBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapClaimBody.Merge(m, src)
}
func (m *SwapClaimBody) XXX_Size() int {
	return m.Size()
}
func (m *SwapClaimBody) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapClaimBody.DiscardUnknown(m)
}

var xxx_messageInfo_SwapClaimBody proto.InternalMessageInfo

func (m *SwapClaimBody) GetNullifier() *v1alpha1.Nullifier {
	if m != nil {
		return m.Nullifier
	}
	return nil
}

func (m *SwapClaimBody) GetFee() *v1alpha1.Fee {
	if m != nil {
		return m.Fee
	}
	return nil
}

func (m *SwapClaimBody) GetOutput_1Commitment() *v1alpha1.StateCommitment {
	if m != nil {
		return m.Output_1Commitment
	}
	return nil
}

func (m *SwapClaimBody) GetOutput_2Commitment() *v1alpha1.StateCommitment {
	if m != nil {
		return m.Output_2Commitment
	}
	return nil
}

func (m *SwapClaimBody) GetOutputData() *BatchSwapOutputData {
	if m != nil {
		return m.OutputData
	}
	return nil
}

// The authorized data of a Swap transaction.
type SwapBody struct {
	// The trading pair to swap.
	TradingPair *TradingPair `protobuf:"bytes,1,opt,name=trading_pair,json=tradingPair,proto3" json:"trading_pair,omitempty"`
	// The amount for asset 1.
	Delta_1I *v1alpha1.Amount `protobuf:"bytes,2,opt,name=delta_1_i,json=delta1I,proto3" json:"delta_1_i,omitempty"`
	// The amount for asset 2.
	Delta_2I *v1alpha1.Amount `protobuf:"bytes,3,opt,name=delta_2_i,json=delta2I,proto3" json:"delta_2_i,omitempty"`
	// A commitment to a prepaid fee for the future SwapClaim.
	// This is recorded separately from delta_j_i because it's shielded;
	// in the future we'll want separate commitments to each delta_j_i
	// anyways in order to prove consistency with flow encryption.
	FeeCommitment *v1alpha1.BalanceCommitment `protobuf:"bytes,4,opt,name=fee_commitment,json=feeCommitment,proto3" json:"fee_commitment,omitempty"`
	// The swap commitment and encryption of the swap data.
	Payload *SwapPayload `protobuf:"bytes,5,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *SwapBody) Reset()         { *m = SwapBody{} }
func (m *SwapBody) String() string { return proto.CompactTextString(m) }
func (*SwapBody) ProtoMessage()    {}
func (*SwapBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1eba752ca2f0d70, []int{3}
}
func (m *SwapBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapBody.Merge(m, src)
}
func (m *SwapBody) XXX_Size() int {
	return m.Size()
}
func (m *SwapBody) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapBody.DiscardUnknown(m)
}

var xxx_messageInfo_SwapBody proto.InternalMessageInfo

func (m *SwapBody) GetTradingPair() *TradingPair {
	if m != nil {
		return m.TradingPair
	}
	return nil
}

func (m *SwapBody) GetDelta_1I() *v1alpha1.Amount {
	if m != nil {
		return m.Delta_1I
	}
	return nil
}

func (m *SwapBody) GetDelta_2I() *v1alpha1.Amount {
	if m != nil {
		return m.Delta_2I
	}
	return nil
}

func (m *SwapBody) GetFeeCommitment() *v1alpha1.BalanceCommitment {
	if m != nil {
		return m.FeeCommitment
	}
	return nil
}

func (m *SwapBody) GetPayload() *SwapPayload {
	if m != nil {
		return m.Payload
	}
	return nil
}

type SwapPayload struct {
	Commitment    *v1alpha1.StateCommitment `protobuf:"bytes,1,opt,name=commitment,proto3" json:"commitment,omitempty"`
	EncryptedSwap []byte                    `protobuf:"bytes,2,opt,name=encrypted_swap,json=encryptedSwap,proto3" json:"encrypted_swap,omitempty"`
}

func (m *SwapPayload) Reset()         { *m = SwapPayload{} }
func (m *SwapPayload) String() string { return proto.CompactTextString(m) }
func (*SwapPayload) ProtoMessage()    {}
func (*SwapPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1eba752ca2f0d70, []int{4}
}
func (m *SwapPayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapPayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapPayload.Merge(m, src)
}
func (m *SwapPayload) XXX_Size() int {
	return m.Size()
}
func (m *SwapPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapPayload.DiscardUnknown(m)
}

var xxx_messageInfo_SwapPayload proto.InternalMessageInfo

func (m *SwapPayload) GetCommitment() *v1alpha1.StateCommitment {
	if m != nil {
		return m.Commitment
	}
	return nil
}

func (m *SwapPayload) GetEncryptedSwap() []byte {
	if m != nil {
		return m.EncryptedSwap
	}
	return nil
}

type SwapPlaintext struct {
	// The trading pair to swap.
	TradingPair *TradingPair `protobuf:"bytes,1,opt,name=trading_pair,json=tradingPair,proto3" json:"trading_pair,omitempty"`
	// Input amount of asset 1
	Delta_1I *v1alpha1.Amount `protobuf:"bytes,2,opt,name=delta_1_i,json=delta1I,proto3" json:"delta_1_i,omitempty"`
	// Input amount of asset 2
	Delta_2I *v1alpha1.Amount `protobuf:"bytes,3,opt,name=delta_2_i,json=delta2I,proto3" json:"delta_2_i,omitempty"`
	// Pre-paid fee to claim the swap
	ClaimFee *v1alpha1.Fee `protobuf:"bytes,4,opt,name=claim_fee,json=claimFee,proto3" json:"claim_fee,omitempty"`
	// Address that will claim the swap outputs via SwapClaim.
	ClaimAddress *v1alpha1.Address `protobuf:"bytes,5,opt,name=claim_address,json=claimAddress,proto3" json:"claim_address,omitempty"`
	// Swap rseed (blinding factors are derived from this)
	Rseed []byte `protobuf:"bytes,6,opt,name=rseed,proto3" json:"rseed,omitempty"`
}

func (m *SwapPlaintext) Reset()         { *m = SwapPlaintext{} }
func (m *SwapPlaintext) String() string { return proto.CompactTextString(m) }
func (*SwapPlaintext) ProtoMessage()    {}
func (*SwapPlaintext) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1eba752ca2f0d70, []int{5}
}
func (m *SwapPlaintext) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapPlaintext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapPlaintext.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapPlaintext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapPlaintext.Merge(m, src)
}
func (m *SwapPlaintext) XXX_Size() int {
	return m.Size()
}
func (m *SwapPlaintext) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapPlaintext.DiscardUnknown(m)
}

var xxx_messageInfo_SwapPlaintext proto.InternalMessageInfo

func (m *SwapPlaintext) GetTradingPair() *TradingPair {
	if m != nil {
		return m.TradingPair
	}
	return nil
}

func (m *SwapPlaintext) GetDelta_1I() *v1alpha1.Amount {
	if m != nil {
		return m.Delta_1I
	}
	return nil
}

func (m *SwapPlaintext) GetDelta_2I() *v1alpha1.Amount {
	if m != nil {
		return m.Delta_2I
	}
	return nil
}

func (m *SwapPlaintext) GetClaimFee() *v1alpha1.Fee {
	if m != nil {
		return m.ClaimFee
	}
	return nil
}

func (m *SwapPlaintext) GetClaimAddress() *v1alpha1.Address {
	if m != nil {
		return m.ClaimAddress
	}
	return nil
}

func (m *SwapPlaintext) GetRseed() []byte {
	if m != nil {
		return m.Rseed
	}
	return nil
}

type MockFlowCiphertext struct {
	// Represents this transaction's contribution to flow's value.
	Value *v1alpha1.Amount `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *MockFlowCiphertext) Reset()         { *m = MockFlowCiphertext{} }
func (m *MockFlowCiphertext) String() string { return proto.CompactTextString(m) }
func (*MockFlowCiphertext) ProtoMessage()    {}
func (*MockFlowCiphertext) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1eba752ca2f0d70, []int{6}
}
func (m *MockFlowCiphertext) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MockFlowCiphertext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MockFlowCiphertext.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MockFlowCiphertext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MockFlowCiphertext.Merge(m, src)
}
func (m *MockFlowCiphertext) XXX_Size() int {
	return m.Size()
}
func (m *MockFlowCiphertext) XXX_DiscardUnknown() {
	xxx_messageInfo_MockFlowCiphertext.DiscardUnknown(m)
}

var xxx_messageInfo_MockFlowCiphertext proto.InternalMessageInfo

func (m *MockFlowCiphertext) GetValue() *v1alpha1.Amount {
	if m != nil {
		return m.Value
	}
	return nil
}

type SwapPlan struct {
	// The plaintext version of the swap to be performed.
	SwapPlaintext *SwapPlaintext `protobuf:"bytes,1,opt,name=swap_plaintext,json=swapPlaintext,proto3" json:"swap_plaintext,omitempty"`
	// The blinding factor for the fee commitment. The fee in the SwapPlan is private to prevent linkability with the SwapClaim.
	FeeBlinding []byte `protobuf:"bytes,2,opt,name=fee_blinding,json=feeBlinding,proto3" json:"fee_blinding,omitempty"`
}

func (m *SwapPlan) Reset()         { *m = SwapPlan{} }
func (m *SwapPlan) String() string { return proto.CompactTextString(m) }
func (*SwapPlan) ProtoMessage()    {}
func (*SwapPlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1eba752ca2f0d70, []int{7}
}
func (m *SwapPlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapPlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapPlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapPlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapPlan.Merge(m, src)
}
func (m *SwapPlan) XXX_Size() int {
	return m.Size()
}
func (m *SwapPlan) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapPlan.DiscardUnknown(m)
}

var xxx_messageInfo_SwapPlan proto.InternalMessageInfo

func (m *SwapPlan) GetSwapPlaintext() *SwapPlaintext {
	if m != nil {
		return m.SwapPlaintext
	}
	return nil
}

func (m *SwapPlan) GetFeeBlinding() []byte {
	if m != nil {
		return m.FeeBlinding
	}
	return nil
}

type SwapClaimPlan struct {
	// The plaintext version of the swap to be performed.
	SwapPlaintext *SwapPlaintext `protobuf:"bytes,1,opt,name=swap_plaintext,json=swapPlaintext,proto3" json:"swap_plaintext,omitempty"`
	// The position of the swap commitment.
	Position uint64 `protobuf:"varint,2,opt,name=position,proto3" json:"position,omitempty"`
	// Input and output amounts for the Swap.
	OutputData *BatchSwapOutputData `protobuf:"bytes,3,opt,name=output_data,json=outputData,proto3" json:"output_data,omitempty"`
	// The epoch duration, used in proving.
	EpochDuration uint64 `protobuf:"varint,4,opt,name=epoch_duration,json=epochDuration,proto3" json:"epoch_duration,omitempty"`
}

func (m *SwapClaimPlan) Reset()         { *m = SwapClaimPlan{} }
func (m *SwapClaimPlan) String() string { return proto.CompactTextString(m) }
func (*SwapClaimPlan) ProtoMessage()    {}
func (*SwapClaimPlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1eba752ca2f0d70, []int{8}
}
func (m *SwapClaimPlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapClaimPlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapClaimPlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapClaimPlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapClaimPlan.Merge(m, src)
}
func (m *SwapClaimPlan) XXX_Size() int {
	return m.Size()
}
func (m *SwapClaimPlan) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapClaimPlan.DiscardUnknown(m)
}

var xxx_messageInfo_SwapClaimPlan proto.InternalMessageInfo

func (m *SwapClaimPlan) GetSwapPlaintext() *SwapPlaintext {
	if m != nil {
		return m.SwapPlaintext
	}
	return nil
}

func (m *SwapClaimPlan) GetPosition() uint64 {
	if m != nil {
		return m.Position
	}
	return 0
}

func (m *SwapClaimPlan) GetOutputData() *BatchSwapOutputData {
	if m != nil {
		return m.OutputData
	}
	return nil
}

func (m *SwapClaimPlan) GetEpochDuration() uint64 {
	if m != nil {
		return m.EpochDuration
	}
	return 0
}

type SwapView struct {
	// Types that are valid to be assigned to SwapView:
	//
	//	*SwapView_Visible_
	//	*SwapView_Opaque_
	SwapView isSwapView_SwapView `protobuf_oneof:"swap_view"`
}

func (m *SwapView) Reset()         { *m = SwapView{} }
func (m *SwapView) String() string { return proto.CompactTextString(m) }
func (*SwapView) ProtoMessage()    {}
func (*SwapView) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1eba752ca2f0d70, []int{9}
}
func (m *SwapView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapView.Merge(m, src)
}
func (m *SwapView) XXX_Size() int {
	return m.Size()
}
func (m *SwapView) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapView.DiscardUnknown(m)
}

var xxx_messageInfo_SwapView proto.InternalMessageInfo

type isSwapView_SwapView interface {
	isSwapView_SwapView()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SwapView_Visible_ struct {
	Visible *SwapView_Visible `protobuf:"bytes,1,opt,name=visible,proto3,oneof" json:"visible,omitempty"`
}
type SwapView_Opaque_ struct {
	Opaque *SwapView_Opaque `protobuf:"bytes,2,opt,name=opaque,proto3,oneof" json:"opaque,omitempty"`
}

func (*SwapView_Visible_) isSwapView_SwapView() {}
func (*SwapView_Opaque_) isSwapView_SwapView()  {}

func (m *SwapView) GetSwapView() isSwapView_SwapView {
	if m != nil {
		return m.SwapView
	}
	return nil
}

func (m *SwapView) GetVisible() *SwapView_Visible {
	if x, ok := m.GetSwapView().(*SwapView_Visible_); ok {
		return x.Visible
	}
	return nil
}

func (m *SwapView) GetOpaque() *SwapView_Opaque {
	if x, ok := m.GetSwapView().(*SwapView_Opaque_); ok {
		return x.Opaque
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SwapView) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SwapView_Visible_)(nil),
		(*SwapView_Opaque_)(nil),
	}
}

type SwapView_Visible struct {
	Swap          *Swap          `protobuf:"bytes,1,opt,name=swap,proto3" json:"swap,omitempty"`
	SwapPlaintext *SwapPlaintext `protobuf:"bytes,3,opt,name=swap_plaintext,json=swapPlaintext,proto3" json:"swap_plaintext,omitempty"`
}

func (m *SwapView_Visible) Reset()         { *m = SwapView_Visible{} }
func (m *SwapView_Visible) String() string { return proto.CompactTextString(m) }
func (*SwapView_Visible) ProtoMessage()    {}
func (*SwapView_Visible) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1eba752ca2f0d70, []int{9, 0}
}
func (m *SwapView_Visible) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapView_Visible) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapView_Visible.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapView_Visible) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapView_Visible.Merge(m, src)
}
func (m *SwapView_Visible) XXX_Size() int {
	return m.Size()
}
func (m *SwapView_Visible) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapView_Visible.DiscardUnknown(m)
}

var xxx_messageInfo_SwapView_Visible proto.InternalMessageInfo

func (m *SwapView_Visible) GetSwap() *Swap {
	if m != nil {
		return m.Swap
	}
	return nil
}

func (m *SwapView_Visible) GetSwapPlaintext() *SwapPlaintext {
	if m != nil {
		return m.SwapPlaintext
	}
	return nil
}

type SwapView_Opaque struct {
	Swap *Swap `protobuf:"bytes,1,opt,name=swap,proto3" json:"swap,omitempty"`
}

func (m *SwapView_Opaque) Reset()         { *m = SwapView_Opaque{} }
func (m *SwapView_Opaque) String() string { return proto.CompactTextString(m) }
func (*SwapView_Opaque) ProtoMessage()    {}
func (*SwapView_Opaque) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1eba752ca2f0d70, []int{9, 1}
}
func (m *SwapView_Opaque) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapView_Opaque) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapView_Opaque.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapView_Opaque) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapView_Opaque.Merge(m, src)
}
func (m *SwapView_Opaque) XXX_Size() int {
	return m.Size()
}
func (m *SwapView_Opaque) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapView_Opaque.DiscardUnknown(m)
}

var xxx_messageInfo_SwapView_Opaque proto.InternalMessageInfo

func (m *SwapView_Opaque) GetSwap() *Swap {
	if m != nil {
		return m.Swap
	}
	return nil
}

type SwapClaimView struct {
	// Types that are valid to be assigned to SwapClaimView:
	//
	//	*SwapClaimView_Visible_
	//	*SwapClaimView_Opaque_
	SwapClaimView isSwapClaimView_SwapClaimView `protobuf_oneof:"swap_claim_view"`
}

func (m *SwapClaimView) Reset()         { *m = SwapClaimView{} }
func (m *SwapClaimView) String() string { return proto.CompactTextString(m) }
func (*SwapClaimView) ProtoMessage()    {}
func (*SwapClaimView) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1eba752ca2f0d70, []int{10}
}
func (m *SwapClaimView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapClaimView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapClaimView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapClaimView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapClaimView.Merge(m, src)
}
func (m *SwapClaimView) XXX_Size() int {
	return m.Size()
}
func (m *SwapClaimView) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapClaimView.DiscardUnknown(m)
}

var xxx_messageInfo_SwapClaimView proto.InternalMessageInfo

type isSwapClaimView_SwapClaimView interface {
	isSwapClaimView_SwapClaimView()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SwapClaimView_Visible_ struct {
	Visible *SwapClaimView_Visible `protobuf:"bytes,1,opt,name=visible,proto3,oneof" json:"visible,omitempty"`
}
type SwapClaimView_Opaque_ struct {
	Opaque *SwapClaimView_Opaque `protobuf:"bytes,2,opt,name=opaque,proto3,oneof" json:"opaque,omitempty"`
}

func (*SwapClaimView_Visible_) isSwapClaimView_SwapClaimView() {}
func (*SwapClaimView_Opaque_) isSwapClaimView_SwapClaimView()  {}

func (m *SwapClaimView) GetSwapClaimView() isSwapClaimView_SwapClaimView {
	if m != nil {
		return m.SwapClaimView
	}
	return nil
}

func (m *SwapClaimView) GetVisible() *SwapClaimView_Visible {
	if x, ok := m.GetSwapClaimView().(*SwapClaimView_Visible_); ok {
		return x.Visible
	}
	return nil
}

func (m *SwapClaimView) GetOpaque() *SwapClaimView_Opaque {
	if x, ok := m.GetSwapClaimView().(*SwapClaimView_Opaque_); ok {
		return x.Opaque
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SwapClaimView) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SwapClaimView_Visible_)(nil),
		(*SwapClaimView_Opaque_)(nil),
	}
}

type SwapClaimView_Visible struct {
	SwapClaim *SwapClaim         `protobuf:"bytes,1,opt,name=swap_claim,json=swapClaim,proto3" json:"swap_claim,omitempty"`
	Output_1  *v1alpha1.NoteView `protobuf:"bytes,2,opt,name=output_1,json=output1,proto3" json:"output_1,omitempty"`
	Output_2  *v1alpha1.NoteView `protobuf:"bytes,3,opt,name=output_2,json=output2,proto3" json:"output_2,omitempty"`
}

func (m *SwapClaimView_Visible) Reset()         { *m = SwapClaimView_Visible{} }
func (m *SwapClaimView_Visible) String() string { return proto.CompactTextString(m) }
func (*SwapClaimView_Visible) ProtoMessage()    {}
func (*SwapClaimView_Visible) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1eba752ca2f0d70, []int{10, 0}
}
func (m *SwapClaimView_Visible) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapClaimView_Visible) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapClaimView_Visible.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapClaimView_Visible) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapClaimView_Visible.Merge(m, src)
}
func (m *SwapClaimView_Visible) XXX_Size() int {
	return m.Size()
}
func (m *SwapClaimView_Visible) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapClaimView_Visible.DiscardUnknown(m)
}

var xxx_messageInfo_SwapClaimView_Visible proto.InternalMessageInfo

func (m *SwapClaimView_Visible) GetSwapClaim() *SwapClaim {
	if m != nil {
		return m.SwapClaim
	}
	return nil
}

func (m *SwapClaimView_Visible) GetOutput_1() *v1alpha1.NoteView {
	if m != nil {
		return m.Output_1
	}
	return nil
}

func (m *SwapClaimView_Visible) GetOutput_2() *v1alpha1.NoteView {
	if m != nil {
		return m.Output_2
	}
	return nil
}

type SwapClaimView_Opaque struct {
	SwapClaim *SwapClaim `protobuf:"bytes,1,opt,name=swap_claim,json=swapClaim,proto3" json:"swap_claim,omitempty"`
}

func (m *SwapClaimView_Opaque) Reset()         { *m = SwapClaimView_Opaque{} }
func (m *SwapClaimView_Opaque) String() string { return proto.CompactTextString(m) }
func (*SwapClaimView_Opaque) ProtoMessage()    {}
func (*SwapClaimView_Opaque) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1eba752ca2f0d70, []int{10, 1}
}
func (m *SwapClaimView_Opaque) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapClaimView_Opaque) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapClaimView_Opaque.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapClaimView_Opaque) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapClaimView_Opaque.Merge(m, src)
}
func (m *SwapClaimView_Opaque) XXX_Size() int {
	return m.Size()
}
func (m *SwapClaimView_Opaque) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapClaimView_Opaque.DiscardUnknown(m)
}

var xxx_messageInfo_SwapClaimView_Opaque proto.InternalMessageInfo

func (m *SwapClaimView_Opaque) GetSwapClaim() *SwapClaim {
	if m != nil {
		return m.SwapClaim
	}
	return nil
}

// Holds two asset IDs. Ordering doesn't reflect trading direction. Instead, we
// require `asset_1 < asset_2` as field elements, to ensure a canonical
// representation of an unordered pair.
type TradingPair struct {
	// The first asset of the pair.
	Asset_1 *v1alpha1.AssetId `protobuf:"bytes,1,opt,name=asset_1,json=asset1,proto3" json:"asset_1,omitempty"`
	// The second asset of the pair.
	Asset_2 *v1alpha1.AssetId `protobuf:"bytes,2,opt,name=asset_2,json=asset2,proto3" json:"asset_2,omitempty"`
}

func (m *TradingPair) Reset()         { *m = TradingPair{} }
func (m *TradingPair) String() string { return proto.CompactTextString(m) }
func (*TradingPair) ProtoMessage()    {}
func (*TradingPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1eba752ca2f0d70, []int{11}
}
func (m *TradingPair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TradingPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TradingPair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TradingPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TradingPair.Merge(m, src)
}
func (m *TradingPair) XXX_Size() int {
	return m.Size()
}
func (m *TradingPair) XXX_DiscardUnknown() {
	xxx_messageInfo_TradingPair.DiscardUnknown(m)
}

var xxx_messageInfo_TradingPair proto.InternalMessageInfo

func (m *TradingPair) GetAsset_1() *v1alpha1.AssetId {
	if m != nil {
		return m.Asset_1
	}
	return nil
}

func (m *TradingPair) GetAsset_2() *v1alpha1.AssetId {
	if m != nil {
		return m.Asset_2
	}
	return nil
}

// Encodes a trading pair starting from asset `start`
// and ending on asset `end`.
type DirectedTradingPair struct {
	// The start asset of the pair.
	Start *v1alpha1.AssetId `protobuf:"bytes,1,opt,name=start,proto3" json:"start,omitempty"`
	// The end asset of the pair.
	End *v1alpha1.AssetId `protobuf:"bytes,2,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *DirectedTradingPair) Reset()         { *m = DirectedTradingPair{} }
func (m *DirectedTradingPair) String() string { return proto.CompactTextString(m) }
func (*DirectedTradingPair) ProtoMessage()    {}
func (*DirectedTradingPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1eba752ca2f0d70, []int{12}
}
func (m *DirectedTradingPair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DirectedTradingPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DirectedTradingPair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DirectedTradingPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DirectedTradingPair.Merge(m, src)
}
func (m *DirectedTradingPair) XXX_Size() int {
	return m.Size()
}
func (m *DirectedTradingPair) XXX_DiscardUnknown() {
	xxx_messageInfo_DirectedTradingPair.DiscardUnknown(m)
}

var xxx_messageInfo_DirectedTradingPair proto.InternalMessageInfo

func (m *DirectedTradingPair) GetStart() *v1alpha1.AssetId {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *DirectedTradingPair) GetEnd() *v1alpha1.AssetId {
	if m != nil {
		return m.End
	}
	return nil
}

// Records the result of a batch swap on-chain.
//
// Used as a public input to a swap claim proof, as it implies the effective
// clearing price for the batch.
type BatchSwapOutputData struct {
	// The total amount of asset 1 that was input to the batch swap.
	Delta_1 *v1alpha1.Amount `protobuf:"bytes,1,opt,name=delta_1,json=delta1,proto3" json:"delta_1,omitempty"`
	// The total amount of asset 2 that was input to the batch swap.
	Delta_2 *v1alpha1.Amount `protobuf:"bytes,2,opt,name=delta_2,json=delta2,proto3" json:"delta_2,omitempty"`
	// The total amount of asset 1 that was output from the batch swap for 1=>2 trades.
	Lambda_1_1 *v1alpha1.Amount `protobuf:"bytes,3,opt,name=lambda_1_1,json=lambda11,proto3" json:"lambda_1_1,omitempty"`
	// The total amount of asset 2 that was output from the batch swap for 1=>2 trades.
	Lambda_2_1 *v1alpha1.Amount `protobuf:"bytes,4,opt,name=lambda_2_1,json=lambda21,proto3" json:"lambda_2_1,omitempty"`
	// The total amount of asset 1 that was output from the batch swap for 2=>1 trades.
	Lambda_1_2 *v1alpha1.Amount `protobuf:"bytes,5,opt,name=lambda_1_2,json=lambda12,proto3" json:"lambda_1_2,omitempty"`
	// The total amount of asset 2 that was output from the batch swap for 2=>1 trades.
	Lambda_2_2 *v1alpha1.Amount `protobuf:"bytes,6,opt,name=lambda_2_2,json=lambda22,proto3" json:"lambda_2_2,omitempty"`
	// The height for which the batch swap data is valid.
	Height uint64 `protobuf:"varint,7,opt,name=height,proto3" json:"height,omitempty"`
	// The trading pair associated with the batch swap.
	TradingPair *TradingPair `protobuf:"bytes,8,opt,name=trading_pair,json=tradingPair,proto3" json:"trading_pair,omitempty"`
}

func (m *BatchSwapOutputData) Reset()         { *m = BatchSwapOutputData{} }
func (m *BatchSwapOutputData) String() string { return proto.CompactTextString(m) }
func (*BatchSwapOutputData) ProtoMessage()    {}
func (*BatchSwapOutputData) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1eba752ca2f0d70, []int{13}
}
func (m *BatchSwapOutputData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchSwapOutputData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchSwapOutputData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchSwapOutputData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchSwapOutputData.Merge(m, src)
}
func (m *BatchSwapOutputData) XXX_Size() int {
	return m.Size()
}
func (m *BatchSwapOutputData) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchSwapOutputData.DiscardUnknown(m)
}

var xxx_messageInfo_BatchSwapOutputData proto.InternalMessageInfo

func (m *BatchSwapOutputData) GetDelta_1() *v1alpha1.Amount {
	if m != nil {
		return m.Delta_1
	}
	return nil
}

func (m *BatchSwapOutputData) GetDelta_2() *v1alpha1.Amount {
	if m != nil {
		return m.Delta_2
	}
	return nil
}

func (m *BatchSwapOutputData) GetLambda_1_1() *v1alpha1.Amount {
	if m != nil {
		return m.Lambda_1_1
	}
	return nil
}

func (m *BatchSwapOutputData) GetLambda_2_1() *v1alpha1.Amount {
	if m != nil {
		return m.Lambda_2_1
	}
	return nil
}

func (m *BatchSwapOutputData) GetLambda_1_2() *v1alpha1.Amount {
	if m != nil {
		return m.Lambda_1_2
	}
	return nil
}

func (m *BatchSwapOutputData) GetLambda_2_2() *v1alpha1.Amount {
	if m != nil {
		return m.Lambda_2_2
	}
	return nil
}

func (m *BatchSwapOutputData) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *BatchSwapOutputData) GetTradingPair() *TradingPair {
	if m != nil {
		return m.TradingPair
	}
	return nil
}

// The trading function for a specific pair.
// For a pair (asset_1, asset_2), a trading function is defined by:
// `phi(R) = p*R_1 + q*R_2` and `gamma = 1 - fee`.
// The trading function is frequently referred to as "phi".
type TradingFunction struct {
	Component *BareTradingFunction `protobuf:"bytes,1,opt,name=component,proto3" json:"component,omitempty"`
	Pair      *TradingPair         `protobuf:"bytes,2,opt,name=pair,proto3" json:"pair,omitempty"`
}

func (m *TradingFunction) Reset()         { *m = TradingFunction{} }
func (m *TradingFunction) String() string { return proto.CompactTextString(m) }
func (*TradingFunction) ProtoMessage()    {}
func (*TradingFunction) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1eba752ca2f0d70, []int{14}
}
func (m *TradingFunction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TradingFunction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TradingFunction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TradingFunction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TradingFunction.Merge(m, src)
}
func (m *TradingFunction) XXX_Size() int {
	return m.Size()
}
func (m *TradingFunction) XXX_DiscardUnknown() {
	xxx_messageInfo_TradingFunction.DiscardUnknown(m)
}

var xxx_messageInfo_TradingFunction proto.InternalMessageInfo

func (m *TradingFunction) GetComponent() *BareTradingFunction {
	if m != nil {
		return m.Component
	}
	return nil
}

func (m *TradingFunction) GetPair() *TradingPair {
	if m != nil {
		return m.Pair
	}
	return nil
}

// The minimum amount of data describing a trading function.
//
// This implicitly treats the trading function as being between assets 1 and 2,
// without specifying what those assets are, to avoid duplicating data (each
// asset ID alone is twice the size of the trading function).
type BareTradingFunction struct {
	Fee uint32 `protobuf:"varint,1,opt,name=fee,proto3" json:"fee,omitempty"`
	// This is not actually an amount, it's an integer the same width as an amount
	P *v1alpha1.Amount `protobuf:"bytes,2,opt,name=p,proto3" json:"p,omitempty"`
	// This is not actually an amount, it's an integer the same width as an amount
	Q *v1alpha1.Amount `protobuf:"bytes,3,opt,name=q,proto3" json:"q,omitempty"`
}

func (m *BareTradingFunction) Reset()         { *m = BareTradingFunction{} }
func (m *BareTradingFunction) String() string { return proto.CompactTextString(m) }
func (*BareTradingFunction) ProtoMessage()    {}
func (*BareTradingFunction) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1eba752ca2f0d70, []int{15}
}
func (m *BareTradingFunction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BareTradingFunction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BareTradingFunction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BareTradingFunction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BareTradingFunction.Merge(m, src)
}
func (m *BareTradingFunction) XXX_Size() int {
	return m.Size()
}
func (m *BareTradingFunction) XXX_DiscardUnknown() {
	xxx_messageInfo_BareTradingFunction.DiscardUnknown(m)
}

var xxx_messageInfo_BareTradingFunction proto.InternalMessageInfo

func (m *BareTradingFunction) GetFee() uint32 {
	if m != nil {
		return m.Fee
	}
	return 0
}

func (m *BareTradingFunction) GetP() *v1alpha1.Amount {
	if m != nil {
		return m.P
	}
	return nil
}

func (m *BareTradingFunction) GetQ() *v1alpha1.Amount {
	if m != nil {
		return m.Q
	}
	return nil
}

// The reserves of a position.
//
// Like a position, this implicitly treats the trading function as being
// between assets 1 and 2, without specifying what those assets are, to avoid
// duplicating data (each asset ID alone is four times the size of the
// reserves).
type Reserves struct {
	R1 *v1alpha1.Amount `protobuf:"bytes,1,opt,name=r1,proto3" json:"r1,omitempty"`
	R2 *v1alpha1.Amount `protobuf:"bytes,2,opt,name=r2,proto3" json:"r2,omitempty"`
}

func (m *Reserves) Reset()         { *m = Reserves{} }
func (m *Reserves) String() string { return proto.CompactTextString(m) }
func (*Reserves) ProtoMessage()    {}
func (*Reserves) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1eba752ca2f0d70, []int{16}
}
func (m *Reserves) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Reserves) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Reserves.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Reserves) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Reserves.Merge(m, src)
}
func (m *Reserves) XXX_Size() int {
	return m.Size()
}
func (m *Reserves) XXX_DiscardUnknown() {
	xxx_messageInfo_Reserves.DiscardUnknown(m)
}

var xxx_messageInfo_Reserves proto.InternalMessageInfo

func (m *Reserves) GetR1() *v1alpha1.Amount {
	if m != nil {
		return m.R1
	}
	return nil
}

func (m *Reserves) GetR2() *v1alpha1.Amount {
	if m != nil {
		return m.R2
	}
	return nil
}

// Data identifying a position.
type Position struct {
	Phi *TradingFunction `protobuf:"bytes,1,opt,name=phi,proto3" json:"phi,omitempty"`
	// A random value used to disambiguate different positions with the exact same
	// trading function.  The chain should reject newly created positions with the
	// same nonce as an existing position.  This ensures that `PositionId`s will
	// be unique, and allows us to track position ownership with a
	// sequence of stateful NFTs based on the `PositionId`.
	Nonce    []byte         `protobuf:"bytes,2,opt,name=nonce,proto3" json:"nonce,omitempty"`
	State    *PositionState `protobuf:"bytes,3,opt,name=state,proto3" json:"state,omitempty"`
	Reserves *Reserves      `protobuf:"bytes,4,opt,name=reserves,proto3" json:"reserves,omitempty"`
}

func (m *Position) Reset()         { *m = Position{} }
func (m *Position) String() string { return proto.CompactTextString(m) }
func (*Position) ProtoMessage()    {}
func (*Position) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1eba752ca2f0d70, []int{17}
}
func (m *Position) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Position) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Position.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Position) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Position.Merge(m, src)
}
func (m *Position) XXX_Size() int {
	return m.Size()
}
func (m *Position) XXX_DiscardUnknown() {
	xxx_messageInfo_Position.DiscardUnknown(m)
}

var xxx_messageInfo_Position proto.InternalMessageInfo

func (m *Position) GetPhi() *TradingFunction {
	if m != nil {
		return m.Phi
	}
	return nil
}

func (m *Position) GetNonce() []byte {
	if m != nil {
		return m.Nonce
	}
	return nil
}

func (m *Position) GetState() *PositionState {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *Position) GetReserves() *Reserves {
	if m != nil {
		return m.Reserves
	}
	return nil
}

// A hash of a `Position`.
type PositionId struct {
	Inner []byte `protobuf:"bytes,1,opt,name=inner,proto3" json:"inner,omitempty"`
}

func (m *PositionId) Reset()         { *m = PositionId{} }
func (m *PositionId) String() string { return proto.CompactTextString(m) }
func (*PositionId) ProtoMessage()    {}
func (*PositionId) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1eba752ca2f0d70, []int{18}
}
func (m *PositionId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PositionId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PositionId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PositionId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PositionId.Merge(m, src)
}
func (m *PositionId) XXX_Size() int {
	return m.Size()
}
func (m *PositionId) XXX_DiscardUnknown() {
	xxx_messageInfo_PositionId.DiscardUnknown(m)
}

var xxx_messageInfo_PositionId proto.InternalMessageInfo

func (m *PositionId) GetInner() []byte {
	if m != nil {
		return m.Inner
	}
	return nil
}

// The state of a position.
type PositionState struct {
	State PositionState_PositionStateEnum `protobuf:"varint,1,opt,name=state,proto3,enum=penumbra.core.dex.v1alpha1.PositionState_PositionStateEnum" json:"state,omitempty"`
}

func (m *PositionState) Reset()         { *m = PositionState{} }
func (m *PositionState) String() string { return proto.CompactTextString(m) }
func (*PositionState) ProtoMessage()    {}
func (*PositionState) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1eba752ca2f0d70, []int{19}
}
func (m *PositionState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PositionState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PositionState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PositionState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PositionState.Merge(m, src)
}
func (m *PositionState) XXX_Size() int {
	return m.Size()
}
func (m *PositionState) XXX_DiscardUnknown() {
	xxx_messageInfo_PositionState.DiscardUnknown(m)
}

var xxx_messageInfo_PositionState proto.InternalMessageInfo

func (m *PositionState) GetState() PositionState_PositionStateEnum {
	if m != nil {
		return m.State
	}
	return PositionState_POSITION_STATE_ENUM_UNSPECIFIED
}

// An LPNFT tracking both ownership and state of a position.
//
// Tracking the state as part of the LPNFT means that all LP-related actions can
// be authorized by spending funds: a state transition (e.g., closing a
// position) is modeled as spending an "open position LPNFT" and minting a
// "closed position LPNFT" for the same (globally unique) position ID.
//
// This means that the LP mechanics can be agnostic to the mechanism used to
// record custody and spend authorization.  For instance, they can be recorded
// in the shielded pool, where custody is based on off-chain keys, or they could
// be recorded in a programmatic on-chain account (in the future, e.g., to
// support interchain accounts).  This also means that LP-related actions don't
// require any cryptographic implementation (proofs, signatures, etc), other
// than hooking into the value commitment mechanism used for transaction
// balances.
type LpNft struct {
	PositionId *PositionId    `protobuf:"bytes,1,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
	State      *PositionState `protobuf:"bytes,2,opt,name=state,proto3" json:"state,omitempty"`
}

func (m *LpNft) Reset()         { *m = LpNft{} }
func (m *LpNft) String() string { return proto.CompactTextString(m) }
func (*LpNft) ProtoMessage()    {}
func (*LpNft) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1eba752ca2f0d70, []int{20}
}
func (m *LpNft) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LpNft) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LpNft.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LpNft) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LpNft.Merge(m, src)
}
func (m *LpNft) XXX_Size() int {
	return m.Size()
}
func (m *LpNft) XXX_DiscardUnknown() {
	xxx_messageInfo_LpNft.DiscardUnknown(m)
}

var xxx_messageInfo_LpNft proto.InternalMessageInfo

func (m *LpNft) GetPositionId() *PositionId {
	if m != nil {
		return m.PositionId
	}
	return nil
}

func (m *LpNft) GetState() *PositionState {
	if m != nil {
		return m.State
	}
	return nil
}

// A transaction action that opens a new position.
//
// This action's contribution to the transaction's value balance is to consume
// the initial reserves and contribute an opened position NFT.
type PositionOpen struct {
	// Contains the data defining the position, sufficient to compute its `PositionId`.
	//
	// Positions are immutable, so the `PositionData` (and hence the `PositionId`)
	// are unchanged over the entire lifetime of the position.
	Position *Position `protobuf:"bytes,1,opt,name=position,proto3" json:"position,omitempty"`
}

func (m *PositionOpen) Reset()         { *m = PositionOpen{} }
func (m *PositionOpen) String() string { return proto.CompactTextString(m) }
func (*PositionOpen) ProtoMessage()    {}
func (*PositionOpen) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1eba752ca2f0d70, []int{21}
}
func (m *PositionOpen) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PositionOpen) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PositionOpen.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PositionOpen) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PositionOpen.Merge(m, src)
}
func (m *PositionOpen) XXX_Size() int {
	return m.Size()
}
func (m *PositionOpen) XXX_DiscardUnknown() {
	xxx_messageInfo_PositionOpen.DiscardUnknown(m)
}

var xxx_messageInfo_PositionOpen proto.InternalMessageInfo

func (m *PositionOpen) GetPosition() *Position {
	if m != nil {
		return m.Position
	}
	return nil
}

// A transaction action that closes a position.
//
// This action's contribution to the transaction's value balance is to consume
// an opened position NFT and contribute a closed position NFT.
//
// Closing a position does not immediately withdraw funds, because Penumbra
// transactions (like any ZK transaction model) are early-binding: the prover
// must know the state transition they prove knowledge of, and they cannot know
// the final reserves with certainty until after the position has been deactivated.
type PositionClose struct {
	PositionId *PositionId `protobuf:"bytes,1,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
}

func (m *PositionClose) Reset()         { *m = PositionClose{} }
func (m *PositionClose) String() string { return proto.CompactTextString(m) }
func (*PositionClose) ProtoMessage()    {}
func (*PositionClose) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1eba752ca2f0d70, []int{22}
}
func (m *PositionClose) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PositionClose) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PositionClose.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PositionClose) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PositionClose.Merge(m, src)
}
func (m *PositionClose) XXX_Size() int {
	return m.Size()
}
func (m *PositionClose) XXX_DiscardUnknown() {
	xxx_messageInfo_PositionClose.DiscardUnknown(m)
}

var xxx_messageInfo_PositionClose proto.InternalMessageInfo

func (m *PositionClose) GetPositionId() *PositionId {
	if m != nil {
		return m.PositionId
	}
	return nil
}

// A transaction action that withdraws funds from a closed position.
//
// This action's contribution to the transaction's value balance is to consume a
// closed position NFT and contribute a withdrawn position NFT, as well as all
// of the funds that were in the position at the time of closing.
type PositionWithdraw struct {
	PositionId *PositionId `protobuf:"bytes,1,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
	// A transparent (zero blinding factor) commitment to the position's final reserves and fees.
	//
	// The chain will check this commitment by recomputing it with the on-chain state.
	ReservesCommitment *v1alpha1.BalanceCommitment `protobuf:"bytes,2,opt,name=reserves_commitment,json=reservesCommitment,proto3" json:"reserves_commitment,omitempty"`
}

func (m *PositionWithdraw) Reset()         { *m = PositionWithdraw{} }
func (m *PositionWithdraw) String() string { return proto.CompactTextString(m) }
func (*PositionWithdraw) ProtoMessage()    {}
func (*PositionWithdraw) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1eba752ca2f0d70, []int{23}
}
func (m *PositionWithdraw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PositionWithdraw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PositionWithdraw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PositionWithdraw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PositionWithdraw.Merge(m, src)
}
func (m *PositionWithdraw) XXX_Size() int {
	return m.Size()
}
func (m *PositionWithdraw) XXX_DiscardUnknown() {
	xxx_messageInfo_PositionWithdraw.DiscardUnknown(m)
}

var xxx_messageInfo_PositionWithdraw proto.InternalMessageInfo

func (m *PositionWithdraw) GetPositionId() *PositionId {
	if m != nil {
		return m.PositionId
	}
	return nil
}

func (m *PositionWithdraw) GetReservesCommitment() *v1alpha1.BalanceCommitment {
	if m != nil {
		return m.ReservesCommitment
	}
	return nil
}

// A transaction action that claims retroactive rewards for a historical
// position.
//
// This action's contribution to the transaction's value balance is to consume a
// withdrawn position NFT and contribute its reward balance.
type PositionRewardClaim struct {
	PositionId *PositionId `protobuf:"bytes,1,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
	// A transparent (zero blinding factor) commitment to the position's accumulated rewards.
	//
	// The chain will check this commitment by recomputing it with the on-chain state.
	RewardsCommitment *v1alpha1.BalanceCommitment `protobuf:"bytes,2,opt,name=rewards_commitment,json=rewardsCommitment,proto3" json:"rewards_commitment,omitempty"`
}

func (m *PositionRewardClaim) Reset()         { *m = PositionRewardClaim{} }
func (m *PositionRewardClaim) String() string { return proto.CompactTextString(m) }
func (*PositionRewardClaim) ProtoMessage()    {}
func (*PositionRewardClaim) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1eba752ca2f0d70, []int{24}
}
func (m *PositionRewardClaim) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PositionRewardClaim) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PositionRewardClaim.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PositionRewardClaim) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PositionRewardClaim.Merge(m, src)
}
func (m *PositionRewardClaim) XXX_Size() int {
	return m.Size()
}
func (m *PositionRewardClaim) XXX_DiscardUnknown() {
	xxx_messageInfo_PositionRewardClaim.DiscardUnknown(m)
}

var xxx_messageInfo_PositionRewardClaim proto.InternalMessageInfo

func (m *PositionRewardClaim) GetPositionId() *PositionId {
	if m != nil {
		return m.PositionId
	}
	return nil
}

func (m *PositionRewardClaim) GetRewardsCommitment() *v1alpha1.BalanceCommitment {
	if m != nil {
		return m.RewardsCommitment
	}
	return nil
}

// Contains a path for a trade, including the trading pair (with direction), the trading
// function defining their relationship, and the route taken between the two assets.
type Path struct {
	Pair  *DirectedTradingPair `protobuf:"bytes,1,opt,name=pair,proto3" json:"pair,omitempty"`
	Route []*v1alpha1.AssetId  `protobuf:"bytes,2,rep,name=route,proto3" json:"route,omitempty"`
	Phi   *BareTradingFunction `protobuf:"bytes,3,opt,name=phi,proto3" json:"phi,omitempty"`
}

func (m *Path) Reset()         { *m = Path{} }
func (m *Path) String() string { return proto.CompactTextString(m) }
func (*Path) ProtoMessage()    {}
func (*Path) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1eba752ca2f0d70, []int{25}
}
func (m *Path) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Path) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Path.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Path) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Path.Merge(m, src)
}
func (m *Path) XXX_Size() int {
	return m.Size()
}
func (m *Path) XXX_DiscardUnknown() {
	xxx_messageInfo_Path.DiscardUnknown(m)
}

var xxx_messageInfo_Path proto.InternalMessageInfo

func (m *Path) GetPair() *DirectedTradingPair {
	if m != nil {
		return m.Pair
	}
	return nil
}

func (m *Path) GetRoute() []*v1alpha1.AssetId {
	if m != nil {
		return m.Route
	}
	return nil
}

func (m *Path) GetPhi() *BareTradingFunction {
	if m != nil {
		return m.Phi
	}
	return nil
}

// A path and the amount of the assets on either side that were traded.
type Trade struct {
	// The path taken by the trade.
	Path *Path `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	// The amount of the start asset being traded.
	StartAmount *v1alpha1.Amount `protobuf:"bytes,2,opt,name=start_amount,json=startAmount,proto3" json:"start_amount,omitempty"`
	// The amount of end asset being received.
	EndAmount *v1alpha1.Amount `protobuf:"bytes,3,opt,name=end_amount,json=endAmount,proto3" json:"end_amount,omitempty"`
}

func (m *Trade) Reset()         { *m = Trade{} }
func (m *Trade) String() string { return proto.CompactTextString(m) }
func (*Trade) ProtoMessage()    {}
func (*Trade) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1eba752ca2f0d70, []int{26}
}
func (m *Trade) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Trade) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Trade.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Trade) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Trade.Merge(m, src)
}
func (m *Trade) XXX_Size() int {
	return m.Size()
}
func (m *Trade) XXX_DiscardUnknown() {
	xxx_messageInfo_Trade.DiscardUnknown(m)
}

var xxx_messageInfo_Trade proto.InternalMessageInfo

func (m *Trade) GetPath() *Path {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *Trade) GetStartAmount() *v1alpha1.Amount {
	if m != nil {
		return m.StartAmount
	}
	return nil
}

func (m *Trade) GetEndAmount() *v1alpha1.Amount {
	if m != nil {
		return m.EndAmount
	}
	return nil
}

// Contains the entire execution of a particular swap.
type SwapExecution struct {
	Trades []*Trade `protobuf:"bytes,1,rep,name=trades,proto3" json:"trades,omitempty"`
}

func (m *SwapExecution) Reset()         { *m = SwapExecution{} }
func (m *SwapExecution) String() string { return proto.CompactTextString(m) }
func (*SwapExecution) ProtoMessage()    {}
func (*SwapExecution) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1eba752ca2f0d70, []int{27}
}
func (m *SwapExecution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapExecution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapExecution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapExecution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapExecution.Merge(m, src)
}
func (m *SwapExecution) XXX_Size() int {
	return m.Size()
}
func (m *SwapExecution) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapExecution.DiscardUnknown(m)
}

var xxx_messageInfo_SwapExecution proto.InternalMessageInfo

func (m *SwapExecution) GetTrades() []*Trade {
	if m != nil {
		return m.Trades
	}
	return nil
}

// Contains private and public data for withdrawing funds from a closed position.
type PositionWithdrawPlan struct {
	Reserves   *Reserves    `protobuf:"bytes,1,opt,name=reserves,proto3" json:"reserves,omitempty"`
	PositionId *PositionId  `protobuf:"bytes,2,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
	Pair       *TradingPair `protobuf:"bytes,3,opt,name=pair,proto3" json:"pair,omitempty"`
}

func (m *PositionWithdrawPlan) Reset()         { *m = PositionWithdrawPlan{} }
func (m *PositionWithdrawPlan) String() string { return proto.CompactTextString(m) }
func (*PositionWithdrawPlan) ProtoMessage()    {}
func (*PositionWithdrawPlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1eba752ca2f0d70, []int{28}
}
func (m *PositionWithdrawPlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PositionWithdrawPlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PositionWithdrawPlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PositionWithdrawPlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PositionWithdrawPlan.Merge(m, src)
}
func (m *PositionWithdrawPlan) XXX_Size() int {
	return m.Size()
}
func (m *PositionWithdrawPlan) XXX_DiscardUnknown() {
	xxx_messageInfo_PositionWithdrawPlan.DiscardUnknown(m)
}

var xxx_messageInfo_PositionWithdrawPlan proto.InternalMessageInfo

func (m *PositionWithdrawPlan) GetReserves() *Reserves {
	if m != nil {
		return m.Reserves
	}
	return nil
}

func (m *PositionWithdrawPlan) GetPositionId() *PositionId {
	if m != nil {
		return m.PositionId
	}
	return nil
}

func (m *PositionWithdrawPlan) GetPair() *TradingPair {
	if m != nil {
		return m.Pair
	}
	return nil
}

// Contains private and public data for claiming rewards from a position.
type PositionRewardClaimPlan struct {
	Reserves *Reserves `protobuf:"bytes,1,opt,name=reserves,proto3" json:"reserves,omitempty"`
}

func (m *PositionRewardClaimPlan) Reset()         { *m = PositionRewardClaimPlan{} }
func (m *PositionRewardClaimPlan) String() string { return proto.CompactTextString(m) }
func (*PositionRewardClaimPlan) ProtoMessage()    {}
func (*PositionRewardClaimPlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1eba752ca2f0d70, []int{29}
}
func (m *PositionRewardClaimPlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PositionRewardClaimPlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PositionRewardClaimPlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PositionRewardClaimPlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PositionRewardClaimPlan.Merge(m, src)
}
func (m *PositionRewardClaimPlan) XXX_Size() int {
	return m.Size()
}
func (m *PositionRewardClaimPlan) XXX_DiscardUnknown() {
	xxx_messageInfo_PositionRewardClaimPlan.DiscardUnknown(m)
}

var xxx_messageInfo_PositionRewardClaimPlan proto.InternalMessageInfo

func (m *PositionRewardClaimPlan) GetReserves() *Reserves {
	if m != nil {
		return m.Reserves
	}
	return nil
}

func init() {
	proto.RegisterEnum("penumbra.core.dex.v1alpha1.PositionState_PositionStateEnum", PositionState_PositionStateEnum_name, PositionState_PositionStateEnum_value)
	proto.RegisterType((*Swap)(nil), "penumbra.core.dex.v1alpha1.Swap")
	proto.RegisterType((*SwapClaim)(nil), "penumbra.core.dex.v1alpha1.SwapClaim")
	proto.RegisterType((*SwapClaimBody)(nil), "penumbra.core.dex.v1alpha1.SwapClaimBody")
	proto.RegisterType((*SwapBody)(nil), "penumbra.core.dex.v1alpha1.SwapBody")
	proto.RegisterType((*SwapPayload)(nil), "penumbra.core.dex.v1alpha1.SwapPayload")
	proto.RegisterType((*SwapPlaintext)(nil), "penumbra.core.dex.v1alpha1.SwapPlaintext")
	proto.RegisterType((*MockFlowCiphertext)(nil), "penumbra.core.dex.v1alpha1.MockFlowCiphertext")
	proto.RegisterType((*SwapPlan)(nil), "penumbra.core.dex.v1alpha1.SwapPlan")
	proto.RegisterType((*SwapClaimPlan)(nil), "penumbra.core.dex.v1alpha1.SwapClaimPlan")
	proto.RegisterType((*SwapView)(nil), "penumbra.core.dex.v1alpha1.SwapView")
	proto.RegisterType((*SwapView_Visible)(nil), "penumbra.core.dex.v1alpha1.SwapView.Visible")
	proto.RegisterType((*SwapView_Opaque)(nil), "penumbra.core.dex.v1alpha1.SwapView.Opaque")
	proto.RegisterType((*SwapClaimView)(nil), "penumbra.core.dex.v1alpha1.SwapClaimView")
	proto.RegisterType((*SwapClaimView_Visible)(nil), "penumbra.core.dex.v1alpha1.SwapClaimView.Visible")
	proto.RegisterType((*SwapClaimView_Opaque)(nil), "penumbra.core.dex.v1alpha1.SwapClaimView.Opaque")
	proto.RegisterType((*TradingPair)(nil), "penumbra.core.dex.v1alpha1.TradingPair")
	proto.RegisterType((*DirectedTradingPair)(nil), "penumbra.core.dex.v1alpha1.DirectedTradingPair")
	proto.RegisterType((*BatchSwapOutputData)(nil), "penumbra.core.dex.v1alpha1.BatchSwapOutputData")
	proto.RegisterType((*TradingFunction)(nil), "penumbra.core.dex.v1alpha1.TradingFunction")
	proto.RegisterType((*BareTradingFunction)(nil), "penumbra.core.dex.v1alpha1.BareTradingFunction")
	proto.RegisterType((*Reserves)(nil), "penumbra.core.dex.v1alpha1.Reserves")
	proto.RegisterType((*Position)(nil), "penumbra.core.dex.v1alpha1.Position")
	proto.RegisterType((*PositionId)(nil), "penumbra.core.dex.v1alpha1.PositionId")
	proto.RegisterType((*PositionState)(nil), "penumbra.core.dex.v1alpha1.PositionState")
	proto.RegisterType((*LpNft)(nil), "penumbra.core.dex.v1alpha1.LpNft")
	proto.RegisterType((*PositionOpen)(nil), "penumbra.core.dex.v1alpha1.PositionOpen")
	proto.RegisterType((*PositionClose)(nil), "penumbra.core.dex.v1alpha1.PositionClose")
	proto.RegisterType((*PositionWithdraw)(nil), "penumbra.core.dex.v1alpha1.PositionWithdraw")
	proto.RegisterType((*PositionRewardClaim)(nil), "penumbra.core.dex.v1alpha1.PositionRewardClaim")
	proto.RegisterType((*Path)(nil), "penumbra.core.dex.v1alpha1.Path")
	proto.RegisterType((*Trade)(nil), "penumbra.core.dex.v1alpha1.Trade")
	proto.RegisterType((*SwapExecution)(nil), "penumbra.core.dex.v1alpha1.SwapExecution")
	proto.RegisterType((*PositionWithdrawPlan)(nil), "penumbra.core.dex.v1alpha1.PositionWithdrawPlan")
	proto.RegisterType((*PositionRewardClaimPlan)(nil), "penumbra.core.dex.v1alpha1.PositionRewardClaimPlan")
}

func init() {
	proto.RegisterFile("penumbra/core/dex/v1alpha1/dex.proto", fileDescriptor_d1eba752ca2f0d70)
}

var fileDescriptor_d1eba752ca2f0d70 = []byte{
	// 1788 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x59, 0x4f, 0x6f, 0xe3, 0xc6,
	0x15, 0xf7, 0x50, 0xb2, 0x2d, 0x3f, 0xc9, 0x1b, 0xef, 0x38, 0x68, 0x0d, 0x17, 0x71, 0x76, 0xd9,
	0xfc, 0xd9, 0x26, 0x85, 0x1c, 0x31, 0x29, 0x90, 0x7a, 0x9b, 0x6c, 0xac, 0x3f, 0x8e, 0xb5, 0x89,
	0x65, 0x86, 0x76, 0x76, 0x8b, 0xd4, 0x28, 0x31, 0x26, 0xc7, 0x2b, 0xa2, 0x14, 0xc9, 0x25, 0x47,
	0xb6, 0x7c, 0x2a, 0x50, 0xb4, 0xe8, 0x29, 0x68, 0xf3, 0x01, 0x8a, 0x22, 0x3d, 0xf6, 0x33, 0x14,
	0xed, 0xb5, 0x28, 0x5a, 0x60, 0x6f, 0xed, 0xa9, 0x28, 0xbc, 0x87, 0x02, 0xfd, 0x00, 0x45, 0x0f,
	0x3d, 0x14, 0x33, 0x1c, 0x8a, 0xb4, 0x2d, 0xaf, 0x44, 0xad, 0x7b, 0xc9, 0x4d, 0x33, 0xf3, 0x7e,
	0x3f, 0xbe, 0x99, 0xf7, 0xe6, 0xfd, 0x1e, 0x29, 0x78, 0x25, 0xa0, 0x5e, 0xbf, 0x77, 0x18, 0x92,
	0x75, 0xcb, 0x0f, 0xe9, 0xba, 0x4d, 0x07, 0xeb, 0xc7, 0x35, 0xe2, 0x06, 0x5d, 0x52, 0xe3, 0x83,
	0x6a, 0x10, 0xfa, 0xcc, 0xc7, 0xab, 0x89, 0x55, 0x95, 0x5b, 0x55, 0xf9, 0x42, 0x62, 0xb5, 0xfa,
	0xc6, 0x79, 0x06, 0x2b, 0x3c, 0x0d, 0x98, 0x9f, 0x92, 0xc4, 0xe3, 0x98, 0x47, 0xfd, 0x09, 0x82,
	0xe2, 0xde, 0x09, 0x09, 0xf0, 0x07, 0x30, 0x1b, 0x84, 0xbe, 0x7f, 0xb4, 0x82, 0x6e, 0xa1, 0x3b,
	0x65, 0xed, 0x8d, 0xea, 0xf9, 0x07, 0x48, 0x50, 0x42, 0x52, 0xfd, 0xec, 0x23, 0x8e, 0xd2, 0x39,
	0xc2, 0x88, 0x81, 0xf8, 0x5d, 0x28, 0x1e, 0xfa, 0xf6, 0xe9, 0x4a, 0x51, 0x10, 0xbc, 0x52, 0xbd,
	0xda, 0xc3, 0x2a, 0xc7, 0xd6, 0x7d, 0xfb, 0xd4, 0x10, 0x08, 0xf5, 0xe7, 0x08, 0x16, 0xf8, 0x54,
	0xc3, 0x25, 0x4e, 0x0f, 0xbf, 0x98, 0xf5, 0xa4, 0x92, 0xb0, 0xbf, 0x27, 0xd9, 0x15, 0xc1, 0xfe,
	0xad, 0x71, 0xec, 0x82, 0x2a, 0x7d, 0x04, 0x7e, 0x15, 0x6e, 0xd0, 0xc0, 0xb7, 0xba, 0xa6, 0xdd,
	0x0f, 0x09, 0x73, 0x7c, 0x6f, 0x65, 0xfe, 0x16, 0xba, 0x53, 0x34, 0x16, 0xc5, 0x6c, 0x53, 0x4e,
	0xaa, 0xbf, 0x2e, 0xc0, 0xe2, 0x39, 0x38, 0xde, 0x82, 0x05, 0xaf, 0xef, 0xba, 0xce, 0x91, 0x43,
	0x43, 0x79, 0x36, 0x77, 0xc6, 0x9c, 0x4d, 0x27, 0xb1, 0x37, 0x52, 0x28, 0x7e, 0x07, 0x0a, 0x47,
	0x94, 0x4a, 0xf7, 0xd5, 0x31, 0x0c, 0x5b, 0x94, 0x1a, 0xdc, 0x1c, 0xff, 0x10, 0x96, 0xfd, 0x3e,
	0x0b, 0xfa, 0xcc, 0xac, 0x99, 0x96, 0xdf, 0xeb, 0x39, 0xac, 0x47, 0x3d, 0xb6, 0x52, 0x10, 0x2c,
	0xd5, 0x31, 0x2c, 0x7b, 0x8c, 0x30, 0xda, 0x18, 0xa2, 0x8c, 0x9b, 0x31, 0x55, 0x2d, 0x9d, 0xca,
	0xf0, 0x6b, 0x59, 0xfe, 0xe2, 0xf3, 0xf0, 0x6b, 0x19, 0x7e, 0x1d, 0xca, 0x92, 0xdf, 0x26, 0x8c,
	0xac, 0xcc, 0x09, 0xde, 0xf5, 0x67, 0x05, 0xaf, 0x4e, 0x98, 0xd5, 0xe5, 0x21, 0xd8, 0x15, 0xb8,
	0x26, 0x61, 0xc4, 0x00, 0x7f, 0xf8, 0x5b, 0xfd, 0x8f, 0x02, 0xa5, 0x24, 0x7d, 0xf0, 0x7d, 0xa8,
	0xb0, 0x90, 0xd8, 0x8e, 0xf7, 0xc8, 0x0c, 0x88, 0x93, 0xc4, 0xe7, 0xf5, 0x67, 0xf1, 0xef, 0xc7,
	0xf6, 0x3a, 0x71, 0x42, 0xa3, 0xcc, 0xd2, 0x01, 0xde, 0x84, 0x05, 0x9b, 0xba, 0x8c, 0x98, 0x35,
	0xd3, 0x91, 0x61, 0x7a, 0x75, 0xcc, 0x01, 0x6c, 0xf6, 0xfc, 0xbe, 0xc7, 0x8c, 0x79, 0x81, 0xab,
	0xb5, 0x53, 0x0a, 0xcd, 0x74, 0x64, 0x8c, 0x72, 0x51, 0x68, 0x6d, 0xfc, 0x10, 0x6e, 0x1c, 0x51,
	0x7a, 0x39, 0x16, 0x6f, 0x8d, 0xe1, 0xa9, 0x13, 0x97, 0x78, 0x56, 0x36, 0x1a, 0x8b, 0x47, 0x34,
	0x33, 0xc4, 0x9b, 0x30, 0x1f, 0x90, 0x53, 0xd7, 0x27, 0xf6, 0xca, 0xec, 0xf8, 0x53, 0x12, 0x97,
	0x3b, 0x36, 0x37, 0x12, 0x9c, 0xfa, 0x53, 0x04, 0xe5, 0xcc, 0x02, 0xee, 0x00, 0x64, 0xfc, 0x44,
	0x53, 0xe5, 0x4c, 0x86, 0x41, 0xdc, 0x51, 0x4f, 0x00, 0xa8, 0x6d, 0x46, 0x27, 0x24, 0x10, 0x61,
	0xa8, 0x18, 0x8b, 0xc3, 0x59, 0xfe, 0x74, 0xf5, 0x67, 0xf2, 0x8e, 0xea, 0x2e, 0x71, 0x3c, 0x46,
	0x07, 0xec, 0x2b, 0x98, 0x06, 0xf7, 0x60, 0xc1, 0xe2, 0x25, 0xc8, 0xe4, 0x35, 0xa3, 0x38, 0x71,
	0xcd, 0x28, 0x09, 0xd0, 0x16, 0xa5, 0xf8, 0x23, 0x58, 0x8c, 0x09, 0x88, 0x6d, 0x87, 0x34, 0x8a,
	0x64, 0xd0, 0x5f, 0x1b, 0xe7, 0x47, 0x6c, 0x6d, 0x54, 0x04, 0x58, 0x8e, 0x78, 0x45, 0x0e, 0x23,
	0x4a, 0x6d, 0x71, 0x7f, 0x2b, 0x46, 0x3c, 0x50, 0x3f, 0x01, 0xbc, 0xe3, 0x5b, 0x3f, 0xda, 0x72,
	0xfd, 0x93, 0x86, 0x13, 0x74, 0x69, 0x28, 0x62, 0x71, 0x17, 0x66, 0x8f, 0x89, 0xdb, 0xa7, 0x32,
	0x08, 0x13, 0x6e, 0x3c, 0xc6, 0xa8, 0x3f, 0x8e, 0xef, 0xb6, 0xee, 0x12, 0x0f, 0xeb, 0x70, 0x83,
	0xe7, 0x80, 0x19, 0x24, 0x61, 0x96, 0x8c, 0x63, 0x4b, 0xff, 0x30, 0x2f, 0x8c, 0xc5, 0xe8, 0x5c,
	0x9a, 0xdc, 0x86, 0x0a, 0xbf, 0x5b, 0x87, 0xae, 0xe3, 0xf1, 0x70, 0xcb, 0xec, 0x2a, 0x1f, 0x51,
	0x5a, 0x97, 0x53, 0xea, 0xbf, 0x51, 0xa6, 0xfe, 0xff, 0x9f, 0xdc, 0x58, 0x85, 0x52, 0xe0, 0x47,
	0x8e, 0x10, 0x21, 0x45, 0x88, 0xd0, 0x70, 0x7c, 0xb1, 0x5e, 0x16, 0x9e, 0xbb, 0x5e, 0x8e, 0x10,
	0xbe, 0xe2, 0x28, 0xe1, 0xfb, 0xaf, 0x2c, 0xab, 0x0f, 0x1c, 0x7a, 0x82, 0xb7, 0x61, 0xfe, 0xd8,
	0x89, 0x9c, 0x43, 0x37, 0x89, 0xe2, 0xb7, 0xc7, 0x6d, 0x96, 0xc3, 0xaa, 0x0f, 0x62, 0xcc, 0xf6,
	0x8c, 0x91, 0xc0, 0x71, 0x0b, 0xe6, 0xfc, 0x80, 0x3c, 0xee, 0x27, 0xc2, 0xf7, 0xe6, 0x44, 0x44,
	0xbb, 0x02, 0xb2, 0x3d, 0x63, 0x48, 0xf0, 0xea, 0x17, 0x08, 0xe6, 0x25, 0x3b, 0x7e, 0x07, 0x8a,
	0xa2, 0x36, 0xc4, 0x9e, 0xdd, 0x1a, 0x47, 0x68, 0x08, 0xeb, 0x11, 0x61, 0x2c, 0x3c, 0x5f, 0x18,
	0x57, 0xdf, 0x87, 0xb9, 0xd8, 0xcf, 0xe9, 0x3c, 0xaa, 0x97, 0x61, 0x41, 0x78, 0x74, 0xec, 0xd0,
	0x13, 0xf5, 0x9f, 0xd9, 0xbe, 0x43, 0xc4, 0x60, 0xe7, 0x62, 0x0c, 0x6a, 0x13, 0xb5, 0x3c, 0x57,
	0x05, 0xe2, 0xfe, 0x85, 0x40, 0xbc, 0x35, 0x39, 0xdb, 0xa5, 0x68, 0xfc, 0x35, 0x13, 0x8d, 0x26,
	0x80, 0xd8, 0x85, 0xa8, 0x17, 0x57, 0xdc, 0xf9, 0xd1, 0xdc, 0x86, 0xd8, 0x7e, 0xdc, 0xf2, 0xd5,
	0xa1, 0x94, 0xb4, 0x39, 0xd2, 0xbf, 0xd7, 0xc7, 0xf5, 0x58, 0x3e, 0xa3, 0xdc, 0x3b, 0x63, 0x5e,
	0x36, 0x35, 0x19, 0x0e, 0x4d, 0xc6, 0x36, 0x2f, 0x87, 0xb6, 0xda, 0x19, 0xc6, 0xf4, 0x5a, 0xf6,
	0x55, 0xbf, 0x09, 0x2f, 0xa4, 0x2c, 0x71, 0xa4, 0x7f, 0x81, 0xa0, 0x9c, 0x11, 0x1f, 0x7c, 0x0f,
	0xe6, 0x49, 0x14, 0x51, 0xbe, 0x73, 0x34, 0x59, 0x89, 0xe6, 0xd6, 0x6d, 0xdb, 0x98, 0x13, 0xb0,
	0x5a, 0x4a, 0xa0, 0xc9, 0xa3, 0xcb, 0x47, 0xa0, 0xa9, 0x9f, 0x23, 0x58, 0x6e, 0x3a, 0x21, 0xb5,
	0x18, 0xb5, 0xb3, 0x9e, 0x7d, 0x0f, 0x66, 0x23, 0x46, 0x42, 0x96, 0xd3, 0xaf, 0x18, 0x84, 0xdf,
	0x85, 0x02, 0xf5, 0xec, 0x9c, 0x2e, 0x71, 0x88, 0xfa, 0x79, 0x11, 0x96, 0x47, 0x54, 0x35, 0xfc,
	0x3e, 0xcc, 0x4b, 0x65, 0xce, 0xa7, 0x2d, 0x73, 0xb1, 0x2e, 0xa7, 0x78, 0x2d, 0x9f, 0xae, 0xc7,
	0x78, 0x0d, 0x37, 0x00, 0x5c, 0xd2, 0x3b, 0xb4, 0x79, 0x6b, 0x50, 0xcb, 0xa7, 0xeb, 0xa5, 0x18,
	0x58, 0xab, 0x65, 0x48, 0x34, 0xb3, 0x26, 0x95, 0x3d, 0x1f, 0x89, 0x56, 0x3b, 0xe7, 0x89, 0x26,
	0x95, 0x3d, 0xa7, 0x27, 0xda, 0x39, 0x4f, 0x34, 0xd9, 0x99, 0xe7, 0xf4, 0x44, 0xc3, 0x5f, 0x83,
	0xb9, 0x2e, 0x75, 0x1e, 0x75, 0x99, 0x7c, 0x9d, 0x92, 0xa3, 0x4b, 0x1d, 0x59, 0x69, 0xfa, 0x8e,
	0x4c, 0xfd, 0x15, 0x82, 0x17, 0xe4, 0xe2, 0x56, 0xdf, 0xb3, 0x84, 0x4e, 0xee, 0xc0, 0x82, 0xe5,
	0xf7, 0x02, 0xdf, 0x4b, 0x3b, 0xcf, 0x31, 0x2a, 0x19, 0xd2, 0x0b, 0x1c, 0x46, 0xca, 0x80, 0xef,
	0x42, 0x51, 0xb8, 0xa9, 0xe4, 0x73, 0x53, 0x80, 0xd4, 0x2f, 0x10, 0xcf, 0xd7, 0x4b, 0xfc, 0x78,
	0x29, 0x7e, 0xe3, 0xe3, 0xde, 0x2d, 0xc6, 0x6f, 0x73, 0x6f, 0x03, 0x0a, 0xf2, 0xe5, 0x1e, 0x0a,
	0x38, 0xe8, 0x71, 0xbe, 0x6c, 0x43, 0x8f, 0xd5, 0x01, 0x94, 0x0c, 0x1a, 0xd1, 0xf0, 0x98, 0x46,
	0xf8, 0x3b, 0xa0, 0x84, 0x39, 0xaf, 0x8c, 0x12, 0xd6, 0x04, 0x2c, 0xe7, 0x4d, 0x51, 0x42, 0x4d,
	0x3d, 0x43, 0x50, 0xd2, 0x93, 0x76, 0xe6, 0x3d, 0x28, 0x04, 0x5d, 0x47, 0x3e, 0xfb, 0xcd, 0x09,
	0x8e, 0x75, 0x18, 0x1c, 0x8e, 0xe3, 0x7d, 0xa7, 0xe7, 0x7b, 0x16, 0x95, 0x9d, 0x5a, 0x3c, 0xc0,
	0xf7, 0x44, 0x5d, 0x62, 0x74, 0x12, 0x05, 0x4f, 0x3c, 0x11, 0xaf, 0x1d, 0x46, 0x8c, 0xc3, 0x1f,
	0x40, 0x29, 0x94, 0x87, 0x33, 0xc9, 0xc7, 0x8a, 0xe4, 0x20, 0x8d, 0x21, 0x4a, 0x55, 0x01, 0x12,
	0xe6, 0xb6, 0xcd, 0xdd, 0x74, 0x3c, 0x4f, 0x7e, 0x1e, 0xa8, 0x18, 0xf1, 0x40, 0xfd, 0x52, 0x81,
	0xc5, 0x73, 0x8f, 0xc7, 0x9f, 0x24, 0x8e, 0x73, 0xbb, 0x1b, 0xda, 0xdd, 0x89, 0x1d, 0x3f, 0x3f,
	0x6a, 0x79, 0xfd, 0x9e, 0xdc, 0x8a, 0xfa, 0x3b, 0x04, 0x37, 0x2f, 0x2d, 0xe2, 0x6f, 0xc2, 0xcb,
	0xfa, 0xee, 0x5e, 0x7b, 0xbf, 0xbd, 0xdb, 0x31, 0xf7, 0xf6, 0x37, 0xf7, 0x5b, 0x66, 0xab, 0xf3,
	0xe9, 0x8e, 0xf9, 0x69, 0x67, 0x4f, 0x6f, 0x35, 0xda, 0x5b, 0xed, 0x56, 0x73, 0x69, 0x06, 0xaf,
	0xc1, 0xea, 0x28, 0xa3, 0x5d, 0xbd, 0xd5, 0x69, 0x35, 0x97, 0xd0, 0x55, 0xeb, 0x8d, 0x8f, 0x77,
	0xf7, 0x5a, 0xcd, 0x25, 0x05, 0xdf, 0x86, 0x97, 0x46, 0xad, 0x3f, 0x6c, 0xef, 0x6f, 0x37, 0x8d,
	0xcd, 0x87, 0x9d, 0xa5, 0x02, 0x7e, 0x19, 0xbe, 0x31, 0x9a, 0x62, 0xb3, 0xbd, 0xd3, 0x6a, 0x2e,
	0x15, 0xf9, 0xd5, 0x99, 0xfd, 0x38, 0xe8, 0x1c, 0x31, 0xfc, 0x21, 0x94, 0x93, 0x26, 0xd8, 0x74,
	0xec, 0x2b, 0x24, 0x67, 0xe4, 0x09, 0xb5, 0x6d, 0x03, 0x82, 0x34, 0x18, 0xc3, 0xec, 0x50, 0xa6,
	0xcb, 0x0e, 0x55, 0x87, 0x4a, 0x32, 0xbf, 0x1b, 0x50, 0x8f, 0x67, 0xcb, 0xb0, 0x5d, 0x47, 0xe3,
	0xb3, 0x25, 0xc1, 0xa6, 0x4d, 0xbd, 0xfa, 0xfd, 0x34, 0x11, 0x1a, 0xae, 0x1f, 0xd1, 0x6b, 0xdb,
	0xac, 0xfa, 0x7b, 0x04, 0x4b, 0xc9, 0xd2, 0x43, 0x87, 0x75, 0xed, 0x90, 0x9c, 0x5c, 0xdf, 0x51,
	0x12, 0x58, 0x4e, 0x32, 0x3e, 0xfb, 0x41, 0x42, 0x99, 0xf2, 0x83, 0x04, 0x4e, 0xc8, 0xd2, 0x39,
	0xf5, 0x0f, 0x08, 0x96, 0x87, 0x27, 0x46, 0x4f, 0x48, 0x68, 0xc7, 0x0d, 0xe1, 0xb5, 0xed, 0xc1,
	0x04, 0x1c, 0x0a, 0xde, 0x6b, 0xd9, 0xc2, 0x4d, 0xc9, 0x95, 0xd9, 0xc1, 0x9f, 0x11, 0x14, 0x75,
	0xc2, 0xba, 0xb8, 0x21, 0x35, 0x64, 0x02, 0x35, 0x1a, 0xd1, 0x6d, 0xc5, 0x5a, 0xc2, 0x7b, 0xae,
	0xd0, 0xef, 0x8b, 0xec, 0x2d, 0xe4, 0xe9, 0xb9, 0x04, 0x08, 0x6f, 0xc6, 0xe5, 0xb6, 0x30, 0x9d,
	0x1e, 0x72, 0xac, 0xfa, 0x17, 0x04, 0xb3, 0x7c, 0x41, 0xbc, 0xd5, 0x04, 0x84, 0x75, 0x27, 0x79,
	0xab, 0xe1, 0xfb, 0x37, 0x84, 0x35, 0xde, 0x86, 0x8a, 0xe8, 0xff, 0x4c, 0x22, 0x24, 0x21, 0x9f,
	0x7e, 0x94, 0x05, 0x34, 0x1e, 0xf0, 0x0e, 0x9c, 0x7a, 0x76, 0xc2, 0x93, 0x4b, 0x00, 0x17, 0xa8,
	0x67, 0xc7, 0x3f, 0xd5, 0xfb, 0xf1, 0x7b, 0x55, 0x6b, 0x40, 0xad, 0xbe, 0x90, 0xa4, 0xef, 0xc2,
	0x1c, 0x6f, 0x2e, 0x68, 0xb4, 0x82, 0xc4, 0x11, 0xdf, 0x1e, 0xa7, 0x4a, 0xd4, 0x90, 0x00, 0xf5,
	0xef, 0x08, 0x5e, 0xbc, 0x78, 0xdb, 0xc4, 0x37, 0x82, 0xac, 0xa0, 0xa0, 0x69, 0x04, 0xe5, 0x62,
	0xbe, 0x2b, 0x53, 0xe7, 0x7b, 0xd2, 0xc9, 0x14, 0xa6, 0xe9, 0x64, 0x7e, 0x00, 0x5f, 0x1f, 0x71,
	0x19, 0xaf, 0x67, 0x8b, 0xf5, 0x2f, 0x95, 0x3f, 0x9e, 0xad, 0xa1, 0x27, 0x67, 0x6b, 0xe8, 0x1f,
	0x67, 0x6b, 0xe8, 0x97, 0x4f, 0xd7, 0x66, 0x9e, 0x3c, 0x5d, 0x9b, 0xf9, 0xdb, 0xd3, 0xb5, 0x19,
	0x58, 0xb3, 0xfc, 0xde, 0x33, 0xd8, 0xea, 0xa5, 0x26, 0x1d, 0xe8, 0xa1, 0xcf, 0x7c, 0x1d, 0x7d,
	0x66, 0x3c, 0x72, 0x58, 0xb7, 0x7f, 0x58, 0xb5, 0xfc, 0xde, 0xba, 0xe5, 0x47, 0x3d, 0x3f, 0x5a,
	0x0f, 0xa9, 0x4b, 0x4e, 0x69, 0xb8, 0x7e, 0xac, 0x0d, 0x7f, 0x5a, 0x5d, 0xe2, 0x78, 0xd1, 0xfa,
	0xd5, 0x7f, 0xa5, 0xdc, 0xb5, 0xe9, 0x20, 0xf9, 0xfd, 0x1b, 0xa5, 0xa0, 0x37, 0x9a, 0xbf, 0x55,
	0x56, 0xf5, 0xc4, 0x85, 0x06, 0x77, 0xa1, 0x49, 0x07, 0xd5, 0x07, 0xd2, 0xe4, 0x4f, 0xe9, 0xe2,
	0x01, 0x5f, 0x3c, 0x68, 0xd2, 0xc1, 0x41, 0xb2, 0x78, 0xa6, 0xbc, 0x76, 0xf5, 0xe2, 0xc1, 0x87,
	0x7a, 0x7d, 0x87, 0x32, 0x62, 0x13, 0x46, 0xfe, 0xa5, 0xbc, 0x94, 0x18, 0x6e, 0x6c, 0x70, 0xcb,
	0x8d, 0x8d, 0x26, 0x1d, 0x6c, 0x6c, 0x24, 0xb6, 0x87, 0x73, 0xe2, 0x4f, 0x99, 0xb7, 0xff, 0x17,
	0x00, 0x00, 0xff, 0xff, 0x38, 0x61, 0x76, 0x55, 0x04, 0x1a, 0x00, 0x00,
}

func (m *Swap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Swap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Swap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Body != nil {
		{
			size, err := m.Body.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Proof != nil {
		{
			size, err := m.Proof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwapClaim) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EpochDuration != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.EpochDuration))
		i--
		dAtA[i] = 0x38
	}
	if m.Body != nil {
		{
			size, err := m.Body.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Proof) > 0 {
		i -= len(m.Proof)
		copy(dAtA[i:], m.Proof)
		i = encodeVarintDex(dAtA, i, uint64(len(m.Proof)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwapClaimBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapClaimBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapClaimBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OutputData != nil {
		{
			size, err := m.OutputData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Output_2Commitment != nil {
		{
			size, err := m.Output_2Commitment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Output_1Commitment != nil {
		{
			size, err := m.Output_1Commitment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Fee != nil {
		{
			size, err := m.Fee.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Nullifier != nil {
		{
			size, err := m.Nullifier.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwapBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.FeeCommitment != nil {
		{
			size, err := m.FeeCommitment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Delta_2I != nil {
		{
			size, err := m.Delta_2I.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Delta_1I != nil {
		{
			size, err := m.Delta_1I.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TradingPair != nil {
		{
			size, err := m.TradingPair.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwapPayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapPayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapPayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EncryptedSwap) > 0 {
		i -= len(m.EncryptedSwap)
		copy(dAtA[i:], m.EncryptedSwap)
		i = encodeVarintDex(dAtA, i, uint64(len(m.EncryptedSwap)))
		i--
		dAtA[i] = 0x12
	}
	if m.Commitment != nil {
		{
			size, err := m.Commitment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwapPlaintext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapPlaintext) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapPlaintext) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Rseed) > 0 {
		i -= len(m.Rseed)
		copy(dAtA[i:], m.Rseed)
		i = encodeVarintDex(dAtA, i, uint64(len(m.Rseed)))
		i--
		dAtA[i] = 0x32
	}
	if m.ClaimAddress != nil {
		{
			size, err := m.ClaimAddress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.ClaimFee != nil {
		{
			size, err := m.ClaimFee.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Delta_2I != nil {
		{
			size, err := m.Delta_2I.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Delta_1I != nil {
		{
			size, err := m.Delta_1I.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TradingPair != nil {
		{
			size, err := m.TradingPair.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MockFlowCiphertext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MockFlowCiphertext) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MockFlowCiphertext) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwapPlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapPlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapPlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FeeBlinding) > 0 {
		i -= len(m.FeeBlinding)
		copy(dAtA[i:], m.FeeBlinding)
		i = encodeVarintDex(dAtA, i, uint64(len(m.FeeBlinding)))
		i--
		dAtA[i] = 0x12
	}
	if m.SwapPlaintext != nil {
		{
			size, err := m.SwapPlaintext.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwapClaimPlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapClaimPlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapClaimPlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EpochDuration != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.EpochDuration))
		i--
		dAtA[i] = 0x20
	}
	if m.OutputData != nil {
		{
			size, err := m.OutputData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Position != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.Position))
		i--
		dAtA[i] = 0x10
	}
	if m.SwapPlaintext != nil {
		{
			size, err := m.SwapPlaintext.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwapView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapView) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SwapView != nil {
		{
			size := m.SwapView.Size()
			i -= size
			if _, err := m.SwapView.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *SwapView_Visible_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapView_Visible_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Visible != nil {
		{
			size, err := m.Visible.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *SwapView_Opaque_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapView_Opaque_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Opaque != nil {
		{
			size, err := m.Opaque.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *SwapView_Visible) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapView_Visible) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapView_Visible) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SwapPlaintext != nil {
		{
			size, err := m.SwapPlaintext.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Swap != nil {
		{
			size, err := m.Swap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwapView_Opaque) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapView_Opaque) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapView_Opaque) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Swap != nil {
		{
			size, err := m.Swap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwapClaimView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapClaimView) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapClaimView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SwapClaimView != nil {
		{
			size := m.SwapClaimView.Size()
			i -= size
			if _, err := m.SwapClaimView.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *SwapClaimView_Visible_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapClaimView_Visible_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Visible != nil {
		{
			size, err := m.Visible.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *SwapClaimView_Opaque_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapClaimView_Opaque_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Opaque != nil {
		{
			size, err := m.Opaque.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *SwapClaimView_Visible) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapClaimView_Visible) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapClaimView_Visible) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Output_2 != nil {
		{
			size, err := m.Output_2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Output_1 != nil {
		{
			size, err := m.Output_1.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SwapClaim != nil {
		{
			size, err := m.SwapClaim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwapClaimView_Opaque) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapClaimView_Opaque) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapClaimView_Opaque) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SwapClaim != nil {
		{
			size, err := m.SwapClaim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TradingPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TradingPair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TradingPair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Asset_2 != nil {
		{
			size, err := m.Asset_2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Asset_1 != nil {
		{
			size, err := m.Asset_1.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DirectedTradingPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DirectedTradingPair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DirectedTradingPair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.End != nil {
		{
			size, err := m.End.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Start != nil {
		{
			size, err := m.Start.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BatchSwapOutputData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchSwapOutputData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchSwapOutputData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TradingPair != nil {
		{
			size, err := m.TradingPair.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Height != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x38
	}
	if m.Lambda_2_2 != nil {
		{
			size, err := m.Lambda_2_2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Lambda_1_2 != nil {
		{
			size, err := m.Lambda_1_2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Lambda_2_1 != nil {
		{
			size, err := m.Lambda_2_1.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Lambda_1_1 != nil {
		{
			size, err := m.Lambda_1_1.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Delta_2 != nil {
		{
			size, err := m.Delta_2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Delta_1 != nil {
		{
			size, err := m.Delta_1.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TradingFunction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TradingFunction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TradingFunction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pair != nil {
		{
			size, err := m.Pair.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Component != nil {
		{
			size, err := m.Component.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BareTradingFunction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BareTradingFunction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BareTradingFunction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Q != nil {
		{
			size, err := m.Q.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.P != nil {
		{
			size, err := m.P.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Fee != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.Fee))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Reserves) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Reserves) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Reserves) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.R2 != nil {
		{
			size, err := m.R2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.R1 != nil {
		{
			size, err := m.R1.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Position) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Position) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Position) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Reserves != nil {
		{
			size, err := m.Reserves.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.State != nil {
		{
			size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintDex(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0x12
	}
	if m.Phi != nil {
		{
			size, err := m.Phi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PositionId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PositionId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PositionId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Inner) > 0 {
		i -= len(m.Inner)
		copy(dAtA[i:], m.Inner)
		i = encodeVarintDex(dAtA, i, uint64(len(m.Inner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PositionState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PositionState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PositionState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LpNft) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LpNft) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LpNft) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != nil {
		{
			size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.PositionId != nil {
		{
			size, err := m.PositionId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PositionOpen) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PositionOpen) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PositionOpen) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Position != nil {
		{
			size, err := m.Position.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PositionClose) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PositionClose) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PositionClose) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PositionId != nil {
		{
			size, err := m.PositionId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PositionWithdraw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PositionWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PositionWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReservesCommitment != nil {
		{
			size, err := m.ReservesCommitment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.PositionId != nil {
		{
			size, err := m.PositionId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PositionRewardClaim) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PositionRewardClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PositionRewardClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RewardsCommitment != nil {
		{
			size, err := m.RewardsCommitment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.PositionId != nil {
		{
			size, err := m.PositionId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Path) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Path) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Path) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Phi != nil {
		{
			size, err := m.Phi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Route) > 0 {
		for iNdEx := len(m.Route) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Route[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDex(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Pair != nil {
		{
			size, err := m.Pair.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Trade) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Trade) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Trade) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EndAmount != nil {
		{
			size, err := m.EndAmount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.StartAmount != nil {
		{
			size, err := m.StartAmount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Path != nil {
		{
			size, err := m.Path.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwapExecution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapExecution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapExecution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Trades) > 0 {
		for iNdEx := len(m.Trades) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Trades[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDex(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PositionWithdrawPlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PositionWithdrawPlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PositionWithdrawPlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pair != nil {
		{
			size, err := m.Pair.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PositionId != nil {
		{
			size, err := m.PositionId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Reserves != nil {
		{
			size, err := m.Reserves.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PositionRewardClaimPlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PositionRewardClaimPlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PositionRewardClaimPlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Reserves != nil {
		{
			size, err := m.Reserves.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintDex(dAtA []byte, offset int, v uint64) int {
	offset -= sovDex(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Swap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Proof != nil {
		l = m.Proof.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Body != nil {
		l = m.Body.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SwapClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Proof)
	if l > 0 {
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Body != nil {
		l = m.Body.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.EpochDuration != 0 {
		n += 1 + sovDex(uint64(m.EpochDuration))
	}
	return n
}

func (m *SwapClaimBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nullifier != nil {
		l = m.Nullifier.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Fee != nil {
		l = m.Fee.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Output_1Commitment != nil {
		l = m.Output_1Commitment.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Output_2Commitment != nil {
		l = m.Output_2Commitment.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.OutputData != nil {
		l = m.OutputData.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SwapBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TradingPair != nil {
		l = m.TradingPair.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Delta_1I != nil {
		l = m.Delta_1I.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Delta_2I != nil {
		l = m.Delta_2I.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.FeeCommitment != nil {
		l = m.FeeCommitment.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SwapPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commitment != nil {
		l = m.Commitment.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	l = len(m.EncryptedSwap)
	if l > 0 {
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SwapPlaintext) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TradingPair != nil {
		l = m.TradingPair.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Delta_1I != nil {
		l = m.Delta_1I.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Delta_2I != nil {
		l = m.Delta_2I.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.ClaimFee != nil {
		l = m.ClaimFee.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.ClaimAddress != nil {
		l = m.ClaimAddress.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	l = len(m.Rseed)
	if l > 0 {
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *MockFlowCiphertext) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SwapPlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SwapPlaintext != nil {
		l = m.SwapPlaintext.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	l = len(m.FeeBlinding)
	if l > 0 {
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SwapClaimPlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SwapPlaintext != nil {
		l = m.SwapPlaintext.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Position != 0 {
		n += 1 + sovDex(uint64(m.Position))
	}
	if m.OutputData != nil {
		l = m.OutputData.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.EpochDuration != 0 {
		n += 1 + sovDex(uint64(m.EpochDuration))
	}
	return n
}

func (m *SwapView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SwapView != nil {
		n += m.SwapView.Size()
	}
	return n
}

func (m *SwapView_Visible_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Visible != nil {
		l = m.Visible.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}
func (m *SwapView_Opaque_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Opaque != nil {
		l = m.Opaque.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}
func (m *SwapView_Visible) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Swap != nil {
		l = m.Swap.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.SwapPlaintext != nil {
		l = m.SwapPlaintext.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SwapView_Opaque) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Swap != nil {
		l = m.Swap.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SwapClaimView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SwapClaimView != nil {
		n += m.SwapClaimView.Size()
	}
	return n
}

func (m *SwapClaimView_Visible_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Visible != nil {
		l = m.Visible.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}
func (m *SwapClaimView_Opaque_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Opaque != nil {
		l = m.Opaque.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}
func (m *SwapClaimView_Visible) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SwapClaim != nil {
		l = m.SwapClaim.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Output_1 != nil {
		l = m.Output_1.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Output_2 != nil {
		l = m.Output_2.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SwapClaimView_Opaque) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SwapClaim != nil {
		l = m.SwapClaim.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *TradingPair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Asset_1 != nil {
		l = m.Asset_1.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Asset_2 != nil {
		l = m.Asset_2.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *DirectedTradingPair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != nil {
		l = m.Start.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.End != nil {
		l = m.End.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *BatchSwapOutputData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Delta_1 != nil {
		l = m.Delta_1.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Delta_2 != nil {
		l = m.Delta_2.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Lambda_1_1 != nil {
		l = m.Lambda_1_1.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Lambda_2_1 != nil {
		l = m.Lambda_2_1.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Lambda_1_2 != nil {
		l = m.Lambda_1_2.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Lambda_2_2 != nil {
		l = m.Lambda_2_2.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovDex(uint64(m.Height))
	}
	if m.TradingPair != nil {
		l = m.TradingPair.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *TradingFunction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Component != nil {
		l = m.Component.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Pair != nil {
		l = m.Pair.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *BareTradingFunction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Fee != 0 {
		n += 1 + sovDex(uint64(m.Fee))
	}
	if m.P != nil {
		l = m.P.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Q != nil {
		l = m.Q.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *Reserves) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.R1 != nil {
		l = m.R1.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.R2 != nil {
		l = m.R2.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *Position) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Phi != nil {
		l = m.Phi.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovDex(uint64(l))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Reserves != nil {
		l = m.Reserves.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *PositionId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Inner)
	if l > 0 {
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *PositionState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovDex(uint64(m.State))
	}
	return n
}

func (m *LpNft) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionId != nil {
		l = m.PositionId.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *PositionOpen) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Position != nil {
		l = m.Position.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *PositionClose) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionId != nil {
		l = m.PositionId.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *PositionWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionId != nil {
		l = m.PositionId.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.ReservesCommitment != nil {
		l = m.ReservesCommitment.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *PositionRewardClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionId != nil {
		l = m.PositionId.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.RewardsCommitment != nil {
		l = m.RewardsCommitment.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *Path) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pair != nil {
		l = m.Pair.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if len(m.Route) > 0 {
		for _, e := range m.Route {
			l = e.Size()
			n += 1 + l + sovDex(uint64(l))
		}
	}
	if m.Phi != nil {
		l = m.Phi.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *Trade) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Path != nil {
		l = m.Path.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.StartAmount != nil {
		l = m.StartAmount.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.EndAmount != nil {
		l = m.EndAmount.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SwapExecution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Trades) > 0 {
		for _, e := range m.Trades {
			l = e.Size()
			n += 1 + l + sovDex(uint64(l))
		}
	}
	return n
}

func (m *PositionWithdrawPlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Reserves != nil {
		l = m.Reserves.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.PositionId != nil {
		l = m.PositionId.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Pair != nil {
		l = m.Pair.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *PositionRewardClaimPlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Reserves != nil {
		l = m.Reserves.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func sovDex(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDex(x uint64) (n int) {
	return sovDex(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Swap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Swap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Swap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proof == nil {
				m.Proof = &v1alpha1.ZKSwapProof{}
			}
			if err := m.Proof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Body == nil {
				m.Body = &SwapBody{}
			}
			if err := m.Body.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapClaim) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapClaim: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapClaim: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proof = append(m.Proof[:0], dAtA[iNdEx:postIndex]...)
			if m.Proof == nil {
				m.Proof = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Body == nil {
				m.Body = &SwapClaimBody{}
			}
			if err := m.Body.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochDuration", wireType)
			}
			m.EpochDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochDuration |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapClaimBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapClaimBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapClaimBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nullifier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Nullifier == nil {
				m.Nullifier = &v1alpha1.Nullifier{}
			}
			if err := m.Nullifier.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fee == nil {
				m.Fee = &v1alpha1.Fee{}
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output_1Commitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output_1Commitment == nil {
				m.Output_1Commitment = &v1alpha1.StateCommitment{}
			}
			if err := m.Output_1Commitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output_2Commitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output_2Commitment == nil {
				m.Output_2Commitment = &v1alpha1.StateCommitment{}
			}
			if err := m.Output_2Commitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutputData == nil {
				m.OutputData = &BatchSwapOutputData{}
			}
			if err := m.OutputData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradingPair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TradingPair == nil {
				m.TradingPair = &TradingPair{}
			}
			if err := m.TradingPair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delta_1I", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Delta_1I == nil {
				m.Delta_1I = &v1alpha1.Amount{}
			}
			if err := m.Delta_1I.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delta_2I", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Delta_2I == nil {
				m.Delta_2I = &v1alpha1.Amount{}
			}
			if err := m.Delta_2I.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeCommitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FeeCommitment == nil {
				m.FeeCommitment = &v1alpha1.BalanceCommitment{}
			}
			if err := m.FeeCommitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &SwapPayload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapPayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commitment == nil {
				m.Commitment = &v1alpha1.StateCommitment{}
			}
			if err := m.Commitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedSwap", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedSwap = append(m.EncryptedSwap[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedSwap == nil {
				m.EncryptedSwap = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapPlaintext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapPlaintext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapPlaintext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradingPair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TradingPair == nil {
				m.TradingPair = &TradingPair{}
			}
			if err := m.TradingPair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delta_1I", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Delta_1I == nil {
				m.Delta_1I = &v1alpha1.Amount{}
			}
			if err := m.Delta_1I.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delta_2I", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Delta_2I == nil {
				m.Delta_2I = &v1alpha1.Amount{}
			}
			if err := m.Delta_2I.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimFee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClaimFee == nil {
				m.ClaimFee = &v1alpha1.Fee{}
			}
			if err := m.ClaimFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClaimAddress == nil {
				m.ClaimAddress = &v1alpha1.Address{}
			}
			if err := m.ClaimAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rseed", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rseed = append(m.Rseed[:0], dAtA[iNdEx:postIndex]...)
			if m.Rseed == nil {
				m.Rseed = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MockFlowCiphertext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MockFlowCiphertext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MockFlowCiphertext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &v1alpha1.Amount{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapPlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapPlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapPlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapPlaintext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SwapPlaintext == nil {
				m.SwapPlaintext = &SwapPlaintext{}
			}
			if err := m.SwapPlaintext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeBlinding", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeBlinding = append(m.FeeBlinding[:0], dAtA[iNdEx:postIndex]...)
			if m.FeeBlinding == nil {
				m.FeeBlinding = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapClaimPlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapClaimPlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapClaimPlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapPlaintext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SwapPlaintext == nil {
				m.SwapPlaintext = &SwapPlaintext{}
			}
			if err := m.SwapPlaintext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			m.Position = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Position |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutputData == nil {
				m.OutputData = &BatchSwapOutputData{}
			}
			if err := m.OutputData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochDuration", wireType)
			}
			m.EpochDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochDuration |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visible", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SwapView_Visible{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SwapView = &SwapView_Visible_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opaque", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SwapView_Opaque{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SwapView = &SwapView_Opaque_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapView_Visible) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Visible: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Visible: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Swap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Swap == nil {
				m.Swap = &Swap{}
			}
			if err := m.Swap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapPlaintext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SwapPlaintext == nil {
				m.SwapPlaintext = &SwapPlaintext{}
			}
			if err := m.SwapPlaintext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapView_Opaque) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Opaque: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Opaque: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Swap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Swap == nil {
				m.Swap = &Swap{}
			}
			if err := m.Swap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapClaimView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapClaimView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapClaimView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visible", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SwapClaimView_Visible{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SwapClaimView = &SwapClaimView_Visible_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opaque", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SwapClaimView_Opaque{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SwapClaimView = &SwapClaimView_Opaque_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapClaimView_Visible) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Visible: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Visible: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SwapClaim == nil {
				m.SwapClaim = &SwapClaim{}
			}
			if err := m.SwapClaim.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output_1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output_1 == nil {
				m.Output_1 = &v1alpha1.NoteView{}
			}
			if err := m.Output_1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output_2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output_2 == nil {
				m.Output_2 = &v1alpha1.NoteView{}
			}
			if err := m.Output_2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapClaimView_Opaque) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Opaque: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Opaque: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SwapClaim == nil {
				m.SwapClaim = &SwapClaim{}
			}
			if err := m.SwapClaim.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TradingPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TradingPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TradingPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset_1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Asset_1 == nil {
				m.Asset_1 = &v1alpha1.AssetId{}
			}
			if err := m.Asset_1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset_2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Asset_2 == nil {
				m.Asset_2 = &v1alpha1.AssetId{}
			}
			if err := m.Asset_2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DirectedTradingPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DirectedTradingPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DirectedTradingPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Start == nil {
				m.Start = &v1alpha1.AssetId{}
			}
			if err := m.Start.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.End == nil {
				m.End = &v1alpha1.AssetId{}
			}
			if err := m.End.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchSwapOutputData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchSwapOutputData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchSwapOutputData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delta_1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Delta_1 == nil {
				m.Delta_1 = &v1alpha1.Amount{}
			}
			if err := m.Delta_1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delta_2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Delta_2 == nil {
				m.Delta_2 = &v1alpha1.Amount{}
			}
			if err := m.Delta_2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lambda_1_1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lambda_1_1 == nil {
				m.Lambda_1_1 = &v1alpha1.Amount{}
			}
			if err := m.Lambda_1_1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lambda_2_1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lambda_2_1 == nil {
				m.Lambda_2_1 = &v1alpha1.Amount{}
			}
			if err := m.Lambda_2_1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lambda_1_2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lambda_1_2 == nil {
				m.Lambda_1_2 = &v1alpha1.Amount{}
			}
			if err := m.Lambda_1_2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lambda_2_2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lambda_2_2 == nil {
				m.Lambda_2_2 = &v1alpha1.Amount{}
			}
			if err := m.Lambda_2_2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradingPair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TradingPair == nil {
				m.TradingPair = &TradingPair{}
			}
			if err := m.TradingPair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TradingFunction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TradingFunction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TradingFunction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Component", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Component == nil {
				m.Component = &BareTradingFunction{}
			}
			if err := m.Component.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pair == nil {
				m.Pair = &TradingPair{}
			}
			if err := m.Pair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BareTradingFunction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BareTradingFunction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BareTradingFunction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			m.Fee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fee |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field P", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.P == nil {
				m.P = &v1alpha1.Amount{}
			}
			if err := m.P.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Q", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Q == nil {
				m.Q = &v1alpha1.Amount{}
			}
			if err := m.Q.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Reserves) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reserves: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reserves: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field R1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.R1 == nil {
				m.R1 = &v1alpha1.Amount{}
			}
			if err := m.R1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field R2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.R2 == nil {
				m.R2 = &v1alpha1.Amount{}
			}
			if err := m.R2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Position) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Position: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Position: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Phi == nil {
				m.Phi = &TradingFunction{}
			}
			if err := m.Phi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = append(m.Nonce[:0], dAtA[iNdEx:postIndex]...)
			if m.Nonce == nil {
				m.Nonce = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &PositionState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserves", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Reserves == nil {
				m.Reserves = &Reserves{}
			}
			if err := m.Reserves.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PositionId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PositionId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PositionId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inner = append(m.Inner[:0], dAtA[iNdEx:postIndex]...)
			if m.Inner == nil {
				m.Inner = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PositionState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PositionState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PositionState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= PositionState_PositionStateEnum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LpNft) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LpNft: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LpNft: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PositionId == nil {
				m.PositionId = &PositionId{}
			}
			if err := m.PositionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &PositionState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PositionOpen) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PositionOpen: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PositionOpen: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Position == nil {
				m.Position = &Position{}
			}
			if err := m.Position.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PositionClose) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PositionClose: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PositionClose: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PositionId == nil {
				m.PositionId = &PositionId{}
			}
			if err := m.PositionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PositionWithdraw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PositionWithdraw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PositionWithdraw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PositionId == nil {
				m.PositionId = &PositionId{}
			}
			if err := m.PositionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReservesCommitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReservesCommitment == nil {
				m.ReservesCommitment = &v1alpha1.BalanceCommitment{}
			}
			if err := m.ReservesCommitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PositionRewardClaim) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PositionRewardClaim: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PositionRewardClaim: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PositionId == nil {
				m.PositionId = &PositionId{}
			}
			if err := m.PositionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardsCommitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RewardsCommitment == nil {
				m.RewardsCommitment = &v1alpha1.BalanceCommitment{}
			}
			if err := m.RewardsCommitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Path) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Path: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Path: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pair == nil {
				m.Pair = &DirectedTradingPair{}
			}
			if err := m.Pair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Route = append(m.Route, &v1alpha1.AssetId{})
			if err := m.Route[len(m.Route)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Phi == nil {
				m.Phi = &BareTradingFunction{}
			}
			if err := m.Phi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Trade) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Trade: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Trade: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Path == nil {
				m.Path = &Path{}
			}
			if err := m.Path.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartAmount == nil {
				m.StartAmount = &v1alpha1.Amount{}
			}
			if err := m.StartAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndAmount == nil {
				m.EndAmount = &v1alpha1.Amount{}
			}
			if err := m.EndAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapExecution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapExecution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapExecution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trades", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Trades = append(m.Trades, &Trade{})
			if err := m.Trades[len(m.Trades)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PositionWithdrawPlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PositionWithdrawPlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PositionWithdrawPlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserves", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Reserves == nil {
				m.Reserves = &Reserves{}
			}
			if err := m.Reserves.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PositionId == nil {
				m.PositionId = &PositionId{}
			}
			if err := m.PositionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pair == nil {
				m.Pair = &TradingPair{}
			}
			if err := m.Pair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PositionRewardClaimPlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PositionRewardClaimPlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PositionRewardClaimPlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserves", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Reserves == nil {
				m.Reserves = &Reserves{}
			}
			if err := m.Reserves.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDex(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDex
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDex
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDex
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDex
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDex
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDex
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDex        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDex          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDex = fmt.Errorf("proto: unexpected end of group")
)
