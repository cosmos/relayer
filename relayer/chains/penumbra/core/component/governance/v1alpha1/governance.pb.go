// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: penumbra/core/component/governance/v1alpha1/governance.proto

package governancev1alpha1

import (
	context "context"
	fmt "fmt"
	types "github.com/cosmos/cosmos-sdk/codec/types"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	v1alpha13 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/asset/v1alpha1"
	v1alpha15 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/component/chain/v1alpha1"
	v1alpha14 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/component/shielded_pool/v1alpha1"
	v1alpha16 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/component/stake/v1alpha1"
	v1alpha12 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/keys/v1alpha1"
	v1alpha1 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/num/v1alpha1"
	v1alpha11 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/crypto/decaf377_rdsa/v1alpha1"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// A vote.
type Vote_Vote int32

const (
	Vote_VOTE_UNSPECIFIED Vote_Vote = 0
	Vote_VOTE_ABSTAIN     Vote_Vote = 1
	Vote_VOTE_YES         Vote_Vote = 2
	Vote_VOTE_NO          Vote_Vote = 3
)

var Vote_Vote_name = map[int32]string{
	0: "VOTE_UNSPECIFIED",
	1: "VOTE_ABSTAIN",
	2: "VOTE_YES",
	3: "VOTE_NO",
}

var Vote_Vote_value = map[string]int32{
	"VOTE_UNSPECIFIED": 0,
	"VOTE_ABSTAIN":     1,
	"VOTE_YES":         2,
	"VOTE_NO":          3,
}

func (x Vote_Vote) String() string {
	return proto.EnumName(Vote_Vote_name, int32(x))
}

func (Vote_Vote) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_67f269dcda22019a, []int{14, 0}
}

// A Penumbra ZK delegator vote proof.
type ZKDelegatorVoteProof struct {
	Inner []byte `protobuf:"bytes,1,opt,name=inner,proto3" json:"inner,omitempty"`
}

func (m *ZKDelegatorVoteProof) Reset()         { *m = ZKDelegatorVoteProof{} }
func (m *ZKDelegatorVoteProof) String() string { return proto.CompactTextString(m) }
func (*ZKDelegatorVoteProof) ProtoMessage()    {}
func (*ZKDelegatorVoteProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_67f269dcda22019a, []int{0}
}
func (m *ZKDelegatorVoteProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZKDelegatorVoteProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZKDelegatorVoteProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZKDelegatorVoteProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZKDelegatorVoteProof.Merge(m, src)
}
func (m *ZKDelegatorVoteProof) XXX_Size() int {
	return m.Size()
}
func (m *ZKDelegatorVoteProof) XXX_DiscardUnknown() {
	xxx_messageInfo_ZKDelegatorVoteProof.DiscardUnknown(m)
}

var xxx_messageInfo_ZKDelegatorVoteProof proto.InternalMessageInfo

func (m *ZKDelegatorVoteProof) GetInner() []byte {
	if m != nil {
		return m.Inner
	}
	return nil
}

type ProposalSubmit struct {
	// The proposal to be submitted.
	Proposal *Proposal `protobuf:"bytes,1,opt,name=proposal,proto3" json:"proposal,omitempty"`
	// The amount of the proposal deposit.
	DepositAmount *v1alpha1.Amount `protobuf:"bytes,3,opt,name=deposit_amount,json=depositAmount,proto3" json:"deposit_amount,omitempty"`
}

func (m *ProposalSubmit) Reset()         { *m = ProposalSubmit{} }
func (m *ProposalSubmit) String() string { return proto.CompactTextString(m) }
func (*ProposalSubmit) ProtoMessage()    {}
func (*ProposalSubmit) Descriptor() ([]byte, []int) {
	return fileDescriptor_67f269dcda22019a, []int{1}
}
func (m *ProposalSubmit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProposalSubmit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProposalSubmit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProposalSubmit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProposalSubmit.Merge(m, src)
}
func (m *ProposalSubmit) XXX_Size() int {
	return m.Size()
}
func (m *ProposalSubmit) XXX_DiscardUnknown() {
	xxx_messageInfo_ProposalSubmit.DiscardUnknown(m)
}

var xxx_messageInfo_ProposalSubmit proto.InternalMessageInfo

func (m *ProposalSubmit) GetProposal() *Proposal {
	if m != nil {
		return m.Proposal
	}
	return nil
}

func (m *ProposalSubmit) GetDepositAmount() *v1alpha1.Amount {
	if m != nil {
		return m.DepositAmount
	}
	return nil
}

type ProposalWithdraw struct {
	// The proposal to be withdrawn.
	Proposal uint64 `protobuf:"varint,1,opt,name=proposal,proto3" json:"proposal,omitempty"`
	// The reason for the proposal being withdrawn.
	Reason string `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *ProposalWithdraw) Reset()         { *m = ProposalWithdraw{} }
func (m *ProposalWithdraw) String() string { return proto.CompactTextString(m) }
func (*ProposalWithdraw) ProtoMessage()    {}
func (*ProposalWithdraw) Descriptor() ([]byte, []int) {
	return fileDescriptor_67f269dcda22019a, []int{2}
}
func (m *ProposalWithdraw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProposalWithdraw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProposalWithdraw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProposalWithdraw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProposalWithdraw.Merge(m, src)
}
func (m *ProposalWithdraw) XXX_Size() int {
	return m.Size()
}
func (m *ProposalWithdraw) XXX_DiscardUnknown() {
	xxx_messageInfo_ProposalWithdraw.DiscardUnknown(m)
}

var xxx_messageInfo_ProposalWithdraw proto.InternalMessageInfo

func (m *ProposalWithdraw) GetProposal() uint64 {
	if m != nil {
		return m.Proposal
	}
	return 0
}

func (m *ProposalWithdraw) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

type ProposalDepositClaim struct {
	// The proposal to claim the deposit for.
	Proposal uint64 `protobuf:"varint,1,opt,name=proposal,proto3" json:"proposal,omitempty"`
	// The expected deposit amount.
	DepositAmount *v1alpha1.Amount `protobuf:"bytes,2,opt,name=deposit_amount,json=depositAmount,proto3" json:"deposit_amount,omitempty"`
	// The outcome of the proposal.
	Outcome *ProposalOutcome `protobuf:"bytes,3,opt,name=outcome,proto3" json:"outcome,omitempty"`
}

func (m *ProposalDepositClaim) Reset()         { *m = ProposalDepositClaim{} }
func (m *ProposalDepositClaim) String() string { return proto.CompactTextString(m) }
func (*ProposalDepositClaim) ProtoMessage()    {}
func (*ProposalDepositClaim) Descriptor() ([]byte, []int) {
	return fileDescriptor_67f269dcda22019a, []int{3}
}
func (m *ProposalDepositClaim) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProposalDepositClaim) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProposalDepositClaim.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProposalDepositClaim) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProposalDepositClaim.Merge(m, src)
}
func (m *ProposalDepositClaim) XXX_Size() int {
	return m.Size()
}
func (m *ProposalDepositClaim) XXX_DiscardUnknown() {
	xxx_messageInfo_ProposalDepositClaim.DiscardUnknown(m)
}

var xxx_messageInfo_ProposalDepositClaim proto.InternalMessageInfo

func (m *ProposalDepositClaim) GetProposal() uint64 {
	if m != nil {
		return m.Proposal
	}
	return 0
}

func (m *ProposalDepositClaim) GetDepositAmount() *v1alpha1.Amount {
	if m != nil {
		return m.DepositAmount
	}
	return nil
}

func (m *ProposalDepositClaim) GetOutcome() *ProposalOutcome {
	if m != nil {
		return m.Outcome
	}
	return nil
}

type ValidatorVote struct {
	// The effecting data for the vote.
	Body *ValidatorVoteBody `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// The vote authorization signature is authorizing data.
	AuthSig *v1alpha11.SpendAuthSignature `protobuf:"bytes,2,opt,name=auth_sig,json=authSig,proto3" json:"auth_sig,omitempty"`
}

func (m *ValidatorVote) Reset()         { *m = ValidatorVote{} }
func (m *ValidatorVote) String() string { return proto.CompactTextString(m) }
func (*ValidatorVote) ProtoMessage()    {}
func (*ValidatorVote) Descriptor() ([]byte, []int) {
	return fileDescriptor_67f269dcda22019a, []int{4}
}
func (m *ValidatorVote) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorVote) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorVote.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorVote) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorVote.Merge(m, src)
}
func (m *ValidatorVote) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorVote) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorVote.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorVote proto.InternalMessageInfo

func (m *ValidatorVote) GetBody() *ValidatorVoteBody {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *ValidatorVote) GetAuthSig() *v1alpha11.SpendAuthSignature {
	if m != nil {
		return m.AuthSig
	}
	return nil
}

type ValidatorVoteReason struct {
	Reason string `protobuf:"bytes,1,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *ValidatorVoteReason) Reset()         { *m = ValidatorVoteReason{} }
func (m *ValidatorVoteReason) String() string { return proto.CompactTextString(m) }
func (*ValidatorVoteReason) ProtoMessage()    {}
func (*ValidatorVoteReason) Descriptor() ([]byte, []int) {
	return fileDescriptor_67f269dcda22019a, []int{5}
}
func (m *ValidatorVoteReason) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorVoteReason) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorVoteReason.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorVoteReason) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorVoteReason.Merge(m, src)
}
func (m *ValidatorVoteReason) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorVoteReason) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorVoteReason.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorVoteReason proto.InternalMessageInfo

func (m *ValidatorVoteReason) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

type ValidatorVoteBody struct {
	// The proposal being voted on.
	Proposal uint64 `protobuf:"varint,1,opt,name=proposal,proto3" json:"proposal,omitempty"`
	// The vote.
	Vote *Vote `protobuf:"bytes,2,opt,name=vote,proto3" json:"vote,omitempty"`
	// The validator identity.
	IdentityKey *v1alpha12.IdentityKey `protobuf:"bytes,3,opt,name=identity_key,json=identityKey,proto3" json:"identity_key,omitempty"`
	// The validator governance key.
	GovernanceKey *v1alpha12.GovernanceKey `protobuf:"bytes,4,opt,name=governance_key,json=governanceKey,proto3" json:"governance_key,omitempty"`
	// A justification of the vote.
	Reason *ValidatorVoteReason `protobuf:"bytes,5,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *ValidatorVoteBody) Reset()         { *m = ValidatorVoteBody{} }
func (m *ValidatorVoteBody) String() string { return proto.CompactTextString(m) }
func (*ValidatorVoteBody) ProtoMessage()    {}
func (*ValidatorVoteBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_67f269dcda22019a, []int{6}
}
func (m *ValidatorVoteBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorVoteBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorVoteBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorVoteBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorVoteBody.Merge(m, src)
}
func (m *ValidatorVoteBody) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorVoteBody) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorVoteBody.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorVoteBody proto.InternalMessageInfo

func (m *ValidatorVoteBody) GetProposal() uint64 {
	if m != nil {
		return m.Proposal
	}
	return 0
}

func (m *ValidatorVoteBody) GetVote() *Vote {
	if m != nil {
		return m.Vote
	}
	return nil
}

func (m *ValidatorVoteBody) GetIdentityKey() *v1alpha12.IdentityKey {
	if m != nil {
		return m.IdentityKey
	}
	return nil
}

func (m *ValidatorVoteBody) GetGovernanceKey() *v1alpha12.GovernanceKey {
	if m != nil {
		return m.GovernanceKey
	}
	return nil
}

func (m *ValidatorVoteBody) GetReason() *ValidatorVoteReason {
	if m != nil {
		return m.Reason
	}
	return nil
}

type DelegatorVote struct {
	// The effecting data for the vote.
	Body *DelegatorVoteBody `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// The vote authorization signature is authorizing data.
	AuthSig *v1alpha11.SpendAuthSignature `protobuf:"bytes,2,opt,name=auth_sig,json=authSig,proto3" json:"auth_sig,omitempty"`
	// The vote proof is authorizing data.
	Proof *ZKDelegatorVoteProof `protobuf:"bytes,3,opt,name=proof,proto3" json:"proof,omitempty"`
}

func (m *DelegatorVote) Reset()         { *m = DelegatorVote{} }
func (m *DelegatorVote) String() string { return proto.CompactTextString(m) }
func (*DelegatorVote) ProtoMessage()    {}
func (*DelegatorVote) Descriptor() ([]byte, []int) {
	return fileDescriptor_67f269dcda22019a, []int{7}
}
func (m *DelegatorVote) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelegatorVote) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelegatorVote.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelegatorVote) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelegatorVote.Merge(m, src)
}
func (m *DelegatorVote) XXX_Size() int {
	return m.Size()
}
func (m *DelegatorVote) XXX_DiscardUnknown() {
	xxx_messageInfo_DelegatorVote.DiscardUnknown(m)
}

var xxx_messageInfo_DelegatorVote proto.InternalMessageInfo

func (m *DelegatorVote) GetBody() *DelegatorVoteBody {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *DelegatorVote) GetAuthSig() *v1alpha11.SpendAuthSignature {
	if m != nil {
		return m.AuthSig
	}
	return nil
}

func (m *DelegatorVote) GetProof() *ZKDelegatorVoteProof {
	if m != nil {
		return m.Proof
	}
	return nil
}

type DelegatorVoteBody struct {
	// The proposal being voted on.
	Proposal uint64 `protobuf:"varint,1,opt,name=proposal,proto3" json:"proposal,omitempty"`
	// The start position of the proposal in the TCT.
	StartPosition uint64 `protobuf:"varint,2,opt,name=start_position,json=startPosition,proto3" json:"start_position,omitempty"`
	// The vote.
	Vote *Vote `protobuf:"bytes,3,opt,name=vote,proto3" json:"vote,omitempty"`
	// The value of the delegation note.
	Value *v1alpha13.Value `protobuf:"bytes,4,opt,name=value,proto3" json:"value,omitempty"`
	// The amount of the delegation note, in unbonded penumbra.
	UnbondedAmount *v1alpha1.Amount `protobuf:"bytes,5,opt,name=unbonded_amount,json=unbondedAmount,proto3" json:"unbonded_amount,omitempty"`
	// The nullifier of the input note.
	Nullifier []byte `protobuf:"bytes,6,opt,name=nullifier,proto3" json:"nullifier,omitempty"`
	// The randomized validating key for the spend authorization signature.
	Rk []byte `protobuf:"bytes,7,opt,name=rk,proto3" json:"rk,omitempty"`
}

func (m *DelegatorVoteBody) Reset()         { *m = DelegatorVoteBody{} }
func (m *DelegatorVoteBody) String() string { return proto.CompactTextString(m) }
func (*DelegatorVoteBody) ProtoMessage()    {}
func (*DelegatorVoteBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_67f269dcda22019a, []int{8}
}
func (m *DelegatorVoteBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelegatorVoteBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelegatorVoteBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelegatorVoteBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelegatorVoteBody.Merge(m, src)
}
func (m *DelegatorVoteBody) XXX_Size() int {
	return m.Size()
}
func (m *DelegatorVoteBody) XXX_DiscardUnknown() {
	xxx_messageInfo_DelegatorVoteBody.DiscardUnknown(m)
}

var xxx_messageInfo_DelegatorVoteBody proto.InternalMessageInfo

func (m *DelegatorVoteBody) GetProposal() uint64 {
	if m != nil {
		return m.Proposal
	}
	return 0
}

func (m *DelegatorVoteBody) GetStartPosition() uint64 {
	if m != nil {
		return m.StartPosition
	}
	return 0
}

func (m *DelegatorVoteBody) GetVote() *Vote {
	if m != nil {
		return m.Vote
	}
	return nil
}

func (m *DelegatorVoteBody) GetValue() *v1alpha13.Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *DelegatorVoteBody) GetUnbondedAmount() *v1alpha1.Amount {
	if m != nil {
		return m.UnbondedAmount
	}
	return nil
}

func (m *DelegatorVoteBody) GetNullifier() []byte {
	if m != nil {
		return m.Nullifier
	}
	return nil
}

func (m *DelegatorVoteBody) GetRk() []byte {
	if m != nil {
		return m.Rk
	}
	return nil
}

type DelegatorVoteView struct {
	// Types that are valid to be assigned to DelegatorVote:
	//	*DelegatorVoteView_Visible_
	//	*DelegatorVoteView_Opaque_
	DelegatorVote isDelegatorVoteView_DelegatorVote `protobuf_oneof:"delegator_vote"`
}

func (m *DelegatorVoteView) Reset()         { *m = DelegatorVoteView{} }
func (m *DelegatorVoteView) String() string { return proto.CompactTextString(m) }
func (*DelegatorVoteView) ProtoMessage()    {}
func (*DelegatorVoteView) Descriptor() ([]byte, []int) {
	return fileDescriptor_67f269dcda22019a, []int{9}
}
func (m *DelegatorVoteView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelegatorVoteView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelegatorVoteView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelegatorVoteView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelegatorVoteView.Merge(m, src)
}
func (m *DelegatorVoteView) XXX_Size() int {
	return m.Size()
}
func (m *DelegatorVoteView) XXX_DiscardUnknown() {
	xxx_messageInfo_DelegatorVoteView.DiscardUnknown(m)
}

var xxx_messageInfo_DelegatorVoteView proto.InternalMessageInfo

type isDelegatorVoteView_DelegatorVote interface {
	isDelegatorVoteView_DelegatorVote()
	MarshalTo([]byte) (int, error)
	Size() int
}

type DelegatorVoteView_Visible_ struct {
	Visible *DelegatorVoteView_Visible `protobuf:"bytes,1,opt,name=visible,proto3,oneof" json:"visible,omitempty"`
}
type DelegatorVoteView_Opaque_ struct {
	Opaque *DelegatorVoteView_Opaque `protobuf:"bytes,2,opt,name=opaque,proto3,oneof" json:"opaque,omitempty"`
}

func (*DelegatorVoteView_Visible_) isDelegatorVoteView_DelegatorVote() {}
func (*DelegatorVoteView_Opaque_) isDelegatorVoteView_DelegatorVote()  {}

func (m *DelegatorVoteView) GetDelegatorVote() isDelegatorVoteView_DelegatorVote {
	if m != nil {
		return m.DelegatorVote
	}
	return nil
}

func (m *DelegatorVoteView) GetVisible() *DelegatorVoteView_Visible {
	if x, ok := m.GetDelegatorVote().(*DelegatorVoteView_Visible_); ok {
		return x.Visible
	}
	return nil
}

func (m *DelegatorVoteView) GetOpaque() *DelegatorVoteView_Opaque {
	if x, ok := m.GetDelegatorVote().(*DelegatorVoteView_Opaque_); ok {
		return x.Opaque
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DelegatorVoteView) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DelegatorVoteView_Visible_)(nil),
		(*DelegatorVoteView_Opaque_)(nil),
	}
}

type DelegatorVoteView_Visible struct {
	DelegatorVote *DelegatorVote      `protobuf:"bytes,1,opt,name=delegator_vote,json=delegatorVote,proto3" json:"delegator_vote,omitempty"`
	Note          *v1alpha14.NoteView `protobuf:"bytes,2,opt,name=note,proto3" json:"note,omitempty"`
}

func (m *DelegatorVoteView_Visible) Reset()         { *m = DelegatorVoteView_Visible{} }
func (m *DelegatorVoteView_Visible) String() string { return proto.CompactTextString(m) }
func (*DelegatorVoteView_Visible) ProtoMessage()    {}
func (*DelegatorVoteView_Visible) Descriptor() ([]byte, []int) {
	return fileDescriptor_67f269dcda22019a, []int{9, 0}
}
func (m *DelegatorVoteView_Visible) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelegatorVoteView_Visible) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelegatorVoteView_Visible.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelegatorVoteView_Visible) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelegatorVoteView_Visible.Merge(m, src)
}
func (m *DelegatorVoteView_Visible) XXX_Size() int {
	return m.Size()
}
func (m *DelegatorVoteView_Visible) XXX_DiscardUnknown() {
	xxx_messageInfo_DelegatorVoteView_Visible.DiscardUnknown(m)
}

var xxx_messageInfo_DelegatorVoteView_Visible proto.InternalMessageInfo

func (m *DelegatorVoteView_Visible) GetDelegatorVote() *DelegatorVote {
	if m != nil {
		return m.DelegatorVote
	}
	return nil
}

func (m *DelegatorVoteView_Visible) GetNote() *v1alpha14.NoteView {
	if m != nil {
		return m.Note
	}
	return nil
}

type DelegatorVoteView_Opaque struct {
	DelegatorVote *DelegatorVote `protobuf:"bytes,1,opt,name=delegator_vote,json=delegatorVote,proto3" json:"delegator_vote,omitempty"`
}

func (m *DelegatorVoteView_Opaque) Reset()         { *m = DelegatorVoteView_Opaque{} }
func (m *DelegatorVoteView_Opaque) String() string { return proto.CompactTextString(m) }
func (*DelegatorVoteView_Opaque) ProtoMessage()    {}
func (*DelegatorVoteView_Opaque) Descriptor() ([]byte, []int) {
	return fileDescriptor_67f269dcda22019a, []int{9, 1}
}
func (m *DelegatorVoteView_Opaque) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelegatorVoteView_Opaque) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelegatorVoteView_Opaque.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelegatorVoteView_Opaque) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelegatorVoteView_Opaque.Merge(m, src)
}
func (m *DelegatorVoteView_Opaque) XXX_Size() int {
	return m.Size()
}
func (m *DelegatorVoteView_Opaque) XXX_DiscardUnknown() {
	xxx_messageInfo_DelegatorVoteView_Opaque.DiscardUnknown(m)
}

var xxx_messageInfo_DelegatorVoteView_Opaque proto.InternalMessageInfo

func (m *DelegatorVoteView_Opaque) GetDelegatorVote() *DelegatorVote {
	if m != nil {
		return m.DelegatorVote
	}
	return nil
}

type DelegatorVotePlan struct {
	// The proposal to vote on.
	Proposal uint64 `protobuf:"varint,1,opt,name=proposal,proto3" json:"proposal,omitempty"`
	// The start position of the proposal in the TCT.
	StartPosition uint64 `protobuf:"varint,2,opt,name=start_position,json=startPosition,proto3" json:"start_position,omitempty"`
	// The vote to cast.
	Vote *Vote `protobuf:"bytes,3,opt,name=vote,proto3" json:"vote,omitempty"`
	// The delegation note to prove that we can vote.
	StakedNote *v1alpha14.Note `protobuf:"bytes,4,opt,name=staked_note,json=stakedNote,proto3" json:"staked_note,omitempty"`
	// The position of that delegation note.
	StakedNotePosition uint64 `protobuf:"varint,5,opt,name=staked_note_position,json=stakedNotePosition,proto3" json:"staked_note_position,omitempty"`
	// The unbonded amount equivalent to the delegation note.
	UnbondedAmount *v1alpha1.Amount `protobuf:"bytes,6,opt,name=unbonded_amount,json=unbondedAmount,proto3" json:"unbonded_amount,omitempty"`
	// The randomizer to use for the proof of spend capability.
	Randomizer []byte `protobuf:"bytes,7,opt,name=randomizer,proto3" json:"randomizer,omitempty"`
	// The first blinding factor to use for the ZK delegator vote proof.
	ProofBlindingR []byte `protobuf:"bytes,8,opt,name=proof_blinding_r,json=proofBlindingR,proto3" json:"proof_blinding_r,omitempty"`
	// The second blinding factor to use for the ZK delegator vote proof.
	ProofBlindingS []byte `protobuf:"bytes,9,opt,name=proof_blinding_s,json=proofBlindingS,proto3" json:"proof_blinding_s,omitempty"`
}

func (m *DelegatorVotePlan) Reset()         { *m = DelegatorVotePlan{} }
func (m *DelegatorVotePlan) String() string { return proto.CompactTextString(m) }
func (*DelegatorVotePlan) ProtoMessage()    {}
func (*DelegatorVotePlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_67f269dcda22019a, []int{10}
}
func (m *DelegatorVotePlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelegatorVotePlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelegatorVotePlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelegatorVotePlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelegatorVotePlan.Merge(m, src)
}
func (m *DelegatorVotePlan) XXX_Size() int {
	return m.Size()
}
func (m *DelegatorVotePlan) XXX_DiscardUnknown() {
	xxx_messageInfo_DelegatorVotePlan.DiscardUnknown(m)
}

var xxx_messageInfo_DelegatorVotePlan proto.InternalMessageInfo

func (m *DelegatorVotePlan) GetProposal() uint64 {
	if m != nil {
		return m.Proposal
	}
	return 0
}

func (m *DelegatorVotePlan) GetStartPosition() uint64 {
	if m != nil {
		return m.StartPosition
	}
	return 0
}

func (m *DelegatorVotePlan) GetVote() *Vote {
	if m != nil {
		return m.Vote
	}
	return nil
}

func (m *DelegatorVotePlan) GetStakedNote() *v1alpha14.Note {
	if m != nil {
		return m.StakedNote
	}
	return nil
}

func (m *DelegatorVotePlan) GetStakedNotePosition() uint64 {
	if m != nil {
		return m.StakedNotePosition
	}
	return 0
}

func (m *DelegatorVotePlan) GetUnbondedAmount() *v1alpha1.Amount {
	if m != nil {
		return m.UnbondedAmount
	}
	return nil
}

func (m *DelegatorVotePlan) GetRandomizer() []byte {
	if m != nil {
		return m.Randomizer
	}
	return nil
}

func (m *DelegatorVotePlan) GetProofBlindingR() []byte {
	if m != nil {
		return m.ProofBlindingR
	}
	return nil
}

func (m *DelegatorVotePlan) GetProofBlindingS() []byte {
	if m != nil {
		return m.ProofBlindingS
	}
	return nil
}

type DaoDeposit struct {
	// The value to deposit into the DAO.
	Value *v1alpha13.Value `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *DaoDeposit) Reset()         { *m = DaoDeposit{} }
func (m *DaoDeposit) String() string { return proto.CompactTextString(m) }
func (*DaoDeposit) ProtoMessage()    {}
func (*DaoDeposit) Descriptor() ([]byte, []int) {
	return fileDescriptor_67f269dcda22019a, []int{11}
}
func (m *DaoDeposit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaoDeposit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DaoDeposit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DaoDeposit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaoDeposit.Merge(m, src)
}
func (m *DaoDeposit) XXX_Size() int {
	return m.Size()
}
func (m *DaoDeposit) XXX_DiscardUnknown() {
	xxx_messageInfo_DaoDeposit.DiscardUnknown(m)
}

var xxx_messageInfo_DaoDeposit proto.InternalMessageInfo

func (m *DaoDeposit) GetValue() *v1alpha13.Value {
	if m != nil {
		return m.Value
	}
	return nil
}

type DaoSpend struct {
	// The value to spend from the DAO.
	Value *v1alpha13.Value `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *DaoSpend) Reset()         { *m = DaoSpend{} }
func (m *DaoSpend) String() string { return proto.CompactTextString(m) }
func (*DaoSpend) ProtoMessage()    {}
func (*DaoSpend) Descriptor() ([]byte, []int) {
	return fileDescriptor_67f269dcda22019a, []int{12}
}
func (m *DaoSpend) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaoSpend) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DaoSpend.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DaoSpend) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaoSpend.Merge(m, src)
}
func (m *DaoSpend) XXX_Size() int {
	return m.Size()
}
func (m *DaoSpend) XXX_DiscardUnknown() {
	xxx_messageInfo_DaoSpend.DiscardUnknown(m)
}

var xxx_messageInfo_DaoSpend proto.InternalMessageInfo

func (m *DaoSpend) GetValue() *v1alpha13.Value {
	if m != nil {
		return m.Value
	}
	return nil
}

type DaoOutput struct {
	// The value to output from the DAO.
	Value *v1alpha13.Value `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	// The address to send the output to.
	Address *v1alpha12.Address `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *DaoOutput) Reset()         { *m = DaoOutput{} }
func (m *DaoOutput) String() string { return proto.CompactTextString(m) }
func (*DaoOutput) ProtoMessage()    {}
func (*DaoOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_67f269dcda22019a, []int{13}
}
func (m *DaoOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaoOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DaoOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DaoOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaoOutput.Merge(m, src)
}
func (m *DaoOutput) XXX_Size() int {
	return m.Size()
}
func (m *DaoOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_DaoOutput.DiscardUnknown(m)
}

var xxx_messageInfo_DaoOutput proto.InternalMessageInfo

func (m *DaoOutput) GetValue() *v1alpha13.Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *DaoOutput) GetAddress() *v1alpha12.Address {
	if m != nil {
		return m.Address
	}
	return nil
}

// A vote on a proposal.
type Vote struct {
	// The vote.
	Vote Vote_Vote `protobuf:"varint,1,opt,name=vote,proto3,enum=penumbra.core.component.governance.v1alpha1.Vote_Vote" json:"vote,omitempty"`
}

func (m *Vote) Reset()         { *m = Vote{} }
func (m *Vote) String() string { return proto.CompactTextString(m) }
func (*Vote) ProtoMessage()    {}
func (*Vote) Descriptor() ([]byte, []int) {
	return fileDescriptor_67f269dcda22019a, []int{14}
}
func (m *Vote) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Vote) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Vote.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Vote) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Vote.Merge(m, src)
}
func (m *Vote) XXX_Size() int {
	return m.Size()
}
func (m *Vote) XXX_DiscardUnknown() {
	xxx_messageInfo_Vote.DiscardUnknown(m)
}

var xxx_messageInfo_Vote proto.InternalMessageInfo

func (m *Vote) GetVote() Vote_Vote {
	if m != nil {
		return m.Vote
	}
	return Vote_VOTE_UNSPECIFIED
}

// The current state of a proposal.
type ProposalState struct {
	// The state of the proposal.
	//
	// Types that are valid to be assigned to State:
	//
	//	*ProposalState_Voting_
	//	*ProposalState_Withdrawn_
	//	*ProposalState_Finished_
	//	*ProposalState_Claimed_
	State isProposalState_State `protobuf_oneof:"state"`
}

func (m *ProposalState) Reset()         { *m = ProposalState{} }
func (m *ProposalState) String() string { return proto.CompactTextString(m) }
func (*ProposalState) ProtoMessage()    {}
func (*ProposalState) Descriptor() ([]byte, []int) {
	return fileDescriptor_67f269dcda22019a, []int{15}
}
func (m *ProposalState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProposalState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProposalState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProposalState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProposalState.Merge(m, src)
}
func (m *ProposalState) XXX_Size() int {
	return m.Size()
}
func (m *ProposalState) XXX_DiscardUnknown() {
	xxx_messageInfo_ProposalState.DiscardUnknown(m)
}

var xxx_messageInfo_ProposalState proto.InternalMessageInfo

type isProposalState_State interface {
	isProposalState_State()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ProposalState_Voting_ struct {
	Voting *ProposalState_Voting `protobuf:"bytes,2,opt,name=voting,proto3,oneof" json:"voting,omitempty"`
}
type ProposalState_Withdrawn_ struct {
	Withdrawn *ProposalState_Withdrawn `protobuf:"bytes,3,opt,name=withdrawn,proto3,oneof" json:"withdrawn,omitempty"`
}
type ProposalState_Finished_ struct {
	Finished *ProposalState_Finished `protobuf:"bytes,4,opt,name=finished,proto3,oneof" json:"finished,omitempty"`
}
type ProposalState_Claimed_ struct {
	Claimed *ProposalState_Claimed `protobuf:"bytes,5,opt,name=claimed,proto3,oneof" json:"claimed,omitempty"`
}

func (*ProposalState_Voting_) isProposalState_State()    {}
func (*ProposalState_Withdrawn_) isProposalState_State() {}
func (*ProposalState_Finished_) isProposalState_State()  {}
func (*ProposalState_Claimed_) isProposalState_State()   {}

func (m *ProposalState) GetState() isProposalState_State {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *ProposalState) GetVoting() *ProposalState_Voting {
	if x, ok := m.GetState().(*ProposalState_Voting_); ok {
		return x.Voting
	}
	return nil
}

func (m *ProposalState) GetWithdrawn() *ProposalState_Withdrawn {
	if x, ok := m.GetState().(*ProposalState_Withdrawn_); ok {
		return x.Withdrawn
	}
	return nil
}

func (m *ProposalState) GetFinished() *ProposalState_Finished {
	if x, ok := m.GetState().(*ProposalState_Finished_); ok {
		return x.Finished
	}
	return nil
}

func (m *ProposalState) GetClaimed() *ProposalState_Claimed {
	if x, ok := m.GetState().(*ProposalState_Claimed_); ok {
		return x.Claimed
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ProposalState) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ProposalState_Voting_)(nil),
		(*ProposalState_Withdrawn_)(nil),
		(*ProposalState_Finished_)(nil),
		(*ProposalState_Claimed_)(nil),
	}
}

// Voting is in progress and the proposal has not yet concluded voting or been withdrawn.
type ProposalState_Voting struct {
}

func (m *ProposalState_Voting) Reset()         { *m = ProposalState_Voting{} }
func (m *ProposalState_Voting) String() string { return proto.CompactTextString(m) }
func (*ProposalState_Voting) ProtoMessage()    {}
func (*ProposalState_Voting) Descriptor() ([]byte, []int) {
	return fileDescriptor_67f269dcda22019a, []int{15, 0}
}
func (m *ProposalState_Voting) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProposalState_Voting) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProposalState_Voting.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProposalState_Voting) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProposalState_Voting.Merge(m, src)
}
func (m *ProposalState_Voting) XXX_Size() int {
	return m.Size()
}
func (m *ProposalState_Voting) XXX_DiscardUnknown() {
	xxx_messageInfo_ProposalState_Voting.DiscardUnknown(m)
}

var xxx_messageInfo_ProposalState_Voting proto.InternalMessageInfo

// The proposal has been withdrawn but the voting period is not yet concluded.
type ProposalState_Withdrawn struct {
	// The reason for the withdrawal.
	Reason string `protobuf:"bytes,1,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *ProposalState_Withdrawn) Reset()         { *m = ProposalState_Withdrawn{} }
func (m *ProposalState_Withdrawn) String() string { return proto.CompactTextString(m) }
func (*ProposalState_Withdrawn) ProtoMessage()    {}
func (*ProposalState_Withdrawn) Descriptor() ([]byte, []int) {
	return fileDescriptor_67f269dcda22019a, []int{15, 1}
}
func (m *ProposalState_Withdrawn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProposalState_Withdrawn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProposalState_Withdrawn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProposalState_Withdrawn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProposalState_Withdrawn.Merge(m, src)
}
func (m *ProposalState_Withdrawn) XXX_Size() int {
	return m.Size()
}
func (m *ProposalState_Withdrawn) XXX_DiscardUnknown() {
	xxx_messageInfo_ProposalState_Withdrawn.DiscardUnknown(m)
}

var xxx_messageInfo_ProposalState_Withdrawn proto.InternalMessageInfo

func (m *ProposalState_Withdrawn) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// The voting period has ended, and the proposal has been assigned an outcome.
type ProposalState_Finished struct {
	Outcome *ProposalOutcome `protobuf:"bytes,1,opt,name=outcome,proto3" json:"outcome,omitempty"`
}

func (m *ProposalState_Finished) Reset()         { *m = ProposalState_Finished{} }
func (m *ProposalState_Finished) String() string { return proto.CompactTextString(m) }
func (*ProposalState_Finished) ProtoMessage()    {}
func (*ProposalState_Finished) Descriptor() ([]byte, []int) {
	return fileDescriptor_67f269dcda22019a, []int{15, 2}
}
func (m *ProposalState_Finished) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProposalState_Finished) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProposalState_Finished.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProposalState_Finished) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProposalState_Finished.Merge(m, src)
}
func (m *ProposalState_Finished) XXX_Size() int {
	return m.Size()
}
func (m *ProposalState_Finished) XXX_DiscardUnknown() {
	xxx_messageInfo_ProposalState_Finished.DiscardUnknown(m)
}

var xxx_messageInfo_ProposalState_Finished proto.InternalMessageInfo

func (m *ProposalState_Finished) GetOutcome() *ProposalOutcome {
	if m != nil {
		return m.Outcome
	}
	return nil
}

// The voting period has ended, and the original proposer has claimed their deposit.
type ProposalState_Claimed struct {
	Outcome *ProposalOutcome `protobuf:"bytes,1,opt,name=outcome,proto3" json:"outcome,omitempty"`
}

func (m *ProposalState_Claimed) Reset()         { *m = ProposalState_Claimed{} }
func (m *ProposalState_Claimed) String() string { return proto.CompactTextString(m) }
func (*ProposalState_Claimed) ProtoMessage()    {}
func (*ProposalState_Claimed) Descriptor() ([]byte, []int) {
	return fileDescriptor_67f269dcda22019a, []int{15, 3}
}
func (m *ProposalState_Claimed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProposalState_Claimed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProposalState_Claimed.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProposalState_Claimed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProposalState_Claimed.Merge(m, src)
}
func (m *ProposalState_Claimed) XXX_Size() int {
	return m.Size()
}
func (m *ProposalState_Claimed) XXX_DiscardUnknown() {
	xxx_messageInfo_ProposalState_Claimed.DiscardUnknown(m)
}

var xxx_messageInfo_ProposalState_Claimed proto.InternalMessageInfo

func (m *ProposalState_Claimed) GetOutcome() *ProposalOutcome {
	if m != nil {
		return m.Outcome
	}
	return nil
}

// The outcome of a concluded proposal.
type ProposalOutcome struct {
	// Types that are valid to be assigned to Outcome:
	//
	//	*ProposalOutcome_Passed_
	//	*ProposalOutcome_Failed_
	//	*ProposalOutcome_Slashed_
	Outcome isProposalOutcome_Outcome `protobuf_oneof:"outcome"`
}

func (m *ProposalOutcome) Reset()         { *m = ProposalOutcome{} }
func (m *ProposalOutcome) String() string { return proto.CompactTextString(m) }
func (*ProposalOutcome) ProtoMessage()    {}
func (*ProposalOutcome) Descriptor() ([]byte, []int) {
	return fileDescriptor_67f269dcda22019a, []int{16}
}
func (m *ProposalOutcome) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProposalOutcome) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProposalOutcome.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProposalOutcome) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProposalOutcome.Merge(m, src)
}
func (m *ProposalOutcome) XXX_Size() int {
	return m.Size()
}
func (m *ProposalOutcome) XXX_DiscardUnknown() {
	xxx_messageInfo_ProposalOutcome.DiscardUnknown(m)
}

var xxx_messageInfo_ProposalOutcome proto.InternalMessageInfo

type isProposalOutcome_Outcome interface {
	isProposalOutcome_Outcome()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ProposalOutcome_Passed_ struct {
	Passed *ProposalOutcome_Passed `protobuf:"bytes,1,opt,name=passed,proto3,oneof" json:"passed,omitempty"`
}
type ProposalOutcome_Failed_ struct {
	Failed *ProposalOutcome_Failed `protobuf:"bytes,2,opt,name=failed,proto3,oneof" json:"failed,omitempty"`
}
type ProposalOutcome_Slashed_ struct {
	Slashed *ProposalOutcome_Slashed `protobuf:"bytes,3,opt,name=slashed,proto3,oneof" json:"slashed,omitempty"`
}

func (*ProposalOutcome_Passed_) isProposalOutcome_Outcome()  {}
func (*ProposalOutcome_Failed_) isProposalOutcome_Outcome()  {}
func (*ProposalOutcome_Slashed_) isProposalOutcome_Outcome() {}

func (m *ProposalOutcome) GetOutcome() isProposalOutcome_Outcome {
	if m != nil {
		return m.Outcome
	}
	return nil
}

func (m *ProposalOutcome) GetPassed() *ProposalOutcome_Passed {
	if x, ok := m.GetOutcome().(*ProposalOutcome_Passed_); ok {
		return x.Passed
	}
	return nil
}

func (m *ProposalOutcome) GetFailed() *ProposalOutcome_Failed {
	if x, ok := m.GetOutcome().(*ProposalOutcome_Failed_); ok {
		return x.Failed
	}
	return nil
}

func (m *ProposalOutcome) GetSlashed() *ProposalOutcome_Slashed {
	if x, ok := m.GetOutcome().(*ProposalOutcome_Slashed_); ok {
		return x.Slashed
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ProposalOutcome) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ProposalOutcome_Passed_)(nil),
		(*ProposalOutcome_Failed_)(nil),
		(*ProposalOutcome_Slashed_)(nil),
	}
}

// Whether or not the proposal was withdrawn.
type ProposalOutcome_Withdrawn struct {
	// The reason for withdrawing the proposal during the voting period.
	Reason string `protobuf:"bytes,1,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *ProposalOutcome_Withdrawn) Reset()         { *m = ProposalOutcome_Withdrawn{} }
func (m *ProposalOutcome_Withdrawn) String() string { return proto.CompactTextString(m) }
func (*ProposalOutcome_Withdrawn) ProtoMessage()    {}
func (*ProposalOutcome_Withdrawn) Descriptor() ([]byte, []int) {
	return fileDescriptor_67f269dcda22019a, []int{16, 0}
}
func (m *ProposalOutcome_Withdrawn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProposalOutcome_Withdrawn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProposalOutcome_Withdrawn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProposalOutcome_Withdrawn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProposalOutcome_Withdrawn.Merge(m, src)
}
func (m *ProposalOutcome_Withdrawn) XXX_Size() int {
	return m.Size()
}
func (m *ProposalOutcome_Withdrawn) XXX_DiscardUnknown() {
	xxx_messageInfo_ProposalOutcome_Withdrawn.DiscardUnknown(m)
}

var xxx_messageInfo_ProposalOutcome_Withdrawn proto.InternalMessageInfo

func (m *ProposalOutcome_Withdrawn) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// The proposal was passed.
type ProposalOutcome_Passed struct {
}

func (m *ProposalOutcome_Passed) Reset()         { *m = ProposalOutcome_Passed{} }
func (m *ProposalOutcome_Passed) String() string { return proto.CompactTextString(m) }
func (*ProposalOutcome_Passed) ProtoMessage()    {}
func (*ProposalOutcome_Passed) Descriptor() ([]byte, []int) {
	return fileDescriptor_67f269dcda22019a, []int{16, 1}
}
func (m *ProposalOutcome_Passed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProposalOutcome_Passed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProposalOutcome_Passed.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProposalOutcome_Passed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProposalOutcome_Passed.Merge(m, src)
}
func (m *ProposalOutcome_Passed) XXX_Size() int {
	return m.Size()
}
func (m *ProposalOutcome_Passed) XXX_DiscardUnknown() {
	xxx_messageInfo_ProposalOutcome_Passed.DiscardUnknown(m)
}

var xxx_messageInfo_ProposalOutcome_Passed proto.InternalMessageInfo

// The proposal did not pass.
type ProposalOutcome_Failed struct {
	// Present if the proposal was withdrawn during the voting period.
	Withdrawn *ProposalOutcome_Withdrawn `protobuf:"bytes,1,opt,name=withdrawn,proto3" json:"withdrawn,omitempty"`
}

func (m *ProposalOutcome_Failed) Reset()         { *m = ProposalOutcome_Failed{} }
func (m *ProposalOutcome_Failed) String() string { return proto.CompactTextString(m) }
func (*ProposalOutcome_Failed) ProtoMessage()    {}
func (*ProposalOutcome_Failed) Descriptor() ([]byte, []int) {
	return fileDescriptor_67f269dcda22019a, []int{16, 2}
}
func (m *ProposalOutcome_Failed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProposalOutcome_Failed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProposalOutcome_Failed.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProposalOutcome_Failed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProposalOutcome_Failed.Merge(m, src)
}
func (m *ProposalOutcome_Failed) XXX_Size() int {
	return m.Size()
}
func (m *ProposalOutcome_Failed) XXX_DiscardUnknown() {
	xxx_messageInfo_ProposalOutcome_Failed.DiscardUnknown(m)
}

var xxx_messageInfo_ProposalOutcome_Failed proto.InternalMessageInfo

func (m *ProposalOutcome_Failed) GetWithdrawn() *ProposalOutcome_Withdrawn {
	if m != nil {
		return m.Withdrawn
	}
	return nil
}

// The proposal did not pass, and was slashed.
type ProposalOutcome_Slashed struct {
	// Present if the proposal was withdrawn during the voting period.
	Withdrawn *ProposalOutcome_Withdrawn `protobuf:"bytes,1,opt,name=withdrawn,proto3" json:"withdrawn,omitempty"`
}

func (m *ProposalOutcome_Slashed) Reset()         { *m = ProposalOutcome_Slashed{} }
func (m *ProposalOutcome_Slashed) String() string { return proto.CompactTextString(m) }
func (*ProposalOutcome_Slashed) ProtoMessage()    {}
func (*ProposalOutcome_Slashed) Descriptor() ([]byte, []int) {
	return fileDescriptor_67f269dcda22019a, []int{16, 3}
}
func (m *ProposalOutcome_Slashed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProposalOutcome_Slashed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProposalOutcome_Slashed.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProposalOutcome_Slashed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProposalOutcome_Slashed.Merge(m, src)
}
func (m *ProposalOutcome_Slashed) XXX_Size() int {
	return m.Size()
}
func (m *ProposalOutcome_Slashed) XXX_DiscardUnknown() {
	xxx_messageInfo_ProposalOutcome_Slashed.DiscardUnknown(m)
}

var xxx_messageInfo_ProposalOutcome_Slashed proto.InternalMessageInfo

func (m *ProposalOutcome_Slashed) GetWithdrawn() *ProposalOutcome_Withdrawn {
	if m != nil {
		return m.Withdrawn
	}
	return nil
}

// A tally of votes on a proposal.
type Tally struct {
	// The number of votes in favor of the proposal.
	Yes uint64 `protobuf:"varint,1,opt,name=yes,proto3" json:"yes,omitempty"`
	// The number of votes against the proposal.
	No uint64 `protobuf:"varint,2,opt,name=no,proto3" json:"no,omitempty"`
	// The number of abstentions.
	Abstain uint64 `protobuf:"varint,3,opt,name=abstain,proto3" json:"abstain,omitempty"`
}

func (m *Tally) Reset()         { *m = Tally{} }
func (m *Tally) String() string { return proto.CompactTextString(m) }
func (*Tally) ProtoMessage()    {}
func (*Tally) Descriptor() ([]byte, []int) {
	return fileDescriptor_67f269dcda22019a, []int{17}
}
func (m *Tally) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tally) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tally.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tally) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tally.Merge(m, src)
}
func (m *Tally) XXX_Size() int {
	return m.Size()
}
func (m *Tally) XXX_DiscardUnknown() {
	xxx_messageInfo_Tally.DiscardUnknown(m)
}

var xxx_messageInfo_Tally proto.InternalMessageInfo

func (m *Tally) GetYes() uint64 {
	if m != nil {
		return m.Yes
	}
	return 0
}

func (m *Tally) GetNo() uint64 {
	if m != nil {
		return m.No
	}
	return 0
}

func (m *Tally) GetAbstain() uint64 {
	if m != nil {
		return m.Abstain
	}
	return 0
}

// A proposal to be voted upon.
type Proposal struct {
	// The unique identifier of the proposal.
	Id uint64 `protobuf:"varint,4,opt,name=id,proto3" json:"id,omitempty"`
	// A short title for the proposal.
	Title string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	// A natural-language description of the effect of the proposal and its justification.
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// The different kinds of proposal. Only one of these should be set.
	Signaling       *Proposal_Signaling       `protobuf:"bytes,5,opt,name=signaling,proto3" json:"signaling,omitempty"`
	Emergency       *Proposal_Emergency       `protobuf:"bytes,6,opt,name=emergency,proto3" json:"emergency,omitempty"`
	ParameterChange *Proposal_ParameterChange `protobuf:"bytes,7,opt,name=parameter_change,json=parameterChange,proto3" json:"parameter_change,omitempty"`
	DaoSpend        *Proposal_DaoSpend        `protobuf:"bytes,8,opt,name=dao_spend,json=daoSpend,proto3" json:"dao_spend,omitempty"`
	UpgradePlan     *Proposal_UpgradePlan     `protobuf:"bytes,9,opt,name=upgrade_plan,json=upgradePlan,proto3" json:"upgrade_plan,omitempty"`
}

func (m *Proposal) Reset()         { *m = Proposal{} }
func (m *Proposal) String() string { return proto.CompactTextString(m) }
func (*Proposal) ProtoMessage()    {}
func (*Proposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_67f269dcda22019a, []int{18}
}
func (m *Proposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Proposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Proposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Proposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Proposal.Merge(m, src)
}
func (m *Proposal) XXX_Size() int {
	return m.Size()
}
func (m *Proposal) XXX_DiscardUnknown() {
	xxx_messageInfo_Proposal.DiscardUnknown(m)
}

var xxx_messageInfo_Proposal proto.InternalMessageInfo

func (m *Proposal) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Proposal) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Proposal) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Proposal) GetSignaling() *Proposal_Signaling {
	if m != nil {
		return m.Signaling
	}
	return nil
}

func (m *Proposal) GetEmergency() *Proposal_Emergency {
	if m != nil {
		return m.Emergency
	}
	return nil
}

func (m *Proposal) GetParameterChange() *Proposal_ParameterChange {
	if m != nil {
		return m.ParameterChange
	}
	return nil
}

func (m *Proposal) GetDaoSpend() *Proposal_DaoSpend {
	if m != nil {
		return m.DaoSpend
	}
	return nil
}

func (m *Proposal) GetUpgradePlan() *Proposal_UpgradePlan {
	if m != nil {
		return m.UpgradePlan
	}
	return nil
}

// A signaling proposal is meant to register a vote on-chain, but does not have an automatic
// effect when passed.
//
// It optionally contains a reference to a commit which contains code to upgrade the chain.
type Proposal_Signaling struct {
	// The commit to be voted upon, if any is relevant.
	Commit string `protobuf:"bytes,1,opt,name=commit,proto3" json:"commit,omitempty"`
}

func (m *Proposal_Signaling) Reset()         { *m = Proposal_Signaling{} }
func (m *Proposal_Signaling) String() string { return proto.CompactTextString(m) }
func (*Proposal_Signaling) ProtoMessage()    {}
func (*Proposal_Signaling) Descriptor() ([]byte, []int) {
	return fileDescriptor_67f269dcda22019a, []int{18, 0}
}
func (m *Proposal_Signaling) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Proposal_Signaling) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Proposal_Signaling.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Proposal_Signaling) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Proposal_Signaling.Merge(m, src)
}
func (m *Proposal_Signaling) XXX_Size() int {
	return m.Size()
}
func (m *Proposal_Signaling) XXX_DiscardUnknown() {
	xxx_messageInfo_Proposal_Signaling.DiscardUnknown(m)
}

var xxx_messageInfo_Proposal_Signaling proto.InternalMessageInfo

func (m *Proposal_Signaling) GetCommit() string {
	if m != nil {
		return m.Commit
	}
	return ""
}

// An emergency proposal can be passed instantaneously by a 2/3 majority of validators, without
// waiting for the voting period to expire.
//
// If the boolean `halt_chain` is set to `true`, then the chain will halt immediately when the
// proposal is passed.
type Proposal_Emergency struct {
	// If `true`, the chain will halt immediately when the proposal is passed.
	HaltChain bool `protobuf:"varint,1,opt,name=halt_chain,json=haltChain,proto3" json:"halt_chain,omitempty"`
}

func (m *Proposal_Emergency) Reset()         { *m = Proposal_Emergency{} }
func (m *Proposal_Emergency) String() string { return proto.CompactTextString(m) }
func (*Proposal_Emergency) ProtoMessage()    {}
func (*Proposal_Emergency) Descriptor() ([]byte, []int) {
	return fileDescriptor_67f269dcda22019a, []int{18, 1}
}
func (m *Proposal_Emergency) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Proposal_Emergency) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Proposal_Emergency.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Proposal_Emergency) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Proposal_Emergency.Merge(m, src)
}
func (m *Proposal_Emergency) XXX_Size() int {
	return m.Size()
}
func (m *Proposal_Emergency) XXX_DiscardUnknown() {
	xxx_messageInfo_Proposal_Emergency.DiscardUnknown(m)
}

var xxx_messageInfo_Proposal_Emergency proto.InternalMessageInfo

func (m *Proposal_Emergency) GetHaltChain() bool {
	if m != nil {
		return m.HaltChain
	}
	return false
}

// A parameter change proposal describes a replacement of the chain parameters, which should take
// effect when the proposal is passed.
type Proposal_ParameterChange struct {
	// The old chain parameters to be replaced: even if the proposal passes, the update will not be
	// applied if the chain parameters have changed *at all* from these chain parameters. Usually,
	// this should be set to the current chain parameters at time of proposal.
	OldParameters *v1alpha15.ChainParameters `protobuf:"bytes,1,opt,name=old_parameters,json=oldParameters,proto3" json:"old_parameters,omitempty"`
	// The new chain parameters to be set: the *entire* chain parameters will be replaced with these
	// at the time the proposal is passed.
	NewParameters *v1alpha15.ChainParameters `protobuf:"bytes,2,opt,name=new_parameters,json=newParameters,proto3" json:"new_parameters,omitempty"`
}

func (m *Proposal_ParameterChange) Reset()         { *m = Proposal_ParameterChange{} }
func (m *Proposal_ParameterChange) String() string { return proto.CompactTextString(m) }
func (*Proposal_ParameterChange) ProtoMessage()    {}
func (*Proposal_ParameterChange) Descriptor() ([]byte, []int) {
	return fileDescriptor_67f269dcda22019a, []int{18, 2}
}
func (m *Proposal_ParameterChange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Proposal_ParameterChange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Proposal_ParameterChange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Proposal_ParameterChange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Proposal_ParameterChange.Merge(m, src)
}
func (m *Proposal_ParameterChange) XXX_Size() int {
	return m.Size()
}
func (m *Proposal_ParameterChange) XXX_DiscardUnknown() {
	xxx_messageInfo_Proposal_ParameterChange.DiscardUnknown(m)
}

var xxx_messageInfo_Proposal_ParameterChange proto.InternalMessageInfo

func (m *Proposal_ParameterChange) GetOldParameters() *v1alpha15.ChainParameters {
	if m != nil {
		return m.OldParameters
	}
	return nil
}

func (m *Proposal_ParameterChange) GetNewParameters() *v1alpha15.ChainParameters {
	if m != nil {
		return m.NewParameters
	}
	return nil
}

// A DAO spend proposal describes zero or more transactions to execute on behalf of the DAO, with
// access to its funds, and zero or more scheduled transactions from previous passed proposals to
// cancel.
type Proposal_DaoSpend struct {
	// The transaction plan to be executed at the time the proposal is passed. This must be a
	// transaction plan which can be executed by the DAO, which means it can't require any witness
	// data or authorization signatures, but it may use the `DaoSpend` action.
	TransactionPlan *types.Any `protobuf:"bytes,2,opt,name=transaction_plan,json=transactionPlan,proto3" json:"transaction_plan,omitempty"`
}

func (m *Proposal_DaoSpend) Reset()         { *m = Proposal_DaoSpend{} }
func (m *Proposal_DaoSpend) String() string { return proto.CompactTextString(m) }
func (*Proposal_DaoSpend) ProtoMessage()    {}
func (*Proposal_DaoSpend) Descriptor() ([]byte, []int) {
	return fileDescriptor_67f269dcda22019a, []int{18, 3}
}
func (m *Proposal_DaoSpend) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Proposal_DaoSpend) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Proposal_DaoSpend.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Proposal_DaoSpend) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Proposal_DaoSpend.Merge(m, src)
}
func (m *Proposal_DaoSpend) XXX_Size() int {
	return m.Size()
}
func (m *Proposal_DaoSpend) XXX_DiscardUnknown() {
	xxx_messageInfo_Proposal_DaoSpend.DiscardUnknown(m)
}

var xxx_messageInfo_Proposal_DaoSpend proto.InternalMessageInfo

func (m *Proposal_DaoSpend) GetTransactionPlan() *types.Any {
	if m != nil {
		return m.TransactionPlan
	}
	return nil
}

// An upgrade plan describes a candidate upgrade to be executed at a certain height. If passed, the chain
// will halt at the specified height.
type Proposal_UpgradePlan struct {
	Height uint64 `protobuf:"varint,1,opt,name=height,proto3" json:"height,omitempty"`
}

func (m *Proposal_UpgradePlan) Reset()         { *m = Proposal_UpgradePlan{} }
func (m *Proposal_UpgradePlan) String() string { return proto.CompactTextString(m) }
func (*Proposal_UpgradePlan) ProtoMessage()    {}
func (*Proposal_UpgradePlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_67f269dcda22019a, []int{18, 4}
}
func (m *Proposal_UpgradePlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Proposal_UpgradePlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Proposal_UpgradePlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Proposal_UpgradePlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Proposal_UpgradePlan.Merge(m, src)
}
func (m *Proposal_UpgradePlan) XXX_Size() int {
	return m.Size()
}
func (m *Proposal_UpgradePlan) XXX_DiscardUnknown() {
	xxx_messageInfo_Proposal_UpgradePlan.DiscardUnknown(m)
}

var xxx_messageInfo_Proposal_UpgradePlan proto.InternalMessageInfo

func (m *Proposal_UpgradePlan) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

type ProposalInfoRequest struct {
	// The expected chain id (empty string if no expectation).
	ChainId string `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// The proposal id to request information on.
	ProposalId uint64 `protobuf:"varint,2,opt,name=proposal_id,json=proposalId,proto3" json:"proposal_id,omitempty"`
}

func (m *ProposalInfoRequest) Reset()         { *m = ProposalInfoRequest{} }
func (m *ProposalInfoRequest) String() string { return proto.CompactTextString(m) }
func (*ProposalInfoRequest) ProtoMessage()    {}
func (*ProposalInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_67f269dcda22019a, []int{19}
}
func (m *ProposalInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProposalInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProposalInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProposalInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProposalInfoRequest.Merge(m, src)
}
func (m *ProposalInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *ProposalInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ProposalInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ProposalInfoRequest proto.InternalMessageInfo

func (m *ProposalInfoRequest) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *ProposalInfoRequest) GetProposalId() uint64 {
	if m != nil {
		return m.ProposalId
	}
	return 0
}

type ProposalInfoResponse struct {
	// The block height at which the proposal started voting.
	StartBlockHeight uint64 `protobuf:"varint,1,opt,name=start_block_height,json=startBlockHeight,proto3" json:"start_block_height,omitempty"`
	// The position of the state commitment tree at which the proposal is considered to have started voting.
	StartPosition uint64 `protobuf:"varint,2,opt,name=start_position,json=startPosition,proto3" json:"start_position,omitempty"`
}

func (m *ProposalInfoResponse) Reset()         { *m = ProposalInfoResponse{} }
func (m *ProposalInfoResponse) String() string { return proto.CompactTextString(m) }
func (*ProposalInfoResponse) ProtoMessage()    {}
func (*ProposalInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_67f269dcda22019a, []int{20}
}
func (m *ProposalInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProposalInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProposalInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProposalInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProposalInfoResponse.Merge(m, src)
}
func (m *ProposalInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *ProposalInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ProposalInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ProposalInfoResponse proto.InternalMessageInfo

func (m *ProposalInfoResponse) GetStartBlockHeight() uint64 {
	if m != nil {
		return m.StartBlockHeight
	}
	return 0
}

func (m *ProposalInfoResponse) GetStartPosition() uint64 {
	if m != nil {
		return m.StartPosition
	}
	return 0
}

// Requests the validator rate data for a proposal.
type ProposalRateDataRequest struct {
	// The expected chain id (empty string if no expectation).
	ChainId string `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// The proposal id to request information on.
	ProposalId uint64 `protobuf:"varint,2,opt,name=proposal_id,json=proposalId,proto3" json:"proposal_id,omitempty"`
}

func (m *ProposalRateDataRequest) Reset()         { *m = ProposalRateDataRequest{} }
func (m *ProposalRateDataRequest) String() string { return proto.CompactTextString(m) }
func (*ProposalRateDataRequest) ProtoMessage()    {}
func (*ProposalRateDataRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_67f269dcda22019a, []int{21}
}
func (m *ProposalRateDataRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProposalRateDataRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProposalRateDataRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProposalRateDataRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProposalRateDataRequest.Merge(m, src)
}
func (m *ProposalRateDataRequest) XXX_Size() int {
	return m.Size()
}
func (m *ProposalRateDataRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ProposalRateDataRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ProposalRateDataRequest proto.InternalMessageInfo

func (m *ProposalRateDataRequest) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *ProposalRateDataRequest) GetProposalId() uint64 {
	if m != nil {
		return m.ProposalId
	}
	return 0
}

// The rate data for a single validator.
type ProposalRateDataResponse struct {
	RateData *v1alpha16.RateData `protobuf:"bytes,1,opt,name=rate_data,json=rateData,proto3" json:"rate_data,omitempty"`
}

func (m *ProposalRateDataResponse) Reset()         { *m = ProposalRateDataResponse{} }
func (m *ProposalRateDataResponse) String() string { return proto.CompactTextString(m) }
func (*ProposalRateDataResponse) ProtoMessage()    {}
func (*ProposalRateDataResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_67f269dcda22019a, []int{22}
}
func (m *ProposalRateDataResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProposalRateDataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProposalRateDataResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProposalRateDataResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProposalRateDataResponse.Merge(m, src)
}
func (m *ProposalRateDataResponse) XXX_Size() int {
	return m.Size()
}
func (m *ProposalRateDataResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ProposalRateDataResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ProposalRateDataResponse proto.InternalMessageInfo

func (m *ProposalRateDataResponse) GetRateData() *v1alpha16.RateData {
	if m != nil {
		return m.RateData
	}
	return nil
}

// Governance configuration data.
type GovernanceParameters struct {
	// The number of blocks during which a proposal is voted on.
	ProposalVotingBlocks uint64 `protobuf:"varint,1,opt,name=proposal_voting_blocks,json=proposalVotingBlocks,proto3" json:"proposal_voting_blocks,omitempty"`
	// The deposit required to create a proposal.
	ProposalDepositAmount *v1alpha1.Amount `protobuf:"bytes,2,opt,name=proposal_deposit_amount,json=proposalDepositAmount,proto3" json:"proposal_deposit_amount,omitempty"`
	// The quorum required for a proposal to be considered valid, as a fraction of the total stake
	// weight of the network.
	ProposalValidQuorum string `protobuf:"bytes,3,opt,name=proposal_valid_quorum,json=proposalValidQuorum,proto3" json:"proposal_valid_quorum,omitempty"`
	// The threshold for a proposal to pass voting, as a ratio of "yes" votes over "no" votes.
	ProposalPassThreshold string `protobuf:"bytes,4,opt,name=proposal_pass_threshold,json=proposalPassThreshold,proto3" json:"proposal_pass_threshold,omitempty"`
	// The threshold for a proposal to be slashed, regardless of whether the "yes" and "no" votes
	// would have passed it, as a ratio of "no" votes over all total votes.
	ProposalSlashThreshold string `protobuf:"bytes,5,opt,name=proposal_slash_threshold,json=proposalSlashThreshold,proto3" json:"proposal_slash_threshold,omitempty"`
}

func (m *GovernanceParameters) Reset()         { *m = GovernanceParameters{} }
func (m *GovernanceParameters) String() string { return proto.CompactTextString(m) }
func (*GovernanceParameters) ProtoMessage()    {}
func (*GovernanceParameters) Descriptor() ([]byte, []int) {
	return fileDescriptor_67f269dcda22019a, []int{23}
}
func (m *GovernanceParameters) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GovernanceParameters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GovernanceParameters.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GovernanceParameters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GovernanceParameters.Merge(m, src)
}
func (m *GovernanceParameters) XXX_Size() int {
	return m.Size()
}
func (m *GovernanceParameters) XXX_DiscardUnknown() {
	xxx_messageInfo_GovernanceParameters.DiscardUnknown(m)
}

var xxx_messageInfo_GovernanceParameters proto.InternalMessageInfo

func (m *GovernanceParameters) GetProposalVotingBlocks() uint64 {
	if m != nil {
		return m.ProposalVotingBlocks
	}
	return 0
}

func (m *GovernanceParameters) GetProposalDepositAmount() *v1alpha1.Amount {
	if m != nil {
		return m.ProposalDepositAmount
	}
	return nil
}

func (m *GovernanceParameters) GetProposalValidQuorum() string {
	if m != nil {
		return m.ProposalValidQuorum
	}
	return ""
}

func (m *GovernanceParameters) GetProposalPassThreshold() string {
	if m != nil {
		return m.ProposalPassThreshold
	}
	return ""
}

func (m *GovernanceParameters) GetProposalSlashThreshold() string {
	if m != nil {
		return m.ProposalSlashThreshold
	}
	return ""
}

// Governance genesis state.
type GenesisContent struct {
	// Governance parameters.
	GovernanceParams *GovernanceParameters `protobuf:"bytes,1,opt,name=governance_params,json=governanceParams,proto3" json:"governance_params,omitempty"`
}

func (m *GenesisContent) Reset()         { *m = GenesisContent{} }
func (m *GenesisContent) String() string { return proto.CompactTextString(m) }
func (*GenesisContent) ProtoMessage()    {}
func (*GenesisContent) Descriptor() ([]byte, []int) {
	return fileDescriptor_67f269dcda22019a, []int{24}
}
func (m *GenesisContent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenesisContent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenesisContent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenesisContent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenesisContent.Merge(m, src)
}
func (m *GenesisContent) XXX_Size() int {
	return m.Size()
}
func (m *GenesisContent) XXX_DiscardUnknown() {
	xxx_messageInfo_GenesisContent.DiscardUnknown(m)
}

var xxx_messageInfo_GenesisContent proto.InternalMessageInfo

func (m *GenesisContent) GetGovernanceParams() *GovernanceParameters {
	if m != nil {
		return m.GovernanceParams
	}
	return nil
}

func init() {
	proto.RegisterEnum("penumbra.core.component.governance.v1alpha1.Vote_Vote", Vote_Vote_name, Vote_Vote_value)
	proto.RegisterType((*ZKDelegatorVoteProof)(nil), "penumbra.core.component.governance.v1alpha1.ZKDelegatorVoteProof")
	proto.RegisterType((*ProposalSubmit)(nil), "penumbra.core.component.governance.v1alpha1.ProposalSubmit")
	proto.RegisterType((*ProposalWithdraw)(nil), "penumbra.core.component.governance.v1alpha1.ProposalWithdraw")
	proto.RegisterType((*ProposalDepositClaim)(nil), "penumbra.core.component.governance.v1alpha1.ProposalDepositClaim")
	proto.RegisterType((*ValidatorVote)(nil), "penumbra.core.component.governance.v1alpha1.ValidatorVote")
	proto.RegisterType((*ValidatorVoteReason)(nil), "penumbra.core.component.governance.v1alpha1.ValidatorVoteReason")
	proto.RegisterType((*ValidatorVoteBody)(nil), "penumbra.core.component.governance.v1alpha1.ValidatorVoteBody")
	proto.RegisterType((*DelegatorVote)(nil), "penumbra.core.component.governance.v1alpha1.DelegatorVote")
	proto.RegisterType((*DelegatorVoteBody)(nil), "penumbra.core.component.governance.v1alpha1.DelegatorVoteBody")
	proto.RegisterType((*DelegatorVoteView)(nil), "penumbra.core.component.governance.v1alpha1.DelegatorVoteView")
	proto.RegisterType((*DelegatorVoteView_Visible)(nil), "penumbra.core.component.governance.v1alpha1.DelegatorVoteView.Visible")
	proto.RegisterType((*DelegatorVoteView_Opaque)(nil), "penumbra.core.component.governance.v1alpha1.DelegatorVoteView.Opaque")
	proto.RegisterType((*DelegatorVotePlan)(nil), "penumbra.core.component.governance.v1alpha1.DelegatorVotePlan")
	proto.RegisterType((*DaoDeposit)(nil), "penumbra.core.component.governance.v1alpha1.DaoDeposit")
	proto.RegisterType((*DaoSpend)(nil), "penumbra.core.component.governance.v1alpha1.DaoSpend")
	proto.RegisterType((*DaoOutput)(nil), "penumbra.core.component.governance.v1alpha1.DaoOutput")
	proto.RegisterType((*Vote)(nil), "penumbra.core.component.governance.v1alpha1.Vote")
	proto.RegisterType((*ProposalState)(nil), "penumbra.core.component.governance.v1alpha1.ProposalState")
	proto.RegisterType((*ProposalState_Voting)(nil), "penumbra.core.component.governance.v1alpha1.ProposalState.Voting")
	proto.RegisterType((*ProposalState_Withdrawn)(nil), "penumbra.core.component.governance.v1alpha1.ProposalState.Withdrawn")
	proto.RegisterType((*ProposalState_Finished)(nil), "penumbra.core.component.governance.v1alpha1.ProposalState.Finished")
	proto.RegisterType((*ProposalState_Claimed)(nil), "penumbra.core.component.governance.v1alpha1.ProposalState.Claimed")
	proto.RegisterType((*ProposalOutcome)(nil), "penumbra.core.component.governance.v1alpha1.ProposalOutcome")
	proto.RegisterType((*ProposalOutcome_Withdrawn)(nil), "penumbra.core.component.governance.v1alpha1.ProposalOutcome.Withdrawn")
	proto.RegisterType((*ProposalOutcome_Passed)(nil), "penumbra.core.component.governance.v1alpha1.ProposalOutcome.Passed")
	proto.RegisterType((*ProposalOutcome_Failed)(nil), "penumbra.core.component.governance.v1alpha1.ProposalOutcome.Failed")
	proto.RegisterType((*ProposalOutcome_Slashed)(nil), "penumbra.core.component.governance.v1alpha1.ProposalOutcome.Slashed")
	proto.RegisterType((*Tally)(nil), "penumbra.core.component.governance.v1alpha1.Tally")
	proto.RegisterType((*Proposal)(nil), "penumbra.core.component.governance.v1alpha1.Proposal")
	proto.RegisterType((*Proposal_Signaling)(nil), "penumbra.core.component.governance.v1alpha1.Proposal.Signaling")
	proto.RegisterType((*Proposal_Emergency)(nil), "penumbra.core.component.governance.v1alpha1.Proposal.Emergency")
	proto.RegisterType((*Proposal_ParameterChange)(nil), "penumbra.core.component.governance.v1alpha1.Proposal.ParameterChange")
	proto.RegisterType((*Proposal_DaoSpend)(nil), "penumbra.core.component.governance.v1alpha1.Proposal.DaoSpend")
	proto.RegisterType((*Proposal_UpgradePlan)(nil), "penumbra.core.component.governance.v1alpha1.Proposal.UpgradePlan")
	proto.RegisterType((*ProposalInfoRequest)(nil), "penumbra.core.component.governance.v1alpha1.ProposalInfoRequest")
	proto.RegisterType((*ProposalInfoResponse)(nil), "penumbra.core.component.governance.v1alpha1.ProposalInfoResponse")
	proto.RegisterType((*ProposalRateDataRequest)(nil), "penumbra.core.component.governance.v1alpha1.ProposalRateDataRequest")
	proto.RegisterType((*ProposalRateDataResponse)(nil), "penumbra.core.component.governance.v1alpha1.ProposalRateDataResponse")
	proto.RegisterType((*GovernanceParameters)(nil), "penumbra.core.component.governance.v1alpha1.GovernanceParameters")
	proto.RegisterType((*GenesisContent)(nil), "penumbra.core.component.governance.v1alpha1.GenesisContent")
}

func init() {
	proto.RegisterFile("penumbra/core/component/governance/v1alpha1/governance.proto", fileDescriptor_67f269dcda22019a)
}

var fileDescriptor_67f269dcda22019a = []byte{
	// 2158 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x59, 0x5b, 0x6f, 0x1b, 0xc7,
	0xf5, 0xd7, 0x52, 0xbc, 0x1e, 0xdd, 0xe8, 0xb1, 0x92, 0x30, 0xc4, 0xff, 0xaf, 0x1a, 0x9b, 0xa4,
	0x30, 0x92, 0x94, 0xb4, 0x95, 0x34, 0x4e, 0xd5, 0x20, 0x89, 0x48, 0xc9, 0xb6, 0xea, 0xc6, 0xa6,
	0x97, 0xb6, 0xd2, 0x3a, 0x4e, 0xb6, 0x43, 0xee, 0x88, 0xdc, 0x6a, 0x39, 0xb3, 0xde, 0x9d, 0x95,
	0xc1, 0x3e, 0xf5, 0xa9, 0xcf, 0x05, 0x12, 0xa0, 0x4f, 0x7d, 0x68, 0x1f, 0xfb, 0xd0, 0x0f, 0x90,
	0x4f, 0x10, 0x14, 0x45, 0x91, 0xa2, 0x28, 0xd0, 0xa7, 0xa2, 0xb0, 0x1f, 0x0a, 0xf4, 0xa9, 0x1f,
	0xa1, 0x98, 0xcb, 0x5e, 0x48, 0x5b, 0xaa, 0x49, 0x26, 0x41, 0x5f, 0x04, 0xce, 0xd9, 0x73, 0x7e,
	0xe7, 0xcc, 0xb9, 0xcd, 0x99, 0x11, 0xbc, 0xe3, 0x13, 0x1a, 0x8d, 0x7a, 0x01, 0x6e, 0xf6, 0x59,
	0x40, 0x9a, 0x7d, 0x36, 0xf2, 0x19, 0x25, 0x94, 0x37, 0x07, 0xec, 0x84, 0x04, 0x14, 0xd3, 0x3e,
	0x69, 0x9e, 0x5c, 0xc6, 0x9e, 0x3f, 0xc4, 0x97, 0x33, 0xb4, 0x86, 0x1f, 0x30, 0xce, 0xd0, 0x6b,
	0xb1, 0x74, 0x43, 0x48, 0x37, 0x12, 0xe9, 0x46, 0x86, 0x33, 0x96, 0xae, 0xbf, 0x38, 0x60, 0x6c,
	0xe0, 0x91, 0xa6, 0x14, 0xed, 0x45, 0x47, 0x4d, 0x4c, 0xc7, 0x0a, 0xa7, 0xbe, 0x93, 0x5a, 0x11,
	0x8c, 0x7d, 0xce, 0x9a, 0x0e, 0xe9, 0xe3, 0xa3, 0x37, 0xae, 0x5c, 0xb1, 0x03, 0x27, 0xc4, 0xa9,
	0x01, 0x13, 0x64, 0x2d, 0xfb, 0xf2, 0xe4, 0x0e, 0x68, 0x34, 0x4a, 0xf9, 0x69, 0x34, 0xd2, 0x5c,
	0x17, 0x27, 0xb9, 0x70, 0x18, 0x12, 0x9e, 0xf2, 0xc9, 0xa5, 0xe6, 0xfc, 0xf6, 0x24, 0xe7, 0x31,
	0x19, 0x87, 0x29, 0xa3, 0x58, 0x69, 0xbe, 0xd6, 0x69, 0x9e, 0x0b, 0x87, 0x2e, 0xf1, 0x1c, 0xe2,
	0xd8, 0x3e, 0x63, 0x5e, 0x2a, 0x3a, 0x41, 0xd6, 0x18, 0xdb, 0xa7, 0x62, 0x70, 0x7c, 0x9c, 0x71,
	0xbc, 0x5c, 0xfe, 0x37, 0x99, 0xfe, 0x10, 0xbb, 0x34, 0x95, 0x91, 0x4b, 0x25, 0x63, 0xbe, 0x0e,
	0x9b, 0xf7, 0x6e, 0xec, 0x11, 0x8f, 0x0c, 0x30, 0x67, 0xc1, 0x21, 0xe3, 0xa4, 0x13, 0x30, 0x76,
	0x84, 0x36, 0xa1, 0xe0, 0x52, 0x4a, 0x82, 0x9a, 0x71, 0xc1, 0xb8, 0xb8, 0x6a, 0xa9, 0x85, 0xf9,
	0x7b, 0x03, 0xd6, 0x3b, 0x01, 0xf3, 0x59, 0x88, 0xbd, 0x6e, 0xd4, 0x1b, 0xb9, 0x1c, 0xdd, 0x86,
	0xb2, 0xaf, 0x29, 0x92, 0x77, 0x65, 0xfb, 0xbb, 0x8d, 0x19, 0x62, 0xdf, 0x88, 0xe1, 0xac, 0x04,
	0x06, 0x1d, 0xc0, 0xba, 0x43, 0x7c, 0x16, 0xba, 0xdc, 0xc6, 0x23, 0x16, 0x51, 0x5e, 0x5b, 0x96,
	0xc0, 0xe6, 0x14, 0xb0, 0x88, 0x61, 0x82, 0xb3, 0x2b, 0x39, 0xad, 0x35, 0x2d, 0xa9, 0x96, 0xe6,
	0x55, 0xa8, 0xc6, 0x0a, 0x3e, 0x74, 0xf9, 0xd0, 0x09, 0xf0, 0x43, 0x54, 0x9f, 0xb2, 0x38, 0x9f,
	0x51, 0xfd, 0x3c, 0x14, 0x03, 0x82, 0x43, 0x46, 0x6b, 0xb9, 0x0b, 0xc6, 0xc5, 0x8a, 0xa5, 0x57,
	0xe6, 0x5f, 0x0d, 0xd8, 0x8c, 0x81, 0xf6, 0x94, 0x86, 0xb6, 0x87, 0xdd, 0xd1, 0x99, 0x60, 0x4f,
	0xee, 0x23, 0x37, 0xe7, 0x3e, 0xd0, 0x21, 0x94, 0x58, 0xc4, 0xfb, 0x6c, 0x44, 0xb4, 0x2f, 0xde,
	0x99, 0xcb, 0xc9, 0xb7, 0x14, 0x86, 0x15, 0x83, 0x99, 0x9f, 0x1b, 0xb0, 0x76, 0x88, 0x3d, 0xd7,
	0x89, 0xa3, 0x8f, 0x2c, 0xc8, 0xf7, 0x98, 0x33, 0xd6, 0xb1, 0x7c, 0x77, 0x26, 0x35, 0x13, 0x48,
	0x2d, 0xe6, 0x8c, 0x2d, 0x89, 0x85, 0xee, 0x42, 0x19, 0x47, 0x7c, 0x68, 0x87, 0xee, 0x40, 0xbb,
	0x60, 0x27, 0x83, 0x2b, 0xeb, 0xba, 0x31, 0x59, 0xc0, 0x09, 0x64, 0xd7, 0x27, 0xd4, 0xd9, 0x8d,
	0xf8, 0xb0, 0xeb, 0x0e, 0x28, 0xe6, 0x51, 0x40, 0xac, 0x12, 0x56, 0x4b, 0xf3, 0x3b, 0x70, 0x7e,
	0x42, 0xa3, 0x25, 0x63, 0x95, 0x89, 0xa1, 0x31, 0x11, 0xc3, 0x7f, 0xe7, 0xe0, 0xdc, 0x13, 0x16,
	0x9e, 0x19, 0xc0, 0x7d, 0xc8, 0x9f, 0x30, 0x4e, 0xb4, 0xcd, 0x97, 0x67, 0xf3, 0x85, 0x30, 0x48,
	0x8a, 0xa3, 0x1b, 0xb0, 0xea, 0x3a, 0x84, 0x72, 0x97, 0x8f, 0xed, 0x63, 0x32, 0xd6, 0x11, 0xbc,
	0x38, 0x05, 0x27, 0x1b, 0x48, 0x22, 0x7e, 0xa0, 0x05, 0x6e, 0x90, 0xb1, 0xb5, 0xe2, 0xa6, 0x0b,
	0x74, 0x1b, 0xd6, 0x53, 0x75, 0x12, 0x2e, 0x2f, 0xe1, 0x5e, 0x3d, 0x13, 0xee, 0x5a, 0x22, 0x22,
	0x00, 0xd7, 0x06, 0xd9, 0x25, 0xfa, 0x51, 0xe2, 0xb0, 0x82, 0x84, 0x7a, 0x7f, 0xfe, 0xa0, 0xab,
	0x10, 0x24, 0x2e, 0xff, 0x34, 0x07, 0x6b, 0x13, 0xcd, 0x65, 0xa1, 0xf4, 0x9a, 0x40, 0xfa, 0xda,
	0xd3, 0x0b, 0x7d, 0x08, 0x05, 0x5f, 0xf4, 0x42, 0x1d, 0xaf, 0xdd, 0x99, 0x6c, 0x7d, 0x5a, 0x53,
	0xb5, 0x14, 0x9e, 0xf9, 0x97, 0x1c, 0x9c, 0x7b, 0x62, 0x2f, 0x67, 0x26, 0xe2, 0x2b, 0xb0, 0x1e,
	0x72, 0x1c, 0x70, 0x5b, 0xf6, 0x04, 0x57, 0xb7, 0xa7, 0xbc, 0xb5, 0x26, 0xa9, 0x1d, 0x4d, 0x4c,
	0xf2, 0x75, 0x79, 0xb1, 0x7c, 0xfd, 0x1e, 0x14, 0x4e, 0xb0, 0x17, 0x11, 0x9d, 0x59, 0x2f, 0x4d,
	0xe1, 0xa8, 0x23, 0x31, 0x1b, 0xff, 0x88, 0x58, 0x4a, 0x02, 0xdd, 0x80, 0x8d, 0x88, 0xf6, 0x18,
	0x15, 0xa7, 0x99, 0xee, 0x79, 0x85, 0x67, 0xee, 0x79, 0xeb, 0xb1, 0xa8, 0x6e, 0x7a, 0xff, 0x07,
	0x15, 0x1a, 0x79, 0x9e, 0x7b, 0xe4, 0x92, 0xa0, 0x56, 0x94, 0xe7, 0x50, 0x4a, 0x40, 0xeb, 0x90,
	0x0b, 0x8e, 0x6b, 0x25, 0x49, 0xce, 0x05, 0xc7, 0xe6, 0x67, 0xf9, 0x29, 0xaf, 0x1e, 0xba, 0xe4,
	0x21, 0xea, 0x41, 0xe9, 0xc4, 0x0d, 0xdd, 0x9e, 0x47, 0x74, 0xca, 0x5d, 0x9d, 0x3f, 0xe5, 0x04,
	0x60, 0xe3, 0x50, 0xa1, 0x5d, 0x5f, 0xb2, 0x62, 0x60, 0x64, 0x43, 0x91, 0xf9, 0xf8, 0x41, 0x14,
	0x37, 0x8a, 0xfd, 0x05, 0x55, 0xdc, 0x92, 0x60, 0xd7, 0x97, 0x2c, 0x0d, 0x5b, 0xff, 0xdc, 0x80,
	0x92, 0xd6, 0x8b, 0xb0, 0x38, 0x54, 0xb4, 0x84, 0x2d, 0xa3, 0x6d, 0x3c, 0x91, 0xf2, 0x33, 0x2a,
	0x15, 0x87, 0x4d, 0xb6, 0x46, 0x7f, 0x08, 0x79, 0x9a, 0xb6, 0xbd, 0xb7, 0x4f, 0x05, 0x9e, 0x9c,
	0x5b, 0x12, 0xec, 0x9b, 0x7a, 0x1f, 0x96, 0x44, 0xa9, 0x1f, 0x43, 0x51, 0x6d, 0xe8, 0x1b, 0x30,
	0xbd, 0x55, 0x9d, 0x56, 0x61, 0xfe, 0x73, 0x79, 0x2a, 0x2d, 0x3a, 0x1e, 0xa6, 0xff, 0x43, 0xc5,
	0x76, 0x17, 0x56, 0xe4, 0x0c, 0xe7, 0xd8, 0xd2, 0xe7, 0xaa, 0xe4, 0xde, 0x9c, 0xc7, 0xe7, 0x16,
	0x28, 0x20, 0xf1, 0x1b, 0x5d, 0x82, 0xcd, 0x0c, 0x6c, 0xba, 0x95, 0x82, 0xdc, 0x0a, 0x4a, 0x39,
	0x93, 0xfd, 0x3c, 0xa5, 0x74, 0x8b, 0x73, 0x97, 0xee, 0x16, 0x40, 0x80, 0xa9, 0xc3, 0x46, 0xee,
	0xcf, 0x48, 0xa0, 0x8b, 0x34, 0x43, 0x41, 0x17, 0xa1, 0x2a, 0x7b, 0xa1, 0xdd, 0xf3, 0x5c, 0xea,
	0xb8, 0x74, 0x60, 0x07, 0xb5, 0xb2, 0xe4, 0x5a, 0x97, 0xf4, 0x96, 0x26, 0x5b, 0x4f, 0xe1, 0x0c,
	0x6b, 0x95, 0xa7, 0x70, 0x76, 0xcd, 0x6b, 0x00, 0x7b, 0x98, 0xe9, 0xe9, 0x2c, 0x6d, 0x62, 0xc6,
	0xac, 0x4d, 0xcc, 0xdc, 0x87, 0xf2, 0x1e, 0x66, 0xf2, 0x68, 0x58, 0x04, 0xe6, 0x17, 0x06, 0x54,
	0xf6, 0x30, 0xbb, 0x15, 0x71, 0x3f, 0x5a, 0xc4, 0x1e, 0xf4, 0x2e, 0x94, 0xb0, 0xe3, 0x04, 0x24,
	0x0c, 0x75, 0x49, 0xbe, 0x7c, 0xe6, 0x59, 0xbf, 0xab, 0x78, 0xad, 0x58, 0xc8, 0xfc, 0xb5, 0x01,
	0x79, 0x59, 0xd8, 0x3f, 0xd0, 0x29, 0x2b, 0x4c, 0x58, 0xdf, 0x7e, 0x6b, 0xe6, 0x94, 0xcd, 0xe4,
	0xad, 0x79, 0xa0, 0x31, 0x37, 0xa1, 0x7a, 0x78, 0xeb, 0xce, 0xbe, 0x7d, 0xf7, 0x66, 0xb7, 0xb3,
	0xdf, 0x3e, 0xb8, 0x7a, 0xb0, 0xbf, 0x57, 0x5d, 0x42, 0x55, 0x58, 0x95, 0xd4, 0xdd, 0x56, 0xf7,
	0xce, 0xee, 0xc1, 0xcd, 0xaa, 0x81, 0x56, 0xa1, 0x2c, 0x29, 0x3f, 0xde, 0xef, 0x56, 0x73, 0x68,
	0x05, 0x4a, 0x72, 0x75, 0xf3, 0x56, 0x75, 0xd9, 0xfc, 0xac, 0x00, 0x6b, 0xc9, 0xad, 0x82, 0x63,
	0x4e, 0xd0, 0x47, 0x50, 0x3c, 0x61, 0xdc, 0xa5, 0xf1, 0x79, 0xbe, 0x3b, 0xd7, 0xb4, 0x2b, 0xb1,
	0x84, 0xcd, 0x2e, 0x1d, 0x88, 0x6e, 0xaa, 0x20, 0x91, 0x03, 0x95, 0x87, 0xfa, 0x2e, 0x40, 0x75,
	0xf5, 0xee, 0x2d, 0x80, 0x1f, 0xdf, 0x2b, 0xe8, 0xf5, 0x25, 0x2b, 0x05, 0x46, 0x18, 0xca, 0x47,
	0x2e, 0x75, 0xc3, 0x21, 0x71, 0x74, 0x51, 0xb7, 0x17, 0x50, 0x72, 0x55, 0x43, 0x5d, 0x5f, 0xb2,
	0x12, 0x58, 0xf4, 0x09, 0x94, 0xfa, 0xe2, 0x12, 0x42, 0x1c, 0x7d, 0xc8, 0xb6, 0x16, 0xd0, 0xd0,
	0x56, 0x48, 0xe2, 0x5c, 0xd3, 0xa0, 0xf5, 0x32, 0x14, 0x95, 0xf3, 0xea, 0x2f, 0x41, 0x25, 0xd9,
	0xe6, 0x69, 0xf3, 0x75, 0xbd, 0x07, 0xe5, 0xd8, 0xcc, 0xec, 0x7d, 0xc5, 0xf8, 0x0a, 0xef, 0x2b,
	0x75, 0x0c, 0x25, 0x6d, 0xe8, 0xd7, 0xa5, 0xa2, 0x55, 0x82, 0x42, 0x28, 0x3c, 0x62, 0xfe, 0x31,
	0x0f, 0x1b, 0x53, 0x5c, 0xe8, 0x63, 0x28, 0xfa, 0xa2, 0x54, 0x1d, 0xad, 0xb3, 0xbd, 0x88, 0xce,
	0x46, 0x47, 0x42, 0x89, 0xd4, 0x54, 0xa0, 0x02, 0xfe, 0x08, 0xbb, 0x1e, 0x71, 0x74, 0xde, 0x2f,
	0x06, 0x7f, 0x55, 0x42, 0x09, 0x78, 0x05, 0x8a, 0x7e, 0x02, 0xa5, 0xd0, 0xc3, 0x32, 0x25, 0x17,
	0xc9, 0xfb, 0x18, 0xbf, 0xab, 0xb0, 0x44, 0xca, 0x68, 0xd8, 0x67, 0x4b, 0x94, 0x32, 0x14, 0xd5,
	0xce, 0xeb, 0x14, 0x8a, 0xca, 0xc8, 0xc9, 0xa2, 0x9c, 0x67, 0x52, 0x9b, 0x36, 0x2e, 0x31, 0x23,
	0x53, 0x94, 0x75, 0x06, 0x25, 0x6d, 0xf4, 0x37, 0xa3, 0xb0, 0x55, 0x49, 0x92, 0xd4, 0x6c, 0x43,
	0xe1, 0x0e, 0xf6, 0xbc, 0x31, 0xaa, 0xc2, 0xf2, 0x98, 0x84, 0x7a, 0xec, 0x10, 0x3f, 0xc5, 0x28,
	0x4b, 0x99, 0x9e, 0x32, 0x72, 0x94, 0xa1, 0x1a, 0x94, 0x70, 0x2f, 0xe4, 0xd8, 0x55, 0xfd, 0x29,
	0x6f, 0xc5, 0x4b, 0xf3, 0xef, 0x25, 0x28, 0xc7, 0x8a, 0x85, 0x98, 0xab, 0x9a, 0x4b, 0xde, 0xca,
	0xb9, 0x0e, 0xda, 0x84, 0x02, 0x77, 0xb9, 0x9e, 0x74, 0x2b, 0x96, 0x5a, 0xa0, 0x0b, 0xb0, 0xe2,
	0x90, 0xb0, 0x1f, 0xb8, 0x7e, 0x32, 0xcb, 0x54, 0xac, 0x2c, 0x09, 0x7d, 0x0c, 0x95, 0x50, 0x5c,
	0x7f, 0x3c, 0xd1, 0x70, 0x55, 0x27, 0x79, 0x6f, 0x2e, 0x57, 0x34, 0xba, 0x31, 0x8c, 0x95, 0x22,
	0x0a, 0x78, 0x32, 0x22, 0xc1, 0x80, 0xd0, 0xfe, 0x58, 0x8f, 0x14, 0x73, 0xc2, 0xef, 0xc7, 0x30,
	0x56, 0x8a, 0x88, 0x7c, 0xa8, 0xfa, 0x38, 0xc0, 0x23, 0xc2, 0x49, 0x60, 0xf7, 0x87, 0x98, 0x0e,
	0x88, 0x1c, 0x38, 0x66, 0x9d, 0xc3, 0x13, 0x2d, 0x9d, 0x18, 0xad, 0x2d, 0xc1, 0xac, 0x0d, 0x7f,
	0x92, 0x80, 0x3e, 0x82, 0x8a, 0x83, 0x99, 0x1d, 0x8a, 0x01, 0x41, 0x4e, 0x2d, 0xb3, 0x5e, 0x64,
	0x13, 0x55, 0xf1, 0x98, 0x61, 0x95, 0x9d, 0x78, 0xe0, 0x70, 0x60, 0x35, 0xf2, 0x07, 0x01, 0x76,
	0x88, 0xed, 0x7b, 0x98, 0xca, 0x59, 0x67, 0xde, 0x03, 0xb0, 0x71, 0x57, 0x21, 0x89, 0x91, 0xd7,
	0x5a, 0x89, 0xd2, 0x85, 0xa8, 0xd3, 0x24, 0x56, 0xa2, 0x4e, 0xfb, 0x6c, 0x34, 0x72, 0x79, 0x5c,
	0xa7, 0x6a, 0x55, 0x7f, 0x15, 0x2a, 0x89, 0xc7, 0xd1, 0xff, 0x03, 0x0c, 0xb1, 0xc7, 0x6d, 0xf9,
	0x78, 0x28, 0x19, 0xcb, 0x56, 0x45, 0x50, 0xda, 0x82, 0x50, 0xff, 0xb3, 0x01, 0x1b, 0x53, 0x8e,
	0x43, 0x9f, 0xc0, 0x3a, 0xf3, 0x1c, 0x3b, 0x71, 0x5f, 0xa8, 0xeb, 0xec, 0xca, 0xa9, 0x9b, 0x51,
	0x2f, 0x93, 0xc9, 0x3e, 0x24, 0x74, 0x82, 0x1a, 0x5a, 0x6b, 0xcc, 0x73, 0xd2, 0xa5, 0xc0, 0xa7,
	0xe4, 0x61, 0x16, 0x3f, 0xb7, 0x20, 0x3e, 0x25, 0x0f, 0xd3, 0x65, 0xfd, 0x46, 0x66, 0x0e, 0x7c,
	0x0f, 0xaa, 0x3c, 0xc0, 0x34, 0xc4, 0x7d, 0x51, 0x32, 0x2a, 0x34, 0x4a, 0xdb, 0x66, 0x43, 0xbd,
	0x5e, 0x37, 0xe2, 0xd7, 0xeb, 0xc6, 0x2e, 0x1d, 0x5b, 0x1b, 0x19, 0x6e, 0xe9, 0xf1, 0x57, 0x60,
	0x25, 0x13, 0x0d, 0xe1, 0xf3, 0x21, 0x71, 0x07, 0x43, 0xae, 0xfb, 0x80, 0x5e, 0x99, 0xb7, 0xe1,
	0x7c, 0x1c, 0xbd, 0x03, 0x7a, 0xc4, 0x2c, 0xf2, 0x20, 0x22, 0x21, 0x47, 0x2f, 0x42, 0x59, 0xda,
	0x6e, 0xbb, 0x8e, 0x0e, 0x52, 0x49, 0xae, 0x0f, 0x1c, 0xf4, 0x2d, 0x58, 0x89, 0xaf, 0x2e, 0xe2,
	0xab, 0xea, 0x22, 0x10, 0x93, 0x0e, 0x1c, 0xf3, 0x38, 0x7d, 0xba, 0x54, 0x90, 0xa1, 0xcf, 0x68,
	0x48, 0xd0, 0xeb, 0x80, 0xd4, 0x3d, 0xa7, 0xe7, 0xb1, 0xfe, 0xb1, 0x3d, 0x61, 0x4e, 0x55, 0x7e,
	0x69, 0x89, 0x0f, 0xd7, 0x25, 0xfd, 0x19, 0x6f, 0x45, 0xe6, 0x5d, 0x78, 0x21, 0x79, 0xd1, 0xc5,
	0x9c, 0xec, 0x61, 0x8e, 0xbf, 0x8a, 0x3d, 0xb8, 0x50, 0x7b, 0x12, 0x56, 0xef, 0xe3, 0x03, 0xa8,
	0x04, 0x98, 0x13, 0xdb, 0xc1, 0x1c, 0xeb, 0x0c, 0xbb, 0x74, 0xfa, 0xfd, 0x49, 0xbe, 0x97, 0x27,
	0x19, 0x90, 0x80, 0x95, 0x03, 0xfd, 0xcb, 0xfc, 0x53, 0x0e, 0x36, 0xd3, 0xe7, 0xb2, 0x4c, 0xba,
	0xbd, 0x09, 0xcf, 0x27, 0x46, 0xaa, 0x51, 0x52, 0x79, 0x2e, 0x6e, 0xe5, 0x9b, 0xf1, 0x57, 0x35,
	0x34, 0x49, 0xe7, 0x85, 0xe8, 0x1e, 0xbc, 0x90, 0x48, 0xcd, 0xfd, 0x1a, 0xfc, 0x9c, 0x3f, 0xf9,
	0xf6, 0xac, 0x6f, 0x59, 0xdb, 0xf0, 0x5c, 0x6a, 0x11, 0xf6, 0x5c, 0xc7, 0x7e, 0x10, 0xb1, 0x20,
	0x1a, 0xc9, 0x53, 0xa3, 0x62, 0x9d, 0x4f, 0x0c, 0x12, 0xdf, 0x6e, 0xcb, 0x4f, 0xe8, 0xad, 0x8c,
	0x3d, 0x62, 0xea, 0xb0, 0xf9, 0x30, 0x20, 0xe1, 0x90, 0x79, 0xea, 0x24, 0xa9, 0xa4, 0xba, 0xc4,
	0x19, 0x7d, 0x27, 0xfe, 0x88, 0xde, 0x86, 0x5a, 0x22, 0x27, 0x4f, 0xfb, 0x8c, 0x60, 0x41, 0x0a,
	0x26, 0xde, 0x91, 0x47, 0x6c, 0x22, 0x69, 0xfe, 0xdc, 0x80, 0xf5, 0x6b, 0x84, 0x92, 0xd0, 0x0d,
	0xdb, 0x8c, 0x72, 0x42, 0x39, 0xa2, 0x70, 0x2e, 0xf3, 0x88, 0x29, 0x0b, 0x38, 0x6e, 0x0e, 0xb3,
	0x75, 0xba, 0xa7, 0x05, 0xca, 0xaa, 0x0e, 0x26, 0xa9, 0xe1, 0xf6, 0x17, 0x39, 0x58, 0xbd, 0x1d,
	0x91, 0x60, 0xdc, 0x25, 0xc1, 0x89, 0xdb, 0x27, 0xe8, 0x53, 0x03, 0x56, 0xb3, 0x45, 0x81, 0xde,
	0x9f, 0xab, 0xc1, 0x66, 0x4a, 0xb4, 0xbe, 0xbb, 0x00, 0x82, 0xce, 0xe4, 0xdf, 0x18, 0xe9, 0xbf,
	0x2b, 0xe2, 0xcc, 0x44, 0xf3, 0xcd, 0x68, 0x53, 0xc5, 0x57, 0xdf, 0x5f, 0x10, 0x45, 0x59, 0x78,
	0xc9, 0x68, 0xfd, 0x6a, 0xf9, 0x8b, 0x47, 0x5b, 0xc6, 0x97, 0x8f, 0xb6, 0x8c, 0x7f, 0x3c, 0xda,
	0x32, 0x7e, 0xf9, 0x78, 0x6b, 0xe9, 0xcb, 0xc7, 0x5b, 0x4b, 0x7f, 0x7b, 0xbc, 0xb5, 0x04, 0xcd,
	0x3e, 0x1b, 0xcd, 0xa2, 0xa6, 0xb5, 0x91, 0x09, 0x9f, 0x68, 0x9e, 0x1d, 0xe3, 0xde, 0x4f, 0x07,
	0x2e, 0x1f, 0x46, 0x3d, 0x21, 0xd8, 0xec, 0xb3, 0x70, 0xc4, 0xc2, 0x66, 0x40, 0x3c, 0x3c, 0x26,
	0x41, 0xf3, 0x64, 0x3b, 0xf9, 0x29, 0xfb, 0x46, 0xd8, 0x9c, 0xe1, 0x3f, 0x94, 0xdf, 0x4f, 0x69,
	0x31, 0xe9, 0xb7, 0xb9, 0x7c, 0xa7, 0xdd, 0xbe, 0xf6, 0xbb, 0xdc, 0x6b, 0x9d, 0xd8, 0xe6, 0xb6,
	0xb0, 0xb9, 0x9d, 0xd8, 0x9c, 0x9a, 0xd7, 0x38, 0xd4, 0x42, 0x7f, 0x48, 0xb9, 0xef, 0x0b, 0xee,
	0xfb, 0x09, 0xf7, 0xfd, 0x94, 0xfb, 0x7e, 0xcc, 0xfd, 0x28, 0x77, 0x65, 0x06, 0xee, 0xfb, 0xd7,
	0x3a, 0xad, 0x0f, 0x08, 0xc7, 0xa2, 0x91, 0xfd, 0x2b, 0xd7, 0x8c, 0x25, 0x77, 0x76, 0x84, 0xa8,
	0xf8, 0xab, 0x65, 0x77, 0x76, 0x52, 0xe1, 0x9d, 0x9d, 0x58, 0xba, 0x57, 0x94, 0x07, 0xd0, 0x1b,
	0xff, 0x09, 0x00, 0x00, 0xff, 0xff, 0xc9, 0xb2, 0x92, 0x0d, 0xb9, 0x1d, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QueryServiceClient is the client API for QueryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryServiceClient interface {
	ProposalInfo(ctx context.Context, in *ProposalInfoRequest, opts ...grpc.CallOption) (*ProposalInfoResponse, error)
	// Used for computing voting power ?
	ProposalRateData(ctx context.Context, in *ProposalRateDataRequest, opts ...grpc.CallOption) (QueryService_ProposalRateDataClient, error)
}

type queryServiceClient struct {
	cc grpc1.ClientConn
}

func NewQueryServiceClient(cc grpc1.ClientConn) QueryServiceClient {
	return &queryServiceClient{cc}
}

func (c *queryServiceClient) ProposalInfo(ctx context.Context, in *ProposalInfoRequest, opts ...grpc.CallOption) (*ProposalInfoResponse, error) {
	out := new(ProposalInfoResponse)
	err := c.cc.Invoke(ctx, "/penumbra.core.component.governance.v1alpha1.QueryService/ProposalInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryServiceClient) ProposalRateData(ctx context.Context, in *ProposalRateDataRequest, opts ...grpc.CallOption) (QueryService_ProposalRateDataClient, error) {
	stream, err := c.cc.NewStream(ctx, &_QueryService_serviceDesc.Streams[0], "/penumbra.core.component.governance.v1alpha1.QueryService/ProposalRateData", opts...)
	if err != nil {
		return nil, err
	}
	x := &queryServiceProposalRateDataClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type QueryService_ProposalRateDataClient interface {
	Recv() (*ProposalRateDataResponse, error)
	grpc.ClientStream
}

type queryServiceProposalRateDataClient struct {
	grpc.ClientStream
}

func (x *queryServiceProposalRateDataClient) Recv() (*ProposalRateDataResponse, error) {
	m := new(ProposalRateDataResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// QueryServiceServer is the server API for QueryService service.
type QueryServiceServer interface {
	ProposalInfo(context.Context, *ProposalInfoRequest) (*ProposalInfoResponse, error)
	// Used for computing voting power ?
	ProposalRateData(*ProposalRateDataRequest, QueryService_ProposalRateDataServer) error
}

// UnimplementedQueryServiceServer can be embedded to have forward compatible implementations.
type UnimplementedQueryServiceServer struct {
}

func (*UnimplementedQueryServiceServer) ProposalInfo(ctx context.Context, req *ProposalInfoRequest) (*ProposalInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProposalInfo not implemented")
}
func (*UnimplementedQueryServiceServer) ProposalRateData(req *ProposalRateDataRequest, srv QueryService_ProposalRateDataServer) error {
	return status.Errorf(codes.Unimplemented, "method ProposalRateData not implemented")
}

func RegisterQueryServiceServer(s grpc1.Server, srv QueryServiceServer) {
	s.RegisterService(&_QueryService_serviceDesc, srv)
}

func _QueryService_ProposalInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProposalInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServiceServer).ProposalInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/penumbra.core.component.governance.v1alpha1.QueryService/ProposalInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServiceServer).ProposalInfo(ctx, req.(*ProposalInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueryService_ProposalRateData_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ProposalRateDataRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryServiceServer).ProposalRateData(m, &queryServiceProposalRateDataServer{stream})
}

type QueryService_ProposalRateDataServer interface {
	Send(*ProposalRateDataResponse) error
	grpc.ServerStream
}

type queryServiceProposalRateDataServer struct {
	grpc.ServerStream
}

func (x *queryServiceProposalRateDataServer) Send(m *ProposalRateDataResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _QueryService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "penumbra.core.component.governance.v1alpha1.QueryService",
	HandlerType: (*QueryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ProposalInfo",
			Handler:    _QueryService_ProposalInfo_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ProposalRateData",
			Handler:       _QueryService_ProposalRateData_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "penumbra/core/component/governance/v1alpha1/governance.proto",
}

func (m *ZKDelegatorVoteProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZKDelegatorVoteProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZKDelegatorVoteProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Inner) > 0 {
		i -= len(m.Inner)
		copy(dAtA[i:], m.Inner)
		i = encodeVarintGovernance(dAtA, i, uint64(len(m.Inner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProposalSubmit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProposalSubmit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalSubmit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DepositAmount != nil {
		{
			size, err := m.DepositAmount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Proposal != nil {
		{
			size, err := m.Proposal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProposalWithdraw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProposalWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintGovernance(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x12
	}
	if m.Proposal != 0 {
		i = encodeVarintGovernance(dAtA, i, uint64(m.Proposal))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProposalDepositClaim) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProposalDepositClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalDepositClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Outcome != nil {
		{
			size, err := m.Outcome.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.DepositAmount != nil {
		{
			size, err := m.DepositAmount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Proposal != 0 {
		i = encodeVarintGovernance(dAtA, i, uint64(m.Proposal))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ValidatorVote) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorVote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorVote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AuthSig != nil {
		{
			size, err := m.AuthSig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Body != nil {
		{
			size, err := m.Body.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidatorVoteReason) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorVoteReason) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorVoteReason) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintGovernance(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidatorVoteBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorVoteBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorVoteBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Reason != nil {
		{
			size, err := m.Reason.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.GovernanceKey != nil {
		{
			size, err := m.GovernanceKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.IdentityKey != nil {
		{
			size, err := m.IdentityKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Vote != nil {
		{
			size, err := m.Vote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Proposal != 0 {
		i = encodeVarintGovernance(dAtA, i, uint64(m.Proposal))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DelegatorVote) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelegatorVote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelegatorVote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Proof != nil {
		{
			size, err := m.Proof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.AuthSig != nil {
		{
			size, err := m.AuthSig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Body != nil {
		{
			size, err := m.Body.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DelegatorVoteBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelegatorVoteBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelegatorVoteBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Rk) > 0 {
		i -= len(m.Rk)
		copy(dAtA[i:], m.Rk)
		i = encodeVarintGovernance(dAtA, i, uint64(len(m.Rk)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Nullifier) > 0 {
		i -= len(m.Nullifier)
		copy(dAtA[i:], m.Nullifier)
		i = encodeVarintGovernance(dAtA, i, uint64(len(m.Nullifier)))
		i--
		dAtA[i] = 0x32
	}
	if m.UnbondedAmount != nil {
		{
			size, err := m.UnbondedAmount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Vote != nil {
		{
			size, err := m.Vote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.StartPosition != 0 {
		i = encodeVarintGovernance(dAtA, i, uint64(m.StartPosition))
		i--
		dAtA[i] = 0x10
	}
	if m.Proposal != 0 {
		i = encodeVarintGovernance(dAtA, i, uint64(m.Proposal))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DelegatorVoteView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelegatorVoteView) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelegatorVoteView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DelegatorVote != nil {
		{
			size := m.DelegatorVote.Size()
			i -= size
			if _, err := m.DelegatorVote.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *DelegatorVoteView_Visible_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelegatorVoteView_Visible_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Visible != nil {
		{
			size, err := m.Visible.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *DelegatorVoteView_Opaque_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelegatorVoteView_Opaque_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Opaque != nil {
		{
			size, err := m.Opaque.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *DelegatorVoteView_Visible) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelegatorVoteView_Visible) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelegatorVoteView_Visible) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Note != nil {
		{
			size, err := m.Note.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.DelegatorVote != nil {
		{
			size, err := m.DelegatorVote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DelegatorVoteView_Opaque) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelegatorVoteView_Opaque) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelegatorVoteView_Opaque) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DelegatorVote != nil {
		{
			size, err := m.DelegatorVote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DelegatorVotePlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelegatorVotePlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelegatorVotePlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProofBlindingS) > 0 {
		i -= len(m.ProofBlindingS)
		copy(dAtA[i:], m.ProofBlindingS)
		i = encodeVarintGovernance(dAtA, i, uint64(len(m.ProofBlindingS)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ProofBlindingR) > 0 {
		i -= len(m.ProofBlindingR)
		copy(dAtA[i:], m.ProofBlindingR)
		i = encodeVarintGovernance(dAtA, i, uint64(len(m.ProofBlindingR)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Randomizer) > 0 {
		i -= len(m.Randomizer)
		copy(dAtA[i:], m.Randomizer)
		i = encodeVarintGovernance(dAtA, i, uint64(len(m.Randomizer)))
		i--
		dAtA[i] = 0x3a
	}
	if m.UnbondedAmount != nil {
		{
			size, err := m.UnbondedAmount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.StakedNotePosition != 0 {
		i = encodeVarintGovernance(dAtA, i, uint64(m.StakedNotePosition))
		i--
		dAtA[i] = 0x28
	}
	if m.StakedNote != nil {
		{
			size, err := m.StakedNote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Vote != nil {
		{
			size, err := m.Vote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.StartPosition != 0 {
		i = encodeVarintGovernance(dAtA, i, uint64(m.StartPosition))
		i--
		dAtA[i] = 0x10
	}
	if m.Proposal != 0 {
		i = encodeVarintGovernance(dAtA, i, uint64(m.Proposal))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DaoDeposit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaoDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DaoSpend) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaoSpend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoSpend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DaoOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaoOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Address != nil {
		{
			size, err := m.Address.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Vote) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Vote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Vote != 0 {
		i = encodeVarintGovernance(dAtA, i, uint64(m.Vote))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProposalState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProposalState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != nil {
		{
			size := m.State.Size()
			i -= size
			if _, err := m.State.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ProposalState_Voting_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalState_Voting_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Voting != nil {
		{
			size, err := m.Voting.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ProposalState_Withdrawn_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalState_Withdrawn_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Withdrawn != nil {
		{
			size, err := m.Withdrawn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ProposalState_Finished_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalState_Finished_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Finished != nil {
		{
			size, err := m.Finished.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ProposalState_Claimed_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalState_Claimed_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Claimed != nil {
		{
			size, err := m.Claimed.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *ProposalState_Voting) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProposalState_Voting) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalState_Voting) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ProposalState_Withdrawn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProposalState_Withdrawn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalState_Withdrawn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintGovernance(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProposalState_Finished) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProposalState_Finished) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalState_Finished) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Outcome != nil {
		{
			size, err := m.Outcome.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProposalState_Claimed) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProposalState_Claimed) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalState_Claimed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Outcome != nil {
		{
			size, err := m.Outcome.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProposalOutcome) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProposalOutcome) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalOutcome) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Outcome != nil {
		{
			size := m.Outcome.Size()
			i -= size
			if _, err := m.Outcome.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ProposalOutcome_Passed_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalOutcome_Passed_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Passed != nil {
		{
			size, err := m.Passed.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ProposalOutcome_Failed_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalOutcome_Failed_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Failed != nil {
		{
			size, err := m.Failed.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ProposalOutcome_Slashed_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalOutcome_Slashed_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Slashed != nil {
		{
			size, err := m.Slashed.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ProposalOutcome_Withdrawn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProposalOutcome_Withdrawn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalOutcome_Withdrawn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintGovernance(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProposalOutcome_Passed) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProposalOutcome_Passed) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalOutcome_Passed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ProposalOutcome_Failed) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProposalOutcome_Failed) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalOutcome_Failed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Withdrawn != nil {
		{
			size, err := m.Withdrawn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProposalOutcome_Slashed) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProposalOutcome_Slashed) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalOutcome_Slashed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Withdrawn != nil {
		{
			size, err := m.Withdrawn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Tally) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tally) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tally) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Abstain != 0 {
		i = encodeVarintGovernance(dAtA, i, uint64(m.Abstain))
		i--
		dAtA[i] = 0x18
	}
	if m.No != 0 {
		i = encodeVarintGovernance(dAtA, i, uint64(m.No))
		i--
		dAtA[i] = 0x10
	}
	if m.Yes != 0 {
		i = encodeVarintGovernance(dAtA, i, uint64(m.Yes))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Proposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Proposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Proposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpgradePlan != nil {
		{
			size, err := m.UpgradePlan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.DaoSpend != nil {
		{
			size, err := m.DaoSpend.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.ParameterChange != nil {
		{
			size, err := m.ParameterChange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Emergency != nil {
		{
			size, err := m.Emergency.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Signaling != nil {
		{
			size, err := m.Signaling.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Id != 0 {
		i = encodeVarintGovernance(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintGovernance(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintGovernance(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Proposal_Signaling) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Proposal_Signaling) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Proposal_Signaling) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Commit) > 0 {
		i -= len(m.Commit)
		copy(dAtA[i:], m.Commit)
		i = encodeVarintGovernance(dAtA, i, uint64(len(m.Commit)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Proposal_Emergency) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Proposal_Emergency) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Proposal_Emergency) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HaltChain {
		i--
		if m.HaltChain {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Proposal_ParameterChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Proposal_ParameterChange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Proposal_ParameterChange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NewParameters != nil {
		{
			size, err := m.NewParameters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.OldParameters != nil {
		{
			size, err := m.OldParameters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Proposal_DaoSpend) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Proposal_DaoSpend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Proposal_DaoSpend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TransactionPlan != nil {
		{
			size, err := m.TransactionPlan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *Proposal_UpgradePlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Proposal_UpgradePlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Proposal_UpgradePlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Height != 0 {
		i = encodeVarintGovernance(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProposalInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProposalInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ProposalId != 0 {
		i = encodeVarintGovernance(dAtA, i, uint64(m.ProposalId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintGovernance(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProposalInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProposalInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StartPosition != 0 {
		i = encodeVarintGovernance(dAtA, i, uint64(m.StartPosition))
		i--
		dAtA[i] = 0x10
	}
	if m.StartBlockHeight != 0 {
		i = encodeVarintGovernance(dAtA, i, uint64(m.StartBlockHeight))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProposalRateDataRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProposalRateDataRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalRateDataRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ProposalId != 0 {
		i = encodeVarintGovernance(dAtA, i, uint64(m.ProposalId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintGovernance(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProposalRateDataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProposalRateDataResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalRateDataResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RateData != nil {
		{
			size, err := m.RateData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GovernanceParameters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GovernanceParameters) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GovernanceParameters) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProposalSlashThreshold) > 0 {
		i -= len(m.ProposalSlashThreshold)
		copy(dAtA[i:], m.ProposalSlashThreshold)
		i = encodeVarintGovernance(dAtA, i, uint64(len(m.ProposalSlashThreshold)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ProposalPassThreshold) > 0 {
		i -= len(m.ProposalPassThreshold)
		copy(dAtA[i:], m.ProposalPassThreshold)
		i = encodeVarintGovernance(dAtA, i, uint64(len(m.ProposalPassThreshold)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ProposalValidQuorum) > 0 {
		i -= len(m.ProposalValidQuorum)
		copy(dAtA[i:], m.ProposalValidQuorum)
		i = encodeVarintGovernance(dAtA, i, uint64(len(m.ProposalValidQuorum)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ProposalDepositAmount != nil {
		{
			size, err := m.ProposalDepositAmount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ProposalVotingBlocks != 0 {
		i = encodeVarintGovernance(dAtA, i, uint64(m.ProposalVotingBlocks))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GenesisContent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenesisContent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenesisContent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GovernanceParams != nil {
		{
			size, err := m.GovernanceParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintGovernance(dAtA []byte, offset int, v uint64) int {
	offset -= sovGovernance(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ZKDelegatorVoteProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Inner)
	if l > 0 {
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func (m *ProposalSubmit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Proposal != nil {
		l = m.Proposal.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	if m.DepositAmount != nil {
		l = m.DepositAmount.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func (m *ProposalWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Proposal != 0 {
		n += 1 + sovGovernance(uint64(m.Proposal))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func (m *ProposalDepositClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Proposal != 0 {
		n += 1 + sovGovernance(uint64(m.Proposal))
	}
	if m.DepositAmount != nil {
		l = m.DepositAmount.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	if m.Outcome != nil {
		l = m.Outcome.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func (m *ValidatorVote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Body != nil {
		l = m.Body.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	if m.AuthSig != nil {
		l = m.AuthSig.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func (m *ValidatorVoteReason) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func (m *ValidatorVoteBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Proposal != 0 {
		n += 1 + sovGovernance(uint64(m.Proposal))
	}
	if m.Vote != nil {
		l = m.Vote.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	if m.IdentityKey != nil {
		l = m.IdentityKey.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	if m.GovernanceKey != nil {
		l = m.GovernanceKey.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	if m.Reason != nil {
		l = m.Reason.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func (m *DelegatorVote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Body != nil {
		l = m.Body.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	if m.AuthSig != nil {
		l = m.AuthSig.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	if m.Proof != nil {
		l = m.Proof.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func (m *DelegatorVoteBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Proposal != 0 {
		n += 1 + sovGovernance(uint64(m.Proposal))
	}
	if m.StartPosition != 0 {
		n += 1 + sovGovernance(uint64(m.StartPosition))
	}
	if m.Vote != nil {
		l = m.Vote.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	if m.UnbondedAmount != nil {
		l = m.UnbondedAmount.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	l = len(m.Nullifier)
	if l > 0 {
		n += 1 + l + sovGovernance(uint64(l))
	}
	l = len(m.Rk)
	if l > 0 {
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func (m *DelegatorVoteView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DelegatorVote != nil {
		n += m.DelegatorVote.Size()
	}
	return n
}

func (m *DelegatorVoteView_Visible_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Visible != nil {
		l = m.Visible.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}
func (m *DelegatorVoteView_Opaque_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Opaque != nil {
		l = m.Opaque.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}
func (m *DelegatorVoteView_Visible) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DelegatorVote != nil {
		l = m.DelegatorVote.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	if m.Note != nil {
		l = m.Note.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func (m *DelegatorVoteView_Opaque) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DelegatorVote != nil {
		l = m.DelegatorVote.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func (m *DelegatorVotePlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Proposal != 0 {
		n += 1 + sovGovernance(uint64(m.Proposal))
	}
	if m.StartPosition != 0 {
		n += 1 + sovGovernance(uint64(m.StartPosition))
	}
	if m.Vote != nil {
		l = m.Vote.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	if m.StakedNote != nil {
		l = m.StakedNote.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	if m.StakedNotePosition != 0 {
		n += 1 + sovGovernance(uint64(m.StakedNotePosition))
	}
	if m.UnbondedAmount != nil {
		l = m.UnbondedAmount.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	l = len(m.Randomizer)
	if l > 0 {
		n += 1 + l + sovGovernance(uint64(l))
	}
	l = len(m.ProofBlindingR)
	if l > 0 {
		n += 1 + l + sovGovernance(uint64(l))
	}
	l = len(m.ProofBlindingS)
	if l > 0 {
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func (m *DaoDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func (m *DaoSpend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func (m *DaoOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	if m.Address != nil {
		l = m.Address.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func (m *Vote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Vote != 0 {
		n += 1 + sovGovernance(uint64(m.Vote))
	}
	return n
}

func (m *ProposalState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != nil {
		n += m.State.Size()
	}
	return n
}

func (m *ProposalState_Voting_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Voting != nil {
		l = m.Voting.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}
func (m *ProposalState_Withdrawn_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Withdrawn != nil {
		l = m.Withdrawn.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}
func (m *ProposalState_Finished_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Finished != nil {
		l = m.Finished.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}
func (m *ProposalState_Claimed_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Claimed != nil {
		l = m.Claimed.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}
func (m *ProposalState_Voting) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ProposalState_Withdrawn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func (m *ProposalState_Finished) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Outcome != nil {
		l = m.Outcome.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func (m *ProposalState_Claimed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Outcome != nil {
		l = m.Outcome.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func (m *ProposalOutcome) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Outcome != nil {
		n += m.Outcome.Size()
	}
	return n
}

func (m *ProposalOutcome_Passed_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Passed != nil {
		l = m.Passed.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}
func (m *ProposalOutcome_Failed_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Failed != nil {
		l = m.Failed.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}
func (m *ProposalOutcome_Slashed_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Slashed != nil {
		l = m.Slashed.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}
func (m *ProposalOutcome_Withdrawn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func (m *ProposalOutcome_Passed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ProposalOutcome_Failed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Withdrawn != nil {
		l = m.Withdrawn.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func (m *ProposalOutcome_Slashed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Withdrawn != nil {
		l = m.Withdrawn.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func (m *Tally) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Yes != 0 {
		n += 1 + sovGovernance(uint64(m.Yes))
	}
	if m.No != 0 {
		n += 1 + sovGovernance(uint64(m.No))
	}
	if m.Abstain != 0 {
		n += 1 + sovGovernance(uint64(m.Abstain))
	}
	return n
}

func (m *Proposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovGovernance(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovGovernance(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovGovernance(uint64(m.Id))
	}
	if m.Signaling != nil {
		l = m.Signaling.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	if m.Emergency != nil {
		l = m.Emergency.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	if m.ParameterChange != nil {
		l = m.ParameterChange.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	if m.DaoSpend != nil {
		l = m.DaoSpend.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	if m.UpgradePlan != nil {
		l = m.UpgradePlan.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func (m *Proposal_Signaling) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Commit)
	if l > 0 {
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func (m *Proposal_Emergency) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HaltChain {
		n += 2
	}
	return n
}

func (m *Proposal_ParameterChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OldParameters != nil {
		l = m.OldParameters.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	if m.NewParameters != nil {
		l = m.NewParameters.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func (m *Proposal_DaoSpend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TransactionPlan != nil {
		l = m.TransactionPlan.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func (m *Proposal_UpgradePlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovGovernance(uint64(m.Height))
	}
	return n
}

func (m *ProposalInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovGovernance(uint64(l))
	}
	if m.ProposalId != 0 {
		n += 1 + sovGovernance(uint64(m.ProposalId))
	}
	return n
}

func (m *ProposalInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartBlockHeight != 0 {
		n += 1 + sovGovernance(uint64(m.StartBlockHeight))
	}
	if m.StartPosition != 0 {
		n += 1 + sovGovernance(uint64(m.StartPosition))
	}
	return n
}

func (m *ProposalRateDataRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovGovernance(uint64(l))
	}
	if m.ProposalId != 0 {
		n += 1 + sovGovernance(uint64(m.ProposalId))
	}
	return n
}

func (m *ProposalRateDataResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RateData != nil {
		l = m.RateData.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func (m *GovernanceParameters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalVotingBlocks != 0 {
		n += 1 + sovGovernance(uint64(m.ProposalVotingBlocks))
	}
	if m.ProposalDepositAmount != nil {
		l = m.ProposalDepositAmount.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	l = len(m.ProposalValidQuorum)
	if l > 0 {
		n += 1 + l + sovGovernance(uint64(l))
	}
	l = len(m.ProposalPassThreshold)
	if l > 0 {
		n += 1 + l + sovGovernance(uint64(l))
	}
	l = len(m.ProposalSlashThreshold)
	if l > 0 {
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func (m *GenesisContent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GovernanceParams != nil {
		l = m.GovernanceParams.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func sovGovernance(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGovernance(x uint64) (n int) {
	return sovGovernance(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ZKDelegatorVoteProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZKDelegatorVoteProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZKDelegatorVoteProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inner = append(m.Inner[:0], dAtA[iNdEx:postIndex]...)
			if m.Inner == nil {
				m.Inner = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProposalSubmit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProposalSubmit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProposalSubmit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proposal == nil {
				m.Proposal = &Proposal{}
			}
			if err := m.Proposal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DepositAmount == nil {
				m.DepositAmount = &v1alpha1.Amount{}
			}
			if err := m.DepositAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProposalWithdraw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProposalWithdraw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProposalWithdraw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposal", wireType)
			}
			m.Proposal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Proposal |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProposalDepositClaim) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProposalDepositClaim: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProposalDepositClaim: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposal", wireType)
			}
			m.Proposal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Proposal |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DepositAmount == nil {
				m.DepositAmount = &v1alpha1.Amount{}
			}
			if err := m.DepositAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outcome", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Outcome == nil {
				m.Outcome = &ProposalOutcome{}
			}
			if err := m.Outcome.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorVote) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorVote: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorVote: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Body == nil {
				m.Body = &ValidatorVoteBody{}
			}
			if err := m.Body.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthSig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuthSig == nil {
				m.AuthSig = &v1alpha11.SpendAuthSignature{}
			}
			if err := m.AuthSig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorVoteReason) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorVoteReason: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorVoteReason: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorVoteBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorVoteBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorVoteBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposal", wireType)
			}
			m.Proposal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Proposal |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vote == nil {
				m.Vote = &Vote{}
			}
			if err := m.Vote.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdentityKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdentityKey == nil {
				m.IdentityKey = &v1alpha12.IdentityKey{}
			}
			if err := m.IdentityKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GovernanceKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GovernanceKey == nil {
				m.GovernanceKey = &v1alpha12.GovernanceKey{}
			}
			if err := m.GovernanceKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Reason == nil {
				m.Reason = &ValidatorVoteReason{}
			}
			if err := m.Reason.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelegatorVote) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelegatorVote: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelegatorVote: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Body == nil {
				m.Body = &DelegatorVoteBody{}
			}
			if err := m.Body.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthSig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuthSig == nil {
				m.AuthSig = &v1alpha11.SpendAuthSignature{}
			}
			if err := m.AuthSig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proof == nil {
				m.Proof = &ZKDelegatorVoteProof{}
			}
			if err := m.Proof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelegatorVoteBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelegatorVoteBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelegatorVoteBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposal", wireType)
			}
			m.Proposal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Proposal |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartPosition", wireType)
			}
			m.StartPosition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartPosition |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vote == nil {
				m.Vote = &Vote{}
			}
			if err := m.Vote.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &v1alpha13.Value{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondedAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UnbondedAmount == nil {
				m.UnbondedAmount = &v1alpha1.Amount{}
			}
			if err := m.UnbondedAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nullifier", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nullifier = append(m.Nullifier[:0], dAtA[iNdEx:postIndex]...)
			if m.Nullifier == nil {
				m.Nullifier = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rk = append(m.Rk[:0], dAtA[iNdEx:postIndex]...)
			if m.Rk == nil {
				m.Rk = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelegatorVoteView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelegatorVoteView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelegatorVoteView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visible", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DelegatorVoteView_Visible{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DelegatorVote = &DelegatorVoteView_Visible_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opaque", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DelegatorVoteView_Opaque{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DelegatorVote = &DelegatorVoteView_Opaque_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelegatorVoteView_Visible) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Visible: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Visible: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorVote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DelegatorVote == nil {
				m.DelegatorVote = &DelegatorVote{}
			}
			if err := m.DelegatorVote.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Note", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Note == nil {
				m.Note = &v1alpha14.NoteView{}
			}
			if err := m.Note.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelegatorVoteView_Opaque) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Opaque: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Opaque: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorVote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DelegatorVote == nil {
				m.DelegatorVote = &DelegatorVote{}
			}
			if err := m.DelegatorVote.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelegatorVotePlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelegatorVotePlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelegatorVotePlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposal", wireType)
			}
			m.Proposal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Proposal |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartPosition", wireType)
			}
			m.StartPosition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartPosition |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vote == nil {
				m.Vote = &Vote{}
			}
			if err := m.Vote.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakedNote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StakedNote == nil {
				m.StakedNote = &v1alpha14.Note{}
			}
			if err := m.StakedNote.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakedNotePosition", wireType)
			}
			m.StakedNotePosition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StakedNotePosition |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondedAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UnbondedAmount == nil {
				m.UnbondedAmount = &v1alpha1.Amount{}
			}
			if err := m.UnbondedAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Randomizer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Randomizer = append(m.Randomizer[:0], dAtA[iNdEx:postIndex]...)
			if m.Randomizer == nil {
				m.Randomizer = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofBlindingR", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofBlindingR = append(m.ProofBlindingR[:0], dAtA[iNdEx:postIndex]...)
			if m.ProofBlindingR == nil {
				m.ProofBlindingR = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofBlindingS", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofBlindingS = append(m.ProofBlindingS[:0], dAtA[iNdEx:postIndex]...)
			if m.ProofBlindingS == nil {
				m.ProofBlindingS = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaoDeposit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaoDeposit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaoDeposit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &v1alpha13.Value{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaoSpend) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaoSpend: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaoSpend: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &v1alpha13.Value{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaoOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaoOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaoOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &v1alpha13.Value{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Address == nil {
				m.Address = &v1alpha12.Address{}
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vote) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vote: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vote: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vote", wireType)
			}
			m.Vote = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vote |= Vote_Vote(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProposalState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProposalState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProposalState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voting", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ProposalState_Voting{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.State = &ProposalState_Voting_{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Withdrawn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ProposalState_Withdrawn{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.State = &ProposalState_Withdrawn_{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Finished", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ProposalState_Finished{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.State = &ProposalState_Finished_{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Claimed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ProposalState_Claimed{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.State = &ProposalState_Claimed_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProposalState_Voting) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Voting: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Voting: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProposalState_Withdrawn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Withdrawn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Withdrawn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProposalState_Finished) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Finished: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Finished: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outcome", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Outcome == nil {
				m.Outcome = &ProposalOutcome{}
			}
			if err := m.Outcome.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProposalState_Claimed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Claimed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Claimed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outcome", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Outcome == nil {
				m.Outcome = &ProposalOutcome{}
			}
			if err := m.Outcome.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProposalOutcome) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProposalOutcome: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProposalOutcome: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Passed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ProposalOutcome_Passed{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Outcome = &ProposalOutcome_Passed_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ProposalOutcome_Failed{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Outcome = &ProposalOutcome_Failed_{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slashed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ProposalOutcome_Slashed{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Outcome = &ProposalOutcome_Slashed_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProposalOutcome_Withdrawn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Withdrawn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Withdrawn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProposalOutcome_Passed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Passed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Passed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProposalOutcome_Failed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Failed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Failed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Withdrawn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Withdrawn == nil {
				m.Withdrawn = &ProposalOutcome_Withdrawn{}
			}
			if err := m.Withdrawn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProposalOutcome_Slashed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Slashed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Slashed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Withdrawn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Withdrawn == nil {
				m.Withdrawn = &ProposalOutcome_Withdrawn{}
			}
			if err := m.Withdrawn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tally) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tally: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tally: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yes", wireType)
			}
			m.Yes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Yes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field No", wireType)
			}
			m.No = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.No |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Abstain", wireType)
			}
			m.Abstain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Abstain |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Proposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Proposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Proposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signaling", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signaling == nil {
				m.Signaling = &Proposal_Signaling{}
			}
			if err := m.Signaling.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Emergency", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Emergency == nil {
				m.Emergency = &Proposal_Emergency{}
			}
			if err := m.Emergency.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParameterChange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParameterChange == nil {
				m.ParameterChange = &Proposal_ParameterChange{}
			}
			if err := m.ParameterChange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DaoSpend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DaoSpend == nil {
				m.DaoSpend = &Proposal_DaoSpend{}
			}
			if err := m.DaoSpend.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradePlan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpgradePlan == nil {
				m.UpgradePlan = &Proposal_UpgradePlan{}
			}
			if err := m.UpgradePlan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Proposal_Signaling) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Signaling: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Signaling: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Proposal_Emergency) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Emergency: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Emergency: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HaltChain", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HaltChain = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Proposal_ParameterChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParameterChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParameterChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OldParameters == nil {
				m.OldParameters = &v1alpha15.ChainParameters{}
			}
			if err := m.OldParameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewParameters == nil {
				m.NewParameters = &v1alpha15.ChainParameters{}
			}
			if err := m.NewParameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Proposal_DaoSpend) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaoSpend: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaoSpend: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionPlan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransactionPlan == nil {
				m.TransactionPlan = &types.Any{}
			}
			if err := m.TransactionPlan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Proposal_UpgradePlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpgradePlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpgradePlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProposalInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProposalInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProposalInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalId", wireType)
			}
			m.ProposalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposalId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProposalInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProposalInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProposalInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartBlockHeight", wireType)
			}
			m.StartBlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartBlockHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartPosition", wireType)
			}
			m.StartPosition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartPosition |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProposalRateDataRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProposalRateDataRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProposalRateDataRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalId", wireType)
			}
			m.ProposalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposalId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProposalRateDataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProposalRateDataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProposalRateDataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RateData == nil {
				m.RateData = &v1alpha16.RateData{}
			}
			if err := m.RateData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GovernanceParameters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GovernanceParameters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GovernanceParameters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalVotingBlocks", wireType)
			}
			m.ProposalVotingBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposalVotingBlocks |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalDepositAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProposalDepositAmount == nil {
				m.ProposalDepositAmount = &v1alpha1.Amount{}
			}
			if err := m.ProposalDepositAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalValidQuorum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProposalValidQuorum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalPassThreshold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProposalPassThreshold = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalSlashThreshold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProposalSlashThreshold = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenesisContent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenesisContent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenesisContent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GovernanceParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GovernanceParams == nil {
				m.GovernanceParams = &GovernanceParameters{}
			}
			if err := m.GovernanceParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGovernance(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGovernance
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGovernance
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGovernance
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGovernance        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGovernance          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGovernance = fmt.Errorf("proto: unexpected end of group")
)
