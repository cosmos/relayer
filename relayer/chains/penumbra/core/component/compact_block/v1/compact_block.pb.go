// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: penumbra/core/component/compact_block/v1/compact_block.proto

package compact_blockv1

import (
	context "context"
	fmt "fmt"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	v13 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/component/dex/v1"
	v14 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/component/fee/v1"
	v1 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/component/sct/v1"
	v12 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/component/shielded_pool/v1"
	v11 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/crypto/tct/v1"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Contains the minimum data needed to update client state.
type CompactBlock struct {
	Height uint64 `protobuf:"varint,1,opt,name=height,proto3" json:"height,omitempty"`
	// State payloads describing new state fragments.
	StatePayloads []*StatePayload `protobuf:"bytes,2,rep,name=state_payloads,json=statePayloads,proto3" json:"state_payloads,omitempty"`
	// Nullifiers identifying spent notes.
	Nullifiers []*v1.Nullifier `protobuf:"bytes,3,rep,name=nullifiers,proto3" json:"nullifiers,omitempty"`
	// The block root of this block.
	BlockRoot *v11.MerkleRoot `protobuf:"bytes,4,opt,name=block_root,json=blockRoot,proto3" json:"block_root,omitempty"`
	// The epoch root of this epoch (only present when the block is the last in an epoch).
	EpochRoot *v11.MerkleRoot `protobuf:"bytes,5,opt,name=epoch_root,json=epochRoot,proto3" json:"epoch_root,omitempty"`
	// If a proposal started voting in this block, this is set to `true`.
	ProposalStarted bool `protobuf:"varint,6,opt,name=proposal_started,json=proposalStarted,proto3" json:"proposal_started,omitempty"`
	// Latest Fuzzy Message Detection parameters.
	FmdParameters *v12.FmdParameters `protobuf:"bytes,7,opt,name=fmd_parameters,json=fmdParameters,proto3" json:"fmd_parameters,omitempty"`
	// Price data for swaps executed in this block.
	SwapOutputs []*v13.BatchSwapOutputData `protobuf:"bytes,8,rep,name=swap_outputs,json=swapOutputs,proto3" json:"swap_outputs,omitempty"`
	// Indicates updated app parameters.
	AppParametersUpdated bool `protobuf:"varint,9,opt,name=app_parameters_updated,json=appParametersUpdated,proto3" json:"app_parameters_updated,omitempty"`
	// Updated gas prices, if they have changed.
	GasPrices *v14.GasPrices `protobuf:"bytes,10,opt,name=gas_prices,json=gasPrices,proto3" json:"gas_prices,omitempty"`
	// Updated gas prices for alternative fee tokens, if they have changed.
	AltGasPrices []*v14.GasPrices `protobuf:"bytes,100,rep,name=alt_gas_prices,json=altGasPrices,proto3" json:"alt_gas_prices,omitempty"`
	// The epoch index
	EpochIndex uint64 `protobuf:"varint,11,opt,name=epoch_index,json=epochIndex,proto3" json:"epoch_index,omitempty"`
}

func (m *CompactBlock) Reset()         { *m = CompactBlock{} }
func (m *CompactBlock) String() string { return proto.CompactTextString(m) }
func (*CompactBlock) ProtoMessage()    {}
func (*CompactBlock) Descriptor() ([]byte, []int) {
	return fileDescriptor_5be1c543aaa156af, []int{0}
}
func (m *CompactBlock) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompactBlock) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompactBlock.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CompactBlock) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompactBlock.Merge(m, src)
}
func (m *CompactBlock) XXX_Size() int {
	return m.Size()
}
func (m *CompactBlock) XXX_DiscardUnknown() {
	xxx_messageInfo_CompactBlock.DiscardUnknown(m)
}

var xxx_messageInfo_CompactBlock proto.InternalMessageInfo

func (m *CompactBlock) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *CompactBlock) GetStatePayloads() []*StatePayload {
	if m != nil {
		return m.StatePayloads
	}
	return nil
}

func (m *CompactBlock) GetNullifiers() []*v1.Nullifier {
	if m != nil {
		return m.Nullifiers
	}
	return nil
}

func (m *CompactBlock) GetBlockRoot() *v11.MerkleRoot {
	if m != nil {
		return m.BlockRoot
	}
	return nil
}

func (m *CompactBlock) GetEpochRoot() *v11.MerkleRoot {
	if m != nil {
		return m.EpochRoot
	}
	return nil
}

func (m *CompactBlock) GetProposalStarted() bool {
	if m != nil {
		return m.ProposalStarted
	}
	return false
}

func (m *CompactBlock) GetFmdParameters() *v12.FmdParameters {
	if m != nil {
		return m.FmdParameters
	}
	return nil
}

func (m *CompactBlock) GetSwapOutputs() []*v13.BatchSwapOutputData {
	if m != nil {
		return m.SwapOutputs
	}
	return nil
}

func (m *CompactBlock) GetAppParametersUpdated() bool {
	if m != nil {
		return m.AppParametersUpdated
	}
	return false
}

func (m *CompactBlock) GetGasPrices() *v14.GasPrices {
	if m != nil {
		return m.GasPrices
	}
	return nil
}

func (m *CompactBlock) GetAltGasPrices() []*v14.GasPrices {
	if m != nil {
		return m.AltGasPrices
	}
	return nil
}

func (m *CompactBlock) GetEpochIndex() uint64 {
	if m != nil {
		return m.EpochIndex
	}
	return 0
}

// An encrypted payload, corresponding to a single commitment in the state commitment tree.
type StatePayload struct {
	// The source of the payload, if known.
	Source *v1.CommitmentSource `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	// The state payload itself.
	//
	// Types that are valid to be assigned to StatePayload:
	//	*StatePayload_RolledUp_
	//	*StatePayload_Note_
	//	*StatePayload_Swap_
	StatePayload isStatePayload_StatePayload `protobuf_oneof:"state_payload"`
}

func (m *StatePayload) Reset()         { *m = StatePayload{} }
func (m *StatePayload) String() string { return proto.CompactTextString(m) }
func (*StatePayload) ProtoMessage()    {}
func (*StatePayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_5be1c543aaa156af, []int{1}
}
func (m *StatePayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatePayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatePayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatePayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatePayload.Merge(m, src)
}
func (m *StatePayload) XXX_Size() int {
	return m.Size()
}
func (m *StatePayload) XXX_DiscardUnknown() {
	xxx_messageInfo_StatePayload.DiscardUnknown(m)
}

var xxx_messageInfo_StatePayload proto.InternalMessageInfo

type isStatePayload_StatePayload interface {
	isStatePayload_StatePayload()
	MarshalTo([]byte) (int, error)
	Size() int
}

type StatePayload_RolledUp_ struct {
	RolledUp *StatePayload_RolledUp `protobuf:"bytes,2,opt,name=rolled_up,json=rolledUp,proto3,oneof" json:"rolled_up,omitempty"`
}
type StatePayload_Note_ struct {
	Note *StatePayload_Note `protobuf:"bytes,3,opt,name=note,proto3,oneof" json:"note,omitempty"`
}
type StatePayload_Swap_ struct {
	Swap *StatePayload_Swap `protobuf:"bytes,4,opt,name=swap,proto3,oneof" json:"swap,omitempty"`
}

func (*StatePayload_RolledUp_) isStatePayload_StatePayload() {}
func (*StatePayload_Note_) isStatePayload_StatePayload()     {}
func (*StatePayload_Swap_) isStatePayload_StatePayload()     {}

func (m *StatePayload) GetStatePayload() isStatePayload_StatePayload {
	if m != nil {
		return m.StatePayload
	}
	return nil
}

func (m *StatePayload) GetSource() *v1.CommitmentSource {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *StatePayload) GetRolledUp() *StatePayload_RolledUp {
	if x, ok := m.GetStatePayload().(*StatePayload_RolledUp_); ok {
		return x.RolledUp
	}
	return nil
}

func (m *StatePayload) GetNote() *StatePayload_Note {
	if x, ok := m.GetStatePayload().(*StatePayload_Note_); ok {
		return x.Note
	}
	return nil
}

func (m *StatePayload) GetSwap() *StatePayload_Swap {
	if x, ok := m.GetStatePayload().(*StatePayload_Swap_); ok {
		return x.Swap
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*StatePayload) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*StatePayload_RolledUp_)(nil),
		(*StatePayload_Note_)(nil),
		(*StatePayload_Swap_)(nil),
	}
}

type StatePayload_RolledUp struct {
	Commitment *v11.StateCommitment `protobuf:"bytes,1,opt,name=commitment,proto3" json:"commitment,omitempty"`
}

func (m *StatePayload_RolledUp) Reset()         { *m = StatePayload_RolledUp{} }
func (m *StatePayload_RolledUp) String() string { return proto.CompactTextString(m) }
func (*StatePayload_RolledUp) ProtoMessage()    {}
func (*StatePayload_RolledUp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5be1c543aaa156af, []int{1, 0}
}
func (m *StatePayload_RolledUp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatePayload_RolledUp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatePayload_RolledUp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatePayload_RolledUp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatePayload_RolledUp.Merge(m, src)
}
func (m *StatePayload_RolledUp) XXX_Size() int {
	return m.Size()
}
func (m *StatePayload_RolledUp) XXX_DiscardUnknown() {
	xxx_messageInfo_StatePayload_RolledUp.DiscardUnknown(m)
}

var xxx_messageInfo_StatePayload_RolledUp proto.InternalMessageInfo

func (m *StatePayload_RolledUp) GetCommitment() *v11.StateCommitment {
	if m != nil {
		return m.Commitment
	}
	return nil
}

type StatePayload_Note struct {
	Note *v12.NotePayload `protobuf:"bytes,2,opt,name=note,proto3" json:"note,omitempty"`
}

func (m *StatePayload_Note) Reset()         { *m = StatePayload_Note{} }
func (m *StatePayload_Note) String() string { return proto.CompactTextString(m) }
func (*StatePayload_Note) ProtoMessage()    {}
func (*StatePayload_Note) Descriptor() ([]byte, []int) {
	return fileDescriptor_5be1c543aaa156af, []int{1, 1}
}
func (m *StatePayload_Note) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatePayload_Note) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatePayload_Note.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatePayload_Note) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatePayload_Note.Merge(m, src)
}
func (m *StatePayload_Note) XXX_Size() int {
	return m.Size()
}
func (m *StatePayload_Note) XXX_DiscardUnknown() {
	xxx_messageInfo_StatePayload_Note.DiscardUnknown(m)
}

var xxx_messageInfo_StatePayload_Note proto.InternalMessageInfo

func (m *StatePayload_Note) GetNote() *v12.NotePayload {
	if m != nil {
		return m.Note
	}
	return nil
}

type StatePayload_Swap struct {
	Swap *v13.SwapPayload `protobuf:"bytes,2,opt,name=swap,proto3" json:"swap,omitempty"`
}

func (m *StatePayload_Swap) Reset()         { *m = StatePayload_Swap{} }
func (m *StatePayload_Swap) String() string { return proto.CompactTextString(m) }
func (*StatePayload_Swap) ProtoMessage()    {}
func (*StatePayload_Swap) Descriptor() ([]byte, []int) {
	return fileDescriptor_5be1c543aaa156af, []int{1, 2}
}
func (m *StatePayload_Swap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatePayload_Swap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatePayload_Swap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatePayload_Swap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatePayload_Swap.Merge(m, src)
}
func (m *StatePayload_Swap) XXX_Size() int {
	return m.Size()
}
func (m *StatePayload_Swap) XXX_DiscardUnknown() {
	xxx_messageInfo_StatePayload_Swap.DiscardUnknown(m)
}

var xxx_messageInfo_StatePayload_Swap proto.InternalMessageInfo

func (m *StatePayload_Swap) GetSwap() *v13.SwapPayload {
	if m != nil {
		return m.Swap
	}
	return nil
}

// Requests a range of compact block data.
type CompactBlockRangeRequest struct {
	// The start height of the range.
	StartHeight uint64 `protobuf:"varint,2,opt,name=start_height,json=startHeight,proto3" json:"start_height,omitempty"`
	// The end height of the range, defaults to the latest block height.
	EndHeight uint64 `protobuf:"varint,3,opt,name=end_height,json=endHeight,proto3" json:"end_height,omitempty"`
	// If set, keeps the connection alive past `end_height`,
	// streaming new compact blocks as they are created.
	KeepAlive bool `protobuf:"varint,4,opt,name=keep_alive,json=keepAlive,proto3" json:"keep_alive,omitempty"`
}

func (m *CompactBlockRangeRequest) Reset()         { *m = CompactBlockRangeRequest{} }
func (m *CompactBlockRangeRequest) String() string { return proto.CompactTextString(m) }
func (*CompactBlockRangeRequest) ProtoMessage()    {}
func (*CompactBlockRangeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5be1c543aaa156af, []int{2}
}
func (m *CompactBlockRangeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompactBlockRangeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompactBlockRangeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CompactBlockRangeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompactBlockRangeRequest.Merge(m, src)
}
func (m *CompactBlockRangeRequest) XXX_Size() int {
	return m.Size()
}
func (m *CompactBlockRangeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CompactBlockRangeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CompactBlockRangeRequest proto.InternalMessageInfo

func (m *CompactBlockRangeRequest) GetStartHeight() uint64 {
	if m != nil {
		return m.StartHeight
	}
	return 0
}

func (m *CompactBlockRangeRequest) GetEndHeight() uint64 {
	if m != nil {
		return m.EndHeight
	}
	return 0
}

func (m *CompactBlockRangeRequest) GetKeepAlive() bool {
	if m != nil {
		return m.KeepAlive
	}
	return false
}

type CompactBlockRangeResponse struct {
	CompactBlock *CompactBlock `protobuf:"bytes,1,opt,name=compact_block,json=compactBlock,proto3" json:"compact_block,omitempty"`
}

func (m *CompactBlockRangeResponse) Reset()         { *m = CompactBlockRangeResponse{} }
func (m *CompactBlockRangeResponse) String() string { return proto.CompactTextString(m) }
func (*CompactBlockRangeResponse) ProtoMessage()    {}
func (*CompactBlockRangeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5be1c543aaa156af, []int{3}
}
func (m *CompactBlockRangeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompactBlockRangeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompactBlockRangeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CompactBlockRangeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompactBlockRangeResponse.Merge(m, src)
}
func (m *CompactBlockRangeResponse) XXX_Size() int {
	return m.Size()
}
func (m *CompactBlockRangeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CompactBlockRangeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CompactBlockRangeResponse proto.InternalMessageInfo

func (m *CompactBlockRangeResponse) GetCompactBlock() *CompactBlock {
	if m != nil {
		return m.CompactBlock
	}
	return nil
}

type CompactBlockRequest struct {
	Height uint64 `protobuf:"varint,1,opt,name=height,proto3" json:"height,omitempty"`
}

func (m *CompactBlockRequest) Reset()         { *m = CompactBlockRequest{} }
func (m *CompactBlockRequest) String() string { return proto.CompactTextString(m) }
func (*CompactBlockRequest) ProtoMessage()    {}
func (*CompactBlockRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5be1c543aaa156af, []int{4}
}
func (m *CompactBlockRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompactBlockRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompactBlockRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CompactBlockRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompactBlockRequest.Merge(m, src)
}
func (m *CompactBlockRequest) XXX_Size() int {
	return m.Size()
}
func (m *CompactBlockRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CompactBlockRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CompactBlockRequest proto.InternalMessageInfo

func (m *CompactBlockRequest) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

type CompactBlockResponse struct {
	CompactBlock *CompactBlock `protobuf:"bytes,1,opt,name=compact_block,json=compactBlock,proto3" json:"compact_block,omitempty"`
}

func (m *CompactBlockResponse) Reset()         { *m = CompactBlockResponse{} }
func (m *CompactBlockResponse) String() string { return proto.CompactTextString(m) }
func (*CompactBlockResponse) ProtoMessage()    {}
func (*CompactBlockResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5be1c543aaa156af, []int{5}
}
func (m *CompactBlockResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompactBlockResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompactBlockResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CompactBlockResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompactBlockResponse.Merge(m, src)
}
func (m *CompactBlockResponse) XXX_Size() int {
	return m.Size()
}
func (m *CompactBlockResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CompactBlockResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CompactBlockResponse proto.InternalMessageInfo

func (m *CompactBlockResponse) GetCompactBlock() *CompactBlock {
	if m != nil {
		return m.CompactBlock
	}
	return nil
}

func init() {
	proto.RegisterType((*CompactBlock)(nil), "penumbra.core.component.compact_block.v1.CompactBlock")
	proto.RegisterType((*StatePayload)(nil), "penumbra.core.component.compact_block.v1.StatePayload")
	proto.RegisterType((*StatePayload_RolledUp)(nil), "penumbra.core.component.compact_block.v1.StatePayload.RolledUp")
	proto.RegisterType((*StatePayload_Note)(nil), "penumbra.core.component.compact_block.v1.StatePayload.Note")
	proto.RegisterType((*StatePayload_Swap)(nil), "penumbra.core.component.compact_block.v1.StatePayload.Swap")
	proto.RegisterType((*CompactBlockRangeRequest)(nil), "penumbra.core.component.compact_block.v1.CompactBlockRangeRequest")
	proto.RegisterType((*CompactBlockRangeResponse)(nil), "penumbra.core.component.compact_block.v1.CompactBlockRangeResponse")
	proto.RegisterType((*CompactBlockRequest)(nil), "penumbra.core.component.compact_block.v1.CompactBlockRequest")
	proto.RegisterType((*CompactBlockResponse)(nil), "penumbra.core.component.compact_block.v1.CompactBlockResponse")
}

func init() {
	proto.RegisterFile("penumbra/core/component/compact_block/v1/compact_block.proto", fileDescriptor_5be1c543aaa156af)
}

var fileDescriptor_5be1c543aaa156af = []byte{
	// 1020 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x96, 0x4f, 0x6f, 0xe3, 0xc4,
	0x1b, 0xc7, 0xeb, 0x34, 0xbf, 0xfe, 0x9a, 0x49, 0xda, 0x85, 0x61, 0xb5, 0x32, 0x95, 0x08, 0x25,
	0x97, 0xcd, 0x6a, 0xc1, 0x59, 0xb7, 0xfc, 0x91, 0xba, 0xc0, 0x6a, 0x13, 0x44, 0xd3, 0xc3, 0xee,
	0xa6, 0x8e, 0xb6, 0x07, 0x08, 0x6b, 0x4d, 0xed, 0x27, 0x89, 0x55, 0xdb, 0x33, 0x78, 0xc6, 0xde,
	0x56, 0x5c, 0x78, 0x03, 0x48, 0xbc, 0x02, 0x0e, 0x1c, 0xe1, 0x45, 0x70, 0x45, 0x9c, 0xf6, 0xc8,
	0x71, 0xd5, 0xde, 0x78, 0x15, 0x68, 0xc6, 0x76, 0x62, 0xb3, 0x44, 0x0d, 0x41, 0xe2, 0x62, 0xcd,
	0x3c, 0x7e, 0xbe, 0x9f, 0x79, 0x9e, 0x67, 0xe6, 0x19, 0x1b, 0x7d, 0xcc, 0x20, 0x8c, 0x83, 0xd3,
	0x88, 0x74, 0x1c, 0x1a, 0x41, 0xc7, 0xa1, 0x01, 0xa3, 0x21, 0x84, 0x42, 0x8d, 0x88, 0x23, 0xec,
	0x53, 0x9f, 0x3a, 0x67, 0x9d, 0xc4, 0x2c, 0x1b, 0x0c, 0x16, 0x51, 0x41, 0x71, 0x3b, 0x57, 0x1b,
	0x52, 0x6d, 0xcc, 0xd4, 0x46, 0xd9, 0x39, 0x31, 0x77, 0xda, 0x8b, 0xd6, 0x71, 0xe1, 0x5c, 0xd2,
	0x5d, 0x38, 0x4f, 0x99, 0x8b, 0x3d, 0xc7, 0x00, 0xd2, 0x73, 0x0c, 0x70, 0x9d, 0x27, 0x77, 0x84,
	0xf4, 0xe4, 0x8e, 0xc8, 0x3c, 0x17, 0x66, 0xc9, 0xa7, 0x1e, 0xf8, 0x2e, 0xb8, 0x36, 0xa3, 0xd4,
	0x57, 0x9a, 0xa2, 0x21, 0x53, 0xef, 0xce, 0xd5, 0xd1, 0x05, 0x13, 0xb4, 0x23, 0x52, 0xbe, 0xc8,
	0xf9, 0xad, 0x9f, 0x37, 0x50, 0xa3, 0x97, 0xa6, 0xdc, 0x95, 0x19, 0xe3, 0x5b, 0x68, 0x63, 0x0a,
	0xde, 0x64, 0x2a, 0x74, 0x6d, 0x57, 0x6b, 0x57, 0xad, 0x6c, 0x86, 0xbf, 0x42, 0xdb, 0x5c, 0x10,
	0x01, 0x36, 0x23, 0x17, 0x3e, 0x25, 0x2e, 0xd7, 0x2b, 0xbb, 0xeb, 0xed, 0xfa, 0xde, 0x87, 0xc6,
	0xb2, 0x95, 0x34, 0x86, 0x52, 0x3f, 0x48, 0xe5, 0xd6, 0x16, 0x2f, 0xcc, 0x38, 0x3e, 0x42, 0x28,
	0x8c, 0x7d, 0xdf, 0x1b, 0x7b, 0x10, 0x71, 0x7d, 0x5d, 0xa1, 0xef, 0x2c, 0x44, 0xcb, 0xfa, 0x24,
	0xa6, 0xf1, 0x38, 0x57, 0x58, 0x05, 0x31, 0x7e, 0x88, 0x90, 0x5a, 0xd2, 0x8e, 0x28, 0x15, 0x7a,
	0x75, 0x57, 0x6b, 0xd7, 0xf7, 0x5a, 0x05, 0x94, 0xaa, 0x84, 0x21, 0x52, 0xc4, 0x23, 0x88, 0xce,
	0x7c, 0xb0, 0x28, 0x15, 0x56, 0x4d, 0xa9, 0xe4, 0x50, 0x22, 0x80, 0x51, 0x67, 0x9a, 0x22, 0xfe,
	0xb7, 0x3c, 0x42, 0xa9, 0x14, 0xe2, 0x0e, 0x7a, 0x8d, 0x45, 0x94, 0x51, 0x4e, 0x7c, 0x9b, 0x0b,
	0x12, 0x09, 0x70, 0xf5, 0x8d, 0x5d, 0xad, 0xbd, 0x69, 0xdd, 0xc8, 0xed, 0xc3, 0xd4, 0x8c, 0x9f,
	0xa1, 0xed, 0x71, 0xe0, 0xda, 0x8c, 0x44, 0x24, 0x00, 0x21, 0xf3, 0xff, 0xbf, 0x5a, 0xf1, 0xa3,
	0xc5, 0xf9, 0x97, 0xf6, 0x3a, 0x31, 0x8d, 0xcf, 0x03, 0x77, 0x30, 0x93, 0x5b, 0x5b, 0xe3, 0xe2,
	0x14, 0x9f, 0xa0, 0x06, 0x7f, 0x4e, 0x98, 0x4d, 0x63, 0xc1, 0x62, 0xc1, 0xf5, 0x4d, 0x55, 0xdd,
	0xfd, 0x85, 0x74, 0x79, 0xa2, 0x13, 0xd3, 0xe8, 0x12, 0xe1, 0x4c, 0x87, 0xcf, 0x09, 0x7b, 0xa2,
	0x74, 0x9f, 0x11, 0x41, 0xac, 0x3a, 0x9f, 0xcd, 0x39, 0x7e, 0x1f, 0xdd, 0x22, 0x8c, 0x15, 0xe2,
	0xb6, 0x63, 0xe6, 0x12, 0x99, 0x68, 0x4d, 0x25, 0x7a, 0x93, 0x30, 0x36, 0x0f, 0xe3, 0x69, 0xfa,
	0x0e, 0xf7, 0x11, 0x9a, 0x10, 0x6e, 0xb3, 0xc8, 0x73, 0x80, 0xeb, 0x48, 0x65, 0xba, 0x78, 0xa7,
	0x65, 0xcf, 0x24, 0xa6, 0x71, 0x48, 0xf8, 0x40, 0x09, 0xac, 0xda, 0x24, 0x1f, 0xe2, 0x27, 0x68,
	0x9b, 0xf8, 0xc2, 0x2e, 0xd0, 0xdc, 0x6b, 0xce, 0xcd, 0x2b, 0xb4, 0x06, 0xf1, 0xc5, 0x6c, 0x86,
	0xdf, 0x46, 0xf5, 0x74, 0xdb, 0xbd, 0xd0, 0x85, 0x73, 0xbd, 0xae, 0x1a, 0x20, 0x3d, 0x09, 0x47,
	0xd2, 0xd2, 0x7a, 0x59, 0x45, 0x8d, 0xe2, 0x29, 0xc6, 0x7d, 0xb4, 0xc1, 0x69, 0x1c, 0x39, 0xa0,
	0xba, 0xa5, 0xbe, 0x77, 0xef, 0xba, 0x23, 0xdb, 0xa3, 0x41, 0xe0, 0x89, 0x00, 0x42, 0x31, 0x54,
	0x3a, 0x2b, 0xd3, 0xe3, 0x67, 0xa8, 0x16, 0x51, 0xdf, 0x07, 0xd7, 0x8e, 0x99, 0x5e, 0x51, 0xb0,
	0x07, 0xab, 0xb5, 0x96, 0x61, 0x29, 0xce, 0x53, 0xd6, 0x5f, 0xb3, 0x36, 0xa3, 0x6c, 0x8c, 0x8f,
	0x51, 0x35, 0xa4, 0x02, 0xf4, 0x75, 0x85, 0xbe, 0xbf, 0x22, 0xfa, 0x31, 0x15, 0xd0, 0x5f, 0xb3,
	0x14, 0x4a, 0x22, 0xe5, 0x71, 0xc8, 0x5a, 0x6c, 0x55, 0xa4, 0x3c, 0x61, 0x12, 0x29, 0x51, 0x3b,
	0x43, 0xb4, 0x99, 0x47, 0x8f, 0x0f, 0x11, 0x72, 0x66, 0xd5, 0xca, 0xea, 0x7b, 0x7b, 0x51, 0x13,
	0x2a, 0xe4, 0xbc, 0xb8, 0x56, 0x41, 0xba, 0x73, 0x8c, 0xaa, 0x32, 0x6e, 0x7c, 0x94, 0x95, 0x20,
	0xad, 0xee, 0x07, 0xcb, 0x77, 0x97, 0x54, 0xe7, 0xf7, 0x96, 0x42, 0xec, 0x1c, 0xa2, 0xaa, 0x8c,
	0x1b, 0x3f, 0xc8, 0x4a, 0x90, 0x22, 0xef, 0x5e, 0xd7, 0x52, 0x52, 0x33, 0x03, 0x49, 0x61, 0xf7,
	0x06, 0xda, 0x2a, 0x5d, 0xab, 0xad, 0x6f, 0x90, 0x5e, 0xbc, 0x8f, 0x2d, 0x12, 0x4e, 0xc0, 0x82,
	0xaf, 0x63, 0xe0, 0x02, 0xbf, 0x83, 0x1a, 0xea, 0x2a, 0xb1, 0xb3, 0x1b, 0xba, 0xa2, 0x0e, 0x68,
	0x5d, 0xd9, 0xfa, 0xe9, 0x35, 0xfd, 0x16, 0x42, 0x10, 0xba, 0xb9, 0xc3, 0xba, 0x72, 0xa8, 0x41,
	0xe8, 0xce, 0x5f, 0x9f, 0x01, 0x30, 0x9b, 0xf8, 0x5e, 0x02, 0x6a, 0xe3, 0x36, 0xad, 0x9a, 0xb4,
	0x3c, 0x94, 0x86, 0xd6, 0x39, 0x7a, 0xf3, 0x6f, 0x16, 0xe7, 0x8c, 0x86, 0x1c, 0xf0, 0x97, 0x68,
	0xab, 0xb4, 0x93, 0xd9, 0x96, 0xfc, 0x83, 0x0f, 0x40, 0x89, 0xdd, 0x70, 0x0a, 0xb3, 0xd6, 0x7b,
	0xe8, 0x8d, 0xd2, 0xdb, 0x2c, 0xe3, 0x05, 0x5f, 0xa3, 0x16, 0x47, 0x37, 0xcb, 0xee, 0xff, 0x41,
	0x8c, 0x7b, 0xbf, 0x54, 0x50, 0xe3, 0x38, 0x86, 0xe8, 0x62, 0x08, 0x51, 0xe2, 0x39, 0x80, 0x7f,
	0xd0, 0xd0, 0xeb, 0xaf, 0xd4, 0x0b, 0x77, 0x57, 0x5c, 0xac, 0xb0, 0xd3, 0x3b, 0xbd, 0x7f, 0xc5,
	0x48, 0x8b, 0x71, 0x4f, 0xc3, 0xdf, 0x69, 0x7f, 0xf9, 0xba, 0x7f, 0xb2, 0x22, 0x37, 0x0b, 0xeb,
	0xd3, 0x55, 0xe5, 0x69, 0x44, 0xdd, 0x6f, 0xd7, 0x7f, 0xbd, 0x6c, 0x6a, 0x2f, 0x2e, 0x9b, 0xda,
	0xcb, 0xcb, 0xa6, 0xf6, 0xfd, 0x55, 0x73, 0xed, 0xc5, 0x55, 0x73, 0xed, 0xf7, 0xab, 0xe6, 0x1a,
	0x7a, 0xd7, 0xa1, 0xc1, 0xd2, 0xf4, 0x6e, 0xa9, 0xec, 0x03, 0xf9, 0x27, 0x33, 0xd0, 0xbe, 0x70,
	0x27, 0x9e, 0x98, 0xc6, 0xa7, 0xd2, 0xbb, 0xe3, 0x50, 0x1e, 0x50, 0xde, 0x89, 0xc0, 0x27, 0x17,
	0x10, 0x75, 0x92, 0xbd, 0xd9, 0xd0, 0x99, 0x12, 0x2f, 0xe4, 0x9d, 0x65, 0xff, 0x1e, 0xef, 0x97,
	0x0c, 0x89, 0xf9, 0x63, 0xa5, 0x3a, 0xe8, 0xf5, 0x7a, 0x3f, 0x55, 0x6e, 0x0f, 0xf2, 0x60, 0x7b,
	0x32, 0xd8, 0xde, 0x2c, 0xd8, 0x62, 0x68, 0xc6, 0x89, 0xf9, 0xdb, 0xdc, 0x73, 0x24, 0x3d, 0x47,
	0x33, 0xcf, 0x51, 0xd1, 0x73, 0x74, 0x62, 0x5e, 0x56, 0xf6, 0x97, 0xf4, 0x1c, 0x1d, 0x0e, 0xba,
	0x8f, 0x40, 0x10, 0x97, 0x08, 0xf2, 0x47, 0xe5, 0x6e, 0xae, 0x3a, 0x38, 0x90, 0x32, 0xf9, 0xcc,
	0x74, 0xe9, 0x30, 0x17, 0x1e, 0x1c, 0x9c, 0x98, 0xa7, 0x1b, 0xea, 0xbf, 0x6f, 0xff, 0xcf, 0x00,
	0x00, 0x00, 0xff, 0xff, 0x51, 0x2b, 0x46, 0xab, 0x3f, 0x0b, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QueryServiceClient is the client API for QueryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryServiceClient interface {
	// Returns a stream of compact blocks, optionally keeping the stream alive for push notifications.
	CompactBlockRange(ctx context.Context, in *CompactBlockRangeRequest, opts ...grpc.CallOption) (QueryService_CompactBlockRangeClient, error)
	// Returns a single compact block at a specific height.
	//
	// Clients requesting multiple compact blocks should generally use the streaming RPC.
	CompactBlock(ctx context.Context, in *CompactBlockRequest, opts ...grpc.CallOption) (*CompactBlockResponse, error)
}

type queryServiceClient struct {
	cc grpc1.ClientConn
}

func NewQueryServiceClient(cc grpc1.ClientConn) QueryServiceClient {
	return &queryServiceClient{cc}
}

func (c *queryServiceClient) CompactBlockRange(ctx context.Context, in *CompactBlockRangeRequest, opts ...grpc.CallOption) (QueryService_CompactBlockRangeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_QueryService_serviceDesc.Streams[0], "/penumbra.core.component.compact_block.v1.QueryService/CompactBlockRange", opts...)
	if err != nil {
		return nil, err
	}
	x := &queryServiceCompactBlockRangeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type QueryService_CompactBlockRangeClient interface {
	Recv() (*CompactBlockRangeResponse, error)
	grpc.ClientStream
}

type queryServiceCompactBlockRangeClient struct {
	grpc.ClientStream
}

func (x *queryServiceCompactBlockRangeClient) Recv() (*CompactBlockRangeResponse, error) {
	m := new(CompactBlockRangeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queryServiceClient) CompactBlock(ctx context.Context, in *CompactBlockRequest, opts ...grpc.CallOption) (*CompactBlockResponse, error) {
	out := new(CompactBlockResponse)
	err := c.cc.Invoke(ctx, "/penumbra.core.component.compact_block.v1.QueryService/CompactBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueryServiceServer is the server API for QueryService service.
type QueryServiceServer interface {
	// Returns a stream of compact blocks, optionally keeping the stream alive for push notifications.
	CompactBlockRange(*CompactBlockRangeRequest, QueryService_CompactBlockRangeServer) error
	// Returns a single compact block at a specific height.
	//
	// Clients requesting multiple compact blocks should generally use the streaming RPC.
	CompactBlock(context.Context, *CompactBlockRequest) (*CompactBlockResponse, error)
}

// UnimplementedQueryServiceServer can be embedded to have forward compatible implementations.
type UnimplementedQueryServiceServer struct {
}

func (*UnimplementedQueryServiceServer) CompactBlockRange(req *CompactBlockRangeRequest, srv QueryService_CompactBlockRangeServer) error {
	return status.Errorf(codes.Unimplemented, "method CompactBlockRange not implemented")
}
func (*UnimplementedQueryServiceServer) CompactBlock(ctx context.Context, req *CompactBlockRequest) (*CompactBlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CompactBlock not implemented")
}

func RegisterQueryServiceServer(s grpc1.Server, srv QueryServiceServer) {
	s.RegisterService(&_QueryService_serviceDesc, srv)
}

func _QueryService_CompactBlockRange_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CompactBlockRangeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryServiceServer).CompactBlockRange(m, &queryServiceCompactBlockRangeServer{stream})
}

type QueryService_CompactBlockRangeServer interface {
	Send(*CompactBlockRangeResponse) error
	grpc.ServerStream
}

type queryServiceCompactBlockRangeServer struct {
	grpc.ServerStream
}

func (x *queryServiceCompactBlockRangeServer) Send(m *CompactBlockRangeResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _QueryService_CompactBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompactBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServiceServer).CompactBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/penumbra.core.component.compact_block.v1.QueryService/CompactBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServiceServer).CompactBlock(ctx, req.(*CompactBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _QueryService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "penumbra.core.component.compact_block.v1.QueryService",
	HandlerType: (*QueryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CompactBlock",
			Handler:    _QueryService_CompactBlock_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "CompactBlockRange",
			Handler:       _QueryService_CompactBlockRange_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "penumbra/core/component/compact_block/v1/compact_block.proto",
}

func (m *CompactBlock) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompactBlock) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompactBlock) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AltGasPrices) > 0 {
		for iNdEx := len(m.AltGasPrices) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AltGasPrices[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCompactBlock(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.EpochIndex != 0 {
		i = encodeVarintCompactBlock(dAtA, i, uint64(m.EpochIndex))
		i--
		dAtA[i] = 0x58
	}
	if m.GasPrices != nil {
		{
			size, err := m.GasPrices.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCompactBlock(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.AppParametersUpdated {
		i--
		if m.AppParametersUpdated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.SwapOutputs) > 0 {
		for iNdEx := len(m.SwapOutputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SwapOutputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCompactBlock(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.FmdParameters != nil {
		{
			size, err := m.FmdParameters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCompactBlock(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.ProposalStarted {
		i--
		if m.ProposalStarted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.EpochRoot != nil {
		{
			size, err := m.EpochRoot.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCompactBlock(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.BlockRoot != nil {
		{
			size, err := m.BlockRoot.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCompactBlock(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Nullifiers) > 0 {
		for iNdEx := len(m.Nullifiers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nullifiers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCompactBlock(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.StatePayloads) > 0 {
		for iNdEx := len(m.StatePayloads) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StatePayloads[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCompactBlock(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Height != 0 {
		i = encodeVarintCompactBlock(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StatePayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatePayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatePayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StatePayload != nil {
		{
			size := m.StatePayload.Size()
			i -= size
			if _, err := m.StatePayload.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Source != nil {
		{
			size, err := m.Source.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCompactBlock(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StatePayload_RolledUp_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatePayload_RolledUp_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RolledUp != nil {
		{
			size, err := m.RolledUp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCompactBlock(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *StatePayload_Note_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatePayload_Note_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Note != nil {
		{
			size, err := m.Note.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCompactBlock(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *StatePayload_Swap_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatePayload_Swap_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Swap != nil {
		{
			size, err := m.Swap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCompactBlock(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *StatePayload_RolledUp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatePayload_RolledUp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatePayload_RolledUp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Commitment != nil {
		{
			size, err := m.Commitment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCompactBlock(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StatePayload_Note) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatePayload_Note) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatePayload_Note) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Note != nil {
		{
			size, err := m.Note.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCompactBlock(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *StatePayload_Swap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatePayload_Swap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatePayload_Swap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Swap != nil {
		{
			size, err := m.Swap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCompactBlock(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *CompactBlockRangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompactBlockRangeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompactBlockRangeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.KeepAlive {
		i--
		if m.KeepAlive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.EndHeight != 0 {
		i = encodeVarintCompactBlock(dAtA, i, uint64(m.EndHeight))
		i--
		dAtA[i] = 0x18
	}
	if m.StartHeight != 0 {
		i = encodeVarintCompactBlock(dAtA, i, uint64(m.StartHeight))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *CompactBlockRangeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompactBlockRangeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompactBlockRangeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CompactBlock != nil {
		{
			size, err := m.CompactBlock.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCompactBlock(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CompactBlockRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompactBlockRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompactBlockRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Height != 0 {
		i = encodeVarintCompactBlock(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CompactBlockResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompactBlockResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompactBlockResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CompactBlock != nil {
		{
			size, err := m.CompactBlock.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCompactBlock(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintCompactBlock(dAtA []byte, offset int, v uint64) int {
	offset -= sovCompactBlock(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CompactBlock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovCompactBlock(uint64(m.Height))
	}
	if len(m.StatePayloads) > 0 {
		for _, e := range m.StatePayloads {
			l = e.Size()
			n += 1 + l + sovCompactBlock(uint64(l))
		}
	}
	if len(m.Nullifiers) > 0 {
		for _, e := range m.Nullifiers {
			l = e.Size()
			n += 1 + l + sovCompactBlock(uint64(l))
		}
	}
	if m.BlockRoot != nil {
		l = m.BlockRoot.Size()
		n += 1 + l + sovCompactBlock(uint64(l))
	}
	if m.EpochRoot != nil {
		l = m.EpochRoot.Size()
		n += 1 + l + sovCompactBlock(uint64(l))
	}
	if m.ProposalStarted {
		n += 2
	}
	if m.FmdParameters != nil {
		l = m.FmdParameters.Size()
		n += 1 + l + sovCompactBlock(uint64(l))
	}
	if len(m.SwapOutputs) > 0 {
		for _, e := range m.SwapOutputs {
			l = e.Size()
			n += 1 + l + sovCompactBlock(uint64(l))
		}
	}
	if m.AppParametersUpdated {
		n += 2
	}
	if m.GasPrices != nil {
		l = m.GasPrices.Size()
		n += 1 + l + sovCompactBlock(uint64(l))
	}
	if m.EpochIndex != 0 {
		n += 1 + sovCompactBlock(uint64(m.EpochIndex))
	}
	if len(m.AltGasPrices) > 0 {
		for _, e := range m.AltGasPrices {
			l = e.Size()
			n += 2 + l + sovCompactBlock(uint64(l))
		}
	}
	return n
}

func (m *StatePayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovCompactBlock(uint64(l))
	}
	if m.StatePayload != nil {
		n += m.StatePayload.Size()
	}
	return n
}

func (m *StatePayload_RolledUp_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RolledUp != nil {
		l = m.RolledUp.Size()
		n += 1 + l + sovCompactBlock(uint64(l))
	}
	return n
}
func (m *StatePayload_Note_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Note != nil {
		l = m.Note.Size()
		n += 1 + l + sovCompactBlock(uint64(l))
	}
	return n
}
func (m *StatePayload_Swap_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Swap != nil {
		l = m.Swap.Size()
		n += 1 + l + sovCompactBlock(uint64(l))
	}
	return n
}
func (m *StatePayload_RolledUp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commitment != nil {
		l = m.Commitment.Size()
		n += 1 + l + sovCompactBlock(uint64(l))
	}
	return n
}

func (m *StatePayload_Note) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Note != nil {
		l = m.Note.Size()
		n += 1 + l + sovCompactBlock(uint64(l))
	}
	return n
}

func (m *StatePayload_Swap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Swap != nil {
		l = m.Swap.Size()
		n += 1 + l + sovCompactBlock(uint64(l))
	}
	return n
}

func (m *CompactBlockRangeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartHeight != 0 {
		n += 1 + sovCompactBlock(uint64(m.StartHeight))
	}
	if m.EndHeight != 0 {
		n += 1 + sovCompactBlock(uint64(m.EndHeight))
	}
	if m.KeepAlive {
		n += 2
	}
	return n
}

func (m *CompactBlockRangeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CompactBlock != nil {
		l = m.CompactBlock.Size()
		n += 1 + l + sovCompactBlock(uint64(l))
	}
	return n
}

func (m *CompactBlockRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovCompactBlock(uint64(m.Height))
	}
	return n
}

func (m *CompactBlockResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CompactBlock != nil {
		l = m.CompactBlock.Size()
		n += 1 + l + sovCompactBlock(uint64(l))
	}
	return n
}

func sovCompactBlock(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCompactBlock(x uint64) (n int) {
	return sovCompactBlock(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CompactBlock) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCompactBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompactBlock: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompactBlock: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompactBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatePayloads", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompactBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompactBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompactBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatePayloads = append(m.StatePayloads, &StatePayload{})
			if err := m.StatePayloads[len(m.StatePayloads)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nullifiers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompactBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompactBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompactBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nullifiers = append(m.Nullifiers, &v1.Nullifier{})
			if err := m.Nullifiers[len(m.Nullifiers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockRoot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompactBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompactBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompactBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BlockRoot == nil {
				m.BlockRoot = &v11.MerkleRoot{}
			}
			if err := m.BlockRoot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochRoot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompactBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompactBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompactBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EpochRoot == nil {
				m.EpochRoot = &v11.MerkleRoot{}
			}
			if err := m.EpochRoot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalStarted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompactBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ProposalStarted = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FmdParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompactBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompactBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompactBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FmdParameters == nil {
				m.FmdParameters = &v12.FmdParameters{}
			}
			if err := m.FmdParameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapOutputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompactBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompactBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompactBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SwapOutputs = append(m.SwapOutputs, &v13.BatchSwapOutputData{})
			if err := m.SwapOutputs[len(m.SwapOutputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppParametersUpdated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompactBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AppParametersUpdated = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasPrices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompactBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompactBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompactBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GasPrices == nil {
				m.GasPrices = &v14.GasPrices{}
			}
			if err := m.GasPrices.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochIndex", wireType)
			}
			m.EpochIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompactBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AltGasPrices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompactBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompactBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompactBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AltGasPrices = append(m.AltGasPrices, &v14.GasPrices{})
			if err := m.AltGasPrices[len(m.AltGasPrices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCompactBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCompactBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatePayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCompactBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatePayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatePayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompactBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompactBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompactBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &v1.CommitmentSource{}
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RolledUp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompactBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompactBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompactBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StatePayload_RolledUp{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StatePayload = &StatePayload_RolledUp_{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Note", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompactBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompactBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompactBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StatePayload_Note{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StatePayload = &StatePayload_Note_{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Swap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompactBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompactBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompactBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StatePayload_Swap{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StatePayload = &StatePayload_Swap_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCompactBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCompactBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatePayload_RolledUp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCompactBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RolledUp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RolledUp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompactBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompactBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompactBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commitment == nil {
				m.Commitment = &v11.StateCommitment{}
			}
			if err := m.Commitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCompactBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCompactBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatePayload_Note) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCompactBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Note: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Note: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Note", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompactBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompactBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompactBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Note == nil {
				m.Note = &v12.NotePayload{}
			}
			if err := m.Note.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCompactBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCompactBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatePayload_Swap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCompactBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Swap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Swap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Swap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompactBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompactBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompactBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Swap == nil {
				m.Swap = &v13.SwapPayload{}
			}
			if err := m.Swap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCompactBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCompactBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompactBlockRangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCompactBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompactBlockRangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompactBlockRangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartHeight", wireType)
			}
			m.StartHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompactBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndHeight", wireType)
			}
			m.EndHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompactBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeepAlive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompactBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.KeepAlive = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCompactBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCompactBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompactBlockRangeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCompactBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompactBlockRangeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompactBlockRangeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactBlock", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompactBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompactBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompactBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompactBlock == nil {
				m.CompactBlock = &CompactBlock{}
			}
			if err := m.CompactBlock.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCompactBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCompactBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompactBlockRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCompactBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompactBlockRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompactBlockRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompactBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCompactBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCompactBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompactBlockResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCompactBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompactBlockResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompactBlockResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactBlock", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompactBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompactBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompactBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompactBlock == nil {
				m.CompactBlock = &CompactBlock{}
			}
			if err := m.CompactBlock.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCompactBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCompactBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCompactBlock(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCompactBlock
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCompactBlock
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCompactBlock
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCompactBlock
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCompactBlock
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCompactBlock
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCompactBlock        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCompactBlock          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCompactBlock = fmt.Errorf("proto: unexpected end of group")
)
