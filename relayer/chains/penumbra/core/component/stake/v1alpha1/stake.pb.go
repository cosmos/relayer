// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: penumbra/core/component/stake/v1alpha1/stake.proto

package stakev1alpha1

import (
	context "context"
	fmt "fmt"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	v1alpha12 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/asset/v1alpha1"
	v1alpha1 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/keys/v1alpha1"
	v1alpha11 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/num/v1alpha1"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type BondingState_BondingStateEnum int32

const (
	BondingState_BONDING_STATE_ENUM_UNSPECIFIED BondingState_BondingStateEnum = 0
	BondingState_BONDING_STATE_ENUM_BONDED      BondingState_BondingStateEnum = 1
	BondingState_BONDING_STATE_ENUM_UNBONDING   BondingState_BondingStateEnum = 2
	BondingState_BONDING_STATE_ENUM_UNBONDED    BondingState_BondingStateEnum = 3
)

var BondingState_BondingStateEnum_name = map[int32]string{
	0: "BONDING_STATE_ENUM_UNSPECIFIED",
	1: "BONDING_STATE_ENUM_BONDED",
	2: "BONDING_STATE_ENUM_UNBONDING",
	3: "BONDING_STATE_ENUM_UNBONDED",
}

var BondingState_BondingStateEnum_value = map[string]int32{
	"BONDING_STATE_ENUM_UNSPECIFIED": 0,
	"BONDING_STATE_ENUM_BONDED":      1,
	"BONDING_STATE_ENUM_UNBONDING":   2,
	"BONDING_STATE_ENUM_UNBONDED":    3,
}

func (x BondingState_BondingStateEnum) String() string {
	return proto.EnumName(BondingState_BondingStateEnum_name, int32(x))
}

func (BondingState_BondingStateEnum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b49c30b9d712baf6, []int{7, 0}
}

type ValidatorState_ValidatorStateEnum int32

const (
	ValidatorState_VALIDATOR_STATE_ENUM_UNSPECIFIED ValidatorState_ValidatorStateEnum = 0
	ValidatorState_VALIDATOR_STATE_ENUM_INACTIVE    ValidatorState_ValidatorStateEnum = 1
	ValidatorState_VALIDATOR_STATE_ENUM_ACTIVE      ValidatorState_ValidatorStateEnum = 2
	ValidatorState_VALIDATOR_STATE_ENUM_JAILED      ValidatorState_ValidatorStateEnum = 3
	ValidatorState_VALIDATOR_STATE_ENUM_TOMBSTONED  ValidatorState_ValidatorStateEnum = 4
	ValidatorState_VALIDATOR_STATE_ENUM_DISABLED    ValidatorState_ValidatorStateEnum = 5
)

var ValidatorState_ValidatorStateEnum_name = map[int32]string{
	0: "VALIDATOR_STATE_ENUM_UNSPECIFIED",
	1: "VALIDATOR_STATE_ENUM_INACTIVE",
	2: "VALIDATOR_STATE_ENUM_ACTIVE",
	3: "VALIDATOR_STATE_ENUM_JAILED",
	4: "VALIDATOR_STATE_ENUM_TOMBSTONED",
	5: "VALIDATOR_STATE_ENUM_DISABLED",
}

var ValidatorState_ValidatorStateEnum_value = map[string]int32{
	"VALIDATOR_STATE_ENUM_UNSPECIFIED": 0,
	"VALIDATOR_STATE_ENUM_INACTIVE":    1,
	"VALIDATOR_STATE_ENUM_ACTIVE":      2,
	"VALIDATOR_STATE_ENUM_JAILED":      3,
	"VALIDATOR_STATE_ENUM_TOMBSTONED":  4,
	"VALIDATOR_STATE_ENUM_DISABLED":    5,
}

func (x ValidatorState_ValidatorStateEnum) String() string {
	return proto.EnumName(ValidatorState_ValidatorStateEnum_name, int32(x))
}

func (ValidatorState_ValidatorStateEnum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b49c30b9d712baf6, []int{8, 0}
}

// A Penumbra ZK undelegate claim proof.
type ZKUndelegateClaimProof struct {
	Inner []byte `protobuf:"bytes,1,opt,name=inner,proto3" json:"inner,omitempty"`
}

func (m *ZKUndelegateClaimProof) Reset()         { *m = ZKUndelegateClaimProof{} }
func (m *ZKUndelegateClaimProof) String() string { return proto.CompactTextString(m) }
func (*ZKUndelegateClaimProof) ProtoMessage()    {}
func (*ZKUndelegateClaimProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_b49c30b9d712baf6, []int{0}
}
func (m *ZKUndelegateClaimProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZKUndelegateClaimProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZKUndelegateClaimProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZKUndelegateClaimProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZKUndelegateClaimProof.Merge(m, src)
}
func (m *ZKUndelegateClaimProof) XXX_Size() int {
	return m.Size()
}
func (m *ZKUndelegateClaimProof) XXX_DiscardUnknown() {
	xxx_messageInfo_ZKUndelegateClaimProof.DiscardUnknown(m)
}

var xxx_messageInfo_ZKUndelegateClaimProof proto.InternalMessageInfo

func (m *ZKUndelegateClaimProof) GetInner() []byte {
	if m != nil {
		return m.Inner
	}
	return nil
}

// Describes a validator's configuration data.
type Validator struct {
	// The validator's identity verification key.
	IdentityKey *v1alpha1.IdentityKey `protobuf:"bytes,1,opt,name=identity_key,json=identityKey,proto3" json:"identity_key,omitempty"`
	// The validator's consensus pubkey for use in Tendermint (Ed25519).
	ConsensusKey []byte `protobuf:"bytes,2,opt,name=consensus_key,json=consensusKey,proto3" json:"consensus_key,omitempty"`
	// The validator's (human-readable) name.
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// The validator's website.
	Website string `protobuf:"bytes,4,opt,name=website,proto3" json:"website,omitempty"`
	// The validator's description.
	Description string `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	// Whether the validator is enabled or not.
	//
	// Disabled validators cannot be delegated to, and immediately begin unbonding.
	Enabled bool `protobuf:"varint,8,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// A list of funding streams describing the validator's commission.
	FundingStreams []*FundingStream `protobuf:"bytes,6,rep,name=funding_streams,json=fundingStreams,proto3" json:"funding_streams,omitempty"`
	// The sequence number determines which validator data takes priority, and
	// prevents replay attacks.  The chain only accepts new validator definitions
	// with increasing sequence numbers.
	SequenceNumber uint32 `protobuf:"varint,7,opt,name=sequence_number,json=sequenceNumber,proto3" json:"sequence_number,omitempty"`
	// The validator's governance key.
	GovernanceKey *v1alpha1.GovernanceKey `protobuf:"bytes,9,opt,name=governance_key,json=governanceKey,proto3" json:"governance_key,omitempty"`
}

func (m *Validator) Reset()         { *m = Validator{} }
func (m *Validator) String() string { return proto.CompactTextString(m) }
func (*Validator) ProtoMessage()    {}
func (*Validator) Descriptor() ([]byte, []int) {
	return fileDescriptor_b49c30b9d712baf6, []int{1}
}
func (m *Validator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Validator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Validator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Validator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Validator.Merge(m, src)
}
func (m *Validator) XXX_Size() int {
	return m.Size()
}
func (m *Validator) XXX_DiscardUnknown() {
	xxx_messageInfo_Validator.DiscardUnknown(m)
}

var xxx_messageInfo_Validator proto.InternalMessageInfo

func (m *Validator) GetIdentityKey() *v1alpha1.IdentityKey {
	if m != nil {
		return m.IdentityKey
	}
	return nil
}

func (m *Validator) GetConsensusKey() []byte {
	if m != nil {
		return m.ConsensusKey
	}
	return nil
}

func (m *Validator) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Validator) GetWebsite() string {
	if m != nil {
		return m.Website
	}
	return ""
}

func (m *Validator) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Validator) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *Validator) GetFundingStreams() []*FundingStream {
	if m != nil {
		return m.FundingStreams
	}
	return nil
}

func (m *Validator) GetSequenceNumber() uint32 {
	if m != nil {
		return m.SequenceNumber
	}
	return 0
}

func (m *Validator) GetGovernanceKey() *v1alpha1.GovernanceKey {
	if m != nil {
		return m.GovernanceKey
	}
	return nil
}

// For storing the list of keys of known validators.
type ValidatorList struct {
	ValidatorKeys []*v1alpha1.IdentityKey `protobuf:"bytes,1,rep,name=validator_keys,json=validatorKeys,proto3" json:"validator_keys,omitempty"`
}

func (m *ValidatorList) Reset()         { *m = ValidatorList{} }
func (m *ValidatorList) String() string { return proto.CompactTextString(m) }
func (*ValidatorList) ProtoMessage()    {}
func (*ValidatorList) Descriptor() ([]byte, []int) {
	return fileDescriptor_b49c30b9d712baf6, []int{2}
}
func (m *ValidatorList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorList.Merge(m, src)
}
func (m *ValidatorList) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorList) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorList.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorList proto.InternalMessageInfo

func (m *ValidatorList) GetValidatorKeys() []*v1alpha1.IdentityKey {
	if m != nil {
		return m.ValidatorKeys
	}
	return nil
}

// A portion of a validator's commission.
type FundingStream struct {
	// The recipient of the funding stream.
	//
	// Types that are valid to be assigned to Recipient:
	//	*FundingStream_ToAddress_
	//	*FundingStream_ToDao_
	Recipient isFundingStream_Recipient `protobuf_oneof:"recipient"`
}

func (m *FundingStream) Reset()         { *m = FundingStream{} }
func (m *FundingStream) String() string { return proto.CompactTextString(m) }
func (*FundingStream) ProtoMessage()    {}
func (*FundingStream) Descriptor() ([]byte, []int) {
	return fileDescriptor_b49c30b9d712baf6, []int{3}
}
func (m *FundingStream) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FundingStream) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FundingStream.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FundingStream) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FundingStream.Merge(m, src)
}
func (m *FundingStream) XXX_Size() int {
	return m.Size()
}
func (m *FundingStream) XXX_DiscardUnknown() {
	xxx_messageInfo_FundingStream.DiscardUnknown(m)
}

var xxx_messageInfo_FundingStream proto.InternalMessageInfo

type isFundingStream_Recipient interface {
	isFundingStream_Recipient()
	MarshalTo([]byte) (int, error)
	Size() int
}

type FundingStream_ToAddress_ struct {
	ToAddress *FundingStream_ToAddress `protobuf:"bytes,1,opt,name=to_address,json=toAddress,proto3,oneof" json:"to_address,omitempty"`
}
type FundingStream_ToDao_ struct {
	ToDao *FundingStream_ToDao `protobuf:"bytes,2,opt,name=to_dao,json=toDao,proto3,oneof" json:"to_dao,omitempty"`
}

func (*FundingStream_ToAddress_) isFundingStream_Recipient() {}
func (*FundingStream_ToDao_) isFundingStream_Recipient()     {}

func (m *FundingStream) GetRecipient() isFundingStream_Recipient {
	if m != nil {
		return m.Recipient
	}
	return nil
}

func (m *FundingStream) GetToAddress() *FundingStream_ToAddress {
	if x, ok := m.GetRecipient().(*FundingStream_ToAddress_); ok {
		return x.ToAddress
	}
	return nil
}

func (m *FundingStream) GetToDao() *FundingStream_ToDao {
	if x, ok := m.GetRecipient().(*FundingStream_ToDao_); ok {
		return x.ToDao
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*FundingStream) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*FundingStream_ToAddress_)(nil),
		(*FundingStream_ToDao_)(nil),
	}
}

type FundingStream_ToAddress struct {
	// The destination address for the funding stream.
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// The portion of the staking reward for the entire delegation pool
	// allocated to this funding stream, specified in basis points.
	RateBps uint32 `protobuf:"varint,2,opt,name=rate_bps,json=rateBps,proto3" json:"rate_bps,omitempty"`
}

func (m *FundingStream_ToAddress) Reset()         { *m = FundingStream_ToAddress{} }
func (m *FundingStream_ToAddress) String() string { return proto.CompactTextString(m) }
func (*FundingStream_ToAddress) ProtoMessage()    {}
func (*FundingStream_ToAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_b49c30b9d712baf6, []int{3, 0}
}
func (m *FundingStream_ToAddress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FundingStream_ToAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FundingStream_ToAddress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FundingStream_ToAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FundingStream_ToAddress.Merge(m, src)
}
func (m *FundingStream_ToAddress) XXX_Size() int {
	return m.Size()
}
func (m *FundingStream_ToAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_FundingStream_ToAddress.DiscardUnknown(m)
}

var xxx_messageInfo_FundingStream_ToAddress proto.InternalMessageInfo

func (m *FundingStream_ToAddress) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *FundingStream_ToAddress) GetRateBps() uint32 {
	if m != nil {
		return m.RateBps
	}
	return 0
}

type FundingStream_ToDao struct {
	// The portion of the staking reward for the entire delegation pool
	// allocated to this funding stream, specified in basis points.
	RateBps uint32 `protobuf:"varint,2,opt,name=rate_bps,json=rateBps,proto3" json:"rate_bps,omitempty"`
}

func (m *FundingStream_ToDao) Reset()         { *m = FundingStream_ToDao{} }
func (m *FundingStream_ToDao) String() string { return proto.CompactTextString(m) }
func (*FundingStream_ToDao) ProtoMessage()    {}
func (*FundingStream_ToDao) Descriptor() ([]byte, []int) {
	return fileDescriptor_b49c30b9d712baf6, []int{3, 1}
}
func (m *FundingStream_ToDao) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FundingStream_ToDao) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FundingStream_ToDao.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FundingStream_ToDao) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FundingStream_ToDao.Merge(m, src)
}
func (m *FundingStream_ToDao) XXX_Size() int {
	return m.Size()
}
func (m *FundingStream_ToDao) XXX_DiscardUnknown() {
	xxx_messageInfo_FundingStream_ToDao.DiscardUnknown(m)
}

var xxx_messageInfo_FundingStream_ToDao proto.InternalMessageInfo

func (m *FundingStream_ToDao) GetRateBps() uint32 {
	if m != nil {
		return m.RateBps
	}
	return 0
}

// Describes the reward and exchange rates and voting power for a validator in some epoch.
type RateData struct {
	IdentityKey           *v1alpha1.IdentityKey `protobuf:"bytes,1,opt,name=identity_key,json=identityKey,proto3" json:"identity_key,omitempty"`
	EpochIndex            uint64                `protobuf:"varint,2,opt,name=epoch_index,json=epochIndex,proto3" json:"epoch_index,omitempty"`
	ValidatorRewardRate   uint64                `protobuf:"varint,4,opt,name=validator_reward_rate,json=validatorRewardRate,proto3" json:"validator_reward_rate,omitempty"`
	ValidatorExchangeRate uint64                `protobuf:"varint,5,opt,name=validator_exchange_rate,json=validatorExchangeRate,proto3" json:"validator_exchange_rate,omitempty"`
}

func (m *RateData) Reset()         { *m = RateData{} }
func (m *RateData) String() string { return proto.CompactTextString(m) }
func (*RateData) ProtoMessage()    {}
func (*RateData) Descriptor() ([]byte, []int) {
	return fileDescriptor_b49c30b9d712baf6, []int{4}
}
func (m *RateData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RateData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RateData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RateData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateData.Merge(m, src)
}
func (m *RateData) XXX_Size() int {
	return m.Size()
}
func (m *RateData) XXX_DiscardUnknown() {
	xxx_messageInfo_RateData.DiscardUnknown(m)
}

var xxx_messageInfo_RateData proto.InternalMessageInfo

func (m *RateData) GetIdentityKey() *v1alpha1.IdentityKey {
	if m != nil {
		return m.IdentityKey
	}
	return nil
}

func (m *RateData) GetEpochIndex() uint64 {
	if m != nil {
		return m.EpochIndex
	}
	return 0
}

func (m *RateData) GetValidatorRewardRate() uint64 {
	if m != nil {
		return m.ValidatorRewardRate
	}
	return 0
}

func (m *RateData) GetValidatorExchangeRate() uint64 {
	if m != nil {
		return m.ValidatorExchangeRate
	}
	return 0
}

// Describes the base reward and exchange rates in some epoch.
type BaseRateData struct {
	EpochIndex       uint64 `protobuf:"varint,1,opt,name=epoch_index,json=epochIndex,proto3" json:"epoch_index,omitempty"`
	BaseRewardRate   uint64 `protobuf:"varint,2,opt,name=base_reward_rate,json=baseRewardRate,proto3" json:"base_reward_rate,omitempty"`
	BaseExchangeRate uint64 `protobuf:"varint,3,opt,name=base_exchange_rate,json=baseExchangeRate,proto3" json:"base_exchange_rate,omitempty"`
}

func (m *BaseRateData) Reset()         { *m = BaseRateData{} }
func (m *BaseRateData) String() string { return proto.CompactTextString(m) }
func (*BaseRateData) ProtoMessage()    {}
func (*BaseRateData) Descriptor() ([]byte, []int) {
	return fileDescriptor_b49c30b9d712baf6, []int{5}
}
func (m *BaseRateData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BaseRateData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BaseRateData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BaseRateData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BaseRateData.Merge(m, src)
}
func (m *BaseRateData) XXX_Size() int {
	return m.Size()
}
func (m *BaseRateData) XXX_DiscardUnknown() {
	xxx_messageInfo_BaseRateData.DiscardUnknown(m)
}

var xxx_messageInfo_BaseRateData proto.InternalMessageInfo

func (m *BaseRateData) GetEpochIndex() uint64 {
	if m != nil {
		return m.EpochIndex
	}
	return 0
}

func (m *BaseRateData) GetBaseRewardRate() uint64 {
	if m != nil {
		return m.BaseRewardRate
	}
	return 0
}

func (m *BaseRateData) GetBaseExchangeRate() uint64 {
	if m != nil {
		return m.BaseExchangeRate
	}
	return 0
}

// Describes the current state of a validator on-chain
type ValidatorStatus struct {
	IdentityKey  *v1alpha1.IdentityKey `protobuf:"bytes,1,opt,name=identity_key,json=identityKey,proto3" json:"identity_key,omitempty"`
	State        *ValidatorState       `protobuf:"bytes,2,opt,name=state,proto3" json:"state,omitempty"`
	VotingPower  uint64                `protobuf:"varint,3,opt,name=voting_power,json=votingPower,proto3" json:"voting_power,omitempty"`
	BondingState *BondingState         `protobuf:"bytes,4,opt,name=bonding_state,json=bondingState,proto3" json:"bonding_state,omitempty"`
}

func (m *ValidatorStatus) Reset()         { *m = ValidatorStatus{} }
func (m *ValidatorStatus) String() string { return proto.CompactTextString(m) }
func (*ValidatorStatus) ProtoMessage()    {}
func (*ValidatorStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_b49c30b9d712baf6, []int{6}
}
func (m *ValidatorStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorStatus.Merge(m, src)
}
func (m *ValidatorStatus) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorStatus proto.InternalMessageInfo

func (m *ValidatorStatus) GetIdentityKey() *v1alpha1.IdentityKey {
	if m != nil {
		return m.IdentityKey
	}
	return nil
}

func (m *ValidatorStatus) GetState() *ValidatorState {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *ValidatorStatus) GetVotingPower() uint64 {
	if m != nil {
		return m.VotingPower
	}
	return 0
}

func (m *ValidatorStatus) GetBondingState() *BondingState {
	if m != nil {
		return m.BondingState
	}
	return nil
}

// Describes the unbonding state of a validator's stake pool.
type BondingState struct {
	State          BondingState_BondingStateEnum `protobuf:"varint,1,opt,name=state,proto3,enum=penumbra.core.component.stake.v1alpha1.BondingState_BondingStateEnum" json:"state,omitempty"`
	UnbondingEpoch uint64                        `protobuf:"varint,2,opt,name=unbonding_epoch,json=unbondingEpoch,proto3" json:"unbonding_epoch,omitempty"`
}

func (m *BondingState) Reset()         { *m = BondingState{} }
func (m *BondingState) String() string { return proto.CompactTextString(m) }
func (*BondingState) ProtoMessage()    {}
func (*BondingState) Descriptor() ([]byte, []int) {
	return fileDescriptor_b49c30b9d712baf6, []int{7}
}
func (m *BondingState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BondingState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BondingState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BondingState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BondingState.Merge(m, src)
}
func (m *BondingState) XXX_Size() int {
	return m.Size()
}
func (m *BondingState) XXX_DiscardUnknown() {
	xxx_messageInfo_BondingState.DiscardUnknown(m)
}

var xxx_messageInfo_BondingState proto.InternalMessageInfo

func (m *BondingState) GetState() BondingState_BondingStateEnum {
	if m != nil {
		return m.State
	}
	return BondingState_BONDING_STATE_ENUM_UNSPECIFIED
}

func (m *BondingState) GetUnbondingEpoch() uint64 {
	if m != nil {
		return m.UnbondingEpoch
	}
	return 0
}

// Describes the state of a validator
type ValidatorState struct {
	State ValidatorState_ValidatorStateEnum `protobuf:"varint,1,opt,name=state,proto3,enum=penumbra.core.component.stake.v1alpha1.ValidatorState_ValidatorStateEnum" json:"state,omitempty"`
}

func (m *ValidatorState) Reset()         { *m = ValidatorState{} }
func (m *ValidatorState) String() string { return proto.CompactTextString(m) }
func (*ValidatorState) ProtoMessage()    {}
func (*ValidatorState) Descriptor() ([]byte, []int) {
	return fileDescriptor_b49c30b9d712baf6, []int{8}
}
func (m *ValidatorState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorState.Merge(m, src)
}
func (m *ValidatorState) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorState) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorState.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorState proto.InternalMessageInfo

func (m *ValidatorState) GetState() ValidatorState_ValidatorStateEnum {
	if m != nil {
		return m.State
	}
	return ValidatorState_VALIDATOR_STATE_ENUM_UNSPECIFIED
}

// Combines all validator info into a single packet.
type ValidatorInfo struct {
	Validator *Validator       `protobuf:"bytes,1,opt,name=validator,proto3" json:"validator,omitempty"`
	Status    *ValidatorStatus `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	RateData  *RateData        `protobuf:"bytes,3,opt,name=rate_data,json=rateData,proto3" json:"rate_data,omitempty"`
}

func (m *ValidatorInfo) Reset()         { *m = ValidatorInfo{} }
func (m *ValidatorInfo) String() string { return proto.CompactTextString(m) }
func (*ValidatorInfo) ProtoMessage()    {}
func (*ValidatorInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_b49c30b9d712baf6, []int{9}
}
func (m *ValidatorInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorInfo.Merge(m, src)
}
func (m *ValidatorInfo) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorInfo proto.InternalMessageInfo

func (m *ValidatorInfo) GetValidator() *Validator {
	if m != nil {
		return m.Validator
	}
	return nil
}

func (m *ValidatorInfo) GetStatus() *ValidatorStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *ValidatorInfo) GetRateData() *RateData {
	if m != nil {
		return m.RateData
	}
	return nil
}

// A transaction action (re)defining a validator.
type ValidatorDefinition struct {
	// The configuration data for the validator.
	Validator *Validator `protobuf:"bytes,1,opt,name=validator,proto3" json:"validator,omitempty"`
	// A signature by the validator's identity key over the validator data.
	AuthSig []byte `protobuf:"bytes,2,opt,name=auth_sig,json=authSig,proto3" json:"auth_sig,omitempty"`
}

func (m *ValidatorDefinition) Reset()         { *m = ValidatorDefinition{} }
func (m *ValidatorDefinition) String() string { return proto.CompactTextString(m) }
func (*ValidatorDefinition) ProtoMessage()    {}
func (*ValidatorDefinition) Descriptor() ([]byte, []int) {
	return fileDescriptor_b49c30b9d712baf6, []int{10}
}
func (m *ValidatorDefinition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorDefinition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorDefinition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorDefinition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorDefinition.Merge(m, src)
}
func (m *ValidatorDefinition) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorDefinition) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorDefinition.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorDefinition proto.InternalMessageInfo

func (m *ValidatorDefinition) GetValidator() *Validator {
	if m != nil {
		return m.Validator
	}
	return nil
}

func (m *ValidatorDefinition) GetAuthSig() []byte {
	if m != nil {
		return m.AuthSig
	}
	return nil
}

// A transaction action adding stake to a validator's delegation pool.
type Delegate struct {
	// The identity key of the validator to delegate to.
	ValidatorIdentity *v1alpha1.IdentityKey `protobuf:"bytes,1,opt,name=validator_identity,json=validatorIdentity,proto3" json:"validator_identity,omitempty"`
	// The index of the epoch in which this delegation was performed.
	// The delegation takes effect in the next epoch.
	EpochIndex uint64 `protobuf:"varint,2,opt,name=epoch_index,json=epochIndex,proto3" json:"epoch_index,omitempty"`
	// The delegation amount, in units of unbonded stake.
	// TODO: use flow aggregation to hide this, replacing it with bytes amount_ciphertext;
	UnbondedAmount *v1alpha11.Amount `protobuf:"bytes,3,opt,name=unbonded_amount,json=unbondedAmount,proto3" json:"unbonded_amount,omitempty"`
	// The amount of delegation tokens produced by this action.
	//
	// This is implied by the validator's exchange rate in the specified epoch
	// (and should be checked in transaction validation!), but including it allows
	// stateless verification that the transaction is internally consistent.
	DelegationAmount *v1alpha11.Amount `protobuf:"bytes,4,opt,name=delegation_amount,json=delegationAmount,proto3" json:"delegation_amount,omitempty"`
}

func (m *Delegate) Reset()         { *m = Delegate{} }
func (m *Delegate) String() string { return proto.CompactTextString(m) }
func (*Delegate) ProtoMessage()    {}
func (*Delegate) Descriptor() ([]byte, []int) {
	return fileDescriptor_b49c30b9d712baf6, []int{11}
}
func (m *Delegate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Delegate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Delegate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Delegate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Delegate.Merge(m, src)
}
func (m *Delegate) XXX_Size() int {
	return m.Size()
}
func (m *Delegate) XXX_DiscardUnknown() {
	xxx_messageInfo_Delegate.DiscardUnknown(m)
}

var xxx_messageInfo_Delegate proto.InternalMessageInfo

func (m *Delegate) GetValidatorIdentity() *v1alpha1.IdentityKey {
	if m != nil {
		return m.ValidatorIdentity
	}
	return nil
}

func (m *Delegate) GetEpochIndex() uint64 {
	if m != nil {
		return m.EpochIndex
	}
	return 0
}

func (m *Delegate) GetUnbondedAmount() *v1alpha11.Amount {
	if m != nil {
		return m.UnbondedAmount
	}
	return nil
}

func (m *Delegate) GetDelegationAmount() *v1alpha11.Amount {
	if m != nil {
		return m.DelegationAmount
	}
	return nil
}

// A transaction action withdrawing stake from a validator's delegation pool.
type Undelegate struct {
	// The identity key of the validator to undelegate from.
	ValidatorIdentity *v1alpha1.IdentityKey `protobuf:"bytes,1,opt,name=validator_identity,json=validatorIdentity,proto3" json:"validator_identity,omitempty"`
	// The index of the epoch in which this undelegation was performed.
	StartEpochIndex uint64 `protobuf:"varint,2,opt,name=start_epoch_index,json=startEpochIndex,proto3" json:"start_epoch_index,omitempty"`
	// The amount to undelegate, in units of unbonding tokens.
	UnbondedAmount *v1alpha11.Amount `protobuf:"bytes,3,opt,name=unbonded_amount,json=unbondedAmount,proto3" json:"unbonded_amount,omitempty"`
	// The amount of delegation tokens consumed by this action.
	//
	// This is implied by the validator's exchange rate in the specified epoch
	// (and should be checked in transaction validation!), but including it allows
	// stateless verification that the transaction is internally consistent.
	DelegationAmount *v1alpha11.Amount `protobuf:"bytes,4,opt,name=delegation_amount,json=delegationAmount,proto3" json:"delegation_amount,omitempty"`
}

func (m *Undelegate) Reset()         { *m = Undelegate{} }
func (m *Undelegate) String() string { return proto.CompactTextString(m) }
func (*Undelegate) ProtoMessage()    {}
func (*Undelegate) Descriptor() ([]byte, []int) {
	return fileDescriptor_b49c30b9d712baf6, []int{12}
}
func (m *Undelegate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Undelegate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Undelegate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Undelegate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Undelegate.Merge(m, src)
}
func (m *Undelegate) XXX_Size() int {
	return m.Size()
}
func (m *Undelegate) XXX_DiscardUnknown() {
	xxx_messageInfo_Undelegate.DiscardUnknown(m)
}

var xxx_messageInfo_Undelegate proto.InternalMessageInfo

func (m *Undelegate) GetValidatorIdentity() *v1alpha1.IdentityKey {
	if m != nil {
		return m.ValidatorIdentity
	}
	return nil
}

func (m *Undelegate) GetStartEpochIndex() uint64 {
	if m != nil {
		return m.StartEpochIndex
	}
	return 0
}

func (m *Undelegate) GetUnbondedAmount() *v1alpha11.Amount {
	if m != nil {
		return m.UnbondedAmount
	}
	return nil
}

func (m *Undelegate) GetDelegationAmount() *v1alpha11.Amount {
	if m != nil {
		return m.DelegationAmount
	}
	return nil
}

// A transaction action finishing an undelegation, converting (slashable)
// "unbonding tokens" to (unslashable) staking tokens.
type UndelegateClaim struct {
	Body  *UndelegateClaimBody `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	Proof []byte               `protobuf:"bytes,2,opt,name=proof,proto3" json:"proof,omitempty"`
}

func (m *UndelegateClaim) Reset()         { *m = UndelegateClaim{} }
func (m *UndelegateClaim) String() string { return proto.CompactTextString(m) }
func (*UndelegateClaim) ProtoMessage()    {}
func (*UndelegateClaim) Descriptor() ([]byte, []int) {
	return fileDescriptor_b49c30b9d712baf6, []int{13}
}
func (m *UndelegateClaim) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UndelegateClaim) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UndelegateClaim.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UndelegateClaim) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UndelegateClaim.Merge(m, src)
}
func (m *UndelegateClaim) XXX_Size() int {
	return m.Size()
}
func (m *UndelegateClaim) XXX_DiscardUnknown() {
	xxx_messageInfo_UndelegateClaim.DiscardUnknown(m)
}

var xxx_messageInfo_UndelegateClaim proto.InternalMessageInfo

func (m *UndelegateClaim) GetBody() *UndelegateClaimBody {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *UndelegateClaim) GetProof() []byte {
	if m != nil {
		return m.Proof
	}
	return nil
}

type UndelegateClaimBody struct {
	// The identity key of the validator to finish undelegating from.
	ValidatorIdentity *v1alpha1.IdentityKey `protobuf:"bytes,1,opt,name=validator_identity,json=validatorIdentity,proto3" json:"validator_identity,omitempty"`
	// The epoch in which unbonding began, used to verify the penalty.
	StartEpochIndex uint64 `protobuf:"varint,2,opt,name=start_epoch_index,json=startEpochIndex,proto3" json:"start_epoch_index,omitempty"`
	// The penalty applied to undelegation, in bps^2 (10e-8).
	// In the happy path (no slashing), this is 0.
	Penalty *Penalty `protobuf:"bytes,3,opt,name=penalty,proto3" json:"penalty,omitempty"`
	// The action's contribution to the transaction's value balance.
	BalanceCommitment *v1alpha12.BalanceCommitment `protobuf:"bytes,4,opt,name=balance_commitment,json=balanceCommitment,proto3" json:"balance_commitment,omitempty"`
}

func (m *UndelegateClaimBody) Reset()         { *m = UndelegateClaimBody{} }
func (m *UndelegateClaimBody) String() string { return proto.CompactTextString(m) }
func (*UndelegateClaimBody) ProtoMessage()    {}
func (*UndelegateClaimBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_b49c30b9d712baf6, []int{14}
}
func (m *UndelegateClaimBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UndelegateClaimBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UndelegateClaimBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UndelegateClaimBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UndelegateClaimBody.Merge(m, src)
}
func (m *UndelegateClaimBody) XXX_Size() int {
	return m.Size()
}
func (m *UndelegateClaimBody) XXX_DiscardUnknown() {
	xxx_messageInfo_UndelegateClaimBody.DiscardUnknown(m)
}

var xxx_messageInfo_UndelegateClaimBody proto.InternalMessageInfo

func (m *UndelegateClaimBody) GetValidatorIdentity() *v1alpha1.IdentityKey {
	if m != nil {
		return m.ValidatorIdentity
	}
	return nil
}

func (m *UndelegateClaimBody) GetStartEpochIndex() uint64 {
	if m != nil {
		return m.StartEpochIndex
	}
	return 0
}

func (m *UndelegateClaimBody) GetPenalty() *Penalty {
	if m != nil {
		return m.Penalty
	}
	return nil
}

func (m *UndelegateClaimBody) GetBalanceCommitment() *v1alpha12.BalanceCommitment {
	if m != nil {
		return m.BalanceCommitment
	}
	return nil
}

type UndelegateClaimPlan struct {
	// The identity key of the validator to finish undelegating from.
	ValidatorIdentity *v1alpha1.IdentityKey `protobuf:"bytes,1,opt,name=validator_identity,json=validatorIdentity,proto3" json:"validator_identity,omitempty"`
	// The epoch in which unbonding began, used to verify the penalty.
	StartEpochIndex uint64 `protobuf:"varint,2,opt,name=start_epoch_index,json=startEpochIndex,proto3" json:"start_epoch_index,omitempty"`
	// The penalty applied to undelegation, in bps^2 (10e-8).
	// In the happy path (no slashing), this is 0.
	Penalty *Penalty `protobuf:"bytes,4,opt,name=penalty,proto3" json:"penalty,omitempty"`
	// The amount of unbonding tokens to claim.
	// This is a bare number because its denom is determined by the preceding data.
	UnbondingAmount *v1alpha11.Amount `protobuf:"bytes,5,opt,name=unbonding_amount,json=unbondingAmount,proto3" json:"unbonding_amount,omitempty"`
	// The blinding factor to use for the balance commitment.
	BalanceBlinding []byte `protobuf:"bytes,6,opt,name=balance_blinding,json=balanceBlinding,proto3" json:"balance_blinding,omitempty"`
	// The first blinding factor to use for the ZK undelegate claim proof.
	ProofBlindingR []byte `protobuf:"bytes,7,opt,name=proof_blinding_r,json=proofBlindingR,proto3" json:"proof_blinding_r,omitempty"`
	// The second blinding factor to use for the ZK undelegate claim proof.
	ProofBlindingS []byte `protobuf:"bytes,8,opt,name=proof_blinding_s,json=proofBlindingS,proto3" json:"proof_blinding_s,omitempty"`
}

func (m *UndelegateClaimPlan) Reset()         { *m = UndelegateClaimPlan{} }
func (m *UndelegateClaimPlan) String() string { return proto.CompactTextString(m) }
func (*UndelegateClaimPlan) ProtoMessage()    {}
func (*UndelegateClaimPlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_b49c30b9d712baf6, []int{15}
}
func (m *UndelegateClaimPlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UndelegateClaimPlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UndelegateClaimPlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UndelegateClaimPlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UndelegateClaimPlan.Merge(m, src)
}
func (m *UndelegateClaimPlan) XXX_Size() int {
	return m.Size()
}
func (m *UndelegateClaimPlan) XXX_DiscardUnknown() {
	xxx_messageInfo_UndelegateClaimPlan.DiscardUnknown(m)
}

var xxx_messageInfo_UndelegateClaimPlan proto.InternalMessageInfo

func (m *UndelegateClaimPlan) GetValidatorIdentity() *v1alpha1.IdentityKey {
	if m != nil {
		return m.ValidatorIdentity
	}
	return nil
}

func (m *UndelegateClaimPlan) GetStartEpochIndex() uint64 {
	if m != nil {
		return m.StartEpochIndex
	}
	return 0
}

func (m *UndelegateClaimPlan) GetPenalty() *Penalty {
	if m != nil {
		return m.Penalty
	}
	return nil
}

func (m *UndelegateClaimPlan) GetUnbondingAmount() *v1alpha11.Amount {
	if m != nil {
		return m.UnbondingAmount
	}
	return nil
}

func (m *UndelegateClaimPlan) GetBalanceBlinding() []byte {
	if m != nil {
		return m.BalanceBlinding
	}
	return nil
}

func (m *UndelegateClaimPlan) GetProofBlindingR() []byte {
	if m != nil {
		return m.ProofBlindingR
	}
	return nil
}

func (m *UndelegateClaimPlan) GetProofBlindingS() []byte {
	if m != nil {
		return m.ProofBlindingS
	}
	return nil
}

// A list of pending delegations and undelegations.
type DelegationChanges struct {
	Delegations   []*Delegate   `protobuf:"bytes,1,rep,name=delegations,proto3" json:"delegations,omitempty"`
	Undelegations []*Undelegate `protobuf:"bytes,2,rep,name=undelegations,proto3" json:"undelegations,omitempty"`
}

func (m *DelegationChanges) Reset()         { *m = DelegationChanges{} }
func (m *DelegationChanges) String() string { return proto.CompactTextString(m) }
func (*DelegationChanges) ProtoMessage()    {}
func (*DelegationChanges) Descriptor() ([]byte, []int) {
	return fileDescriptor_b49c30b9d712baf6, []int{16}
}
func (m *DelegationChanges) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelegationChanges) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelegationChanges.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelegationChanges) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelegationChanges.Merge(m, src)
}
func (m *DelegationChanges) XXX_Size() int {
	return m.Size()
}
func (m *DelegationChanges) XXX_DiscardUnknown() {
	xxx_messageInfo_DelegationChanges.DiscardUnknown(m)
}

var xxx_messageInfo_DelegationChanges proto.InternalMessageInfo

func (m *DelegationChanges) GetDelegations() []*Delegate {
	if m != nil {
		return m.Delegations
	}
	return nil
}

func (m *DelegationChanges) GetUndelegations() []*Undelegate {
	if m != nil {
		return m.Undelegations
	}
	return nil
}

// Track's a validator's uptime.
type Uptime struct {
	AsOfBlockHeight uint64 `protobuf:"varint,1,opt,name=as_of_block_height,json=asOfBlockHeight,proto3" json:"as_of_block_height,omitempty"`
	WindowLen       uint32 `protobuf:"varint,2,opt,name=window_len,json=windowLen,proto3" json:"window_len,omitempty"`
	Bitvec          []byte `protobuf:"bytes,3,opt,name=bitvec,proto3" json:"bitvec,omitempty"`
}

func (m *Uptime) Reset()         { *m = Uptime{} }
func (m *Uptime) String() string { return proto.CompactTextString(m) }
func (*Uptime) ProtoMessage()    {}
func (*Uptime) Descriptor() ([]byte, []int) {
	return fileDescriptor_b49c30b9d712baf6, []int{17}
}
func (m *Uptime) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Uptime) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Uptime.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Uptime) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Uptime.Merge(m, src)
}
func (m *Uptime) XXX_Size() int {
	return m.Size()
}
func (m *Uptime) XXX_DiscardUnknown() {
	xxx_messageInfo_Uptime.DiscardUnknown(m)
}

var xxx_messageInfo_Uptime proto.InternalMessageInfo

func (m *Uptime) GetAsOfBlockHeight() uint64 {
	if m != nil {
		return m.AsOfBlockHeight
	}
	return 0
}

func (m *Uptime) GetWindowLen() uint32 {
	if m != nil {
		return m.WindowLen
	}
	return 0
}

func (m *Uptime) GetBitvec() []byte {
	if m != nil {
		return m.Bitvec
	}
	return nil
}

// Tracks our view of Tendermint's view of the validator set, so we can keep it
// from getting confused.
type CurrentConsensusKeys struct {
	ConsensusKeys []*v1alpha1.ConsensusKey `protobuf:"bytes,1,rep,name=consensus_keys,json=consensusKeys,proto3" json:"consensus_keys,omitempty"`
}

func (m *CurrentConsensusKeys) Reset()         { *m = CurrentConsensusKeys{} }
func (m *CurrentConsensusKeys) String() string { return proto.CompactTextString(m) }
func (*CurrentConsensusKeys) ProtoMessage()    {}
func (*CurrentConsensusKeys) Descriptor() ([]byte, []int) {
	return fileDescriptor_b49c30b9d712baf6, []int{18}
}
func (m *CurrentConsensusKeys) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CurrentConsensusKeys) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CurrentConsensusKeys.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CurrentConsensusKeys) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CurrentConsensusKeys.Merge(m, src)
}
func (m *CurrentConsensusKeys) XXX_Size() int {
	return m.Size()
}
func (m *CurrentConsensusKeys) XXX_DiscardUnknown() {
	xxx_messageInfo_CurrentConsensusKeys.DiscardUnknown(m)
}

var xxx_messageInfo_CurrentConsensusKeys proto.InternalMessageInfo

func (m *CurrentConsensusKeys) GetConsensusKeys() []*v1alpha1.ConsensusKey {
	if m != nil {
		return m.ConsensusKeys
	}
	return nil
}

// Tracks slashing penalties applied to a validator in some epoch.
type Penalty struct {
	Inner uint64 `protobuf:"varint,1,opt,name=inner,proto3" json:"inner,omitempty"`
}

func (m *Penalty) Reset()         { *m = Penalty{} }
func (m *Penalty) String() string { return proto.CompactTextString(m) }
func (*Penalty) ProtoMessage()    {}
func (*Penalty) Descriptor() ([]byte, []int) {
	return fileDescriptor_b49c30b9d712baf6, []int{19}
}
func (m *Penalty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Penalty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Penalty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Penalty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Penalty.Merge(m, src)
}
func (m *Penalty) XXX_Size() int {
	return m.Size()
}
func (m *Penalty) XXX_DiscardUnknown() {
	xxx_messageInfo_Penalty.DiscardUnknown(m)
}

var xxx_messageInfo_Penalty proto.InternalMessageInfo

func (m *Penalty) GetInner() uint64 {
	if m != nil {
		return m.Inner
	}
	return 0
}

// Requests information on the chain's validators.
type ValidatorInfoRequest struct {
	// The expected chain id (empty string if no expectation).
	ChainId string `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Whether or not to return inactive validators
	ShowInactive bool `protobuf:"varint,2,opt,name=show_inactive,json=showInactive,proto3" json:"show_inactive,omitempty"`
}

func (m *ValidatorInfoRequest) Reset()         { *m = ValidatorInfoRequest{} }
func (m *ValidatorInfoRequest) String() string { return proto.CompactTextString(m) }
func (*ValidatorInfoRequest) ProtoMessage()    {}
func (*ValidatorInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b49c30b9d712baf6, []int{20}
}
func (m *ValidatorInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorInfoRequest.Merge(m, src)
}
func (m *ValidatorInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorInfoRequest proto.InternalMessageInfo

func (m *ValidatorInfoRequest) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *ValidatorInfoRequest) GetShowInactive() bool {
	if m != nil {
		return m.ShowInactive
	}
	return false
}

type ValidatorInfoResponse struct {
	ValidatorInfo *ValidatorInfo `protobuf:"bytes,1,opt,name=validator_info,json=validatorInfo,proto3" json:"validator_info,omitempty"`
}

func (m *ValidatorInfoResponse) Reset()         { *m = ValidatorInfoResponse{} }
func (m *ValidatorInfoResponse) String() string { return proto.CompactTextString(m) }
func (*ValidatorInfoResponse) ProtoMessage()    {}
func (*ValidatorInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b49c30b9d712baf6, []int{21}
}
func (m *ValidatorInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorInfoResponse.Merge(m, src)
}
func (m *ValidatorInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorInfoResponse proto.InternalMessageInfo

func (m *ValidatorInfoResponse) GetValidatorInfo() *ValidatorInfo {
	if m != nil {
		return m.ValidatorInfo
	}
	return nil
}

type ValidatorStatusRequest struct {
	// The expected chain id (empty string if no expectation).
	ChainId     string                `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	IdentityKey *v1alpha1.IdentityKey `protobuf:"bytes,2,opt,name=identity_key,json=identityKey,proto3" json:"identity_key,omitempty"`
}

func (m *ValidatorStatusRequest) Reset()         { *m = ValidatorStatusRequest{} }
func (m *ValidatorStatusRequest) String() string { return proto.CompactTextString(m) }
func (*ValidatorStatusRequest) ProtoMessage()    {}
func (*ValidatorStatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b49c30b9d712baf6, []int{22}
}
func (m *ValidatorStatusRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorStatusRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorStatusRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorStatusRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorStatusRequest.Merge(m, src)
}
func (m *ValidatorStatusRequest) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorStatusRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorStatusRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorStatusRequest proto.InternalMessageInfo

func (m *ValidatorStatusRequest) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *ValidatorStatusRequest) GetIdentityKey() *v1alpha1.IdentityKey {
	if m != nil {
		return m.IdentityKey
	}
	return nil
}

type ValidatorStatusResponse struct {
	Status *ValidatorStatus `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *ValidatorStatusResponse) Reset()         { *m = ValidatorStatusResponse{} }
func (m *ValidatorStatusResponse) String() string { return proto.CompactTextString(m) }
func (*ValidatorStatusResponse) ProtoMessage()    {}
func (*ValidatorStatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b49c30b9d712baf6, []int{23}
}
func (m *ValidatorStatusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorStatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorStatusResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorStatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorStatusResponse.Merge(m, src)
}
func (m *ValidatorStatusResponse) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorStatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorStatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorStatusResponse proto.InternalMessageInfo

func (m *ValidatorStatusResponse) GetStatus() *ValidatorStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// Requests the compounded penalty for a validator over a range of epochs.
type ValidatorPenaltyRequest struct {
	// The expected chain id (empty string if no expectation).
	ChainId         string                `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	IdentityKey     *v1alpha1.IdentityKey `protobuf:"bytes,2,opt,name=identity_key,json=identityKey,proto3" json:"identity_key,omitempty"`
	StartEpochIndex uint64                `protobuf:"varint,3,opt,name=start_epoch_index,json=startEpochIndex,proto3" json:"start_epoch_index,omitempty"`
	EndEpochIndex   uint64                `protobuf:"varint,4,opt,name=end_epoch_index,json=endEpochIndex,proto3" json:"end_epoch_index,omitempty"`
}

func (m *ValidatorPenaltyRequest) Reset()         { *m = ValidatorPenaltyRequest{} }
func (m *ValidatorPenaltyRequest) String() string { return proto.CompactTextString(m) }
func (*ValidatorPenaltyRequest) ProtoMessage()    {}
func (*ValidatorPenaltyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b49c30b9d712baf6, []int{24}
}
func (m *ValidatorPenaltyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorPenaltyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorPenaltyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorPenaltyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorPenaltyRequest.Merge(m, src)
}
func (m *ValidatorPenaltyRequest) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorPenaltyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorPenaltyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorPenaltyRequest proto.InternalMessageInfo

func (m *ValidatorPenaltyRequest) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *ValidatorPenaltyRequest) GetIdentityKey() *v1alpha1.IdentityKey {
	if m != nil {
		return m.IdentityKey
	}
	return nil
}

func (m *ValidatorPenaltyRequest) GetStartEpochIndex() uint64 {
	if m != nil {
		return m.StartEpochIndex
	}
	return 0
}

func (m *ValidatorPenaltyRequest) GetEndEpochIndex() uint64 {
	if m != nil {
		return m.EndEpochIndex
	}
	return 0
}

type ValidatorPenaltyResponse struct {
	Penalty *Penalty `protobuf:"bytes,1,opt,name=penalty,proto3" json:"penalty,omitempty"`
}

func (m *ValidatorPenaltyResponse) Reset()         { *m = ValidatorPenaltyResponse{} }
func (m *ValidatorPenaltyResponse) String() string { return proto.CompactTextString(m) }
func (*ValidatorPenaltyResponse) ProtoMessage()    {}
func (*ValidatorPenaltyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b49c30b9d712baf6, []int{25}
}
func (m *ValidatorPenaltyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorPenaltyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorPenaltyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorPenaltyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorPenaltyResponse.Merge(m, src)
}
func (m *ValidatorPenaltyResponse) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorPenaltyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorPenaltyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorPenaltyResponse proto.InternalMessageInfo

func (m *ValidatorPenaltyResponse) GetPenalty() *Penalty {
	if m != nil {
		return m.Penalty
	}
	return nil
}

type CurrentValidatorRateRequest struct {
	// The expected chain id (empty string if no expectation).
	ChainId     string                `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	IdentityKey *v1alpha1.IdentityKey `protobuf:"bytes,2,opt,name=identity_key,json=identityKey,proto3" json:"identity_key,omitempty"`
}

func (m *CurrentValidatorRateRequest) Reset()         { *m = CurrentValidatorRateRequest{} }
func (m *CurrentValidatorRateRequest) String() string { return proto.CompactTextString(m) }
func (*CurrentValidatorRateRequest) ProtoMessage()    {}
func (*CurrentValidatorRateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b49c30b9d712baf6, []int{26}
}
func (m *CurrentValidatorRateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CurrentValidatorRateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CurrentValidatorRateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CurrentValidatorRateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CurrentValidatorRateRequest.Merge(m, src)
}
func (m *CurrentValidatorRateRequest) XXX_Size() int {
	return m.Size()
}
func (m *CurrentValidatorRateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CurrentValidatorRateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CurrentValidatorRateRequest proto.InternalMessageInfo

func (m *CurrentValidatorRateRequest) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *CurrentValidatorRateRequest) GetIdentityKey() *v1alpha1.IdentityKey {
	if m != nil {
		return m.IdentityKey
	}
	return nil
}

type CurrentValidatorRateResponse struct {
	Data *RateData `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *CurrentValidatorRateResponse) Reset()         { *m = CurrentValidatorRateResponse{} }
func (m *CurrentValidatorRateResponse) String() string { return proto.CompactTextString(m) }
func (*CurrentValidatorRateResponse) ProtoMessage()    {}
func (*CurrentValidatorRateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b49c30b9d712baf6, []int{27}
}
func (m *CurrentValidatorRateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CurrentValidatorRateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CurrentValidatorRateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CurrentValidatorRateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CurrentValidatorRateResponse.Merge(m, src)
}
func (m *CurrentValidatorRateResponse) XXX_Size() int {
	return m.Size()
}
func (m *CurrentValidatorRateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CurrentValidatorRateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CurrentValidatorRateResponse proto.InternalMessageInfo

func (m *CurrentValidatorRateResponse) GetData() *RateData {
	if m != nil {
		return m.Data
	}
	return nil
}

type NextValidatorRateRequest struct {
	// The expected chain id (empty string if no expectation).
	ChainId     string                `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	IdentityKey *v1alpha1.IdentityKey `protobuf:"bytes,2,opt,name=identity_key,json=identityKey,proto3" json:"identity_key,omitempty"`
}

func (m *NextValidatorRateRequest) Reset()         { *m = NextValidatorRateRequest{} }
func (m *NextValidatorRateRequest) String() string { return proto.CompactTextString(m) }
func (*NextValidatorRateRequest) ProtoMessage()    {}
func (*NextValidatorRateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b49c30b9d712baf6, []int{28}
}
func (m *NextValidatorRateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NextValidatorRateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NextValidatorRateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NextValidatorRateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NextValidatorRateRequest.Merge(m, src)
}
func (m *NextValidatorRateRequest) XXX_Size() int {
	return m.Size()
}
func (m *NextValidatorRateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NextValidatorRateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NextValidatorRateRequest proto.InternalMessageInfo

func (m *NextValidatorRateRequest) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *NextValidatorRateRequest) GetIdentityKey() *v1alpha1.IdentityKey {
	if m != nil {
		return m.IdentityKey
	}
	return nil
}

type NextValidatorRateResponse struct {
	Data *RateData `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *NextValidatorRateResponse) Reset()         { *m = NextValidatorRateResponse{} }
func (m *NextValidatorRateResponse) String() string { return proto.CompactTextString(m) }
func (*NextValidatorRateResponse) ProtoMessage()    {}
func (*NextValidatorRateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b49c30b9d712baf6, []int{29}
}
func (m *NextValidatorRateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NextValidatorRateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NextValidatorRateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NextValidatorRateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NextValidatorRateResponse.Merge(m, src)
}
func (m *NextValidatorRateResponse) XXX_Size() int {
	return m.Size()
}
func (m *NextValidatorRateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NextValidatorRateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NextValidatorRateResponse proto.InternalMessageInfo

func (m *NextValidatorRateResponse) GetData() *RateData {
	if m != nil {
		return m.Data
	}
	return nil
}

// Staking configuration data.
type StakeParameters struct {
	// The number of epochs an unbonding note for before being released.
	UnbondingEpochs uint64 `protobuf:"varint,1,opt,name=unbonding_epochs,json=unbondingEpochs,proto3" json:"unbonding_epochs,omitempty"`
	// The maximum number of validators in the consensus set.
	ActiveValidatorLimit uint64 `protobuf:"varint,2,opt,name=active_validator_limit,json=activeValidatorLimit,proto3" json:"active_validator_limit,omitempty"`
	// The base reward rate, expressed in basis points of basis points
	BaseRewardRate uint64 `protobuf:"varint,3,opt,name=base_reward_rate,json=baseRewardRate,proto3" json:"base_reward_rate,omitempty"`
	// The penalty for slashing due to misbehavior.
	SlashingPenaltyMisbehavior uint64 `protobuf:"varint,4,opt,name=slashing_penalty_misbehavior,json=slashingPenaltyMisbehavior,proto3" json:"slashing_penalty_misbehavior,omitempty"`
	// The penalty for slashing due to downtime.
	SlashingPenaltyDowntime uint64 `protobuf:"varint,5,opt,name=slashing_penalty_downtime,json=slashingPenaltyDowntime,proto3" json:"slashing_penalty_downtime,omitempty"`
	// The number of blocks in the window to check for downtime.
	SignedBlocksWindowLen uint64 `protobuf:"varint,6,opt,name=signed_blocks_window_len,json=signedBlocksWindowLen,proto3" json:"signed_blocks_window_len,omitempty"`
	// The maximum number of blocks in the window each validator can miss signing without slashing.
	MissedBlocksMaximum uint64 `protobuf:"varint,7,opt,name=missed_blocks_maximum,json=missedBlocksMaximum,proto3" json:"missed_blocks_maximum,omitempty"`
}

func (m *StakeParameters) Reset()         { *m = StakeParameters{} }
func (m *StakeParameters) String() string { return proto.CompactTextString(m) }
func (*StakeParameters) ProtoMessage()    {}
func (*StakeParameters) Descriptor() ([]byte, []int) {
	return fileDescriptor_b49c30b9d712baf6, []int{30}
}
func (m *StakeParameters) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StakeParameters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StakeParameters.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StakeParameters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StakeParameters.Merge(m, src)
}
func (m *StakeParameters) XXX_Size() int {
	return m.Size()
}
func (m *StakeParameters) XXX_DiscardUnknown() {
	xxx_messageInfo_StakeParameters.DiscardUnknown(m)
}

var xxx_messageInfo_StakeParameters proto.InternalMessageInfo

func (m *StakeParameters) GetUnbondingEpochs() uint64 {
	if m != nil {
		return m.UnbondingEpochs
	}
	return 0
}

func (m *StakeParameters) GetActiveValidatorLimit() uint64 {
	if m != nil {
		return m.ActiveValidatorLimit
	}
	return 0
}

func (m *StakeParameters) GetBaseRewardRate() uint64 {
	if m != nil {
		return m.BaseRewardRate
	}
	return 0
}

func (m *StakeParameters) GetSlashingPenaltyMisbehavior() uint64 {
	if m != nil {
		return m.SlashingPenaltyMisbehavior
	}
	return 0
}

func (m *StakeParameters) GetSlashingPenaltyDowntime() uint64 {
	if m != nil {
		return m.SlashingPenaltyDowntime
	}
	return 0
}

func (m *StakeParameters) GetSignedBlocksWindowLen() uint64 {
	if m != nil {
		return m.SignedBlocksWindowLen
	}
	return 0
}

func (m *StakeParameters) GetMissedBlocksMaximum() uint64 {
	if m != nil {
		return m.MissedBlocksMaximum
	}
	return 0
}

// Genesis data for the staking component.
type GenesisContent struct {
	// The configuration parameters for the staking component present at genesis
	StakeParams *StakeParameters `protobuf:"bytes,1,opt,name=stake_params,json=stakeParams,proto3" json:"stake_params,omitempty"`
	// The list of validators present at genesis.
	Validators []*Validator `protobuf:"bytes,2,rep,name=validators,proto3" json:"validators,omitempty"`
}

func (m *GenesisContent) Reset()         { *m = GenesisContent{} }
func (m *GenesisContent) String() string { return proto.CompactTextString(m) }
func (*GenesisContent) ProtoMessage()    {}
func (*GenesisContent) Descriptor() ([]byte, []int) {
	return fileDescriptor_b49c30b9d712baf6, []int{31}
}
func (m *GenesisContent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenesisContent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenesisContent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenesisContent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenesisContent.Merge(m, src)
}
func (m *GenesisContent) XXX_Size() int {
	return m.Size()
}
func (m *GenesisContent) XXX_DiscardUnknown() {
	xxx_messageInfo_GenesisContent.DiscardUnknown(m)
}

var xxx_messageInfo_GenesisContent proto.InternalMessageInfo

func (m *GenesisContent) GetStakeParams() *StakeParameters {
	if m != nil {
		return m.StakeParams
	}
	return nil
}

func (m *GenesisContent) GetValidators() []*Validator {
	if m != nil {
		return m.Validators
	}
	return nil
}

func init() {
	proto.RegisterEnum("penumbra.core.component.stake.v1alpha1.BondingState_BondingStateEnum", BondingState_BondingStateEnum_name, BondingState_BondingStateEnum_value)
	proto.RegisterEnum("penumbra.core.component.stake.v1alpha1.ValidatorState_ValidatorStateEnum", ValidatorState_ValidatorStateEnum_name, ValidatorState_ValidatorStateEnum_value)
	proto.RegisterType((*ZKUndelegateClaimProof)(nil), "penumbra.core.component.stake.v1alpha1.ZKUndelegateClaimProof")
	proto.RegisterType((*Validator)(nil), "penumbra.core.component.stake.v1alpha1.Validator")
	proto.RegisterType((*ValidatorList)(nil), "penumbra.core.component.stake.v1alpha1.ValidatorList")
	proto.RegisterType((*FundingStream)(nil), "penumbra.core.component.stake.v1alpha1.FundingStream")
	proto.RegisterType((*FundingStream_ToAddress)(nil), "penumbra.core.component.stake.v1alpha1.FundingStream.ToAddress")
	proto.RegisterType((*FundingStream_ToDao)(nil), "penumbra.core.component.stake.v1alpha1.FundingStream.ToDao")
	proto.RegisterType((*RateData)(nil), "penumbra.core.component.stake.v1alpha1.RateData")
	proto.RegisterType((*BaseRateData)(nil), "penumbra.core.component.stake.v1alpha1.BaseRateData")
	proto.RegisterType((*ValidatorStatus)(nil), "penumbra.core.component.stake.v1alpha1.ValidatorStatus")
	proto.RegisterType((*BondingState)(nil), "penumbra.core.component.stake.v1alpha1.BondingState")
	proto.RegisterType((*ValidatorState)(nil), "penumbra.core.component.stake.v1alpha1.ValidatorState")
	proto.RegisterType((*ValidatorInfo)(nil), "penumbra.core.component.stake.v1alpha1.ValidatorInfo")
	proto.RegisterType((*ValidatorDefinition)(nil), "penumbra.core.component.stake.v1alpha1.ValidatorDefinition")
	proto.RegisterType((*Delegate)(nil), "penumbra.core.component.stake.v1alpha1.Delegate")
	proto.RegisterType((*Undelegate)(nil), "penumbra.core.component.stake.v1alpha1.Undelegate")
	proto.RegisterType((*UndelegateClaim)(nil), "penumbra.core.component.stake.v1alpha1.UndelegateClaim")
	proto.RegisterType((*UndelegateClaimBody)(nil), "penumbra.core.component.stake.v1alpha1.UndelegateClaimBody")
	proto.RegisterType((*UndelegateClaimPlan)(nil), "penumbra.core.component.stake.v1alpha1.UndelegateClaimPlan")
	proto.RegisterType((*DelegationChanges)(nil), "penumbra.core.component.stake.v1alpha1.DelegationChanges")
	proto.RegisterType((*Uptime)(nil), "penumbra.core.component.stake.v1alpha1.Uptime")
	proto.RegisterType((*CurrentConsensusKeys)(nil), "penumbra.core.component.stake.v1alpha1.CurrentConsensusKeys")
	proto.RegisterType((*Penalty)(nil), "penumbra.core.component.stake.v1alpha1.Penalty")
	proto.RegisterType((*ValidatorInfoRequest)(nil), "penumbra.core.component.stake.v1alpha1.ValidatorInfoRequest")
	proto.RegisterType((*ValidatorInfoResponse)(nil), "penumbra.core.component.stake.v1alpha1.ValidatorInfoResponse")
	proto.RegisterType((*ValidatorStatusRequest)(nil), "penumbra.core.component.stake.v1alpha1.ValidatorStatusRequest")
	proto.RegisterType((*ValidatorStatusResponse)(nil), "penumbra.core.component.stake.v1alpha1.ValidatorStatusResponse")
	proto.RegisterType((*ValidatorPenaltyRequest)(nil), "penumbra.core.component.stake.v1alpha1.ValidatorPenaltyRequest")
	proto.RegisterType((*ValidatorPenaltyResponse)(nil), "penumbra.core.component.stake.v1alpha1.ValidatorPenaltyResponse")
	proto.RegisterType((*CurrentValidatorRateRequest)(nil), "penumbra.core.component.stake.v1alpha1.CurrentValidatorRateRequest")
	proto.RegisterType((*CurrentValidatorRateResponse)(nil), "penumbra.core.component.stake.v1alpha1.CurrentValidatorRateResponse")
	proto.RegisterType((*NextValidatorRateRequest)(nil), "penumbra.core.component.stake.v1alpha1.NextValidatorRateRequest")
	proto.RegisterType((*NextValidatorRateResponse)(nil), "penumbra.core.component.stake.v1alpha1.NextValidatorRateResponse")
	proto.RegisterType((*StakeParameters)(nil), "penumbra.core.component.stake.v1alpha1.StakeParameters")
	proto.RegisterType((*GenesisContent)(nil), "penumbra.core.component.stake.v1alpha1.GenesisContent")
}

func init() {
	proto.RegisterFile("penumbra/core/component/stake/v1alpha1/stake.proto", fileDescriptor_b49c30b9d712baf6)
}

var fileDescriptor_b49c30b9d712baf6 = []byte{
	// 2171 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x59, 0xcd, 0x6f, 0x1b, 0xc7,
	0x15, 0xd7, 0x52, 0xd4, 0xd7, 0x23, 0x29, 0x51, 0xe3, 0x2f, 0x5a, 0xb1, 0x65, 0x65, 0x1d, 0x38,
	0x8a, 0x5b, 0x50, 0x31, 0x9b, 0x0f, 0x40, 0x69, 0x1b, 0x8b, 0x1f, 0xb1, 0x59, 0x5b, 0x12, 0xbd,
	0x94, 0x9d, 0xd6, 0x15, 0xb2, 0x1e, 0x72, 0x47, 0xe2, 0xd4, 0xdc, 0x59, 0x66, 0x67, 0x28, 0x59,
	0xb7, 0xb4, 0x40, 0x91, 0x43, 0x81, 0xa2, 0x28, 0x50, 0x20, 0xd7, 0xe6, 0x98, 0x4b, 0x0f, 0xbd,
	0xf5, 0x52, 0x14, 0x45, 0x81, 0xa2, 0xa7, 0x5c, 0x0a, 0x14, 0xe8, 0xa5, 0xb0, 0x0b, 0x14, 0xe8,
	0xa5, 0xff, 0x42, 0x31, 0xb3, 0xb3, 0xbb, 0x24, 0x45, 0x3b, 0x14, 0xed, 0xa6, 0xc9, 0x85, 0xd8,
	0xf7, 0xe6, 0xf7, 0xde, 0xbc, 0xf7, 0x66, 0xe6, 0xbd, 0x37, 0x43, 0x28, 0x74, 0x08, 0xeb, 0xba,
	0x0d, 0x1f, 0xaf, 0x35, 0x3d, 0x9f, 0xac, 0x35, 0x3d, 0xb7, 0xe3, 0x31, 0xc2, 0xc4, 0x1a, 0x17,
	0xf8, 0x21, 0x59, 0x3b, 0xb8, 0x86, 0xdb, 0x9d, 0x16, 0xbe, 0x16, 0x90, 0xf9, 0x8e, 0xef, 0x09,
	0x0f, 0x5d, 0x09, 0x65, 0xf2, 0x52, 0x26, 0x1f, 0xc9, 0xe4, 0x03, 0x50, 0x28, 0xb3, 0x74, 0xa5,
	0x5f, 0xf7, 0x43, 0x72, 0xc4, 0x63, 0x85, 0x92, 0x0a, 0xf4, 0x2d, 0xbd, 0xd2, 0x8f, 0x63, 0x5d,
	0x37, 0x86, 0xb1, 0xae, 0xab, 0x51, 0xab, 0xfd, 0x28, 0xcc, 0x39, 0x11, 0x31, 0x4e, 0x91, 0x01,
	0xd2, 0xcc, 0xc3, 0xd9, 0xfb, 0xb7, 0xee, 0x32, 0x87, 0xb4, 0xc9, 0x3e, 0x16, 0xa4, 0xd4, 0xc6,
	0xd4, 0xad, 0xf9, 0x9e, 0xb7, 0x87, 0x4e, 0xc3, 0x14, 0x65, 0x8c, 0xf8, 0x39, 0x63, 0xc5, 0x58,
	0x4d, 0x5b, 0x01, 0x61, 0xfe, 0x71, 0x12, 0xe6, 0xee, 0xe1, 0x36, 0x75, 0xb0, 0xf0, 0x7c, 0x74,
	0x0b, 0xd2, 0xd4, 0x21, 0x4c, 0x50, 0x71, 0x64, 0x3f, 0x24, 0x47, 0x0a, 0x9a, 0x2a, 0xac, 0xe6,
	0xfb, 0x9d, 0x56, 0xe6, 0x87, 0xb3, 0xe7, 0xab, 0x5a, 0xe0, 0x16, 0x39, 0xb2, 0x52, 0x34, 0x26,
	0xd0, 0x65, 0xc8, 0x34, 0x3d, 0xc6, 0x09, 0xe3, 0x5d, 0xae, 0xb4, 0x25, 0xd4, 0xc4, 0xe9, 0x88,
	0x29, 0x41, 0x08, 0x92, 0x0c, 0xbb, 0x24, 0x37, 0xb9, 0x62, 0xac, 0xce, 0x59, 0xea, 0x1b, 0xe5,
	0x60, 0xe6, 0x90, 0x34, 0x38, 0x15, 0x24, 0x97, 0x54, 0xec, 0x90, 0x44, 0x2b, 0x90, 0x72, 0x08,
	0x6f, 0xfa, 0xb4, 0x23, 0xa8, 0xc7, 0x72, 0x53, 0x6a, 0xb4, 0x97, 0x25, 0x65, 0x09, 0xc3, 0x8d,
	0x36, 0x71, 0x72, 0xb3, 0x2b, 0xc6, 0xea, 0xac, 0x15, 0x92, 0xe8, 0x03, 0x58, 0xd8, 0xeb, 0x32,
	0x87, 0xb2, 0x7d, 0x9b, 0x0b, 0x9f, 0x60, 0x97, 0xe7, 0xa6, 0x57, 0x26, 0x57, 0x53, 0x85, 0x37,
	0xf3, 0xa3, 0xad, 0x69, 0xfe, 0xbd, 0x40, 0xbc, 0xae, 0xa4, 0xad, 0xf9, 0xbd, 0x5e, 0x92, 0xa3,
	0x57, 0x61, 0x81, 0x93, 0x0f, 0xbb, 0x84, 0x35, 0x89, 0x2d, 0xd5, 0x11, 0x3f, 0x37, 0xb3, 0x62,
	0xac, 0x66, 0xac, 0xf9, 0x90, 0xbd, 0xa5, 0xb8, 0xe8, 0x0e, 0xcc, 0xef, 0x7b, 0x07, 0xc4, 0x67,
	0x58, 0x42, 0x65, 0x60, 0xe6, 0x54, 0x98, 0xaf, 0x3e, 0x33, 0xcc, 0x37, 0x22, 0x11, 0x19, 0xe8,
	0xcc, 0x7e, 0x2f, 0x69, 0x3e, 0x80, 0x4c, 0xb4, 0x88, 0xb7, 0x29, 0x17, 0x68, 0x1b, 0xe6, 0x0f,
	0x42, 0x86, 0x9c, 0x82, 0xe7, 0x0c, 0xe5, 0xeb, 0xe8, 0x4b, 0x99, 0x89, 0xe4, 0x6f, 0x91, 0x23,
	0x6e, 0xfe, 0x2e, 0x01, 0x99, 0x3e, 0xff, 0xd1, 0x03, 0x00, 0xe1, 0xd9, 0xd8, 0x71, 0x7c, 0xc2,
	0xb9, 0xde, 0x29, 0xef, 0x8e, 0x15, 0xca, 0xfc, 0x8e, 0xb7, 0x11, 0xa8, 0xb9, 0x39, 0x61, 0xcd,
	0x89, 0x90, 0x40, 0x3b, 0x30, 0x2d, 0x3c, 0xdb, 0xc1, 0x9e, 0xda, 0x39, 0xa9, 0xc2, 0x3b, 0xe3,
	0x6a, 0x2f, 0x63, 0xef, 0xe6, 0x84, 0x35, 0x25, 0xe4, 0xc7, 0xd2, 0x75, 0x98, 0x8b, 0xe6, 0x93,
	0xdb, 0xa5, 0xd7, 0x83, 0x39, 0x2b, 0x24, 0xd1, 0x79, 0x98, 0xf5, 0xb1, 0x20, 0x76, 0xa3, 0xc3,
	0xd5, 0xf4, 0x19, 0x6b, 0x46, 0xd2, 0xc5, 0x0e, 0x5f, 0x32, 0x61, 0x4a, 0xe9, 0x7c, 0x06, 0xa6,
	0x98, 0x82, 0x39, 0x9f, 0x34, 0x69, 0x87, 0x12, 0x26, 0xcc, 0x7f, 0x1a, 0x30, 0x6b, 0x61, 0x41,
	0xca, 0x58, 0xe0, 0x17, 0x7b, 0xc6, 0x2e, 0x41, 0x8a, 0x74, 0xbc, 0x66, 0xcb, 0xa6, 0xcc, 0x21,
	0x8f, 0x94, 0x11, 0x49, 0x0b, 0x14, 0xab, 0x2a, 0x39, 0xa8, 0x00, 0x67, 0xe2, 0x8d, 0xe0, 0x93,
	0x43, 0xec, 0x3b, 0xb6, 0xb4, 0x51, 0x9d, 0xac, 0xa4, 0x75, 0x2a, 0x1a, 0xb4, 0xd4, 0x98, 0xb4,
	0x12, 0xbd, 0x05, 0xe7, 0x62, 0x19, 0xf2, 0xa8, 0xd9, 0xc2, 0x6c, 0x9f, 0x04, 0x52, 0x53, 0x4a,
	0x2a, 0x56, 0x59, 0xd1, 0xa3, 0x52, 0xce, 0xfc, 0xd8, 0x80, 0x74, 0x11, 0x73, 0x12, 0xb9, 0x3a,
	0x60, 0x9d, 0x71, 0xcc, 0xba, 0x55, 0xc8, 0x36, 0x30, 0x27, 0x7d, 0x86, 0x05, 0x3e, 0xcc, 0x4b,
	0x7e, 0x8f, 0x4d, 0xdf, 0x04, 0xa4, 0x90, 0xfd, 0xe6, 0x4c, 0x2a, 0xac, 0xd2, 0xd1, 0x67, 0xc9,
	0x67, 0x09, 0x58, 0x88, 0x0e, 0x44, 0x5d, 0x60, 0xd1, 0xe5, 0x2f, 0x36, 0xee, 0xb7, 0x61, 0x8a,
	0x8b, 0xd0, 0xda, 0x54, 0xe1, 0xad, 0x51, 0x77, 0x66, 0x9f, 0x51, 0xc4, 0x0a, 0x94, 0xa0, 0x97,
	0x21, 0x7d, 0xe0, 0x09, 0x99, 0x99, 0x3a, 0xde, 0x21, 0xf1, 0xb5, 0x5b, 0xa9, 0x80, 0x57, 0x93,
	0x2c, 0xf4, 0x03, 0xc8, 0x34, 0xbc, 0x30, 0x7b, 0x85, 0xeb, 0x97, 0x2a, 0xbc, 0x31, 0xea, 0xc4,
	0x45, 0x4f, 0x1f, 0x09, 0x39, 0x6d, 0xba, 0xd1, 0x43, 0x99, 0xbf, 0x49, 0x40, 0xba, 0x77, 0x18,
	0xfd, 0x30, 0x74, 0x4e, 0x86, 0x68, 0xbe, 0x50, 0x19, 0x67, 0x8e, 0x3e, 0xa2, 0xc2, 0xba, 0x6e,
	0xe8, 0xeb, 0xab, 0xb0, 0xd0, 0x65, 0xa1, 0x2b, 0x6a, 0x2b, 0x84, 0x2b, 0x1e, 0xb1, 0x2b, 0x92,
	0x6b, 0x7e, 0x62, 0x40, 0x76, 0x50, 0x09, 0x32, 0x61, 0xb9, 0xb8, 0xbd, 0x55, 0xae, 0x6e, 0xdd,
	0xb0, 0xeb, 0x3b, 0x1b, 0x3b, 0x15, 0xbb, 0xb2, 0x75, 0x77, 0xd3, 0xbe, 0xbb, 0x55, 0xaf, 0x55,
	0x4a, 0xd5, 0xf7, 0xaa, 0x95, 0x72, 0x76, 0x02, 0x5d, 0x84, 0xf3, 0x43, 0x30, 0x92, 0x55, 0x29,
	0x67, 0x0d, 0xb4, 0x02, 0x17, 0x86, 0xaa, 0xd0, 0xcc, 0x6c, 0x02, 0x5d, 0x82, 0x97, 0x9e, 0x8a,
	0xa8, 0x94, 0xb3, 0x93, 0xe6, 0xdf, 0x13, 0x30, 0xdf, 0xbf, 0x92, 0xc8, 0xee, 0x8f, 0x59, 0x75,
	0xbc, 0x0d, 0x31, 0x40, 0xf6, 0xc4, 0xcd, 0xfc, 0x97, 0x01, 0xe8, 0xf8, 0x28, 0x7a, 0x05, 0x56,
	0xee, 0x6d, 0xdc, 0xae, 0x96, 0x37, 0x76, 0xb6, 0xad, 0xa7, 0x87, 0xe4, 0x65, 0xb8, 0x38, 0x14,
	0x55, 0xdd, 0xda, 0x28, 0xed, 0x54, 0xef, 0x55, 0xb2, 0x86, 0x74, 0x7a, 0x28, 0x44, 0x03, 0x12,
	0x4f, 0x05, 0x7c, 0x6f, 0xa3, 0x7a, 0x5b, 0x46, 0x05, 0x5d, 0x86, 0x4b, 0x43, 0x01, 0x3b, 0xdb,
	0x9b, 0xc5, 0xfa, 0xce, 0xf6, 0x56, 0xa5, 0x9c, 0x4d, 0x3e, 0xd5, 0x92, 0x72, 0xb5, 0xbe, 0x51,
	0x94, 0x7a, 0xa6, 0xcc, 0x8f, 0x12, 0x3d, 0xd5, 0xac, 0xca, 0xf6, 0x3c, 0xb4, 0x0d, 0x73, 0x51,
	0xc6, 0xd1, 0xe7, 0xf6, 0xda, 0x89, 0x03, 0x6c, 0xc5, 0x3a, 0xd0, 0x36, 0x4c, 0x73, 0x95, 0x15,
	0xf4, 0xf9, 0x7d, 0x7b, 0xac, 0xe5, 0xea, 0x72, 0x4b, 0xab, 0x41, 0x9b, 0x30, 0xa7, 0x2a, 0x81,
	0x83, 0x05, 0x56, 0xc7, 0x37, 0x55, 0x78, 0x7d, 0x54, 0x9d, 0x61, 0xba, 0xb4, 0x54, 0x31, 0x91,
	0x5f, 0xe6, 0x8f, 0x0d, 0x38, 0x15, 0x4d, 0x55, 0x26, 0x7b, 0x94, 0x51, 0xd5, 0xdd, 0xbc, 0xf0,
	0x40, 0x9c, 0x87, 0x59, 0xdc, 0x15, 0x2d, 0x9b, 0xd3, 0x7d, 0xdd, 0x9e, 0xcd, 0x48, 0xba, 0x4e,
	0xf7, 0xcd, 0x4f, 0x13, 0x30, 0x5b, 0xd6, 0x6d, 0x24, 0x7a, 0x1f, 0x50, 0x5c, 0x12, 0xc2, 0x44,
	0x78, 0xe2, 0x14, 0xba, 0x18, 0xe9, 0x08, 0xb9, 0x5f, 0x5c, 0xc0, 0x6e, 0x85, 0xf9, 0x82, 0x38,
	0x36, 0x76, 0xbd, 0x2e, 0x13, 0x3a, 0xbe, 0xe6, 0xc0, 0xb4, 0xb2, 0x5b, 0x8e, 0x66, 0xdd, 0x50,
	0xc8, 0x30, 0xa7, 0x10, 0x27, 0xa0, 0xd1, 0x36, 0x2c, 0xea, 0xce, 0x98, 0x7a, 0x2c, 0x54, 0x97,
	0x1c, 0x59, 0x5d, 0x36, 0x16, 0x0e, 0x38, 0x32, 0x77, 0x42, 0xdc, 0x6d, 0xff, 0xef, 0xc2, 0x74,
	0x15, 0x16, 0xb9, 0xc0, 0xbe, 0xb0, 0x8f, 0x07, 0x6b, 0x41, 0x0d, 0x54, 0xbe, 0x2e, 0x11, 0x7b,
	0x04, 0x0b, 0x03, 0xd7, 0x13, 0xb4, 0x0d, 0xc9, 0x86, 0xe7, 0x84, 0x71, 0x1a, 0xb9, 0xcb, 0x1b,
	0x50, 0x53, 0xf4, 0x9c, 0x23, 0x4b, 0x29, 0x92, 0x57, 0x9d, 0x8e, 0xbc, 0xf3, 0xe8, 0x2d, 0x1d,
	0x10, 0xe6, 0x9f, 0x12, 0x70, 0x6a, 0x88, 0xcc, 0x57, 0x63, 0xd1, 0xaa, 0x30, 0xd3, 0x21, 0x0c,
	0xb7, 0xc5, 0x91, 0x5e, 0xac, 0xb5, 0x51, 0xc3, 0x50, 0x0b, 0xc4, 0xac, 0x50, 0x1e, 0x7d, 0x20,
	0x5b, 0xa5, 0xb6, 0xba, 0x5c, 0x34, 0x3d, 0xd7, 0xa5, 0xc2, 0x25, 0xd1, 0x9a, 0x0d, 0x6a, 0x0d,
	0xae, 0x8e, 0x71, 0x05, 0x0f, 0xe4, 0x4a, 0x91, 0x98, 0xb5, 0xd8, 0x18, 0x64, 0x99, 0xbf, 0x9d,
	0x3c, 0x16, 0xc7, 0x5a, 0x1b, 0xb3, 0xaf, 0x5c, 0x1c, 0x93, 0xcf, 0x19, 0xc7, 0x4d, 0xc8, 0xc6,
	0x9d, 0x8a, 0xde, 0xf9, 0x53, 0x23, 0xef, 0xfc, 0xb8, 0xcb, 0xd1, 0x27, 0xe9, 0x35, 0xd9, 0xeb,
	0x06, 0xcb, 0xd2, 0x68, 0x53, 0x35, 0x92, 0x9b, 0x56, 0xfb, 0x73, 0x41, 0xf3, 0x8b, 0x9a, 0x2d,
	0xdb, 0x62, 0xb5, 0x65, 0x23, 0xa0, 0x1d, 0xdc, 0x25, 0xd3, 0xd6, 0xbc, 0xe2, 0x87, 0x40, 0x6b,
	0x08, 0x92, 0xab, 0x7b, 0xef, 0x20, 0xb2, 0x6e, 0xfe, 0xc1, 0x80, 0xc5, 0x72, 0x74, 0x18, 0x4b,
	0xaa, 0x57, 0xe6, 0xc8, 0x92, 0x17, 0xea, 0x90, 0x19, 0x5e, 0x12, 0x47, 0xae, 0x5c, 0x61, 0x79,
	0xb0, 0x7a, 0x95, 0xa0, 0xef, 0x43, 0xa6, 0xcb, 0x7a, 0xb5, 0x26, 0x94, 0xd6, 0xc2, 0xc9, 0xcf,
	0xb5, 0xd5, 0xaf, 0xc8, 0x6c, 0xc3, 0xf4, 0xdd, 0x8e, 0xa0, 0x2e, 0x41, 0xdf, 0x00, 0x84, 0xb9,
	0xad, 0xfc, 0xf6, 0x9a, 0x0f, 0xed, 0x16, 0xa1, 0xfb, 0x2d, 0xa1, 0x2f, 0x18, 0x0b, 0x98, 0x6f,
	0xef, 0x15, 0x25, 0xff, 0xa6, 0x62, 0xa3, 0x8b, 0x00, 0x87, 0x94, 0x39, 0xde, 0xa1, 0xdd, 0x26,
	0x4c, 0x5f, 0xd4, 0xe6, 0x02, 0xce, 0x6d, 0xc2, 0xd0, 0x59, 0x98, 0x6e, 0x50, 0x71, 0x40, 0x9a,
	0xea, 0xe4, 0xa5, 0x2d, 0x4d, 0x99, 0x2d, 0x38, 0x5d, 0xea, 0xfa, 0x3e, 0x61, 0xa2, 0xd4, 0xf3,
	0x62, 0xc1, 0x51, 0x0d, 0xe6, 0xfb, 0xde, 0x35, 0xc2, 0xb0, 0xbd, 0xf6, 0xcc, 0x3d, 0xde, 0xab,
	0xc3, 0xca, 0xf4, 0xbe, 0x81, 0x70, 0xf3, 0x12, 0xcc, 0xe8, 0xdd, 0xd7, 0xff, 0x4a, 0x93, 0x0c,
	0x5f, 0x69, 0xee, 0xc1, 0xe9, 0xbe, 0x8e, 0xc8, 0x22, 0x1f, 0x76, 0x09, 0x17, 0xb2, 0x7c, 0x37,
	0x5b, 0x98, 0x32, 0x9b, 0x3a, 0xe1, 0xfd, 0x55, 0xd1, 0x55, 0x07, 0x5d, 0x86, 0x0c, 0x6f, 0x79,
	0x87, 0x36, 0x65, 0xb8, 0x29, 0xe8, 0x41, 0x70, 0x53, 0x99, 0xb5, 0xd2, 0x92, 0x59, 0xd5, 0x3c,
	0xb3, 0x0b, 0x67, 0x06, 0xf4, 0xf2, 0x8e, 0xb4, 0x0c, 0xed, 0xf6, 0xbe, 0x1f, 0x50, 0xb6, 0xe7,
	0xe9, 0x73, 0xfc, 0xe6, 0x89, 0xbb, 0x0d, 0xa5, 0x36, 0x7e, 0x4c, 0x90, 0xa4, 0xf9, 0x91, 0x01,
	0x67, 0x07, 0x3b, 0xa9, 0x2f, 0xf6, 0x68, 0xf0, 0x02, 0x97, 0x78, 0x8e, 0x0b, 0x9c, 0xf9, 0x23,
	0x38, 0x77, 0xcc, 0x02, 0xed, 0x7b, 0xdc, 0x1c, 0x1a, 0x2f, 0xa4, 0x39, 0x34, 0xff, 0x6a, 0xf4,
	0x4c, 0x16, 0xa6, 0x99, 0x2f, 0xd7, 0xdf, 0xe1, 0x39, 0x74, 0x72, 0x78, 0x0e, 0xbd, 0x02, 0x0b,
	0x84, 0x39, 0x7d, 0xc8, 0xe0, 0xb5, 0x20, 0x43, 0x98, 0x13, 0xe3, 0x4c, 0x02, 0xb9, 0xe3, 0x6e,
	0xe9, 0x20, 0xf6, 0xe4, 0x61, 0xe3, 0xf9, 0xf2, 0xb0, 0xf9, 0x53, 0x03, 0x5e, 0xd2, 0x07, 0x31,
	0xee, 0x61, 0x65, 0x76, 0xf8, 0x92, 0xb7, 0x8c, 0x03, 0x17, 0x86, 0x9b, 0xa1, 0x5d, 0x2e, 0x43,
	0x52, 0xb5, 0xff, 0xc6, 0x98, 0xed, 0xbf, 0x92, 0x36, 0x7f, 0x62, 0x40, 0x6e, 0x8b, 0x3c, 0xfa,
	0xff, 0xba, 0x8a, 0xe1, 0xfc, 0x10, 0x1b, 0x5e, 0xa8, 0x9f, 0x1f, 0x4f, 0xc2, 0x42, 0x5d, 0x22,
	0x6a, 0xd8, 0xc7, 0x2e, 0x11, 0xc4, 0xe7, 0xb2, 0x44, 0x0e, 0xbc, 0x0d, 0xf0, 0x30, 0xa7, 0xf7,
	0x3f, 0x0e, 0x70, 0xf4, 0x06, 0x9c, 0x0d, 0x72, 0x98, 0x1d, 0xe7, 0xa9, 0x36, 0x75, 0xa9, 0xd0,
	0x8d, 0xc1, 0xe9, 0x60, 0xb4, 0xe7, 0x55, 0xd4, 0xa5, 0x62, 0xe8, 0x7b, 0xd3, 0xe4, 0xd0, 0xf7,
	0xa6, 0xeb, 0x70, 0x81, 0xb7, 0x31, 0x6f, 0xa9, 0x47, 0x99, 0x60, 0x23, 0xda, 0x2e, 0xe5, 0x0d,
	0xd2, 0xc2, 0x07, 0xd4, 0xf3, 0xf5, 0x81, 0x58, 0x0a, 0x31, 0x7a, 0xd3, 0x6e, 0xc6, 0x08, 0xb4,
	0x0e, 0xe7, 0x8f, 0x69, 0x70, 0xbc, 0x43, 0x26, 0xeb, 0x97, 0x7e, 0x47, 0x3b, 0x37, 0x20, 0x5e,
	0xd6, 0xc3, 0xe8, 0x6d, 0xc8, 0x71, 0xba, 0xcf, 0x88, 0x13, 0xd4, 0x37, 0x6e, 0xf7, 0xd4, 0xaf,
	0xe9, 0xe0, 0x09, 0x2e, 0x18, 0x57, 0x65, 0x8e, 0xbf, 0x1f, 0xd5, 0xb2, 0x02, 0x9c, 0x71, 0x29,
	0xe7, 0xb1, 0xa0, 0x8b, 0x1f, 0x51, 0xb7, 0xeb, 0xaa, 0xf6, 0x21, 0x69, 0x9d, 0x0a, 0x06, 0x03,
	0xa9, 0xcd, 0x60, 0xc8, 0xfc, 0xbd, 0x01, 0xf3, 0x37, 0x08, 0x23, 0x9c, 0xf2, 0x92, 0xc7, 0x04,
	0x61, 0x02, 0xdd, 0x87, 0xb4, 0x5a, 0x3d, 0xbb, 0x23, 0x17, 0xe7, 0xc4, 0x89, 0x70, 0x60, 0x5d,
	0xad, 0x14, 0x8f, 0x18, 0x1c, 0xdd, 0x01, 0x88, 0x96, 0x2c, 0xec, 0x0d, 0xc6, 0xb8, 0xc4, 0xf6,
	0x28, 0x29, 0xfc, 0x6c, 0x1a, 0xd2, 0x77, 0xba, 0xc4, 0x3f, 0xaa, 0x13, 0xff, 0x80, 0x36, 0x09,
	0xfa, 0xb9, 0x31, 0xf8, 0x84, 0xf0, 0xed, 0xf1, 0x0a, 0x57, 0x70, 0xee, 0x96, 0xbe, 0x33, 0xa6,
	0x74, 0x70, 0x62, 0x5e, 0x37, 0xd0, 0x2f, 0x8d, 0xe3, 0x0f, 0x92, 0xdf, 0x1d, 0xb7, 0xae, 0x68,
	0xa3, 0xde, 0x1d, 0x5b, 0x5e, 0x1f, 0xe4, 0x5f, 0x19, 0x90, 0x1d, 0x4c, 0xe0, 0xe8, 0xe4, 0x5a,
	0xfb, 0x2b, 0xda, 0xd2, 0xf5, 0xf1, 0x15, 0x68, 0xbb, 0x7e, 0x6d, 0x44, 0x9d, 0x57, 0x5f, 0x06,
	0x42, 0xa5, 0x51, 0x55, 0x3f, 0xa3, 0x5c, 0x2c, 0x95, 0x9f, 0x4f, 0x89, 0xb6, 0xf1, 0x13, 0x03,
	0x16, 0x8f, 0xa5, 0x48, 0x34, 0xb2, 0xef, 0x4f, 0xcb, 0xf0, 0x4b, 0x1b, 0xcf, 0xa1, 0x21, 0x30,
	0xad, 0xf8, 0x9f, 0xc4, 0x9f, 0x1f, 0x2f, 0x1b, 0x9f, 0x3f, 0x5e, 0x36, 0xfe, 0xf1, 0x78, 0xd9,
	0xf8, 0xc5, 0x93, 0xe5, 0x89, 0xcf, 0x9f, 0x2c, 0x4f, 0xfc, 0xed, 0xc9, 0xf2, 0x04, 0x5c, 0x6d,
	0x7a, 0xee, 0x88, 0x13, 0x14, 0x21, 0x38, 0xc5, 0xbe, 0x27, 0xbc, 0x9a, 0x71, 0xff, 0xc1, 0x3e,
	0x15, 0xad, 0x6e, 0x43, 0xc2, 0xd7, 0x9a, 0x1e, 0x77, 0x3d, 0xbe, 0xe6, 0x93, 0x36, 0x3e, 0x22,
	0xfe, 0xda, 0x41, 0x21, 0xfa, 0x54, 0xc5, 0x88, 0xaf, 0x8d, 0xf6, 0xbf, 0xea, 0x3b, 0x8a, 0x0c,
	0xa9, 0x4f, 0x13, 0xc9, 0x5a, 0xa9, 0x54, 0xff, 0x2c, 0x71, 0xa5, 0x16, 0xda, 0x57, 0x92, 0xf6,
	0x95, 0x22, 0xfb, 0x94, 0x3d, 0xf9, 0x7b, 0x1a, 0xff, 0x97, 0x18, 0xb8, 0x2b, 0x81, 0xbb, 0x11,
	0x70, 0x57, 0x01, 0x77, 0x43, 0xe0, 0xe3, 0x44, 0x61, 0x34, 0xe0, 0xee, 0x8d, 0x5a, 0x71, 0x93,
	0x08, 0x2c, 0xcb, 0xd3, 0xbf, 0x13, 0x57, 0x43, 0xa1, 0xf5, 0x75, 0x29, 0x25, 0x7f, 0xb5, 0xd8,
	0xfa, 0xba, 0x92, 0x5b, 0x5f, 0x0f, 0x05, 0x1b, 0xd3, 0xea, 0xbf, 0xd7, 0x6f, 0xfd, 0x37, 0x00,
	0x00, 0xff, 0xff, 0x38, 0x58, 0x1d, 0xfa, 0x51, 0x1e, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QueryServiceClient is the client API for QueryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryServiceClient interface {
	// Queries the current validator set, with filtering.
	ValidatorInfo(ctx context.Context, in *ValidatorInfoRequest, opts ...grpc.CallOption) (QueryService_ValidatorInfoClient, error)
	ValidatorStatus(ctx context.Context, in *ValidatorStatusRequest, opts ...grpc.CallOption) (*ValidatorStatusResponse, error)
	ValidatorPenalty(ctx context.Context, in *ValidatorPenaltyRequest, opts ...grpc.CallOption) (*ValidatorPenaltyResponse, error)
	CurrentValidatorRate(ctx context.Context, in *CurrentValidatorRateRequest, opts ...grpc.CallOption) (*CurrentValidatorRateResponse, error)
	NextValidatorRate(ctx context.Context, in *NextValidatorRateRequest, opts ...grpc.CallOption) (*NextValidatorRateResponse, error)
}

type queryServiceClient struct {
	cc grpc1.ClientConn
}

func NewQueryServiceClient(cc grpc1.ClientConn) QueryServiceClient {
	return &queryServiceClient{cc}
}

func (c *queryServiceClient) ValidatorInfo(ctx context.Context, in *ValidatorInfoRequest, opts ...grpc.CallOption) (QueryService_ValidatorInfoClient, error) {
	stream, err := c.cc.NewStream(ctx, &_QueryService_serviceDesc.Streams[0], "/penumbra.core.component.stake.v1alpha1.QueryService/ValidatorInfo", opts...)
	if err != nil {
		return nil, err
	}
	x := &queryServiceValidatorInfoClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type QueryService_ValidatorInfoClient interface {
	Recv() (*ValidatorInfoResponse, error)
	grpc.ClientStream
}

type queryServiceValidatorInfoClient struct {
	grpc.ClientStream
}

func (x *queryServiceValidatorInfoClient) Recv() (*ValidatorInfoResponse, error) {
	m := new(ValidatorInfoResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queryServiceClient) ValidatorStatus(ctx context.Context, in *ValidatorStatusRequest, opts ...grpc.CallOption) (*ValidatorStatusResponse, error) {
	out := new(ValidatorStatusResponse)
	err := c.cc.Invoke(ctx, "/penumbra.core.component.stake.v1alpha1.QueryService/ValidatorStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryServiceClient) ValidatorPenalty(ctx context.Context, in *ValidatorPenaltyRequest, opts ...grpc.CallOption) (*ValidatorPenaltyResponse, error) {
	out := new(ValidatorPenaltyResponse)
	err := c.cc.Invoke(ctx, "/penumbra.core.component.stake.v1alpha1.QueryService/ValidatorPenalty", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryServiceClient) CurrentValidatorRate(ctx context.Context, in *CurrentValidatorRateRequest, opts ...grpc.CallOption) (*CurrentValidatorRateResponse, error) {
	out := new(CurrentValidatorRateResponse)
	err := c.cc.Invoke(ctx, "/penumbra.core.component.stake.v1alpha1.QueryService/CurrentValidatorRate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryServiceClient) NextValidatorRate(ctx context.Context, in *NextValidatorRateRequest, opts ...grpc.CallOption) (*NextValidatorRateResponse, error) {
	out := new(NextValidatorRateResponse)
	err := c.cc.Invoke(ctx, "/penumbra.core.component.stake.v1alpha1.QueryService/NextValidatorRate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueryServiceServer is the server API for QueryService service.
type QueryServiceServer interface {
	// Queries the current validator set, with filtering.
	ValidatorInfo(*ValidatorInfoRequest, QueryService_ValidatorInfoServer) error
	ValidatorStatus(context.Context, *ValidatorStatusRequest) (*ValidatorStatusResponse, error)
	ValidatorPenalty(context.Context, *ValidatorPenaltyRequest) (*ValidatorPenaltyResponse, error)
	CurrentValidatorRate(context.Context, *CurrentValidatorRateRequest) (*CurrentValidatorRateResponse, error)
	NextValidatorRate(context.Context, *NextValidatorRateRequest) (*NextValidatorRateResponse, error)
}

// UnimplementedQueryServiceServer can be embedded to have forward compatible implementations.
type UnimplementedQueryServiceServer struct {
}

func (*UnimplementedQueryServiceServer) ValidatorInfo(req *ValidatorInfoRequest, srv QueryService_ValidatorInfoServer) error {
	return status.Errorf(codes.Unimplemented, "method ValidatorInfo not implemented")
}
func (*UnimplementedQueryServiceServer) ValidatorStatus(ctx context.Context, req *ValidatorStatusRequest) (*ValidatorStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidatorStatus not implemented")
}
func (*UnimplementedQueryServiceServer) ValidatorPenalty(ctx context.Context, req *ValidatorPenaltyRequest) (*ValidatorPenaltyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidatorPenalty not implemented")
}
func (*UnimplementedQueryServiceServer) CurrentValidatorRate(ctx context.Context, req *CurrentValidatorRateRequest) (*CurrentValidatorRateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CurrentValidatorRate not implemented")
}
func (*UnimplementedQueryServiceServer) NextValidatorRate(ctx context.Context, req *NextValidatorRateRequest) (*NextValidatorRateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NextValidatorRate not implemented")
}

func RegisterQueryServiceServer(s grpc1.Server, srv QueryServiceServer) {
	s.RegisterService(&_QueryService_serviceDesc, srv)
}

func _QueryService_ValidatorInfo_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ValidatorInfoRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryServiceServer).ValidatorInfo(m, &queryServiceValidatorInfoServer{stream})
}

type QueryService_ValidatorInfoServer interface {
	Send(*ValidatorInfoResponse) error
	grpc.ServerStream
}

type queryServiceValidatorInfoServer struct {
	grpc.ServerStream
}

func (x *queryServiceValidatorInfoServer) Send(m *ValidatorInfoResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _QueryService_ValidatorStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidatorStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServiceServer).ValidatorStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/penumbra.core.component.stake.v1alpha1.QueryService/ValidatorStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServiceServer).ValidatorStatus(ctx, req.(*ValidatorStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueryService_ValidatorPenalty_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidatorPenaltyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServiceServer).ValidatorPenalty(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/penumbra.core.component.stake.v1alpha1.QueryService/ValidatorPenalty",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServiceServer).ValidatorPenalty(ctx, req.(*ValidatorPenaltyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueryService_CurrentValidatorRate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CurrentValidatorRateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServiceServer).CurrentValidatorRate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/penumbra.core.component.stake.v1alpha1.QueryService/CurrentValidatorRate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServiceServer).CurrentValidatorRate(ctx, req.(*CurrentValidatorRateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueryService_NextValidatorRate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NextValidatorRateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServiceServer).NextValidatorRate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/penumbra.core.component.stake.v1alpha1.QueryService/NextValidatorRate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServiceServer).NextValidatorRate(ctx, req.(*NextValidatorRateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _QueryService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "penumbra.core.component.stake.v1alpha1.QueryService",
	HandlerType: (*QueryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ValidatorStatus",
			Handler:    _QueryService_ValidatorStatus_Handler,
		},
		{
			MethodName: "ValidatorPenalty",
			Handler:    _QueryService_ValidatorPenalty_Handler,
		},
		{
			MethodName: "CurrentValidatorRate",
			Handler:    _QueryService_CurrentValidatorRate_Handler,
		},
		{
			MethodName: "NextValidatorRate",
			Handler:    _QueryService_NextValidatorRate_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ValidatorInfo",
			Handler:       _QueryService_ValidatorInfo_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "penumbra/core/component/stake/v1alpha1/stake.proto",
}

func (m *ZKUndelegateClaimProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZKUndelegateClaimProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZKUndelegateClaimProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Inner) > 0 {
		i -= len(m.Inner)
		copy(dAtA[i:], m.Inner)
		i = encodeVarintStake(dAtA, i, uint64(len(m.Inner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Validator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Validator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Validator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GovernanceKey != nil {
		{
			size, err := m.GovernanceKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.SequenceNumber != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.SequenceNumber))
		i--
		dAtA[i] = 0x38
	}
	if len(m.FundingStreams) > 0 {
		for iNdEx := len(m.FundingStreams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FundingStreams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStake(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintStake(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Website) > 0 {
		i -= len(m.Website)
		copy(dAtA[i:], m.Website)
		i = encodeVarintStake(dAtA, i, uint64(len(m.Website)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintStake(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ConsensusKey) > 0 {
		i -= len(m.ConsensusKey)
		copy(dAtA[i:], m.ConsensusKey)
		i = encodeVarintStake(dAtA, i, uint64(len(m.ConsensusKey)))
		i--
		dAtA[i] = 0x12
	}
	if m.IdentityKey != nil {
		{
			size, err := m.IdentityKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidatorList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ValidatorKeys) > 0 {
		for iNdEx := len(m.ValidatorKeys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ValidatorKeys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStake(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FundingStream) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FundingStream) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FundingStream) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Recipient != nil {
		{
			size := m.Recipient.Size()
			i -= size
			if _, err := m.Recipient.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *FundingStream_ToAddress_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FundingStream_ToAddress_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ToAddress != nil {
		{
			size, err := m.ToAddress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *FundingStream_ToDao_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FundingStream_ToDao_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ToDao != nil {
		{
			size, err := m.ToDao.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *FundingStream_ToAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FundingStream_ToAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FundingStream_ToAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RateBps != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.RateBps))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintStake(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FundingStream_ToDao) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FundingStream_ToDao) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FundingStream_ToDao) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RateBps != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.RateBps))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *RateData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ValidatorExchangeRate != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.ValidatorExchangeRate))
		i--
		dAtA[i] = 0x28
	}
	if m.ValidatorRewardRate != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.ValidatorRewardRate))
		i--
		dAtA[i] = 0x20
	}
	if m.EpochIndex != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.EpochIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.IdentityKey != nil {
		{
			size, err := m.IdentityKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BaseRateData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BaseRateData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BaseRateData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BaseExchangeRate != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.BaseExchangeRate))
		i--
		dAtA[i] = 0x18
	}
	if m.BaseRewardRate != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.BaseRewardRate))
		i--
		dAtA[i] = 0x10
	}
	if m.EpochIndex != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.EpochIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ValidatorStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BondingState != nil {
		{
			size, err := m.BondingState.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.VotingPower != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.VotingPower))
		i--
		dAtA[i] = 0x18
	}
	if m.State != nil {
		{
			size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.IdentityKey != nil {
		{
			size, err := m.IdentityKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BondingState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BondingState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BondingState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UnbondingEpoch != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.UnbondingEpoch))
		i--
		dAtA[i] = 0x10
	}
	if m.State != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ValidatorState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ValidatorInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RateData != nil {
		{
			size, err := m.RateData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Validator != nil {
		{
			size, err := m.Validator.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidatorDefinition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorDefinition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorDefinition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AuthSig) > 0 {
		i -= len(m.AuthSig)
		copy(dAtA[i:], m.AuthSig)
		i = encodeVarintStake(dAtA, i, uint64(len(m.AuthSig)))
		i--
		dAtA[i] = 0x12
	}
	if m.Validator != nil {
		{
			size, err := m.Validator.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Delegate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Delegate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Delegate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DelegationAmount != nil {
		{
			size, err := m.DelegationAmount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.UnbondedAmount != nil {
		{
			size, err := m.UnbondedAmount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.EpochIndex != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.EpochIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.ValidatorIdentity != nil {
		{
			size, err := m.ValidatorIdentity.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Undelegate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Undelegate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Undelegate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DelegationAmount != nil {
		{
			size, err := m.DelegationAmount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.UnbondedAmount != nil {
		{
			size, err := m.UnbondedAmount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.StartEpochIndex != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.StartEpochIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.ValidatorIdentity != nil {
		{
			size, err := m.ValidatorIdentity.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UndelegateClaim) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UndelegateClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UndelegateClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Proof) > 0 {
		i -= len(m.Proof)
		copy(dAtA[i:], m.Proof)
		i = encodeVarintStake(dAtA, i, uint64(len(m.Proof)))
		i--
		dAtA[i] = 0x12
	}
	if m.Body != nil {
		{
			size, err := m.Body.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UndelegateClaimBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UndelegateClaimBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UndelegateClaimBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BalanceCommitment != nil {
		{
			size, err := m.BalanceCommitment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Penalty != nil {
		{
			size, err := m.Penalty.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.StartEpochIndex != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.StartEpochIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.ValidatorIdentity != nil {
		{
			size, err := m.ValidatorIdentity.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UndelegateClaimPlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UndelegateClaimPlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UndelegateClaimPlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProofBlindingS) > 0 {
		i -= len(m.ProofBlindingS)
		copy(dAtA[i:], m.ProofBlindingS)
		i = encodeVarintStake(dAtA, i, uint64(len(m.ProofBlindingS)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ProofBlindingR) > 0 {
		i -= len(m.ProofBlindingR)
		copy(dAtA[i:], m.ProofBlindingR)
		i = encodeVarintStake(dAtA, i, uint64(len(m.ProofBlindingR)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.BalanceBlinding) > 0 {
		i -= len(m.BalanceBlinding)
		copy(dAtA[i:], m.BalanceBlinding)
		i = encodeVarintStake(dAtA, i, uint64(len(m.BalanceBlinding)))
		i--
		dAtA[i] = 0x32
	}
	if m.UnbondingAmount != nil {
		{
			size, err := m.UnbondingAmount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Penalty != nil {
		{
			size, err := m.Penalty.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.StartEpochIndex != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.StartEpochIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.ValidatorIdentity != nil {
		{
			size, err := m.ValidatorIdentity.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DelegationChanges) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelegationChanges) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelegationChanges) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Undelegations) > 0 {
		for iNdEx := len(m.Undelegations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Undelegations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStake(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Delegations) > 0 {
		for iNdEx := len(m.Delegations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Delegations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStake(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Uptime) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Uptime) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Uptime) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Bitvec) > 0 {
		i -= len(m.Bitvec)
		copy(dAtA[i:], m.Bitvec)
		i = encodeVarintStake(dAtA, i, uint64(len(m.Bitvec)))
		i--
		dAtA[i] = 0x1a
	}
	if m.WindowLen != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.WindowLen))
		i--
		dAtA[i] = 0x10
	}
	if m.AsOfBlockHeight != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.AsOfBlockHeight))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CurrentConsensusKeys) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CurrentConsensusKeys) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CurrentConsensusKeys) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ConsensusKeys) > 0 {
		for iNdEx := len(m.ConsensusKeys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ConsensusKeys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStake(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Penalty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Penalty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Penalty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Inner != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.Inner))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ValidatorInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ShowInactive {
		i--
		if m.ShowInactive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintStake(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidatorInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ValidatorInfo != nil {
		{
			size, err := m.ValidatorInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidatorStatusRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorStatusRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorStatusRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IdentityKey != nil {
		{
			size, err := m.IdentityKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintStake(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidatorStatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorStatusResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorStatusResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidatorPenaltyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorPenaltyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorPenaltyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EndEpochIndex != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.EndEpochIndex))
		i--
		dAtA[i] = 0x20
	}
	if m.StartEpochIndex != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.StartEpochIndex))
		i--
		dAtA[i] = 0x18
	}
	if m.IdentityKey != nil {
		{
			size, err := m.IdentityKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintStake(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidatorPenaltyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorPenaltyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorPenaltyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Penalty != nil {
		{
			size, err := m.Penalty.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CurrentValidatorRateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CurrentValidatorRateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CurrentValidatorRateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IdentityKey != nil {
		{
			size, err := m.IdentityKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintStake(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CurrentValidatorRateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CurrentValidatorRateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CurrentValidatorRateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NextValidatorRateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NextValidatorRateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NextValidatorRateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IdentityKey != nil {
		{
			size, err := m.IdentityKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintStake(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NextValidatorRateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NextValidatorRateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NextValidatorRateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StakeParameters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StakeParameters) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StakeParameters) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MissedBlocksMaximum != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.MissedBlocksMaximum))
		i--
		dAtA[i] = 0x38
	}
	if m.SignedBlocksWindowLen != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.SignedBlocksWindowLen))
		i--
		dAtA[i] = 0x30
	}
	if m.SlashingPenaltyDowntime != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.SlashingPenaltyDowntime))
		i--
		dAtA[i] = 0x28
	}
	if m.SlashingPenaltyMisbehavior != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.SlashingPenaltyMisbehavior))
		i--
		dAtA[i] = 0x20
	}
	if m.BaseRewardRate != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.BaseRewardRate))
		i--
		dAtA[i] = 0x18
	}
	if m.ActiveValidatorLimit != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.ActiveValidatorLimit))
		i--
		dAtA[i] = 0x10
	}
	if m.UnbondingEpochs != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.UnbondingEpochs))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GenesisContent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenesisContent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenesisContent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Validators) > 0 {
		for iNdEx := len(m.Validators) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Validators[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStake(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.StakeParams != nil {
		{
			size, err := m.StakeParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintStake(dAtA []byte, offset int, v uint64) int {
	offset -= sovStake(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ZKUndelegateClaimProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Inner)
	if l > 0 {
		n += 1 + l + sovStake(uint64(l))
	}
	return n
}

func (m *Validator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IdentityKey != nil {
		l = m.IdentityKey.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	l = len(m.ConsensusKey)
	if l > 0 {
		n += 1 + l + sovStake(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovStake(uint64(l))
	}
	l = len(m.Website)
	if l > 0 {
		n += 1 + l + sovStake(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovStake(uint64(l))
	}
	if len(m.FundingStreams) > 0 {
		for _, e := range m.FundingStreams {
			l = e.Size()
			n += 1 + l + sovStake(uint64(l))
		}
	}
	if m.SequenceNumber != 0 {
		n += 1 + sovStake(uint64(m.SequenceNumber))
	}
	if m.Enabled {
		n += 2
	}
	if m.GovernanceKey != nil {
		l = m.GovernanceKey.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	return n
}

func (m *ValidatorList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ValidatorKeys) > 0 {
		for _, e := range m.ValidatorKeys {
			l = e.Size()
			n += 1 + l + sovStake(uint64(l))
		}
	}
	return n
}

func (m *FundingStream) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Recipient != nil {
		n += m.Recipient.Size()
	}
	return n
}

func (m *FundingStream_ToAddress_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ToAddress != nil {
		l = m.ToAddress.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	return n
}
func (m *FundingStream_ToDao_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ToDao != nil {
		l = m.ToDao.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	return n
}
func (m *FundingStream_ToAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovStake(uint64(l))
	}
	if m.RateBps != 0 {
		n += 1 + sovStake(uint64(m.RateBps))
	}
	return n
}

func (m *FundingStream_ToDao) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RateBps != 0 {
		n += 1 + sovStake(uint64(m.RateBps))
	}
	return n
}

func (m *RateData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IdentityKey != nil {
		l = m.IdentityKey.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	if m.EpochIndex != 0 {
		n += 1 + sovStake(uint64(m.EpochIndex))
	}
	if m.ValidatorRewardRate != 0 {
		n += 1 + sovStake(uint64(m.ValidatorRewardRate))
	}
	if m.ValidatorExchangeRate != 0 {
		n += 1 + sovStake(uint64(m.ValidatorExchangeRate))
	}
	return n
}

func (m *BaseRateData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EpochIndex != 0 {
		n += 1 + sovStake(uint64(m.EpochIndex))
	}
	if m.BaseRewardRate != 0 {
		n += 1 + sovStake(uint64(m.BaseRewardRate))
	}
	if m.BaseExchangeRate != 0 {
		n += 1 + sovStake(uint64(m.BaseExchangeRate))
	}
	return n
}

func (m *ValidatorStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IdentityKey != nil {
		l = m.IdentityKey.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	if m.VotingPower != 0 {
		n += 1 + sovStake(uint64(m.VotingPower))
	}
	if m.BondingState != nil {
		l = m.BondingState.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	return n
}

func (m *BondingState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovStake(uint64(m.State))
	}
	if m.UnbondingEpoch != 0 {
		n += 1 + sovStake(uint64(m.UnbondingEpoch))
	}
	return n
}

func (m *ValidatorState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovStake(uint64(m.State))
	}
	return n
}

func (m *ValidatorInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Validator != nil {
		l = m.Validator.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	if m.RateData != nil {
		l = m.RateData.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	return n
}

func (m *ValidatorDefinition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Validator != nil {
		l = m.Validator.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	l = len(m.AuthSig)
	if l > 0 {
		n += 1 + l + sovStake(uint64(l))
	}
	return n
}

func (m *Delegate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ValidatorIdentity != nil {
		l = m.ValidatorIdentity.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	if m.EpochIndex != 0 {
		n += 1 + sovStake(uint64(m.EpochIndex))
	}
	if m.UnbondedAmount != nil {
		l = m.UnbondedAmount.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	if m.DelegationAmount != nil {
		l = m.DelegationAmount.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	return n
}

func (m *Undelegate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ValidatorIdentity != nil {
		l = m.ValidatorIdentity.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	if m.StartEpochIndex != 0 {
		n += 1 + sovStake(uint64(m.StartEpochIndex))
	}
	if m.UnbondedAmount != nil {
		l = m.UnbondedAmount.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	if m.DelegationAmount != nil {
		l = m.DelegationAmount.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	return n
}

func (m *UndelegateClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Body != nil {
		l = m.Body.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	l = len(m.Proof)
	if l > 0 {
		n += 1 + l + sovStake(uint64(l))
	}
	return n
}

func (m *UndelegateClaimBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ValidatorIdentity != nil {
		l = m.ValidatorIdentity.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	if m.StartEpochIndex != 0 {
		n += 1 + sovStake(uint64(m.StartEpochIndex))
	}
	if m.Penalty != nil {
		l = m.Penalty.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	if m.BalanceCommitment != nil {
		l = m.BalanceCommitment.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	return n
}

func (m *UndelegateClaimPlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ValidatorIdentity != nil {
		l = m.ValidatorIdentity.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	if m.StartEpochIndex != 0 {
		n += 1 + sovStake(uint64(m.StartEpochIndex))
	}
	if m.Penalty != nil {
		l = m.Penalty.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	if m.UnbondingAmount != nil {
		l = m.UnbondingAmount.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	l = len(m.BalanceBlinding)
	if l > 0 {
		n += 1 + l + sovStake(uint64(l))
	}
	l = len(m.ProofBlindingR)
	if l > 0 {
		n += 1 + l + sovStake(uint64(l))
	}
	l = len(m.ProofBlindingS)
	if l > 0 {
		n += 1 + l + sovStake(uint64(l))
	}
	return n
}

func (m *DelegationChanges) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Delegations) > 0 {
		for _, e := range m.Delegations {
			l = e.Size()
			n += 1 + l + sovStake(uint64(l))
		}
	}
	if len(m.Undelegations) > 0 {
		for _, e := range m.Undelegations {
			l = e.Size()
			n += 1 + l + sovStake(uint64(l))
		}
	}
	return n
}

func (m *Uptime) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AsOfBlockHeight != 0 {
		n += 1 + sovStake(uint64(m.AsOfBlockHeight))
	}
	if m.WindowLen != 0 {
		n += 1 + sovStake(uint64(m.WindowLen))
	}
	l = len(m.Bitvec)
	if l > 0 {
		n += 1 + l + sovStake(uint64(l))
	}
	return n
}

func (m *CurrentConsensusKeys) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ConsensusKeys) > 0 {
		for _, e := range m.ConsensusKeys {
			l = e.Size()
			n += 1 + l + sovStake(uint64(l))
		}
	}
	return n
}

func (m *Penalty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Inner != 0 {
		n += 1 + sovStake(uint64(m.Inner))
	}
	return n
}

func (m *ValidatorInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovStake(uint64(l))
	}
	if m.ShowInactive {
		n += 2
	}
	return n
}

func (m *ValidatorInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ValidatorInfo != nil {
		l = m.ValidatorInfo.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	return n
}

func (m *ValidatorStatusRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovStake(uint64(l))
	}
	if m.IdentityKey != nil {
		l = m.IdentityKey.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	return n
}

func (m *ValidatorStatusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	return n
}

func (m *ValidatorPenaltyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovStake(uint64(l))
	}
	if m.IdentityKey != nil {
		l = m.IdentityKey.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	if m.StartEpochIndex != 0 {
		n += 1 + sovStake(uint64(m.StartEpochIndex))
	}
	if m.EndEpochIndex != 0 {
		n += 1 + sovStake(uint64(m.EndEpochIndex))
	}
	return n
}

func (m *ValidatorPenaltyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Penalty != nil {
		l = m.Penalty.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	return n
}

func (m *CurrentValidatorRateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovStake(uint64(l))
	}
	if m.IdentityKey != nil {
		l = m.IdentityKey.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	return n
}

func (m *CurrentValidatorRateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	return n
}

func (m *NextValidatorRateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovStake(uint64(l))
	}
	if m.IdentityKey != nil {
		l = m.IdentityKey.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	return n
}

func (m *NextValidatorRateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	return n
}

func (m *StakeParameters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UnbondingEpochs != 0 {
		n += 1 + sovStake(uint64(m.UnbondingEpochs))
	}
	if m.ActiveValidatorLimit != 0 {
		n += 1 + sovStake(uint64(m.ActiveValidatorLimit))
	}
	if m.BaseRewardRate != 0 {
		n += 1 + sovStake(uint64(m.BaseRewardRate))
	}
	if m.SlashingPenaltyMisbehavior != 0 {
		n += 1 + sovStake(uint64(m.SlashingPenaltyMisbehavior))
	}
	if m.SlashingPenaltyDowntime != 0 {
		n += 1 + sovStake(uint64(m.SlashingPenaltyDowntime))
	}
	if m.SignedBlocksWindowLen != 0 {
		n += 1 + sovStake(uint64(m.SignedBlocksWindowLen))
	}
	if m.MissedBlocksMaximum != 0 {
		n += 1 + sovStake(uint64(m.MissedBlocksMaximum))
	}
	return n
}

func (m *GenesisContent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StakeParams != nil {
		l = m.StakeParams.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	if len(m.Validators) > 0 {
		for _, e := range m.Validators {
			l = e.Size()
			n += 1 + l + sovStake(uint64(l))
		}
	}
	return n
}

func sovStake(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozStake(x uint64) (n int) {
	return sovStake(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ZKUndelegateClaimProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZKUndelegateClaimProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZKUndelegateClaimProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inner = append(m.Inner[:0], dAtA[iNdEx:postIndex]...)
			if m.Inner == nil {
				m.Inner = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Validator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Validator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Validator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdentityKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdentityKey == nil {
				m.IdentityKey = &v1alpha1.IdentityKey{}
			}
			if err := m.IdentityKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsensusKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsensusKey = append(m.ConsensusKey[:0], dAtA[iNdEx:postIndex]...)
			if m.ConsensusKey == nil {
				m.ConsensusKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Website", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Website = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FundingStreams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FundingStreams = append(m.FundingStreams, &FundingStream{})
			if err := m.FundingStreams[len(m.FundingStreams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNumber", wireType)
			}
			m.SequenceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GovernanceKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GovernanceKey == nil {
				m.GovernanceKey = &v1alpha1.GovernanceKey{}
			}
			if err := m.GovernanceKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorKeys = append(m.ValidatorKeys, &v1alpha1.IdentityKey{})
			if err := m.ValidatorKeys[len(m.ValidatorKeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FundingStream) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FundingStream: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FundingStream: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FundingStream_ToAddress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Recipient = &FundingStream_ToAddress_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToDao", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FundingStream_ToDao{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Recipient = &FundingStream_ToDao_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FundingStream_ToAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ToAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ToAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateBps", wireType)
			}
			m.RateBps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RateBps |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FundingStream_ToDao) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ToDao: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ToDao: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateBps", wireType)
			}
			m.RateBps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RateBps |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RateData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RateData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RateData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdentityKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdentityKey == nil {
				m.IdentityKey = &v1alpha1.IdentityKey{}
			}
			if err := m.IdentityKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochIndex", wireType)
			}
			m.EpochIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorRewardRate", wireType)
			}
			m.ValidatorRewardRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidatorRewardRate |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorExchangeRate", wireType)
			}
			m.ValidatorExchangeRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidatorExchangeRate |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BaseRateData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BaseRateData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BaseRateData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochIndex", wireType)
			}
			m.EpochIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseRewardRate", wireType)
			}
			m.BaseRewardRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseRewardRate |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseExchangeRate", wireType)
			}
			m.BaseExchangeRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseExchangeRate |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdentityKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdentityKey == nil {
				m.IdentityKey = &v1alpha1.IdentityKey{}
			}
			if err := m.IdentityKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &ValidatorState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotingPower", wireType)
			}
			m.VotingPower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VotingPower |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondingState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BondingState == nil {
				m.BondingState = &BondingState{}
			}
			if err := m.BondingState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BondingState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BondingState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BondingState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= BondingState_BondingStateEnum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondingEpoch", wireType)
			}
			m.UnbondingEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnbondingEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= ValidatorState_ValidatorStateEnum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Validator == nil {
				m.Validator = &Validator{}
			}
			if err := m.Validator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &ValidatorStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RateData == nil {
				m.RateData = &RateData{}
			}
			if err := m.RateData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorDefinition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorDefinition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorDefinition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Validator == nil {
				m.Validator = &Validator{}
			}
			if err := m.Validator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthSig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthSig = append(m.AuthSig[:0], dAtA[iNdEx:postIndex]...)
			if m.AuthSig == nil {
				m.AuthSig = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Delegate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Delegate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Delegate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorIdentity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ValidatorIdentity == nil {
				m.ValidatorIdentity = &v1alpha1.IdentityKey{}
			}
			if err := m.ValidatorIdentity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochIndex", wireType)
			}
			m.EpochIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondedAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UnbondedAmount == nil {
				m.UnbondedAmount = &v1alpha11.Amount{}
			}
			if err := m.UnbondedAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegationAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DelegationAmount == nil {
				m.DelegationAmount = &v1alpha11.Amount{}
			}
			if err := m.DelegationAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Undelegate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Undelegate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Undelegate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorIdentity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ValidatorIdentity == nil {
				m.ValidatorIdentity = &v1alpha1.IdentityKey{}
			}
			if err := m.ValidatorIdentity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartEpochIndex", wireType)
			}
			m.StartEpochIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartEpochIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondedAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UnbondedAmount == nil {
				m.UnbondedAmount = &v1alpha11.Amount{}
			}
			if err := m.UnbondedAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegationAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DelegationAmount == nil {
				m.DelegationAmount = &v1alpha11.Amount{}
			}
			if err := m.DelegationAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UndelegateClaim) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UndelegateClaim: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UndelegateClaim: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Body == nil {
				m.Body = &UndelegateClaimBody{}
			}
			if err := m.Body.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proof = append(m.Proof[:0], dAtA[iNdEx:postIndex]...)
			if m.Proof == nil {
				m.Proof = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UndelegateClaimBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UndelegateClaimBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UndelegateClaimBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorIdentity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ValidatorIdentity == nil {
				m.ValidatorIdentity = &v1alpha1.IdentityKey{}
			}
			if err := m.ValidatorIdentity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartEpochIndex", wireType)
			}
			m.StartEpochIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartEpochIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Penalty", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Penalty == nil {
				m.Penalty = &Penalty{}
			}
			if err := m.Penalty.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BalanceCommitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BalanceCommitment == nil {
				m.BalanceCommitment = &v1alpha12.BalanceCommitment{}
			}
			if err := m.BalanceCommitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UndelegateClaimPlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UndelegateClaimPlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UndelegateClaimPlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorIdentity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ValidatorIdentity == nil {
				m.ValidatorIdentity = &v1alpha1.IdentityKey{}
			}
			if err := m.ValidatorIdentity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartEpochIndex", wireType)
			}
			m.StartEpochIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartEpochIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Penalty", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Penalty == nil {
				m.Penalty = &Penalty{}
			}
			if err := m.Penalty.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondingAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UnbondingAmount == nil {
				m.UnbondingAmount = &v1alpha11.Amount{}
			}
			if err := m.UnbondingAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BalanceBlinding", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BalanceBlinding = append(m.BalanceBlinding[:0], dAtA[iNdEx:postIndex]...)
			if m.BalanceBlinding == nil {
				m.BalanceBlinding = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofBlindingR", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofBlindingR = append(m.ProofBlindingR[:0], dAtA[iNdEx:postIndex]...)
			if m.ProofBlindingR == nil {
				m.ProofBlindingR = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofBlindingS", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofBlindingS = append(m.ProofBlindingS[:0], dAtA[iNdEx:postIndex]...)
			if m.ProofBlindingS == nil {
				m.ProofBlindingS = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelegationChanges) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelegationChanges: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelegationChanges: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delegations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Delegations = append(m.Delegations, &Delegate{})
			if err := m.Delegations[len(m.Delegations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Undelegations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Undelegations = append(m.Undelegations, &Undelegate{})
			if err := m.Undelegations[len(m.Undelegations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Uptime) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Uptime: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Uptime: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsOfBlockHeight", wireType)
			}
			m.AsOfBlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AsOfBlockHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowLen", wireType)
			}
			m.WindowLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WindowLen |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bitvec", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bitvec = append(m.Bitvec[:0], dAtA[iNdEx:postIndex]...)
			if m.Bitvec == nil {
				m.Bitvec = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CurrentConsensusKeys) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CurrentConsensusKeys: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CurrentConsensusKeys: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsensusKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsensusKeys = append(m.ConsensusKeys, &v1alpha1.ConsensusKey{})
			if err := m.ConsensusKeys[len(m.ConsensusKeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Penalty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Penalty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Penalty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			m.Inner = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Inner |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowInactive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ShowInactive = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ValidatorInfo == nil {
				m.ValidatorInfo = &ValidatorInfo{}
			}
			if err := m.ValidatorInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorStatusRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorStatusRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorStatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdentityKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdentityKey == nil {
				m.IdentityKey = &v1alpha1.IdentityKey{}
			}
			if err := m.IdentityKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorStatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorStatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorStatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &ValidatorStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorPenaltyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorPenaltyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorPenaltyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdentityKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdentityKey == nil {
				m.IdentityKey = &v1alpha1.IdentityKey{}
			}
			if err := m.IdentityKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartEpochIndex", wireType)
			}
			m.StartEpochIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartEpochIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndEpochIndex", wireType)
			}
			m.EndEpochIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndEpochIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorPenaltyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorPenaltyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorPenaltyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Penalty", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Penalty == nil {
				m.Penalty = &Penalty{}
			}
			if err := m.Penalty.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CurrentValidatorRateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CurrentValidatorRateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CurrentValidatorRateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdentityKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdentityKey == nil {
				m.IdentityKey = &v1alpha1.IdentityKey{}
			}
			if err := m.IdentityKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CurrentValidatorRateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CurrentValidatorRateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CurrentValidatorRateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &RateData{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NextValidatorRateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NextValidatorRateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NextValidatorRateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdentityKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdentityKey == nil {
				m.IdentityKey = &v1alpha1.IdentityKey{}
			}
			if err := m.IdentityKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NextValidatorRateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NextValidatorRateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NextValidatorRateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &RateData{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StakeParameters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StakeParameters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StakeParameters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondingEpochs", wireType)
			}
			m.UnbondingEpochs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnbondingEpochs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveValidatorLimit", wireType)
			}
			m.ActiveValidatorLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActiveValidatorLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseRewardRate", wireType)
			}
			m.BaseRewardRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseRewardRate |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashingPenaltyMisbehavior", wireType)
			}
			m.SlashingPenaltyMisbehavior = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlashingPenaltyMisbehavior |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashingPenaltyDowntime", wireType)
			}
			m.SlashingPenaltyDowntime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlashingPenaltyDowntime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignedBlocksWindowLen", wireType)
			}
			m.SignedBlocksWindowLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SignedBlocksWindowLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MissedBlocksMaximum", wireType)
			}
			m.MissedBlocksMaximum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MissedBlocksMaximum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenesisContent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenesisContent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenesisContent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakeParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StakeParams == nil {
				m.StakeParams = &StakeParameters{}
			}
			if err := m.StakeParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validators", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validators = append(m.Validators, &Validator{})
			if err := m.Validators[len(m.Validators)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStake(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStake
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStake
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStake
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthStake
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupStake
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthStake
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthStake        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStake          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupStake = fmt.Errorf("proto: unexpected end of group")
)
