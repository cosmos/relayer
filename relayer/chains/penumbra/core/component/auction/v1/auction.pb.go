// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: penumbra/core/component/auction/v1/auction.proto

package auctionv1

import (
	context "context"
	fmt "fmt"
	types "github.com/cosmos/cosmos-sdk/codec/types"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	v11 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/asset/v1"
	v1 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/component/dex/v1"
	v12 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/num/v1"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// The reason the auction ended.
type EventDutchAuctionEnded_Reason int32

const (
	EventDutchAuctionEnded_REASON_UNSPECIFIED EventDutchAuctionEnded_Reason = 0
	// The auction ended due to reaching its terminal height.
	EventDutchAuctionEnded_REASON_EXPIRED EventDutchAuctionEnded_Reason = 1
	// The auction ran out of reserves.
	EventDutchAuctionEnded_REASON_FILLED EventDutchAuctionEnded_Reason = 2
	// The auction ended was terminated by the initiator.
	EventDutchAuctionEnded_REASON_CLOSED_BY_OWNER EventDutchAuctionEnded_Reason = 3
)

var EventDutchAuctionEnded_Reason_name = map[int32]string{
	0: "REASON_UNSPECIFIED",
	1: "REASON_EXPIRED",
	2: "REASON_FILLED",
	3: "REASON_CLOSED_BY_OWNER",
}

var EventDutchAuctionEnded_Reason_value = map[string]int32{
	"REASON_UNSPECIFIED":     0,
	"REASON_EXPIRED":         1,
	"REASON_FILLED":          2,
	"REASON_CLOSED_BY_OWNER": 3,
}

func (x EventDutchAuctionEnded_Reason) String() string {
	return proto.EnumName(EventDutchAuctionEnded_Reason_name, int32(x))
}

func (EventDutchAuctionEnded_Reason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5bd5c1fb0f471c5d, []int{19, 0}
}

// The configuration parameters for the auction component.
type AuctionParameters struct {
}

func (m *AuctionParameters) Reset()         { *m = AuctionParameters{} }
func (m *AuctionParameters) String() string { return proto.CompactTextString(m) }
func (*AuctionParameters) ProtoMessage()    {}
func (*AuctionParameters) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bd5c1fb0f471c5d, []int{0}
}
func (m *AuctionParameters) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuctionParameters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuctionParameters.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuctionParameters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuctionParameters.Merge(m, src)
}
func (m *AuctionParameters) XXX_Size() int {
	return m.Size()
}
func (m *AuctionParameters) XXX_DiscardUnknown() {
	xxx_messageInfo_AuctionParameters.DiscardUnknown(m)
}

var xxx_messageInfo_AuctionParameters proto.InternalMessageInfo

// Genesis data for the auction component.
type GenesisContent struct {
	// The configuration parameters for the auction component at genesis.
	Params *AuctionParameters `protobuf:"bytes,1,opt,name=params,proto3" json:"params,omitempty"`
}

func (m *GenesisContent) Reset()         { *m = GenesisContent{} }
func (m *GenesisContent) String() string { return proto.CompactTextString(m) }
func (*GenesisContent) ProtoMessage()    {}
func (*GenesisContent) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bd5c1fb0f471c5d, []int{1}
}
func (m *GenesisContent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenesisContent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenesisContent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenesisContent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenesisContent.Merge(m, src)
}
func (m *GenesisContent) XXX_Size() int {
	return m.Size()
}
func (m *GenesisContent) XXX_DiscardUnknown() {
	xxx_messageInfo_GenesisContent.DiscardUnknown(m)
}

var xxx_messageInfo_GenesisContent proto.InternalMessageInfo

func (m *GenesisContent) GetParams() *AuctionParameters {
	if m != nil {
		return m.Params
	}
	return nil
}

type AuctionStateByIdRequest struct {
	Id *AuctionId `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *AuctionStateByIdRequest) Reset()         { *m = AuctionStateByIdRequest{} }
func (m *AuctionStateByIdRequest) String() string { return proto.CompactTextString(m) }
func (*AuctionStateByIdRequest) ProtoMessage()    {}
func (*AuctionStateByIdRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bd5c1fb0f471c5d, []int{2}
}
func (m *AuctionStateByIdRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuctionStateByIdRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuctionStateByIdRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuctionStateByIdRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuctionStateByIdRequest.Merge(m, src)
}
func (m *AuctionStateByIdRequest) XXX_Size() int {
	return m.Size()
}
func (m *AuctionStateByIdRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AuctionStateByIdRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AuctionStateByIdRequest proto.InternalMessageInfo

func (m *AuctionStateByIdRequest) GetId() *AuctionId {
	if m != nil {
		return m.Id
	}
	return nil
}

type AuctionStateByIdResponse struct {
	// If present, the state of the auction. If not present, no such auction is known.
	Auction *types.Any `protobuf:"bytes,2,opt,name=auction,proto3" json:"auction,omitempty"`
	// The state of any DEX positions relevant to the returned auction.
	//
	// Could be empty, depending on the auction state.
	Positions []*v1.Position `protobuf:"bytes,3,rep,name=positions,proto3" json:"positions,omitempty"`
}

func (m *AuctionStateByIdResponse) Reset()         { *m = AuctionStateByIdResponse{} }
func (m *AuctionStateByIdResponse) String() string { return proto.CompactTextString(m) }
func (*AuctionStateByIdResponse) ProtoMessage()    {}
func (*AuctionStateByIdResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bd5c1fb0f471c5d, []int{3}
}
func (m *AuctionStateByIdResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuctionStateByIdResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuctionStateByIdResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuctionStateByIdResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuctionStateByIdResponse.Merge(m, src)
}
func (m *AuctionStateByIdResponse) XXX_Size() int {
	return m.Size()
}
func (m *AuctionStateByIdResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AuctionStateByIdResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AuctionStateByIdResponse proto.InternalMessageInfo

func (m *AuctionStateByIdResponse) GetAuction() *types.Any {
	if m != nil {
		return m.Auction
	}
	return nil
}

func (m *AuctionStateByIdResponse) GetPositions() []*v1.Position {
	if m != nil {
		return m.Positions
	}
	return nil
}

type AuctionStateByIdsRequest struct {
	// The auction IDs to request. Only known IDs will be returned in the response.
	Id []*AuctionId `protobuf:"bytes,1,rep,name=id,proto3" json:"id,omitempty"`
}

func (m *AuctionStateByIdsRequest) Reset()         { *m = AuctionStateByIdsRequest{} }
func (m *AuctionStateByIdsRequest) String() string { return proto.CompactTextString(m) }
func (*AuctionStateByIdsRequest) ProtoMessage()    {}
func (*AuctionStateByIdsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bd5c1fb0f471c5d, []int{4}
}
func (m *AuctionStateByIdsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuctionStateByIdsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuctionStateByIdsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuctionStateByIdsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuctionStateByIdsRequest.Merge(m, src)
}
func (m *AuctionStateByIdsRequest) XXX_Size() int {
	return m.Size()
}
func (m *AuctionStateByIdsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AuctionStateByIdsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AuctionStateByIdsRequest proto.InternalMessageInfo

func (m *AuctionStateByIdsRequest) GetId() []*AuctionId {
	if m != nil {
		return m.Id
	}
	return nil
}

type AuctionStateByIdsResponse struct {
	// The auction ID of the returned auction.
	Id *AuctionId `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The state of the returned auction.
	Auction *DutchAuctionState `protobuf:"bytes,2,opt,name=auction,proto3" json:"auction,omitempty"`
	// The state of any DEX positions relevant to the returned auction.
	//
	// Could be empty, depending on the auction state.
	Positions []*v1.Position `protobuf:"bytes,3,rep,name=positions,proto3" json:"positions,omitempty"`
}

func (m *AuctionStateByIdsResponse) Reset()         { *m = AuctionStateByIdsResponse{} }
func (m *AuctionStateByIdsResponse) String() string { return proto.CompactTextString(m) }
func (*AuctionStateByIdsResponse) ProtoMessage()    {}
func (*AuctionStateByIdsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bd5c1fb0f471c5d, []int{5}
}
func (m *AuctionStateByIdsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuctionStateByIdsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuctionStateByIdsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuctionStateByIdsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuctionStateByIdsResponse.Merge(m, src)
}
func (m *AuctionStateByIdsResponse) XXX_Size() int {
	return m.Size()
}
func (m *AuctionStateByIdsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AuctionStateByIdsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AuctionStateByIdsResponse proto.InternalMessageInfo

func (m *AuctionStateByIdsResponse) GetId() *AuctionId {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *AuctionStateByIdsResponse) GetAuction() *DutchAuctionState {
	if m != nil {
		return m.Auction
	}
	return nil
}

func (m *AuctionStateByIdsResponse) GetPositions() []*v1.Position {
	if m != nil {
		return m.Positions
	}
	return nil
}

// A unique identifier for an auction, obtained from hashing a domain separator
// along with the immutable part of an auction description.
type AuctionId struct {
	Inner []byte `protobuf:"bytes,1,opt,name=inner,proto3" json:"inner,omitempty"`
}

func (m *AuctionId) Reset()         { *m = AuctionId{} }
func (m *AuctionId) String() string { return proto.CompactTextString(m) }
func (*AuctionId) ProtoMessage()    {}
func (*AuctionId) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bd5c1fb0f471c5d, []int{6}
}
func (m *AuctionId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuctionId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuctionId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuctionId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuctionId.Merge(m, src)
}
func (m *AuctionId) XXX_Size() int {
	return m.Size()
}
func (m *AuctionId) XXX_DiscardUnknown() {
	xxx_messageInfo_AuctionId.DiscardUnknown(m)
}

var xxx_messageInfo_AuctionId proto.InternalMessageInfo

func (m *AuctionId) GetInner() []byte {
	if m != nil {
		return m.Inner
	}
	return nil
}

// A bearer NFT tracking ownership of an auction and its proceeds.
type AuctionNft struct {
	Id  *AuctionId `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Seq uint64     `protobuf:"varint,2,opt,name=seq,proto3" json:"seq,omitempty"`
}

func (m *AuctionNft) Reset()         { *m = AuctionNft{} }
func (m *AuctionNft) String() string { return proto.CompactTextString(m) }
func (*AuctionNft) ProtoMessage()    {}
func (*AuctionNft) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bd5c1fb0f471c5d, []int{7}
}
func (m *AuctionNft) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuctionNft) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuctionNft.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuctionNft) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuctionNft.Merge(m, src)
}
func (m *AuctionNft) XXX_Size() int {
	return m.Size()
}
func (m *AuctionNft) XXX_DiscardUnknown() {
	xxx_messageInfo_AuctionNft.DiscardUnknown(m)
}

var xxx_messageInfo_AuctionNft proto.InternalMessageInfo

func (m *AuctionNft) GetId() *AuctionId {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *AuctionNft) GetSeq() uint64 {
	if m != nil {
		return m.Seq
	}
	return 0
}

// Describes a Dutch auction using programmatic liquidity on the DEX.
type DutchAuctionDescription struct {
	// The value the seller wishes to auction.
	Input *v11.Value `protobuf:"bytes,1,opt,name=input,proto3" json:"input,omitempty"`
	// The asset ID of the target asset the seller wishes to acquire.
	OutputId *v11.AssetId `protobuf:"bytes,2,opt,name=output_id,json=outputId,proto3" json:"output_id,omitempty"`
	// The maximum output the seller can receive.
	//
	// This implicitly defines the starting price for the auction.
	MaxOutput *v12.Amount `protobuf:"bytes,3,opt,name=max_output,json=maxOutput,proto3" json:"max_output,omitempty"`
	// The minimum output the seller is willing to receive.
	//
	// This implicitly defines the ending price for the auction.
	MinOutput *v12.Amount `protobuf:"bytes,4,opt,name=min_output,json=minOutput,proto3" json:"min_output,omitempty"`
	// The block height at which the auction begins.
	//
	// This allows the seller to schedule an auction at a future time.
	StartHeight uint64 `protobuf:"varint,5,opt,name=start_height,json=startHeight,proto3" json:"start_height,omitempty"`
	// The block height at which the auction ends.
	//
	// Together with `start_height`, `max_output`, and `min_output`,
	// this implicitly defines the speed of the auction.
	EndHeight uint64 `protobuf:"varint,6,opt,name=end_height,json=endHeight,proto3" json:"end_height,omitempty"`
	// The number of discrete price steps to use for the auction.
	//
	// `end_height - start_height` must be a multiple of `step_count`.
	StepCount uint64 `protobuf:"varint,7,opt,name=step_count,json=stepCount,proto3" json:"step_count,omitempty"`
	// A random nonce used to allow identical auctions to have
	// distinct auction IDs.
	Nonce []byte `protobuf:"bytes,8,opt,name=nonce,proto3" json:"nonce,omitempty"`
}

func (m *DutchAuctionDescription) Reset()         { *m = DutchAuctionDescription{} }
func (m *DutchAuctionDescription) String() string { return proto.CompactTextString(m) }
func (*DutchAuctionDescription) ProtoMessage()    {}
func (*DutchAuctionDescription) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bd5c1fb0f471c5d, []int{8}
}
func (m *DutchAuctionDescription) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DutchAuctionDescription) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DutchAuctionDescription.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DutchAuctionDescription) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DutchAuctionDescription.Merge(m, src)
}
func (m *DutchAuctionDescription) XXX_Size() int {
	return m.Size()
}
func (m *DutchAuctionDescription) XXX_DiscardUnknown() {
	xxx_messageInfo_DutchAuctionDescription.DiscardUnknown(m)
}

var xxx_messageInfo_DutchAuctionDescription proto.InternalMessageInfo

func (m *DutchAuctionDescription) GetInput() *v11.Value {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *DutchAuctionDescription) GetOutputId() *v11.AssetId {
	if m != nil {
		return m.OutputId
	}
	return nil
}

func (m *DutchAuctionDescription) GetMaxOutput() *v12.Amount {
	if m != nil {
		return m.MaxOutput
	}
	return nil
}

func (m *DutchAuctionDescription) GetMinOutput() *v12.Amount {
	if m != nil {
		return m.MinOutput
	}
	return nil
}

func (m *DutchAuctionDescription) GetStartHeight() uint64 {
	if m != nil {
		return m.StartHeight
	}
	return 0
}

func (m *DutchAuctionDescription) GetEndHeight() uint64 {
	if m != nil {
		return m.EndHeight
	}
	return 0
}

func (m *DutchAuctionDescription) GetStepCount() uint64 {
	if m != nil {
		return m.StepCount
	}
	return 0
}

func (m *DutchAuctionDescription) GetNonce() []byte {
	if m != nil {
		return m.Nonce
	}
	return nil
}

type DutchAuctionState struct {
	// The sequence number of the auction state.
	//
	// Dutch auctions move from:
	// 0 (opened) => 1 (closed) => n (withdrawn)
	Seq uint64 `protobuf:"varint,1,opt,name=seq,proto3" json:"seq,omitempty"`
	// If present, the current position controlled by this auction.
	CurrentPosition *v1.PositionId `protobuf:"bytes,2,opt,name=current_position,json=currentPosition,proto3" json:"current_position,omitempty"`
	// If present, the next trigger height to step down the price.
	NextTrigger uint64 `protobuf:"varint,3,opt,name=next_trigger,json=nextTrigger,proto3" json:"next_trigger,omitempty"`
	// The amount of the input asset directly owned by the auction.
	//
	// The auction may also own the input asset indirectly,
	// via the reserves of `current_position` if it exists.
	InputReserves *v12.Amount `protobuf:"bytes,4,opt,name=input_reserves,json=inputReserves,proto3" json:"input_reserves,omitempty"`
	// The amount of the output asset directly owned by the auction.
	//
	// The auction may also own the output asset indirectly,
	// via the reserves of `current_position` if it exists.
	OutputReserves *v12.Amount `protobuf:"bytes,5,opt,name=output_reserves,json=outputReserves,proto3" json:"output_reserves,omitempty"`
}

func (m *DutchAuctionState) Reset()         { *m = DutchAuctionState{} }
func (m *DutchAuctionState) String() string { return proto.CompactTextString(m) }
func (*DutchAuctionState) ProtoMessage()    {}
func (*DutchAuctionState) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bd5c1fb0f471c5d, []int{9}
}
func (m *DutchAuctionState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DutchAuctionState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DutchAuctionState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DutchAuctionState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DutchAuctionState.Merge(m, src)
}
func (m *DutchAuctionState) XXX_Size() int {
	return m.Size()
}
func (m *DutchAuctionState) XXX_DiscardUnknown() {
	xxx_messageInfo_DutchAuctionState.DiscardUnknown(m)
}

var xxx_messageInfo_DutchAuctionState proto.InternalMessageInfo

func (m *DutchAuctionState) GetSeq() uint64 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *DutchAuctionState) GetCurrentPosition() *v1.PositionId {
	if m != nil {
		return m.CurrentPosition
	}
	return nil
}

func (m *DutchAuctionState) GetNextTrigger() uint64 {
	if m != nil {
		return m.NextTrigger
	}
	return 0
}

func (m *DutchAuctionState) GetInputReserves() *v12.Amount {
	if m != nil {
		return m.InputReserves
	}
	return nil
}

func (m *DutchAuctionState) GetOutputReserves() *v12.Amount {
	if m != nil {
		return m.OutputReserves
	}
	return nil
}

type DutchAuction struct {
	// The immutable data describing the auction and its auction ID.
	Description *DutchAuctionDescription `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	// The mutable data describing the auction's execution.
	State *DutchAuctionState `protobuf:"bytes,2,opt,name=state,proto3" json:"state,omitempty"`
}

func (m *DutchAuction) Reset()         { *m = DutchAuction{} }
func (m *DutchAuction) String() string { return proto.CompactTextString(m) }
func (*DutchAuction) ProtoMessage()    {}
func (*DutchAuction) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bd5c1fb0f471c5d, []int{10}
}
func (m *DutchAuction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DutchAuction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DutchAuction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DutchAuction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DutchAuction.Merge(m, src)
}
func (m *DutchAuction) XXX_Size() int {
	return m.Size()
}
func (m *DutchAuction) XXX_DiscardUnknown() {
	xxx_messageInfo_DutchAuction.DiscardUnknown(m)
}

var xxx_messageInfo_DutchAuction proto.InternalMessageInfo

func (m *DutchAuction) GetDescription() *DutchAuctionDescription {
	if m != nil {
		return m.Description
	}
	return nil
}

func (m *DutchAuction) GetState() *DutchAuctionState {
	if m != nil {
		return m.State
	}
	return nil
}

// Initiates a Dutch auction using protocol-controlled liquidity.
type ActionDutchAuctionSchedule struct {
	Description *DutchAuctionDescription `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
}

func (m *ActionDutchAuctionSchedule) Reset()         { *m = ActionDutchAuctionSchedule{} }
func (m *ActionDutchAuctionSchedule) String() string { return proto.CompactTextString(m) }
func (*ActionDutchAuctionSchedule) ProtoMessage()    {}
func (*ActionDutchAuctionSchedule) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bd5c1fb0f471c5d, []int{11}
}
func (m *ActionDutchAuctionSchedule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionDutchAuctionSchedule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionDutchAuctionSchedule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionDutchAuctionSchedule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionDutchAuctionSchedule.Merge(m, src)
}
func (m *ActionDutchAuctionSchedule) XXX_Size() int {
	return m.Size()
}
func (m *ActionDutchAuctionSchedule) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionDutchAuctionSchedule.DiscardUnknown(m)
}

var xxx_messageInfo_ActionDutchAuctionSchedule proto.InternalMessageInfo

func (m *ActionDutchAuctionSchedule) GetDescription() *DutchAuctionDescription {
	if m != nil {
		return m.Description
	}
	return nil
}

// Terminate the auction associated with the specified `auction_id`
type ActionDutchAuctionEnd struct {
	// The auction to end.
	AuctionId *AuctionId `protobuf:"bytes,1,opt,name=auction_id,json=auctionId,proto3" json:"auction_id,omitempty"`
}

func (m *ActionDutchAuctionEnd) Reset()         { *m = ActionDutchAuctionEnd{} }
func (m *ActionDutchAuctionEnd) String() string { return proto.CompactTextString(m) }
func (*ActionDutchAuctionEnd) ProtoMessage()    {}
func (*ActionDutchAuctionEnd) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bd5c1fb0f471c5d, []int{12}
}
func (m *ActionDutchAuctionEnd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionDutchAuctionEnd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionDutchAuctionEnd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionDutchAuctionEnd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionDutchAuctionEnd.Merge(m, src)
}
func (m *ActionDutchAuctionEnd) XXX_Size() int {
	return m.Size()
}
func (m *ActionDutchAuctionEnd) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionDutchAuctionEnd.DiscardUnknown(m)
}

var xxx_messageInfo_ActionDutchAuctionEnd proto.InternalMessageInfo

func (m *ActionDutchAuctionEnd) GetAuctionId() *AuctionId {
	if m != nil {
		return m.AuctionId
	}
	return nil
}

// Withdraw funds from the ended auction associated with the specified `auction_id`
type ActionDutchAuctionWithdraw struct {
	// The auction to withdraw funds from.
	AuctionId *AuctionId `protobuf:"bytes,1,opt,name=auction_id,json=auctionId,proto3" json:"auction_id,omitempty"`
	// The sequence number of the withdrawal.
	Seq uint64 `protobuf:"varint,2,opt,name=seq,proto3" json:"seq,omitempty"`
	// A transparent (zero blinding factor) commitment to the
	// auction's final reserves.
	//
	// The chain will check this commitment by recomputing it
	// with the on-chain state.
	ReservesCommitment *v11.BalanceCommitment `protobuf:"bytes,3,opt,name=reserves_commitment,json=reservesCommitment,proto3" json:"reserves_commitment,omitempty"`
}

func (m *ActionDutchAuctionWithdraw) Reset()         { *m = ActionDutchAuctionWithdraw{} }
func (m *ActionDutchAuctionWithdraw) String() string { return proto.CompactTextString(m) }
func (*ActionDutchAuctionWithdraw) ProtoMessage()    {}
func (*ActionDutchAuctionWithdraw) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bd5c1fb0f471c5d, []int{13}
}
func (m *ActionDutchAuctionWithdraw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionDutchAuctionWithdraw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionDutchAuctionWithdraw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionDutchAuctionWithdraw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionDutchAuctionWithdraw.Merge(m, src)
}
func (m *ActionDutchAuctionWithdraw) XXX_Size() int {
	return m.Size()
}
func (m *ActionDutchAuctionWithdraw) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionDutchAuctionWithdraw.DiscardUnknown(m)
}

var xxx_messageInfo_ActionDutchAuctionWithdraw proto.InternalMessageInfo

func (m *ActionDutchAuctionWithdraw) GetAuctionId() *AuctionId {
	if m != nil {
		return m.AuctionId
	}
	return nil
}

func (m *ActionDutchAuctionWithdraw) GetSeq() uint64 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *ActionDutchAuctionWithdraw) GetReservesCommitment() *v11.BalanceCommitment {
	if m != nil {
		return m.ReservesCommitment
	}
	return nil
}

// A plan to a `ActionDutchAuctionWithdraw` which contains both private and public data.
type ActionDutchAuctionWithdrawPlan struct {
	AuctionId      *AuctionId `protobuf:"bytes,1,opt,name=auction_id,json=auctionId,proto3" json:"auction_id,omitempty"`
	Seq            uint64     `protobuf:"varint,2,opt,name=seq,proto3" json:"seq,omitempty"`
	ReservesInput  *v11.Value `protobuf:"bytes,3,opt,name=reserves_input,json=reservesInput,proto3" json:"reserves_input,omitempty"`
	ReservesOutput *v11.Value `protobuf:"bytes,4,opt,name=reserves_output,json=reservesOutput,proto3" json:"reserves_output,omitempty"`
}

func (m *ActionDutchAuctionWithdrawPlan) Reset()         { *m = ActionDutchAuctionWithdrawPlan{} }
func (m *ActionDutchAuctionWithdrawPlan) String() string { return proto.CompactTextString(m) }
func (*ActionDutchAuctionWithdrawPlan) ProtoMessage()    {}
func (*ActionDutchAuctionWithdrawPlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bd5c1fb0f471c5d, []int{14}
}
func (m *ActionDutchAuctionWithdrawPlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionDutchAuctionWithdrawPlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionDutchAuctionWithdrawPlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionDutchAuctionWithdrawPlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionDutchAuctionWithdrawPlan.Merge(m, src)
}
func (m *ActionDutchAuctionWithdrawPlan) XXX_Size() int {
	return m.Size()
}
func (m *ActionDutchAuctionWithdrawPlan) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionDutchAuctionWithdrawPlan.DiscardUnknown(m)
}

var xxx_messageInfo_ActionDutchAuctionWithdrawPlan proto.InternalMessageInfo

func (m *ActionDutchAuctionWithdrawPlan) GetAuctionId() *AuctionId {
	if m != nil {
		return m.AuctionId
	}
	return nil
}

func (m *ActionDutchAuctionWithdrawPlan) GetSeq() uint64 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *ActionDutchAuctionWithdrawPlan) GetReservesInput() *v11.Value {
	if m != nil {
		return m.ReservesInput
	}
	return nil
}

func (m *ActionDutchAuctionWithdrawPlan) GetReservesOutput() *v11.Value {
	if m != nil {
		return m.ReservesOutput
	}
	return nil
}

// An `ActionDutchAuctionSchedule` augmented with additional metadata.
type ActionDutchAuctionScheduleView struct {
	Action         *ActionDutchAuctionSchedule `protobuf:"bytes,1,opt,name=action,proto3" json:"action,omitempty"`
	AuctionId      *AuctionId                  `protobuf:"bytes,2,opt,name=auction_id,json=auctionId,proto3" json:"auction_id,omitempty"`
	InputMetadata  *v11.Metadata               `protobuf:"bytes,3,opt,name=input_metadata,json=inputMetadata,proto3" json:"input_metadata,omitempty"`
	OutputMetadata *v11.Metadata               `protobuf:"bytes,4,opt,name=output_metadata,json=outputMetadata,proto3" json:"output_metadata,omitempty"`
}

func (m *ActionDutchAuctionScheduleView) Reset()         { *m = ActionDutchAuctionScheduleView{} }
func (m *ActionDutchAuctionScheduleView) String() string { return proto.CompactTextString(m) }
func (*ActionDutchAuctionScheduleView) ProtoMessage()    {}
func (*ActionDutchAuctionScheduleView) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bd5c1fb0f471c5d, []int{15}
}
func (m *ActionDutchAuctionScheduleView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionDutchAuctionScheduleView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionDutchAuctionScheduleView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionDutchAuctionScheduleView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionDutchAuctionScheduleView.Merge(m, src)
}
func (m *ActionDutchAuctionScheduleView) XXX_Size() int {
	return m.Size()
}
func (m *ActionDutchAuctionScheduleView) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionDutchAuctionScheduleView.DiscardUnknown(m)
}

var xxx_messageInfo_ActionDutchAuctionScheduleView proto.InternalMessageInfo

func (m *ActionDutchAuctionScheduleView) GetAction() *ActionDutchAuctionSchedule {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *ActionDutchAuctionScheduleView) GetAuctionId() *AuctionId {
	if m != nil {
		return m.AuctionId
	}
	return nil
}

func (m *ActionDutchAuctionScheduleView) GetInputMetadata() *v11.Metadata {
	if m != nil {
		return m.InputMetadata
	}
	return nil
}

func (m *ActionDutchAuctionScheduleView) GetOutputMetadata() *v11.Metadata {
	if m != nil {
		return m.OutputMetadata
	}
	return nil
}

// An `ActionDutchAuctionWithdraw` augmented with additional metadata.
type ActionDutchAuctionWithdrawView struct {
	Action *ActionDutchAuctionWithdraw `protobuf:"bytes,1,opt,name=action,proto3" json:"action,omitempty"`
	// A sequence of values that sum together to the provided
	// reserves commitment.
	Reserves []*v11.ValueView `protobuf:"bytes,2,rep,name=reserves,proto3" json:"reserves,omitempty"`
}

func (m *ActionDutchAuctionWithdrawView) Reset()         { *m = ActionDutchAuctionWithdrawView{} }
func (m *ActionDutchAuctionWithdrawView) String() string { return proto.CompactTextString(m) }
func (*ActionDutchAuctionWithdrawView) ProtoMessage()    {}
func (*ActionDutchAuctionWithdrawView) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bd5c1fb0f471c5d, []int{16}
}
func (m *ActionDutchAuctionWithdrawView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionDutchAuctionWithdrawView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionDutchAuctionWithdrawView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionDutchAuctionWithdrawView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionDutchAuctionWithdrawView.Merge(m, src)
}
func (m *ActionDutchAuctionWithdrawView) XXX_Size() int {
	return m.Size()
}
func (m *ActionDutchAuctionWithdrawView) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionDutchAuctionWithdrawView.DiscardUnknown(m)
}

var xxx_messageInfo_ActionDutchAuctionWithdrawView proto.InternalMessageInfo

func (m *ActionDutchAuctionWithdrawView) GetAction() *ActionDutchAuctionWithdraw {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *ActionDutchAuctionWithdrawView) GetReserves() []*v11.ValueView {
	if m != nil {
		return m.Reserves
	}
	return nil
}

type EventDutchAuctionScheduled struct {
	AuctionId   *AuctionId               `protobuf:"bytes,1,opt,name=auction_id,json=auctionId,proto3" json:"auction_id,omitempty"`
	Description *DutchAuctionDescription `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
}

func (m *EventDutchAuctionScheduled) Reset()         { *m = EventDutchAuctionScheduled{} }
func (m *EventDutchAuctionScheduled) String() string { return proto.CompactTextString(m) }
func (*EventDutchAuctionScheduled) ProtoMessage()    {}
func (*EventDutchAuctionScheduled) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bd5c1fb0f471c5d, []int{17}
}
func (m *EventDutchAuctionScheduled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventDutchAuctionScheduled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventDutchAuctionScheduled.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventDutchAuctionScheduled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventDutchAuctionScheduled.Merge(m, src)
}
func (m *EventDutchAuctionScheduled) XXX_Size() int {
	return m.Size()
}
func (m *EventDutchAuctionScheduled) XXX_DiscardUnknown() {
	xxx_messageInfo_EventDutchAuctionScheduled.DiscardUnknown(m)
}

var xxx_messageInfo_EventDutchAuctionScheduled proto.InternalMessageInfo

func (m *EventDutchAuctionScheduled) GetAuctionId() *AuctionId {
	if m != nil {
		return m.AuctionId
	}
	return nil
}

func (m *EventDutchAuctionScheduled) GetDescription() *DutchAuctionDescription {
	if m != nil {
		return m.Description
	}
	return nil
}

type EventDutchAuctionUpdated struct {
	AuctionId *AuctionId         `protobuf:"bytes,1,opt,name=auction_id,json=auctionId,proto3" json:"auction_id,omitempty"`
	State     *DutchAuctionState `protobuf:"bytes,2,opt,name=state,proto3" json:"state,omitempty"`
}

func (m *EventDutchAuctionUpdated) Reset()         { *m = EventDutchAuctionUpdated{} }
func (m *EventDutchAuctionUpdated) String() string { return proto.CompactTextString(m) }
func (*EventDutchAuctionUpdated) ProtoMessage()    {}
func (*EventDutchAuctionUpdated) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bd5c1fb0f471c5d, []int{18}
}
func (m *EventDutchAuctionUpdated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventDutchAuctionUpdated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventDutchAuctionUpdated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventDutchAuctionUpdated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventDutchAuctionUpdated.Merge(m, src)
}
func (m *EventDutchAuctionUpdated) XXX_Size() int {
	return m.Size()
}
func (m *EventDutchAuctionUpdated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventDutchAuctionUpdated.DiscardUnknown(m)
}

var xxx_messageInfo_EventDutchAuctionUpdated proto.InternalMessageInfo

func (m *EventDutchAuctionUpdated) GetAuctionId() *AuctionId {
	if m != nil {
		return m.AuctionId
	}
	return nil
}

func (m *EventDutchAuctionUpdated) GetState() *DutchAuctionState {
	if m != nil {
		return m.State
	}
	return nil
}

type EventDutchAuctionEnded struct {
	AuctionId *AuctionId                    `protobuf:"bytes,1,opt,name=auction_id,json=auctionId,proto3" json:"auction_id,omitempty"`
	State     *DutchAuctionState            `protobuf:"bytes,2,opt,name=state,proto3" json:"state,omitempty"`
	Reason    EventDutchAuctionEnded_Reason `protobuf:"varint,3,opt,name=reason,proto3,enum=penumbra.core.component.auction.v1.EventDutchAuctionEnded_Reason" json:"reason,omitempty"`
}

func (m *EventDutchAuctionEnded) Reset()         { *m = EventDutchAuctionEnded{} }
func (m *EventDutchAuctionEnded) String() string { return proto.CompactTextString(m) }
func (*EventDutchAuctionEnded) ProtoMessage()    {}
func (*EventDutchAuctionEnded) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bd5c1fb0f471c5d, []int{19}
}
func (m *EventDutchAuctionEnded) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventDutchAuctionEnded) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventDutchAuctionEnded.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventDutchAuctionEnded) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventDutchAuctionEnded.Merge(m, src)
}
func (m *EventDutchAuctionEnded) XXX_Size() int {
	return m.Size()
}
func (m *EventDutchAuctionEnded) XXX_DiscardUnknown() {
	xxx_messageInfo_EventDutchAuctionEnded.DiscardUnknown(m)
}

var xxx_messageInfo_EventDutchAuctionEnded proto.InternalMessageInfo

func (m *EventDutchAuctionEnded) GetAuctionId() *AuctionId {
	if m != nil {
		return m.AuctionId
	}
	return nil
}

func (m *EventDutchAuctionEnded) GetState() *DutchAuctionState {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *EventDutchAuctionEnded) GetReason() EventDutchAuctionEnded_Reason {
	if m != nil {
		return m.Reason
	}
	return EventDutchAuctionEnded_REASON_UNSPECIFIED
}

// A message emitted when value flows *into* the auction component.
type EventValueCircuitBreakerCredit struct {
	// The asset ID being deposited into the Auction component.
	AssetId *v11.AssetId `protobuf:"bytes,1,opt,name=asset_id,json=assetId,proto3" json:"asset_id,omitempty"`
	// The previous balance of the asset in the Auction component.
	PreviousBalance *v12.Amount `protobuf:"bytes,2,opt,name=previous_balance,json=previousBalance,proto3" json:"previous_balance,omitempty"`
	// The new balance of the asset in the Auction component.
	NewBalance *v12.Amount `protobuf:"bytes,3,opt,name=new_balance,json=newBalance,proto3" json:"new_balance,omitempty"`
}

func (m *EventValueCircuitBreakerCredit) Reset()         { *m = EventValueCircuitBreakerCredit{} }
func (m *EventValueCircuitBreakerCredit) String() string { return proto.CompactTextString(m) }
func (*EventValueCircuitBreakerCredit) ProtoMessage()    {}
func (*EventValueCircuitBreakerCredit) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bd5c1fb0f471c5d, []int{20}
}
func (m *EventValueCircuitBreakerCredit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventValueCircuitBreakerCredit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventValueCircuitBreakerCredit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventValueCircuitBreakerCredit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventValueCircuitBreakerCredit.Merge(m, src)
}
func (m *EventValueCircuitBreakerCredit) XXX_Size() int {
	return m.Size()
}
func (m *EventValueCircuitBreakerCredit) XXX_DiscardUnknown() {
	xxx_messageInfo_EventValueCircuitBreakerCredit.DiscardUnknown(m)
}

var xxx_messageInfo_EventValueCircuitBreakerCredit proto.InternalMessageInfo

func (m *EventValueCircuitBreakerCredit) GetAssetId() *v11.AssetId {
	if m != nil {
		return m.AssetId
	}
	return nil
}

func (m *EventValueCircuitBreakerCredit) GetPreviousBalance() *v12.Amount {
	if m != nil {
		return m.PreviousBalance
	}
	return nil
}

func (m *EventValueCircuitBreakerCredit) GetNewBalance() *v12.Amount {
	if m != nil {
		return m.NewBalance
	}
	return nil
}

// A message emitted when value flows *out* of the auction component.
type EventValueCircuitBreakerDebit struct {
	// The asset ID being deposited into the Auction component.
	AssetId *v11.AssetId `protobuf:"bytes,1,opt,name=asset_id,json=assetId,proto3" json:"asset_id,omitempty"`
	// The previous balance of the asset in the Auction component.
	PreviousBalance *v12.Amount `protobuf:"bytes,2,opt,name=previous_balance,json=previousBalance,proto3" json:"previous_balance,omitempty"`
	// The new balance of the asset in the Auction component.
	NewBalance *v12.Amount `protobuf:"bytes,3,opt,name=new_balance,json=newBalance,proto3" json:"new_balance,omitempty"`
}

func (m *EventValueCircuitBreakerDebit) Reset()         { *m = EventValueCircuitBreakerDebit{} }
func (m *EventValueCircuitBreakerDebit) String() string { return proto.CompactTextString(m) }
func (*EventValueCircuitBreakerDebit) ProtoMessage()    {}
func (*EventValueCircuitBreakerDebit) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bd5c1fb0f471c5d, []int{21}
}
func (m *EventValueCircuitBreakerDebit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventValueCircuitBreakerDebit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventValueCircuitBreakerDebit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventValueCircuitBreakerDebit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventValueCircuitBreakerDebit.Merge(m, src)
}
func (m *EventValueCircuitBreakerDebit) XXX_Size() int {
	return m.Size()
}
func (m *EventValueCircuitBreakerDebit) XXX_DiscardUnknown() {
	xxx_messageInfo_EventValueCircuitBreakerDebit.DiscardUnknown(m)
}

var xxx_messageInfo_EventValueCircuitBreakerDebit proto.InternalMessageInfo

func (m *EventValueCircuitBreakerDebit) GetAssetId() *v11.AssetId {
	if m != nil {
		return m.AssetId
	}
	return nil
}

func (m *EventValueCircuitBreakerDebit) GetPreviousBalance() *v12.Amount {
	if m != nil {
		return m.PreviousBalance
	}
	return nil
}

func (m *EventValueCircuitBreakerDebit) GetNewBalance() *v12.Amount {
	if m != nil {
		return m.NewBalance
	}
	return nil
}

func init() {
	proto.RegisterEnum("penumbra.core.component.auction.v1.EventDutchAuctionEnded_Reason", EventDutchAuctionEnded_Reason_name, EventDutchAuctionEnded_Reason_value)
	proto.RegisterType((*AuctionParameters)(nil), "penumbra.core.component.auction.v1.AuctionParameters")
	proto.RegisterType((*GenesisContent)(nil), "penumbra.core.component.auction.v1.GenesisContent")
	proto.RegisterType((*AuctionStateByIdRequest)(nil), "penumbra.core.component.auction.v1.AuctionStateByIdRequest")
	proto.RegisterType((*AuctionStateByIdResponse)(nil), "penumbra.core.component.auction.v1.AuctionStateByIdResponse")
	proto.RegisterType((*AuctionStateByIdsRequest)(nil), "penumbra.core.component.auction.v1.AuctionStateByIdsRequest")
	proto.RegisterType((*AuctionStateByIdsResponse)(nil), "penumbra.core.component.auction.v1.AuctionStateByIdsResponse")
	proto.RegisterType((*AuctionId)(nil), "penumbra.core.component.auction.v1.AuctionId")
	proto.RegisterType((*AuctionNft)(nil), "penumbra.core.component.auction.v1.AuctionNft")
	proto.RegisterType((*DutchAuctionDescription)(nil), "penumbra.core.component.auction.v1.DutchAuctionDescription")
	proto.RegisterType((*DutchAuctionState)(nil), "penumbra.core.component.auction.v1.DutchAuctionState")
	proto.RegisterType((*DutchAuction)(nil), "penumbra.core.component.auction.v1.DutchAuction")
	proto.RegisterType((*ActionDutchAuctionSchedule)(nil), "penumbra.core.component.auction.v1.ActionDutchAuctionSchedule")
	proto.RegisterType((*ActionDutchAuctionEnd)(nil), "penumbra.core.component.auction.v1.ActionDutchAuctionEnd")
	proto.RegisterType((*ActionDutchAuctionWithdraw)(nil), "penumbra.core.component.auction.v1.ActionDutchAuctionWithdraw")
	proto.RegisterType((*ActionDutchAuctionWithdrawPlan)(nil), "penumbra.core.component.auction.v1.ActionDutchAuctionWithdrawPlan")
	proto.RegisterType((*ActionDutchAuctionScheduleView)(nil), "penumbra.core.component.auction.v1.ActionDutchAuctionScheduleView")
	proto.RegisterType((*ActionDutchAuctionWithdrawView)(nil), "penumbra.core.component.auction.v1.ActionDutchAuctionWithdrawView")
	proto.RegisterType((*EventDutchAuctionScheduled)(nil), "penumbra.core.component.auction.v1.EventDutchAuctionScheduled")
	proto.RegisterType((*EventDutchAuctionUpdated)(nil), "penumbra.core.component.auction.v1.EventDutchAuctionUpdated")
	proto.RegisterType((*EventDutchAuctionEnded)(nil), "penumbra.core.component.auction.v1.EventDutchAuctionEnded")
	proto.RegisterType((*EventValueCircuitBreakerCredit)(nil), "penumbra.core.component.auction.v1.EventValueCircuitBreakerCredit")
	proto.RegisterType((*EventValueCircuitBreakerDebit)(nil), "penumbra.core.component.auction.v1.EventValueCircuitBreakerDebit")
}

func init() {
	proto.RegisterFile("penumbra/core/component/auction/v1/auction.proto", fileDescriptor_5bd5c1fb0f471c5d)
}

var fileDescriptor_5bd5c1fb0f471c5d = []byte{
	// 1372 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x58, 0xcd, 0x6e, 0xdb, 0x46,
	0x10, 0x36, 0xe9, 0x9f, 0xd8, 0x63, 0xc7, 0x56, 0x36, 0x69, 0xa2, 0x08, 0x8d, 0x9a, 0xf0, 0x10,
	0xb8, 0x05, 0x4a, 0x45, 0x0e, 0x7a, 0x91, 0xe3, 0x02, 0xfa, 0xb3, 0x2b, 0xd4, 0xb1, 0x55, 0xba,
	0x71, 0x7e, 0xe0, 0x80, 0xa0, 0xc9, 0x89, 0x45, 0xd4, 0x5c, 0x2a, 0xe4, 0x52, 0xb6, 0xd1, 0x67,
	0x68, 0x51, 0xe4, 0x11, 0x7a, 0x6c, 0x8f, 0x45, 0x51, 0xa0, 0x4f, 0xd0, 0xf6, 0x94, 0x4b, 0x81,
	0xa0, 0xa7, 0xc2, 0xee, 0xa9, 0xd7, 0x9c, 0x0b, 0x14, 0x24, 0x77, 0x29, 0x45, 0xb2, 0x62, 0xc5,
	0x56, 0x80, 0xa2, 0x17, 0x61, 0x39, 0x9c, 0xef, 0x9b, 0x99, 0x6f, 0x67, 0x47, 0x24, 0xe1, 0x56,
	0x13, 0x69, 0xe0, 0x6c, 0x7b, 0x46, 0xce, 0x74, 0x3d, 0xcc, 0x99, 0xae, 0xd3, 0x74, 0x29, 0x52,
	0x96, 0x33, 0x02, 0x93, 0xd9, 0x2e, 0xcd, 0xb5, 0xf2, 0x62, 0xa9, 0x36, 0x3d, 0x97, 0xb9, 0x44,
	0x11, 0x08, 0x35, 0x44, 0xa8, 0x09, 0x42, 0x15, 0x6e, 0xad, 0x7c, 0xe6, 0xea, 0x8e, 0xeb, 0xee,
	0xec, 0x62, 0x2e, 0x42, 0x6c, 0x07, 0x4f, 0x72, 0x06, 0x3d, 0x88, 0xe1, 0x19, 0xe5, 0xd5, 0x80,
	0x86, 0xef, 0x23, 0x8b, 0x82, 0x84, 0x0b, 0xee, 0x33, 0xdf, 0x2f, 0x29, 0x0b, 0xf7, 0x43, 0x5f,
	0x0b, 0xf7, 0xb9, 0x67, 0xf6, 0x55, 0x4f, 0x1a, 0x38, 0xe1, 0x7d, 0x1a, 0x38, 0xf1, 0x7d, 0xe5,
	0x22, 0x5c, 0x28, 0xc6, 0x69, 0xd5, 0x0d, 0xcf, 0x70, 0x90, 0xa1, 0xe7, 0x2b, 0x3a, 0xcc, 0xae,
	0x20, 0x45, 0xdf, 0xf6, 0xcb, 0x2e, 0x65, 0x48, 0x19, 0xb9, 0x0b, 0x13, 0xcd, 0xf0, 0xbe, 0x9f,
	0x96, 0xae, 0x4b, 0xf3, 0xd3, 0x0b, 0x1f, 0xa9, 0x27, 0x17, 0xa9, 0xf6, 0x10, 0x6b, 0x9c, 0x44,
	0x79, 0x00, 0x57, 0xf8, 0xcd, 0x0d, 0x66, 0x30, 0x2c, 0x1d, 0xd4, 0x2c, 0x0d, 0x9f, 0x06, 0xe8,
	0x33, 0xb2, 0x04, 0xb2, 0x6d, 0xf1, 0x28, 0x1f, 0xbe, 0x41, 0x94, 0x9a, 0xa5, 0xc9, 0xb6, 0xa5,
	0x3c, 0x93, 0x20, 0xdd, 0x4b, 0xed, 0x37, 0x5d, 0xea, 0x23, 0x51, 0xe1, 0x1c, 0x07, 0xa6, 0xe5,
	0x28, 0xc0, 0x25, 0x35, 0xde, 0x07, 0x55, 0xec, 0x83, 0x5a, 0xa4, 0x07, 0x9a, 0x70, 0x22, 0xcb,
	0x30, 0xd5, 0x74, 0x7d, 0x3b, 0x5c, 0xfb, 0xe9, 0xd1, 0xeb, 0xa3, 0xf3, 0xd3, 0x0b, 0xf3, 0x7d,
	0x53, 0x0a, 0x35, 0x6f, 0xe5, 0xd5, 0x3a, 0x07, 0x68, 0x6d, 0xa8, 0xf2, 0xb0, 0x37, 0x27, 0xbf,
	0xbb, 0xde, 0xd1, 0xd3, 0xd5, 0xfb, 0x52, 0x82, 0xab, 0xc7, 0x70, 0xf3, 0x82, 0xcf, 0x26, 0x26,
	0x59, 0xef, 0xd6, 0x6b, 0xa0, 0x6d, 0xaf, 0x04, 0xcc, 0x6c, 0x74, 0xe6, 0x34, 0x7c, 0x41, 0x6f,
	0xc0, 0x54, 0x92, 0x29, 0xb9, 0x04, 0xe3, 0x36, 0xa5, 0xe8, 0x45, 0x75, 0xce, 0x68, 0xf1, 0x85,
	0xf2, 0x18, 0x80, 0xbb, 0xac, 0x3d, 0x39, 0x6b, 0x57, 0x91, 0x14, 0x8c, 0xfa, 0xf8, 0x34, 0x12,
	0x61, 0x4c, 0x0b, 0x97, 0xca, 0x3f, 0x32, 0x5c, 0xe9, 0x2c, 0xb4, 0x82, 0xbe, 0xe9, 0xd9, 0xcd,
	0xa8, 0xca, 0xdb, 0x61, 0x42, 0xcd, 0x80, 0xf1, 0x78, 0xd7, 0xba, 0xe2, 0xc5, 0x07, 0xb9, 0x95,
	0x57, 0x37, 0x8d, 0xdd, 0x00, 0xb5, 0xd8, 0x97, 0xdc, 0x81, 0x29, 0x37, 0x60, 0xcd, 0x80, 0xe9,
	0xb6, 0xc5, 0xd5, 0x7e, 0xaf, 0x1f, 0xb0, 0x18, 0x2e, 0x6a, 0x96, 0x36, 0x19, 0x23, 0x6a, 0x16,
	0x59, 0x04, 0x70, 0x8c, 0x7d, 0x3d, 0xbe, 0x4e, 0x8f, 0x46, 0xf0, 0x77, 0xbb, 0xe0, 0xe1, 0xa1,
	0x0f, 0xc1, 0x8e, 0x1b, 0x50, 0xa6, 0x4d, 0x39, 0xc6, 0xfe, 0x7a, 0xe4, 0x1e, 0x81, 0x6d, 0x2a,
	0xc0, 0x63, 0x03, 0x81, 0x6d, 0xca, 0xc1, 0x37, 0x60, 0xc6, 0x67, 0x86, 0xc7, 0xf4, 0x06, 0xda,
	0x3b, 0x0d, 0x96, 0x1e, 0x8f, 0x34, 0x9a, 0x8e, 0x6c, 0x9f, 0x44, 0x26, 0x72, 0x0d, 0x00, 0xa9,
	0x25, 0x1c, 0x26, 0x22, 0x87, 0x29, 0xa4, 0x56, 0xfb, 0xb6, 0xcf, 0xb0, 0xa9, 0x9b, 0x21, 0x75,
	0xfa, 0x5c, 0x7c, 0x3b, 0xb4, 0x94, 0x43, 0x43, 0xb8, 0xbd, 0xd4, 0xa5, 0x26, 0xa6, 0x27, 0xe3,
	0xed, 0x8d, 0x2e, 0x94, 0xef, 0x65, 0xb8, 0xd0, 0xd3, 0x68, 0x62, 0x9f, 0xa4, 0x64, 0x9f, 0xc8,
	0x3d, 0x48, 0x99, 0x81, 0xe7, 0x21, 0x65, 0xba, 0x68, 0x1f, 0xae, 0xee, 0x07, 0x83, 0x36, 0x5e,
	0xcd, 0xd2, 0xe6, 0x38, 0x87, 0x30, 0x85, 0x55, 0x53, 0xdc, 0x67, 0x3a, 0xf3, 0xec, 0x9d, 0x1d,
	0xf4, 0x22, 0xc5, 0xc7, 0xb4, 0xe9, 0xd0, 0xf6, 0x79, 0x6c, 0x22, 0x65, 0x98, 0x8d, 0x76, 0x56,
	0xf7, 0xd0, 0x47, 0xaf, 0x85, 0xfe, 0x40, 0xca, 0x9e, 0x8f, 0x30, 0x1a, 0x87, 0x90, 0x2a, 0xcc,
	0xf1, 0xae, 0x48, 0x58, 0xc6, 0x07, 0x60, 0x99, 0x8d, 0x41, 0x82, 0x46, 0xf9, 0x59, 0x82, 0x99,
	0x4e, 0xb5, 0xc8, 0x63, 0x98, 0xb6, 0xda, 0x1d, 0xcb, 0x1b, 0x75, 0xf1, 0x4d, 0x4f, 0x77, 0x47,
	0xd3, 0x6b, 0x9d, 0x7c, 0xe4, 0x53, 0x18, 0xf7, 0xc3, 0x0d, 0x39, 0xdb, 0xd8, 0x88, 0x39, 0x94,
	0x2f, 0x21, 0x53, 0x8c, 0xc3, 0x75, 0x7a, 0x98, 0x0d, 0xb4, 0x82, 0x5d, 0x7c, 0xcb, 0x95, 0x28,
	0x08, 0xef, 0xf4, 0x06, 0xaf, 0x52, 0x8b, 0xac, 0x02, 0x70, 0x2e, 0xfd, 0xb4, 0x93, 0x65, 0xca,
	0x10, 0x4b, 0xe5, 0x85, 0x74, 0x5c, 0x91, 0xf7, 0x6d, 0xd6, 0xb0, 0x3c, 0x63, 0x6f, 0xb8, 0xc1,
	0x7a, 0xa7, 0x19, 0x79, 0x04, 0x17, 0x45, 0x7f, 0xe9, 0xa6, 0xeb, 0x38, 0x36, 0x73, 0x90, 0x8a,
	0x39, 0xf2, 0x7e, 0xbf, 0x31, 0x54, 0x32, 0x76, 0x0d, 0x6a, 0x62, 0x39, 0x01, 0x68, 0x44, 0xb0,
	0xb4, 0x6d, 0xca, 0xd7, 0x32, 0x64, 0xfb, 0x97, 0x56, 0xdf, 0x35, 0xe8, 0x5b, 0x2f, 0xaf, 0x02,
	0xb3, 0x49, 0x79, 0xf1, 0x64, 0x1e, 0x1d, 0x64, 0x32, 0x9f, 0x17, 0xa0, 0x5a, 0x34, 0xa1, 0x97,
	0x61, 0x2e, 0x61, 0x79, 0x65, 0x56, 0x9e, 0x40, 0x93, 0xc4, 0x8e, 0x27, 0xa6, 0xf2, 0xc7, 0xb1,
	0x82, 0x88, 0x86, 0xde, 0xb4, 0x71, 0x8f, 0x6c, 0xc2, 0x84, 0x61, 0x76, 0xf4, 0xf3, 0xc7, 0x03,
	0x89, 0xd1, 0x97, 0x53, 0xe3, 0x6c, 0x5d, 0x42, 0xcb, 0x67, 0x14, 0x7a, 0x45, 0x4c, 0x38, 0x07,
	0x99, 0x61, 0x19, 0xcc, 0xe0, 0xb2, 0x5e, 0xef, 0xa7, 0xc7, 0x5d, 0xee, 0xc7, 0xa7, 0x9c, 0xb8,
	0x24, 0xb5, 0x64, 0xca, 0x25, 0x4c, 0x63, 0x03, 0x32, 0xf1, 0x49, 0x27, 0xae, 0x95, 0x9f, 0xa4,
	0xd7, 0x75, 0xdb, 0x30, 0xc5, 0x15, 0x9c, 0x89, 0xb8, 0x4b, 0x30, 0x99, 0x0c, 0x69, 0x39, 0x7a,
	0xb6, 0xb9, 0xf1, 0xda, 0xc6, 0x08, 0x93, 0xd1, 0x12, 0x88, 0xf2, 0xab, 0x04, 0x99, 0x6a, 0x0b,
	0x29, 0x3b, 0x6e, 0x07, 0x87, 0x3c, 0x6f, 0xba, 0xa7, 0xa6, 0x3c, 0xe4, 0xa9, 0xf9, 0xa3, 0x04,
	0xe9, 0x9e, 0x5a, 0xee, 0x35, 0x2d, 0x83, 0x0d, 0xbd, 0x92, 0xa1, 0xfe, 0xd5, 0xbc, 0x94, 0xe1,
	0x72, 0x4f, 0xde, 0x55, 0x6a, 0xfd, 0xa7, 0xb3, 0x26, 0x0f, 0x61, 0xc2, 0x43, 0xc3, 0x77, 0x69,
	0x74, 0xfe, 0x66, 0x17, 0x8a, 0x83, 0xb0, 0x1d, 0x5f, 0xa6, 0xaa, 0x45, 0x44, 0x1a, 0x27, 0x54,
	0x4c, 0x98, 0x88, 0x2d, 0xe4, 0x32, 0x10, 0xad, 0x5a, 0xdc, 0x58, 0x5f, 0xd3, 0xef, 0xad, 0x6d,
	0xd4, 0xab, 0xe5, 0xda, 0x72, 0xad, 0x5a, 0x49, 0x8d, 0x10, 0x02, 0xb3, 0xdc, 0x5e, 0x7d, 0x50,
	0xaf, 0x69, 0xd5, 0x4a, 0x4a, 0x22, 0x17, 0xe0, 0x3c, 0xb7, 0x2d, 0xd7, 0x56, 0x57, 0xab, 0x95,
	0x94, 0x4c, 0x32, 0x70, 0x99, 0x9b, 0xca, 0xab, 0xeb, 0x1b, 0xd5, 0x8a, 0x5e, 0x7a, 0xa8, 0xaf,
	0xdf, 0x5f, 0xab, 0x6a, 0xa9, 0x51, 0xe5, 0x2f, 0x09, 0xb2, 0x51, 0x3a, 0xd1, 0xb1, 0x28, 0xdb,
	0x9e, 0x19, 0xd8, 0xac, 0xe4, 0xa1, 0xf1, 0x05, 0x7a, 0x65, 0x0f, 0x2d, 0x9b, 0x91, 0x02, 0x4c,
	0x46, 0x87, 0xa7, 0xad, 0xfd, 0x89, 0x0f, 0xc7, 0xe7, 0x8c, 0x78, 0x41, 0x56, 0x20, 0xd5, 0xf4,
	0xb0, 0x65, 0xbb, 0x81, 0xaf, 0x6f, 0xc7, 0x7f, 0x59, 0x5c, 0xf6, 0xd7, 0x3f, 0x44, 0xcd, 0x09,
	0x14, 0xff, 0x9f, 0x23, 0x4b, 0x30, 0x4d, 0x71, 0x2f, 0xe1, 0x18, 0xe4, 0x29, 0x1b, 0x28, 0xee,
	0x71, 0xb8, 0x72, 0x24, 0xc1, 0xb5, 0x7e, 0x65, 0x56, 0x70, 0xfb, 0xff, 0x51, 0xe5, 0xc2, 0x0f,
	0x32, 0xcc, 0x7c, 0x16, 0xa0, 0x77, 0xb0, 0x81, 0x5e, 0xcb, 0x36, 0x91, 0x7c, 0x25, 0x41, 0xaa,
	0xfb, 0x0d, 0x95, 0x2c, 0xbe, 0xc1, 0xc9, 0xe9, 0xfe, 0x44, 0x90, 0xb9, 0x73, 0x3a, 0x30, 0x7f,
	0x27, 0x7e, 0x26, 0x25, 0x9f, 0x3c, 0xda, 0x6f, 0xcc, 0xe4, 0x54, 0x9c, 0xe2, 0x25, 0x3e, 0xb3,
	0x74, 0x4a, 0x74, 0x9c, 0xd2, 0x2d, 0xa9, 0xf4, 0xbb, 0xfc, 0xcb, 0x61, 0x56, 0x7a, 0x7e, 0x98,
	0x95, 0xfe, 0x3c, 0xcc, 0x4a, 0xdf, 0x1c, 0x65, 0x47, 0x9e, 0x1f, 0x65, 0x47, 0x5e, 0x1c, 0x65,
	0x47, 0xe0, 0xa6, 0xe9, 0x3a, 0x03, 0xd0, 0x97, 0x66, 0xc4, 0xe7, 0x16, 0xcf, 0x65, 0x6e, 0x5d,
	0x7a, 0xf4, 0x60, 0xc7, 0x66, 0x8d, 0x60, 0x3b, 0x74, 0xce, 0x99, 0xae, 0xef, 0xb8, 0x7e, 0xce,
	0xc3, 0x5d, 0xe3, 0x00, 0xbd, 0x5c, 0x6b, 0x21, 0x59, 0x9a, 0x0d, 0xc3, 0xa6, 0x7e, 0xee, 0xe4,
	0x8f, 0x5c, 0x8b, 0x7c, 0xd9, 0xca, 0x7f, 0x2b, 0x8f, 0xd5, 0xcb, 0xe5, 0xe2, 0x77, 0xb2, 0x52,
	0x17, 0x59, 0x95, 0xc3, 0xac, 0xca, 0x49, 0x56, 0x3c, 0x13, 0x75, 0x33, 0xff, 0x5b, 0xdb, 0x69,
	0x2b, 0x74, 0xda, 0x4a, 0x9c, 0xb6, 0xb8, 0xd3, 0xd6, 0x66, 0xfe, 0x50, 0x56, 0x4f, 0x76, 0xda,
	0x5a, 0xa9, 0x97, 0xc4, 0xbf, 0xfc, 0xdf, 0xf2, 0x4d, 0x01, 0x28, 0x14, 0x42, 0x44, 0xf8, 0xcb,
	0x21, 0x85, 0x02, 0xc7, 0x14, 0x0a, 0x9b, 0xf9, 0xed, 0x89, 0xe8, 0xc3, 0xce, 0xed, 0x7f, 0x03,
	0x00, 0x00, 0xff, 0xff, 0x69, 0xe3, 0xc7, 0x9d, 0xc6, 0x13, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QueryServiceClient is the client API for QueryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryServiceClient interface {
	// Get the current state of an auction by ID.
	AuctionStateById(ctx context.Context, in *AuctionStateByIdRequest, opts ...grpc.CallOption) (*AuctionStateByIdResponse, error)
	// Get the current state of a group of auctions by ID.
	AuctionStateByIds(ctx context.Context, in *AuctionStateByIdsRequest, opts ...grpc.CallOption) (QueryService_AuctionStateByIdsClient, error)
}

type queryServiceClient struct {
	cc grpc1.ClientConn
}

func NewQueryServiceClient(cc grpc1.ClientConn) QueryServiceClient {
	return &queryServiceClient{cc}
}

func (c *queryServiceClient) AuctionStateById(ctx context.Context, in *AuctionStateByIdRequest, opts ...grpc.CallOption) (*AuctionStateByIdResponse, error) {
	out := new(AuctionStateByIdResponse)
	err := c.cc.Invoke(ctx, "/penumbra.core.component.auction.v1.QueryService/AuctionStateById", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryServiceClient) AuctionStateByIds(ctx context.Context, in *AuctionStateByIdsRequest, opts ...grpc.CallOption) (QueryService_AuctionStateByIdsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_QueryService_serviceDesc.Streams[0], "/penumbra.core.component.auction.v1.QueryService/AuctionStateByIds", opts...)
	if err != nil {
		return nil, err
	}
	x := &queryServiceAuctionStateByIdsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type QueryService_AuctionStateByIdsClient interface {
	Recv() (*AuctionStateByIdsResponse, error)
	grpc.ClientStream
}

type queryServiceAuctionStateByIdsClient struct {
	grpc.ClientStream
}

func (x *queryServiceAuctionStateByIdsClient) Recv() (*AuctionStateByIdsResponse, error) {
	m := new(AuctionStateByIdsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// QueryServiceServer is the server API for QueryService service.
type QueryServiceServer interface {
	// Get the current state of an auction by ID.
	AuctionStateById(context.Context, *AuctionStateByIdRequest) (*AuctionStateByIdResponse, error)
	// Get the current state of a group of auctions by ID.
	AuctionStateByIds(*AuctionStateByIdsRequest, QueryService_AuctionStateByIdsServer) error
}

// UnimplementedQueryServiceServer can be embedded to have forward compatible implementations.
type UnimplementedQueryServiceServer struct {
}

func (*UnimplementedQueryServiceServer) AuctionStateById(ctx context.Context, req *AuctionStateByIdRequest) (*AuctionStateByIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuctionStateById not implemented")
}
func (*UnimplementedQueryServiceServer) AuctionStateByIds(req *AuctionStateByIdsRequest, srv QueryService_AuctionStateByIdsServer) error {
	return status.Errorf(codes.Unimplemented, "method AuctionStateByIds not implemented")
}

func RegisterQueryServiceServer(s grpc1.Server, srv QueryServiceServer) {
	s.RegisterService(&_QueryService_serviceDesc, srv)
}

func _QueryService_AuctionStateById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuctionStateByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServiceServer).AuctionStateById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/penumbra.core.component.auction.v1.QueryService/AuctionStateById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServiceServer).AuctionStateById(ctx, req.(*AuctionStateByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueryService_AuctionStateByIds_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AuctionStateByIdsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryServiceServer).AuctionStateByIds(m, &queryServiceAuctionStateByIdsServer{stream})
}

type QueryService_AuctionStateByIdsServer interface {
	Send(*AuctionStateByIdsResponse) error
	grpc.ServerStream
}

type queryServiceAuctionStateByIdsServer struct {
	grpc.ServerStream
}

func (x *queryServiceAuctionStateByIdsServer) Send(m *AuctionStateByIdsResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _QueryService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "penumbra.core.component.auction.v1.QueryService",
	HandlerType: (*QueryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AuctionStateById",
			Handler:    _QueryService_AuctionStateById_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "AuctionStateByIds",
			Handler:       _QueryService_AuctionStateByIds_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "penumbra/core/component/auction/v1/auction.proto",
}

func (m *AuctionParameters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuctionParameters) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuctionParameters) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GenesisContent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenesisContent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenesisContent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Params != nil {
		{
			size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuctionStateByIdRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuctionStateByIdRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuctionStateByIdRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Id != nil {
		{
			size, err := m.Id.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuctionStateByIdResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuctionStateByIdResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuctionStateByIdResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Positions) > 0 {
		for iNdEx := len(m.Positions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Positions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAuction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Auction != nil {
		{
			size, err := m.Auction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *AuctionStateByIdsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuctionStateByIdsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuctionStateByIdsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Id[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAuction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AuctionStateByIdsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuctionStateByIdsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuctionStateByIdsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Positions) > 0 {
		for iNdEx := len(m.Positions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Positions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAuction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Auction != nil {
		{
			size, err := m.Auction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		{
			size, err := m.Id.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuctionId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuctionId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuctionId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Inner) > 0 {
		i -= len(m.Inner)
		copy(dAtA[i:], m.Inner)
		i = encodeVarintAuction(dAtA, i, uint64(len(m.Inner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuctionNft) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuctionNft) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuctionNft) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Seq != 0 {
		i = encodeVarintAuction(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != nil {
		{
			size, err := m.Id.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DutchAuctionDescription) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DutchAuctionDescription) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DutchAuctionDescription) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintAuction(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0x42
	}
	if m.StepCount != 0 {
		i = encodeVarintAuction(dAtA, i, uint64(m.StepCount))
		i--
		dAtA[i] = 0x38
	}
	if m.EndHeight != 0 {
		i = encodeVarintAuction(dAtA, i, uint64(m.EndHeight))
		i--
		dAtA[i] = 0x30
	}
	if m.StartHeight != 0 {
		i = encodeVarintAuction(dAtA, i, uint64(m.StartHeight))
		i--
		dAtA[i] = 0x28
	}
	if m.MinOutput != nil {
		{
			size, err := m.MinOutput.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.MaxOutput != nil {
		{
			size, err := m.MaxOutput.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.OutputId != nil {
		{
			size, err := m.OutputId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Input != nil {
		{
			size, err := m.Input.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DutchAuctionState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DutchAuctionState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DutchAuctionState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OutputReserves != nil {
		{
			size, err := m.OutputReserves.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.InputReserves != nil {
		{
			size, err := m.InputReserves.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.NextTrigger != 0 {
		i = encodeVarintAuction(dAtA, i, uint64(m.NextTrigger))
		i--
		dAtA[i] = 0x18
	}
	if m.CurrentPosition != nil {
		{
			size, err := m.CurrentPosition.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Seq != 0 {
		i = encodeVarintAuction(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DutchAuction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DutchAuction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DutchAuction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != nil {
		{
			size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Description != nil {
		{
			size, err := m.Description.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ActionDutchAuctionSchedule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionDutchAuctionSchedule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionDutchAuctionSchedule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Description != nil {
		{
			size, err := m.Description.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ActionDutchAuctionEnd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionDutchAuctionEnd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionDutchAuctionEnd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AuctionId != nil {
		{
			size, err := m.AuctionId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ActionDutchAuctionWithdraw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionDutchAuctionWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionDutchAuctionWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReservesCommitment != nil {
		{
			size, err := m.ReservesCommitment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Seq != 0 {
		i = encodeVarintAuction(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x10
	}
	if m.AuctionId != nil {
		{
			size, err := m.AuctionId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ActionDutchAuctionWithdrawPlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionDutchAuctionWithdrawPlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionDutchAuctionWithdrawPlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReservesOutput != nil {
		{
			size, err := m.ReservesOutput.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.ReservesInput != nil {
		{
			size, err := m.ReservesInput.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Seq != 0 {
		i = encodeVarintAuction(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x10
	}
	if m.AuctionId != nil {
		{
			size, err := m.AuctionId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ActionDutchAuctionScheduleView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionDutchAuctionScheduleView) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionDutchAuctionScheduleView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OutputMetadata != nil {
		{
			size, err := m.OutputMetadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.InputMetadata != nil {
		{
			size, err := m.InputMetadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.AuctionId != nil {
		{
			size, err := m.AuctionId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Action != nil {
		{
			size, err := m.Action.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ActionDutchAuctionWithdrawView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionDutchAuctionWithdrawView) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionDutchAuctionWithdrawView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reserves) > 0 {
		for iNdEx := len(m.Reserves) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Reserves[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAuction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Action != nil {
		{
			size, err := m.Action.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventDutchAuctionScheduled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventDutchAuctionScheduled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventDutchAuctionScheduled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Description != nil {
		{
			size, err := m.Description.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.AuctionId != nil {
		{
			size, err := m.AuctionId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventDutchAuctionUpdated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventDutchAuctionUpdated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventDutchAuctionUpdated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != nil {
		{
			size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.AuctionId != nil {
		{
			size, err := m.AuctionId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventDutchAuctionEnded) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventDutchAuctionEnded) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventDutchAuctionEnded) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Reason != 0 {
		i = encodeVarintAuction(dAtA, i, uint64(m.Reason))
		i--
		dAtA[i] = 0x18
	}
	if m.State != nil {
		{
			size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.AuctionId != nil {
		{
			size, err := m.AuctionId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventValueCircuitBreakerCredit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventValueCircuitBreakerCredit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventValueCircuitBreakerCredit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NewBalance != nil {
		{
			size, err := m.NewBalance.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PreviousBalance != nil {
		{
			size, err := m.PreviousBalance.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.AssetId != nil {
		{
			size, err := m.AssetId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventValueCircuitBreakerDebit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventValueCircuitBreakerDebit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventValueCircuitBreakerDebit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NewBalance != nil {
		{
			size, err := m.NewBalance.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PreviousBalance != nil {
		{
			size, err := m.PreviousBalance.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.AssetId != nil {
		{
			size, err := m.AssetId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintAuction(dAtA []byte, offset int, v uint64) int {
	offset -= sovAuction(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AuctionParameters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GenesisContent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	return n
}

func (m *AuctionStateByIdRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	return n
}

func (m *AuctionStateByIdResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Auction != nil {
		l = m.Auction.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	if len(m.Positions) > 0 {
		for _, e := range m.Positions {
			l = e.Size()
			n += 1 + l + sovAuction(uint64(l))
		}
	}
	return n
}

func (m *AuctionStateByIdsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, e := range m.Id {
			l = e.Size()
			n += 1 + l + sovAuction(uint64(l))
		}
	}
	return n
}

func (m *AuctionStateByIdsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	if m.Auction != nil {
		l = m.Auction.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	if len(m.Positions) > 0 {
		for _, e := range m.Positions {
			l = e.Size()
			n += 1 + l + sovAuction(uint64(l))
		}
	}
	return n
}

func (m *AuctionId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Inner)
	if l > 0 {
		n += 1 + l + sovAuction(uint64(l))
	}
	return n
}

func (m *AuctionNft) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	if m.Seq != 0 {
		n += 1 + sovAuction(uint64(m.Seq))
	}
	return n
}

func (m *DutchAuctionDescription) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Input != nil {
		l = m.Input.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	if m.OutputId != nil {
		l = m.OutputId.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	if m.MaxOutput != nil {
		l = m.MaxOutput.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	if m.MinOutput != nil {
		l = m.MinOutput.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	if m.StartHeight != 0 {
		n += 1 + sovAuction(uint64(m.StartHeight))
	}
	if m.EndHeight != 0 {
		n += 1 + sovAuction(uint64(m.EndHeight))
	}
	if m.StepCount != 0 {
		n += 1 + sovAuction(uint64(m.StepCount))
	}
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovAuction(uint64(l))
	}
	return n
}

func (m *DutchAuctionState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Seq != 0 {
		n += 1 + sovAuction(uint64(m.Seq))
	}
	if m.CurrentPosition != nil {
		l = m.CurrentPosition.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	if m.NextTrigger != 0 {
		n += 1 + sovAuction(uint64(m.NextTrigger))
	}
	if m.InputReserves != nil {
		l = m.InputReserves.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	if m.OutputReserves != nil {
		l = m.OutputReserves.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	return n
}

func (m *DutchAuction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Description != nil {
		l = m.Description.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	return n
}

func (m *ActionDutchAuctionSchedule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Description != nil {
		l = m.Description.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	return n
}

func (m *ActionDutchAuctionEnd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AuctionId != nil {
		l = m.AuctionId.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	return n
}

func (m *ActionDutchAuctionWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AuctionId != nil {
		l = m.AuctionId.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	if m.Seq != 0 {
		n += 1 + sovAuction(uint64(m.Seq))
	}
	if m.ReservesCommitment != nil {
		l = m.ReservesCommitment.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	return n
}

func (m *ActionDutchAuctionWithdrawPlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AuctionId != nil {
		l = m.AuctionId.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	if m.Seq != 0 {
		n += 1 + sovAuction(uint64(m.Seq))
	}
	if m.ReservesInput != nil {
		l = m.ReservesInput.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	if m.ReservesOutput != nil {
		l = m.ReservesOutput.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	return n
}

func (m *ActionDutchAuctionScheduleView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Action != nil {
		l = m.Action.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	if m.AuctionId != nil {
		l = m.AuctionId.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	if m.InputMetadata != nil {
		l = m.InputMetadata.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	if m.OutputMetadata != nil {
		l = m.OutputMetadata.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	return n
}

func (m *ActionDutchAuctionWithdrawView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Action != nil {
		l = m.Action.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	if len(m.Reserves) > 0 {
		for _, e := range m.Reserves {
			l = e.Size()
			n += 1 + l + sovAuction(uint64(l))
		}
	}
	return n
}

func (m *EventDutchAuctionScheduled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AuctionId != nil {
		l = m.AuctionId.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	if m.Description != nil {
		l = m.Description.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	return n
}

func (m *EventDutchAuctionUpdated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AuctionId != nil {
		l = m.AuctionId.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	return n
}

func (m *EventDutchAuctionEnded) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AuctionId != nil {
		l = m.AuctionId.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	if m.Reason != 0 {
		n += 1 + sovAuction(uint64(m.Reason))
	}
	return n
}

func (m *EventValueCircuitBreakerCredit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AssetId != nil {
		l = m.AssetId.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	if m.PreviousBalance != nil {
		l = m.PreviousBalance.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	if m.NewBalance != nil {
		l = m.NewBalance.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	return n
}

func (m *EventValueCircuitBreakerDebit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AssetId != nil {
		l = m.AssetId.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	if m.PreviousBalance != nil {
		l = m.PreviousBalance.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	if m.NewBalance != nil {
		l = m.NewBalance.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	return n
}

func sovAuction(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAuction(x uint64) (n int) {
	return sovAuction(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AuctionParameters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuctionParameters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuctionParameters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenesisContent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenesisContent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenesisContent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &AuctionParameters{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuctionStateByIdRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuctionStateByIdRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuctionStateByIdRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &AuctionId{}
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuctionStateByIdResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuctionStateByIdResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuctionStateByIdResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Auction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Auction == nil {
				m.Auction = &types.Any{}
			}
			if err := m.Auction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Positions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Positions = append(m.Positions, &v1.Position{})
			if err := m.Positions[len(m.Positions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuctionStateByIdsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuctionStateByIdsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuctionStateByIdsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, &AuctionId{})
			if err := m.Id[len(m.Id)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuctionStateByIdsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuctionStateByIdsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuctionStateByIdsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &AuctionId{}
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Auction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Auction == nil {
				m.Auction = &DutchAuctionState{}
			}
			if err := m.Auction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Positions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Positions = append(m.Positions, &v1.Position{})
			if err := m.Positions[len(m.Positions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuctionId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuctionId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuctionId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inner = append(m.Inner[:0], dAtA[iNdEx:postIndex]...)
			if m.Inner == nil {
				m.Inner = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuctionNft) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuctionNft: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuctionNft: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &AuctionId{}
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DutchAuctionDescription) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DutchAuctionDescription: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DutchAuctionDescription: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Input == nil {
				m.Input = &v11.Value{}
			}
			if err := m.Input.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutputId == nil {
				m.OutputId = &v11.AssetId{}
			}
			if err := m.OutputId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxOutput", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxOutput == nil {
				m.MaxOutput = &v12.Amount{}
			}
			if err := m.MaxOutput.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinOutput", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MinOutput == nil {
				m.MinOutput = &v12.Amount{}
			}
			if err := m.MinOutput.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartHeight", wireType)
			}
			m.StartHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndHeight", wireType)
			}
			m.EndHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepCount", wireType)
			}
			m.StepCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StepCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = append(m.Nonce[:0], dAtA[iNdEx:postIndex]...)
			if m.Nonce == nil {
				m.Nonce = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DutchAuctionState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DutchAuctionState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DutchAuctionState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentPosition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CurrentPosition == nil {
				m.CurrentPosition = &v1.PositionId{}
			}
			if err := m.CurrentPosition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextTrigger", wireType)
			}
			m.NextTrigger = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextTrigger |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputReserves", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InputReserves == nil {
				m.InputReserves = &v12.Amount{}
			}
			if err := m.InputReserves.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputReserves", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutputReserves == nil {
				m.OutputReserves = &v12.Amount{}
			}
			if err := m.OutputReserves.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DutchAuction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DutchAuction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DutchAuction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Description == nil {
				m.Description = &DutchAuctionDescription{}
			}
			if err := m.Description.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &DutchAuctionState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionDutchAuctionSchedule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionDutchAuctionSchedule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionDutchAuctionSchedule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Description == nil {
				m.Description = &DutchAuctionDescription{}
			}
			if err := m.Description.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionDutchAuctionEnd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionDutchAuctionEnd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionDutchAuctionEnd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuctionId == nil {
				m.AuctionId = &AuctionId{}
			}
			if err := m.AuctionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionDutchAuctionWithdraw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionDutchAuctionWithdraw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionDutchAuctionWithdraw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuctionId == nil {
				m.AuctionId = &AuctionId{}
			}
			if err := m.AuctionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReservesCommitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReservesCommitment == nil {
				m.ReservesCommitment = &v11.BalanceCommitment{}
			}
			if err := m.ReservesCommitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionDutchAuctionWithdrawPlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionDutchAuctionWithdrawPlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionDutchAuctionWithdrawPlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuctionId == nil {
				m.AuctionId = &AuctionId{}
			}
			if err := m.AuctionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReservesInput", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReservesInput == nil {
				m.ReservesInput = &v11.Value{}
			}
			if err := m.ReservesInput.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReservesOutput", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReservesOutput == nil {
				m.ReservesOutput = &v11.Value{}
			}
			if err := m.ReservesOutput.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionDutchAuctionScheduleView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionDutchAuctionScheduleView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionDutchAuctionScheduleView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Action == nil {
				m.Action = &ActionDutchAuctionSchedule{}
			}
			if err := m.Action.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuctionId == nil {
				m.AuctionId = &AuctionId{}
			}
			if err := m.AuctionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InputMetadata == nil {
				m.InputMetadata = &v11.Metadata{}
			}
			if err := m.InputMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutputMetadata == nil {
				m.OutputMetadata = &v11.Metadata{}
			}
			if err := m.OutputMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionDutchAuctionWithdrawView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionDutchAuctionWithdrawView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionDutchAuctionWithdrawView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Action == nil {
				m.Action = &ActionDutchAuctionWithdraw{}
			}
			if err := m.Action.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserves", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reserves = append(m.Reserves, &v11.ValueView{})
			if err := m.Reserves[len(m.Reserves)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventDutchAuctionScheduled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventDutchAuctionScheduled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventDutchAuctionScheduled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuctionId == nil {
				m.AuctionId = &AuctionId{}
			}
			if err := m.AuctionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Description == nil {
				m.Description = &DutchAuctionDescription{}
			}
			if err := m.Description.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventDutchAuctionUpdated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventDutchAuctionUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventDutchAuctionUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuctionId == nil {
				m.AuctionId = &AuctionId{}
			}
			if err := m.AuctionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &DutchAuctionState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventDutchAuctionEnded) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventDutchAuctionEnded: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventDutchAuctionEnded: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuctionId == nil {
				m.AuctionId = &AuctionId{}
			}
			if err := m.AuctionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &DutchAuctionState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			m.Reason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reason |= EventDutchAuctionEnded_Reason(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventValueCircuitBreakerCredit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventValueCircuitBreakerCredit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventValueCircuitBreakerCredit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AssetId == nil {
				m.AssetId = &v11.AssetId{}
			}
			if err := m.AssetId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousBalance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PreviousBalance == nil {
				m.PreviousBalance = &v12.Amount{}
			}
			if err := m.PreviousBalance.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewBalance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewBalance == nil {
				m.NewBalance = &v12.Amount{}
			}
			if err := m.NewBalance.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventValueCircuitBreakerDebit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventValueCircuitBreakerDebit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventValueCircuitBreakerDebit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AssetId == nil {
				m.AssetId = &v11.AssetId{}
			}
			if err := m.AssetId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousBalance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PreviousBalance == nil {
				m.PreviousBalance = &v12.Amount{}
			}
			if err := m.PreviousBalance.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewBalance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewBalance == nil {
				m.NewBalance = &v12.Amount{}
			}
			if err := m.NewBalance.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAuction(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAuction
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAuction
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAuction
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAuction        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAuction          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAuction = fmt.Errorf("proto: unexpected end of group")
)
