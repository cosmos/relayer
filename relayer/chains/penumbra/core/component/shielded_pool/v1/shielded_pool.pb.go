// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: penumbra/core/component/shielded_pool/v1/shielded_pool.proto

package shielded_poolv1

import (
	context "context"
	fmt "fmt"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	v12 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/asset/v1"
	v15 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/component/sct/v1"
	v11 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/keys/v1"
	v1 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/num/v1"
	v17 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/txhash/v1"
	v16 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/crypto/decaf377_fmd/v1"
	v14 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/crypto/decaf377_rdsa/v1"
	v13 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/crypto/tct/v1"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Configuration data for the shielded pool component.
type ShieldedPoolParameters struct {
	FixedFmdParams *FmdParameters     `protobuf:"bytes,1,opt,name=fixed_fmd_params,json=fixedFmdParams,proto3" json:"fixed_fmd_params,omitempty"` // Deprecated: Do not use.
	FmdMetaParams  *FmdMetaParameters `protobuf:"bytes,2,opt,name=fmd_meta_params,json=fmdMetaParams,proto3" json:"fmd_meta_params,omitempty"`
}

func (m *ShieldedPoolParameters) Reset()         { *m = ShieldedPoolParameters{} }
func (m *ShieldedPoolParameters) String() string { return proto.CompactTextString(m) }
func (*ShieldedPoolParameters) ProtoMessage()    {}
func (*ShieldedPoolParameters) Descriptor() ([]byte, []int) {
	return fileDescriptor_26a9f446de1cd73c, []int{0}
}
func (m *ShieldedPoolParameters) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShieldedPoolParameters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShieldedPoolParameters.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShieldedPoolParameters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShieldedPoolParameters.Merge(m, src)
}
func (m *ShieldedPoolParameters) XXX_Size() int {
	return m.Size()
}
func (m *ShieldedPoolParameters) XXX_DiscardUnknown() {
	xxx_messageInfo_ShieldedPoolParameters.DiscardUnknown(m)
}

var xxx_messageInfo_ShieldedPoolParameters proto.InternalMessageInfo

// Deprecated: Do not use.
func (m *ShieldedPoolParameters) GetFixedFmdParams() *FmdParameters {
	if m != nil {
		return m.FixedFmdParams
	}
	return nil
}

func (m *ShieldedPoolParameters) GetFmdMetaParams() *FmdMetaParameters {
	if m != nil {
		return m.FmdMetaParams
	}
	return nil
}

// Genesis data for the shielded pool component.
type GenesisContent struct {
	ShieldedPoolParams *ShieldedPoolParameters `protobuf:"bytes,1,opt,name=shielded_pool_params,json=shieldedPoolParams,proto3" json:"shielded_pool_params,omitempty"`
	// The allocations present at genesis
	Allocations []*GenesisContent_Allocation `protobuf:"bytes,3,rep,name=allocations,proto3" json:"allocations,omitempty"`
}

func (m *GenesisContent) Reset()         { *m = GenesisContent{} }
func (m *GenesisContent) String() string { return proto.CompactTextString(m) }
func (*GenesisContent) ProtoMessage()    {}
func (*GenesisContent) Descriptor() ([]byte, []int) {
	return fileDescriptor_26a9f446de1cd73c, []int{1}
}
func (m *GenesisContent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenesisContent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenesisContent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenesisContent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenesisContent.Merge(m, src)
}
func (m *GenesisContent) XXX_Size() int {
	return m.Size()
}
func (m *GenesisContent) XXX_DiscardUnknown() {
	xxx_messageInfo_GenesisContent.DiscardUnknown(m)
}

var xxx_messageInfo_GenesisContent proto.InternalMessageInfo

func (m *GenesisContent) GetShieldedPoolParams() *ShieldedPoolParameters {
	if m != nil {
		return m.ShieldedPoolParams
	}
	return nil
}

func (m *GenesisContent) GetAllocations() []*GenesisContent_Allocation {
	if m != nil {
		return m.Allocations
	}
	return nil
}

type GenesisContent_Allocation struct {
	Amount  *v1.Amount   `protobuf:"bytes,1,opt,name=amount,proto3" json:"amount,omitempty"`
	Denom   string       `protobuf:"bytes,2,opt,name=denom,proto3" json:"denom,omitempty"`
	Address *v11.Address `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *GenesisContent_Allocation) Reset()         { *m = GenesisContent_Allocation{} }
func (m *GenesisContent_Allocation) String() string { return proto.CompactTextString(m) }
func (*GenesisContent_Allocation) ProtoMessage()    {}
func (*GenesisContent_Allocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_26a9f446de1cd73c, []int{1, 0}
}
func (m *GenesisContent_Allocation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenesisContent_Allocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenesisContent_Allocation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenesisContent_Allocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenesisContent_Allocation.Merge(m, src)
}
func (m *GenesisContent_Allocation) XXX_Size() int {
	return m.Size()
}
func (m *GenesisContent_Allocation) XXX_DiscardUnknown() {
	xxx_messageInfo_GenesisContent_Allocation.DiscardUnknown(m)
}

var xxx_messageInfo_GenesisContent_Allocation proto.InternalMessageInfo

func (m *GenesisContent_Allocation) GetAmount() *v1.Amount {
	if m != nil {
		return m.Amount
	}
	return nil
}

func (m *GenesisContent_Allocation) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *GenesisContent_Allocation) GetAddress() *v11.Address {
	if m != nil {
		return m.Address
	}
	return nil
}

// The parameters which control how the FMD parameters evolve over time.
type FmdMetaParameters struct {
	// How much time users have to transition to new parameters.
	FmdGracePeriodBlocks uint64 `protobuf:"varint,1,opt,name=fmd_grace_period_blocks,json=fmdGracePeriodBlocks,proto3" json:"fmd_grace_period_blocks,omitempty"`
	// The algorithm governing how the parameters change.
	//
	// Types that are valid to be assigned to Algorithm:
	//
	//	*FmdMetaParameters_FixedPrecisionBits
	//	*FmdMetaParameters_SlidingWindow
	Algorithm isFmdMetaParameters_Algorithm `protobuf_oneof:"algorithm"`
}

func (m *FmdMetaParameters) Reset()         { *m = FmdMetaParameters{} }
func (m *FmdMetaParameters) String() string { return proto.CompactTextString(m) }
func (*FmdMetaParameters) ProtoMessage()    {}
func (*FmdMetaParameters) Descriptor() ([]byte, []int) {
	return fileDescriptor_26a9f446de1cd73c, []int{2}
}
func (m *FmdMetaParameters) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FmdMetaParameters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FmdMetaParameters.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FmdMetaParameters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FmdMetaParameters.Merge(m, src)
}
func (m *FmdMetaParameters) XXX_Size() int {
	return m.Size()
}
func (m *FmdMetaParameters) XXX_DiscardUnknown() {
	xxx_messageInfo_FmdMetaParameters.DiscardUnknown(m)
}

var xxx_messageInfo_FmdMetaParameters proto.InternalMessageInfo

type isFmdMetaParameters_Algorithm interface {
	isFmdMetaParameters_Algorithm()
	MarshalTo([]byte) (int, error)
	Size() int
}

type FmdMetaParameters_FixedPrecisionBits struct {
	FixedPrecisionBits uint32 `protobuf:"varint,2,opt,name=fixed_precision_bits,json=fixedPrecisionBits,proto3,oneof" json:"fixed_precision_bits,omitempty"`
}
type FmdMetaParameters_SlidingWindow struct {
	SlidingWindow *FmdMetaParameters_AlgorithmSlidingWindow `protobuf:"bytes,3,opt,name=sliding_window,json=slidingWindow,proto3,oneof" json:"sliding_window,omitempty"`
}

func (*FmdMetaParameters_FixedPrecisionBits) isFmdMetaParameters_Algorithm() {}
func (*FmdMetaParameters_SlidingWindow) isFmdMetaParameters_Algorithm()      {}

func (m *FmdMetaParameters) GetAlgorithm() isFmdMetaParameters_Algorithm {
	if m != nil {
		return m.Algorithm
	}
	return nil
}

func (m *FmdMetaParameters) GetFmdGracePeriodBlocks() uint64 {
	if m != nil {
		return m.FmdGracePeriodBlocks
	}
	return 0
}

func (m *FmdMetaParameters) GetFixedPrecisionBits() uint32 {
	if x, ok := m.GetAlgorithm().(*FmdMetaParameters_FixedPrecisionBits); ok {
		return x.FixedPrecisionBits
	}
	return 0
}

func (m *FmdMetaParameters) GetSlidingWindow() *FmdMetaParameters_AlgorithmSlidingWindow {
	if x, ok := m.GetAlgorithm().(*FmdMetaParameters_SlidingWindow); ok {
		return x.SlidingWindow
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*FmdMetaParameters) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*FmdMetaParameters_FixedPrecisionBits)(nil),
		(*FmdMetaParameters_SlidingWindow)(nil),
	}
}

// A sliding window algorithm for updating the parameters.
type FmdMetaParameters_AlgorithmSlidingWindow struct {
	// The window size, in terms of the number of update periods.
	//
	// The update period is 16 blocks, by default, but can change with governance.
	WindowUpdatePeriods uint32 `protobuf:"varint,1,opt,name=window_update_periods,json=windowUpdatePeriods,proto3" json:"window_update_periods,omitempty"`
	// The number of detections we aim to see per window.
	TargetedDetectionsPerWindow uint32 `protobuf:"varint,2,opt,name=targeted_detections_per_window,json=targetedDetectionsPerWindow,proto3" json:"targeted_detections_per_window,omitempty"`
}

func (m *FmdMetaParameters_AlgorithmSlidingWindow) Reset() {
	*m = FmdMetaParameters_AlgorithmSlidingWindow{}
}
func (m *FmdMetaParameters_AlgorithmSlidingWindow) String() string { return proto.CompactTextString(m) }
func (*FmdMetaParameters_AlgorithmSlidingWindow) ProtoMessage()    {}
func (*FmdMetaParameters_AlgorithmSlidingWindow) Descriptor() ([]byte, []int) {
	return fileDescriptor_26a9f446de1cd73c, []int{2, 0}
}
func (m *FmdMetaParameters_AlgorithmSlidingWindow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FmdMetaParameters_AlgorithmSlidingWindow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FmdMetaParameters_AlgorithmSlidingWindow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FmdMetaParameters_AlgorithmSlidingWindow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FmdMetaParameters_AlgorithmSlidingWindow.Merge(m, src)
}
func (m *FmdMetaParameters_AlgorithmSlidingWindow) XXX_Size() int {
	return m.Size()
}
func (m *FmdMetaParameters_AlgorithmSlidingWindow) XXX_DiscardUnknown() {
	xxx_messageInfo_FmdMetaParameters_AlgorithmSlidingWindow.DiscardUnknown(m)
}

var xxx_messageInfo_FmdMetaParameters_AlgorithmSlidingWindow proto.InternalMessageInfo

func (m *FmdMetaParameters_AlgorithmSlidingWindow) GetWindowUpdatePeriods() uint32 {
	if m != nil {
		return m.WindowUpdatePeriods
	}
	return 0
}

func (m *FmdMetaParameters_AlgorithmSlidingWindow) GetTargetedDetectionsPerWindow() uint32 {
	if m != nil {
		return m.TargetedDetectionsPerWindow
	}
	return 0
}

// Used to potentially store state for the FMD Meta Parameters algorithm.
type FmdMetaParametersAlgorithmState struct {
	// Types that are valid to be assigned to State:
	//
	//	*FmdMetaParametersAlgorithmState_Fixed
	//	*FmdMetaParametersAlgorithmState_SlidingWindow
	State isFmdMetaParametersAlgorithmState_State `protobuf_oneof:"state"`
}

func (m *FmdMetaParametersAlgorithmState) Reset()         { *m = FmdMetaParametersAlgorithmState{} }
func (m *FmdMetaParametersAlgorithmState) String() string { return proto.CompactTextString(m) }
func (*FmdMetaParametersAlgorithmState) ProtoMessage()    {}
func (*FmdMetaParametersAlgorithmState) Descriptor() ([]byte, []int) {
	return fileDescriptor_26a9f446de1cd73c, []int{3}
}
func (m *FmdMetaParametersAlgorithmState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FmdMetaParametersAlgorithmState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FmdMetaParametersAlgorithmState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FmdMetaParametersAlgorithmState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FmdMetaParametersAlgorithmState.Merge(m, src)
}
func (m *FmdMetaParametersAlgorithmState) XXX_Size() int {
	return m.Size()
}
func (m *FmdMetaParametersAlgorithmState) XXX_DiscardUnknown() {
	xxx_messageInfo_FmdMetaParametersAlgorithmState.DiscardUnknown(m)
}

var xxx_messageInfo_FmdMetaParametersAlgorithmState proto.InternalMessageInfo

type isFmdMetaParametersAlgorithmState_State interface {
	isFmdMetaParametersAlgorithmState_State()
	MarshalTo([]byte) (int, error)
	Size() int
}

type FmdMetaParametersAlgorithmState_Fixed struct {
	Fixed *FmdMetaParametersAlgorithmState_FixedState `protobuf:"bytes,1,opt,name=fixed,proto3,oneof" json:"fixed,omitempty"`
}
type FmdMetaParametersAlgorithmState_SlidingWindow struct {
	SlidingWindow *FmdMetaParametersAlgorithmState_SlidingWindowState `protobuf:"bytes,2,opt,name=sliding_window,json=slidingWindow,proto3,oneof" json:"sliding_window,omitempty"`
}

func (*FmdMetaParametersAlgorithmState_Fixed) isFmdMetaParametersAlgorithmState_State()         {}
func (*FmdMetaParametersAlgorithmState_SlidingWindow) isFmdMetaParametersAlgorithmState_State() {}

func (m *FmdMetaParametersAlgorithmState) GetState() isFmdMetaParametersAlgorithmState_State {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *FmdMetaParametersAlgorithmState) GetFixed() *FmdMetaParametersAlgorithmState_FixedState {
	if x, ok := m.GetState().(*FmdMetaParametersAlgorithmState_Fixed); ok {
		return x.Fixed
	}
	return nil
}

func (m *FmdMetaParametersAlgorithmState) GetSlidingWindow() *FmdMetaParametersAlgorithmState_SlidingWindowState {
	if x, ok := m.GetState().(*FmdMetaParametersAlgorithmState_SlidingWindow); ok {
		return x.SlidingWindow
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*FmdMetaParametersAlgorithmState) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*FmdMetaParametersAlgorithmState_Fixed)(nil),
		(*FmdMetaParametersAlgorithmState_SlidingWindow)(nil),
	}
}

// The state used for the fixed algorithm.
type FmdMetaParametersAlgorithmState_FixedState struct {
}

func (m *FmdMetaParametersAlgorithmState_FixedState) Reset() {
	*m = FmdMetaParametersAlgorithmState_FixedState{}
}
func (m *FmdMetaParametersAlgorithmState_FixedState) String() string {
	return proto.CompactTextString(m)
}
func (*FmdMetaParametersAlgorithmState_FixedState) ProtoMessage() {}
func (*FmdMetaParametersAlgorithmState_FixedState) Descriptor() ([]byte, []int) {
	return fileDescriptor_26a9f446de1cd73c, []int{3, 0}
}
func (m *FmdMetaParametersAlgorithmState_FixedState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FmdMetaParametersAlgorithmState_FixedState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FmdMetaParametersAlgorithmState_FixedState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FmdMetaParametersAlgorithmState_FixedState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FmdMetaParametersAlgorithmState_FixedState.Merge(m, src)
}
func (m *FmdMetaParametersAlgorithmState_FixedState) XXX_Size() int {
	return m.Size()
}
func (m *FmdMetaParametersAlgorithmState_FixedState) XXX_DiscardUnknown() {
	xxx_messageInfo_FmdMetaParametersAlgorithmState_FixedState.DiscardUnknown(m)
}

var xxx_messageInfo_FmdMetaParametersAlgorithmState_FixedState proto.InternalMessageInfo

// The state used for the sliding window algorithm.
type FmdMetaParametersAlgorithmState_SlidingWindowState struct {
	// The number of clues previously observed, approximately.
	ApproximateClueCount uint32 `protobuf:"varint,1,opt,name=approximate_clue_count,json=approximateClueCount,proto3" json:"approximate_clue_count,omitempty"`
}

func (m *FmdMetaParametersAlgorithmState_SlidingWindowState) Reset() {
	*m = FmdMetaParametersAlgorithmState_SlidingWindowState{}
}
func (m *FmdMetaParametersAlgorithmState_SlidingWindowState) String() string {
	return proto.CompactTextString(m)
}
func (*FmdMetaParametersAlgorithmState_SlidingWindowState) ProtoMessage() {}
func (*FmdMetaParametersAlgorithmState_SlidingWindowState) Descriptor() ([]byte, []int) {
	return fileDescriptor_26a9f446de1cd73c, []int{3, 1}
}
func (m *FmdMetaParametersAlgorithmState_SlidingWindowState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FmdMetaParametersAlgorithmState_SlidingWindowState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FmdMetaParametersAlgorithmState_SlidingWindowState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FmdMetaParametersAlgorithmState_SlidingWindowState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FmdMetaParametersAlgorithmState_SlidingWindowState.Merge(m, src)
}
func (m *FmdMetaParametersAlgorithmState_SlidingWindowState) XXX_Size() int {
	return m.Size()
}
func (m *FmdMetaParametersAlgorithmState_SlidingWindowState) XXX_DiscardUnknown() {
	xxx_messageInfo_FmdMetaParametersAlgorithmState_SlidingWindowState.DiscardUnknown(m)
}

var xxx_messageInfo_FmdMetaParametersAlgorithmState_SlidingWindowState proto.InternalMessageInfo

func (m *FmdMetaParametersAlgorithmState_SlidingWindowState) GetApproximateClueCount() uint32 {
	if m != nil {
		return m.ApproximateClueCount
	}
	return 0
}

// Parameters for Fuzzy Message Detection
type FmdParameters struct {
	PrecisionBits   uint32 `protobuf:"varint,1,opt,name=precision_bits,json=precisionBits,proto3" json:"precision_bits,omitempty"`
	AsOfBlockHeight uint64 `protobuf:"varint,2,opt,name=as_of_block_height,json=asOfBlockHeight,proto3" json:"as_of_block_height,omitempty"`
}

func (m *FmdParameters) Reset()         { *m = FmdParameters{} }
func (m *FmdParameters) String() string { return proto.CompactTextString(m) }
func (*FmdParameters) ProtoMessage()    {}
func (*FmdParameters) Descriptor() ([]byte, []int) {
	return fileDescriptor_26a9f446de1cd73c, []int{4}
}
func (m *FmdParameters) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FmdParameters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FmdParameters.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FmdParameters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FmdParameters.Merge(m, src)
}
func (m *FmdParameters) XXX_Size() int {
	return m.Size()
}
func (m *FmdParameters) XXX_DiscardUnknown() {
	xxx_messageInfo_FmdParameters.DiscardUnknown(m)
}

var xxx_messageInfo_FmdParameters proto.InternalMessageInfo

func (m *FmdParameters) GetPrecisionBits() uint32 {
	if m != nil {
		return m.PrecisionBits
	}
	return 0
}

func (m *FmdParameters) GetAsOfBlockHeight() uint64 {
	if m != nil {
		return m.AsOfBlockHeight
	}
	return 0
}

type Note struct {
	Value   *v12.Value   `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	Rseed   []byte       `protobuf:"bytes,2,opt,name=rseed,proto3" json:"rseed,omitempty"`
	Address *v11.Address `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *Note) Reset()         { *m = Note{} }
func (m *Note) String() string { return proto.CompactTextString(m) }
func (*Note) ProtoMessage()    {}
func (*Note) Descriptor() ([]byte, []int) {
	return fileDescriptor_26a9f446de1cd73c, []int{5}
}
func (m *Note) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Note) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Note.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Note) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Note.Merge(m, src)
}
func (m *Note) XXX_Size() int {
	return m.Size()
}
func (m *Note) XXX_DiscardUnknown() {
	xxx_messageInfo_Note.DiscardUnknown(m)
}

var xxx_messageInfo_Note proto.InternalMessageInfo

func (m *Note) GetValue() *v12.Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Note) GetRseed() []byte {
	if m != nil {
		return m.Rseed
	}
	return nil
}

func (m *Note) GetAddress() *v11.Address {
	if m != nil {
		return m.Address
	}
	return nil
}

type NoteView struct {
	Value   *v12.ValueView   `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	Rseed   []byte           `protobuf:"bytes,2,opt,name=rseed,proto3" json:"rseed,omitempty"`
	Address *v11.AddressView `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *NoteView) Reset()         { *m = NoteView{} }
func (m *NoteView) String() string { return proto.CompactTextString(m) }
func (*NoteView) ProtoMessage()    {}
func (*NoteView) Descriptor() ([]byte, []int) {
	return fileDescriptor_26a9f446de1cd73c, []int{6}
}
func (m *NoteView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NoteView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NoteView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NoteView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NoteView.Merge(m, src)
}
func (m *NoteView) XXX_Size() int {
	return m.Size()
}
func (m *NoteView) XXX_DiscardUnknown() {
	xxx_messageInfo_NoteView.DiscardUnknown(m)
}

var xxx_messageInfo_NoteView proto.InternalMessageInfo

func (m *NoteView) GetValue() *v12.ValueView {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *NoteView) GetRseed() []byte {
	if m != nil {
		return m.Rseed
	}
	return nil
}

func (m *NoteView) GetAddress() *v11.AddressView {
	if m != nil {
		return m.Address
	}
	return nil
}

// An encrypted note.
// 176 = 80(address) + 16(amount) + 32(asset ID) + 32(rseed) + 16(MAC) bytes.
type NoteCiphertext struct {
	Inner []byte `protobuf:"bytes,1,opt,name=inner,proto3" json:"inner,omitempty"`
}

func (m *NoteCiphertext) Reset()         { *m = NoteCiphertext{} }
func (m *NoteCiphertext) String() string { return proto.CompactTextString(m) }
func (*NoteCiphertext) ProtoMessage()    {}
func (*NoteCiphertext) Descriptor() ([]byte, []int) {
	return fileDescriptor_26a9f446de1cd73c, []int{7}
}
func (m *NoteCiphertext) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NoteCiphertext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NoteCiphertext.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NoteCiphertext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NoteCiphertext.Merge(m, src)
}
func (m *NoteCiphertext) XXX_Size() int {
	return m.Size()
}
func (m *NoteCiphertext) XXX_DiscardUnknown() {
	xxx_messageInfo_NoteCiphertext.DiscardUnknown(m)
}

var xxx_messageInfo_NoteCiphertext proto.InternalMessageInfo

func (m *NoteCiphertext) GetInner() []byte {
	if m != nil {
		return m.Inner
	}
	return nil
}

// The body of an output description, including only the minimal
// data required to scan and process the output.
type NotePayload struct {
	// The note commitment for the output note. 32 bytes.
	NoteCommitment *v13.StateCommitment `protobuf:"bytes,1,opt,name=note_commitment,json=noteCommitment,proto3" json:"note_commitment,omitempty"`
	// The encoding of an ephemeral public key. 32 bytes.
	EphemeralKey []byte `protobuf:"bytes,2,opt,name=ephemeral_key,json=ephemeralKey,proto3" json:"ephemeral_key,omitempty"`
	// An encryption of the newly created note.
	// 176 = 80(address) + 16(amount) + 32(asset ID) + 32(rseed) + 16(MAC) bytes.
	EncryptedNote *NoteCiphertext `protobuf:"bytes,3,opt,name=encrypted_note,json=encryptedNote,proto3" json:"encrypted_note,omitempty"`
}

func (m *NotePayload) Reset()         { *m = NotePayload{} }
func (m *NotePayload) String() string { return proto.CompactTextString(m) }
func (*NotePayload) ProtoMessage()    {}
func (*NotePayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_26a9f446de1cd73c, []int{8}
}
func (m *NotePayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NotePayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NotePayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NotePayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotePayload.Merge(m, src)
}
func (m *NotePayload) XXX_Size() int {
	return m.Size()
}
func (m *NotePayload) XXX_DiscardUnknown() {
	xxx_messageInfo_NotePayload.DiscardUnknown(m)
}

var xxx_messageInfo_NotePayload proto.InternalMessageInfo

func (m *NotePayload) GetNoteCommitment() *v13.StateCommitment {
	if m != nil {
		return m.NoteCommitment
	}
	return nil
}

func (m *NotePayload) GetEphemeralKey() []byte {
	if m != nil {
		return m.EphemeralKey
	}
	return nil
}

func (m *NotePayload) GetEncryptedNote() *NoteCiphertext {
	if m != nil {
		return m.EncryptedNote
	}
	return nil
}

// A Penumbra ZK output proof.
type ZKOutputProof struct {
	Inner []byte `protobuf:"bytes,1,opt,name=inner,proto3" json:"inner,omitempty"`
}

func (m *ZKOutputProof) Reset()         { *m = ZKOutputProof{} }
func (m *ZKOutputProof) String() string { return proto.CompactTextString(m) }
func (*ZKOutputProof) ProtoMessage()    {}
func (*ZKOutputProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_26a9f446de1cd73c, []int{9}
}
func (m *ZKOutputProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZKOutputProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZKOutputProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZKOutputProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZKOutputProof.Merge(m, src)
}
func (m *ZKOutputProof) XXX_Size() int {
	return m.Size()
}
func (m *ZKOutputProof) XXX_DiscardUnknown() {
	xxx_messageInfo_ZKOutputProof.DiscardUnknown(m)
}

var xxx_messageInfo_ZKOutputProof proto.InternalMessageInfo

func (m *ZKOutputProof) GetInner() []byte {
	if m != nil {
		return m.Inner
	}
	return nil
}

// A Penumbra ZK spend proof.
type ZKSpendProof struct {
	Inner []byte `protobuf:"bytes,1,opt,name=inner,proto3" json:"inner,omitempty"`
}

func (m *ZKSpendProof) Reset()         { *m = ZKSpendProof{} }
func (m *ZKSpendProof) String() string { return proto.CompactTextString(m) }
func (*ZKSpendProof) ProtoMessage()    {}
func (*ZKSpendProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_26a9f446de1cd73c, []int{10}
}
func (m *ZKSpendProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZKSpendProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZKSpendProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZKSpendProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZKSpendProof.Merge(m, src)
}
func (m *ZKSpendProof) XXX_Size() int {
	return m.Size()
}
func (m *ZKSpendProof) XXX_DiscardUnknown() {
	xxx_messageInfo_ZKSpendProof.DiscardUnknown(m)
}

var xxx_messageInfo_ZKSpendProof proto.InternalMessageInfo

func (m *ZKSpendProof) GetInner() []byte {
	if m != nil {
		return m.Inner
	}
	return nil
}

// A Penumbra ZK nullifier derivation proof.
type ZKNullifierDerivationProof struct {
	Inner []byte `protobuf:"bytes,1,opt,name=inner,proto3" json:"inner,omitempty"`
}

func (m *ZKNullifierDerivationProof) Reset()         { *m = ZKNullifierDerivationProof{} }
func (m *ZKNullifierDerivationProof) String() string { return proto.CompactTextString(m) }
func (*ZKNullifierDerivationProof) ProtoMessage()    {}
func (*ZKNullifierDerivationProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_26a9f446de1cd73c, []int{11}
}
func (m *ZKNullifierDerivationProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZKNullifierDerivationProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZKNullifierDerivationProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZKNullifierDerivationProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZKNullifierDerivationProof.Merge(m, src)
}
func (m *ZKNullifierDerivationProof) XXX_Size() int {
	return m.Size()
}
func (m *ZKNullifierDerivationProof) XXX_DiscardUnknown() {
	xxx_messageInfo_ZKNullifierDerivationProof.DiscardUnknown(m)
}

var xxx_messageInfo_ZKNullifierDerivationProof proto.InternalMessageInfo

func (m *ZKNullifierDerivationProof) GetInner() []byte {
	if m != nil {
		return m.Inner
	}
	return nil
}

// Spends a shielded note.
type Spend struct {
	// The effecting data of the spend.
	Body *SpendBody `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// The authorizing signature for the spend.
	AuthSig *v14.SpendAuthSignature `protobuf:"bytes,2,opt,name=auth_sig,json=authSig,proto3" json:"auth_sig,omitempty"`
	// The proof that the spend is well-formed is authorizing data.
	Proof *ZKSpendProof `protobuf:"bytes,3,opt,name=proof,proto3" json:"proof,omitempty"`
}

func (m *Spend) Reset()         { *m = Spend{} }
func (m *Spend) String() string { return proto.CompactTextString(m) }
func (*Spend) ProtoMessage()    {}
func (*Spend) Descriptor() ([]byte, []int) {
	return fileDescriptor_26a9f446de1cd73c, []int{12}
}
func (m *Spend) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Spend) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Spend.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Spend) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Spend.Merge(m, src)
}
func (m *Spend) XXX_Size() int {
	return m.Size()
}
func (m *Spend) XXX_DiscardUnknown() {
	xxx_messageInfo_Spend.DiscardUnknown(m)
}

var xxx_messageInfo_Spend proto.InternalMessageInfo

func (m *Spend) GetBody() *SpendBody {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *Spend) GetAuthSig() *v14.SpendAuthSignature {
	if m != nil {
		return m.AuthSig
	}
	return nil
}

func (m *Spend) GetProof() *ZKSpendProof {
	if m != nil {
		return m.Proof
	}
	return nil
}

// ABCI Event recording a spend.
type EventSpend struct {
	Nullifier *v15.Nullifier `protobuf:"bytes,1,opt,name=nullifier,proto3" json:"nullifier,omitempty"`
}

func (m *EventSpend) Reset()         { *m = EventSpend{} }
func (m *EventSpend) String() string { return proto.CompactTextString(m) }
func (*EventSpend) ProtoMessage()    {}
func (*EventSpend) Descriptor() ([]byte, []int) {
	return fileDescriptor_26a9f446de1cd73c, []int{13}
}
func (m *EventSpend) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSpend) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSpend.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSpend) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSpend.Merge(m, src)
}
func (m *EventSpend) XXX_Size() int {
	return m.Size()
}
func (m *EventSpend) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSpend.DiscardUnknown(m)
}

var xxx_messageInfo_EventSpend proto.InternalMessageInfo

func (m *EventSpend) GetNullifier() *v15.Nullifier {
	if m != nil {
		return m.Nullifier
	}
	return nil
}

// ABCI Event recording an output.
type EventOutput struct {
	NoteCommitment *v13.StateCommitment `protobuf:"bytes,1,opt,name=note_commitment,json=noteCommitment,proto3" json:"note_commitment,omitempty"`
}

func (m *EventOutput) Reset()         { *m = EventOutput{} }
func (m *EventOutput) String() string { return proto.CompactTextString(m) }
func (*EventOutput) ProtoMessage()    {}
func (*EventOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_26a9f446de1cd73c, []int{14}
}
func (m *EventOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventOutput.Merge(m, src)
}
func (m *EventOutput) XXX_Size() int {
	return m.Size()
}
func (m *EventOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_EventOutput.DiscardUnknown(m)
}

var xxx_messageInfo_EventOutput proto.InternalMessageInfo

func (m *EventOutput) GetNoteCommitment() *v13.StateCommitment {
	if m != nil {
		return m.NoteCommitment
	}
	return nil
}

// ABCI Event recording a clue.
type EventBroadcastClue struct {
	Clue *v16.Clue          `protobuf:"bytes,1,opt,name=clue,proto3" json:"clue,omitempty"`
	Tx   *v17.TransactionId `protobuf:"bytes,2,opt,name=tx,proto3" json:"tx,omitempty"`
}

func (m *EventBroadcastClue) Reset()         { *m = EventBroadcastClue{} }
func (m *EventBroadcastClue) String() string { return proto.CompactTextString(m) }
func (*EventBroadcastClue) ProtoMessage()    {}
func (*EventBroadcastClue) Descriptor() ([]byte, []int) {
	return fileDescriptor_26a9f446de1cd73c, []int{15}
}
func (m *EventBroadcastClue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventBroadcastClue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventBroadcastClue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventBroadcastClue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventBroadcastClue.Merge(m, src)
}
func (m *EventBroadcastClue) XXX_Size() int {
	return m.Size()
}
func (m *EventBroadcastClue) XXX_DiscardUnknown() {
	xxx_messageInfo_EventBroadcastClue.DiscardUnknown(m)
}

var xxx_messageInfo_EventBroadcastClue proto.InternalMessageInfo

func (m *EventBroadcastClue) GetClue() *v16.Clue {
	if m != nil {
		return m.Clue
	}
	return nil
}

func (m *EventBroadcastClue) GetTx() *v17.TransactionId {
	if m != nil {
		return m.Tx
	}
	return nil
}

// The body of a spend description, containing only the effecting data
// describing changes to the ledger, and not the authorizing data that allows
// those changes to be performed.
type SpendBody struct {
	// A commitment to the value of the input note.
	BalanceCommitment *v12.BalanceCommitment `protobuf:"bytes,1,opt,name=balance_commitment,json=balanceCommitment,proto3" json:"balance_commitment,omitempty"`
	// The nullifier of the input note.
	Nullifier *v15.Nullifier `protobuf:"bytes,6,opt,name=nullifier,proto3" json:"nullifier,omitempty"`
	// The randomized validating key for the spend authorization signature.
	Rk *v14.SpendVerificationKey `protobuf:"bytes,4,opt,name=rk,proto3" json:"rk,omitempty"`
}

func (m *SpendBody) Reset()         { *m = SpendBody{} }
func (m *SpendBody) String() string { return proto.CompactTextString(m) }
func (*SpendBody) ProtoMessage()    {}
func (*SpendBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_26a9f446de1cd73c, []int{16}
}
func (m *SpendBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpendBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpendBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpendBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpendBody.Merge(m, src)
}
func (m *SpendBody) XXX_Size() int {
	return m.Size()
}
func (m *SpendBody) XXX_DiscardUnknown() {
	xxx_messageInfo_SpendBody.DiscardUnknown(m)
}

var xxx_messageInfo_SpendBody proto.InternalMessageInfo

func (m *SpendBody) GetBalanceCommitment() *v12.BalanceCommitment {
	if m != nil {
		return m.BalanceCommitment
	}
	return nil
}

func (m *SpendBody) GetNullifier() *v15.Nullifier {
	if m != nil {
		return m.Nullifier
	}
	return nil
}

func (m *SpendBody) GetRk() *v14.SpendVerificationKey {
	if m != nil {
		return m.Rk
	}
	return nil
}

type SpendView struct {
	// Types that are valid to be assigned to SpendView:
	//
	//	*SpendView_Visible_
	//	*SpendView_Opaque_
	SpendView isSpendView_SpendView `protobuf_oneof:"spend_view"`
}

func (m *SpendView) Reset()         { *m = SpendView{} }
func (m *SpendView) String() string { return proto.CompactTextString(m) }
func (*SpendView) ProtoMessage()    {}
func (*SpendView) Descriptor() ([]byte, []int) {
	return fileDescriptor_26a9f446de1cd73c, []int{17}
}
func (m *SpendView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpendView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpendView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpendView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpendView.Merge(m, src)
}
func (m *SpendView) XXX_Size() int {
	return m.Size()
}
func (m *SpendView) XXX_DiscardUnknown() {
	xxx_messageInfo_SpendView.DiscardUnknown(m)
}

var xxx_messageInfo_SpendView proto.InternalMessageInfo

type isSpendView_SpendView interface {
	isSpendView_SpendView()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SpendView_Visible_ struct {
	Visible *SpendView_Visible `protobuf:"bytes,1,opt,name=visible,proto3,oneof" json:"visible,omitempty"`
}
type SpendView_Opaque_ struct {
	Opaque *SpendView_Opaque `protobuf:"bytes,2,opt,name=opaque,proto3,oneof" json:"opaque,omitempty"`
}

func (*SpendView_Visible_) isSpendView_SpendView() {}
func (*SpendView_Opaque_) isSpendView_SpendView()  {}

func (m *SpendView) GetSpendView() isSpendView_SpendView {
	if m != nil {
		return m.SpendView
	}
	return nil
}

func (m *SpendView) GetVisible() *SpendView_Visible {
	if x, ok := m.GetSpendView().(*SpendView_Visible_); ok {
		return x.Visible
	}
	return nil
}

func (m *SpendView) GetOpaque() *SpendView_Opaque {
	if x, ok := m.GetSpendView().(*SpendView_Opaque_); ok {
		return x.Opaque
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SpendView) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SpendView_Visible_)(nil),
		(*SpendView_Opaque_)(nil),
	}
}

type SpendView_Visible struct {
	Spend *Spend    `protobuf:"bytes,1,opt,name=spend,proto3" json:"spend,omitempty"`
	Note  *NoteView `protobuf:"bytes,2,opt,name=note,proto3" json:"note,omitempty"`
}

func (m *SpendView_Visible) Reset()         { *m = SpendView_Visible{} }
func (m *SpendView_Visible) String() string { return proto.CompactTextString(m) }
func (*SpendView_Visible) ProtoMessage()    {}
func (*SpendView_Visible) Descriptor() ([]byte, []int) {
	return fileDescriptor_26a9f446de1cd73c, []int{17, 0}
}
func (m *SpendView_Visible) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpendView_Visible) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpendView_Visible.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpendView_Visible) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpendView_Visible.Merge(m, src)
}
func (m *SpendView_Visible) XXX_Size() int {
	return m.Size()
}
func (m *SpendView_Visible) XXX_DiscardUnknown() {
	xxx_messageInfo_SpendView_Visible.DiscardUnknown(m)
}

var xxx_messageInfo_SpendView_Visible proto.InternalMessageInfo

func (m *SpendView_Visible) GetSpend() *Spend {
	if m != nil {
		return m.Spend
	}
	return nil
}

func (m *SpendView_Visible) GetNote() *NoteView {
	if m != nil {
		return m.Note
	}
	return nil
}

type SpendView_Opaque struct {
	Spend *Spend `protobuf:"bytes,1,opt,name=spend,proto3" json:"spend,omitempty"`
}

func (m *SpendView_Opaque) Reset()         { *m = SpendView_Opaque{} }
func (m *SpendView_Opaque) String() string { return proto.CompactTextString(m) }
func (*SpendView_Opaque) ProtoMessage()    {}
func (*SpendView_Opaque) Descriptor() ([]byte, []int) {
	return fileDescriptor_26a9f446de1cd73c, []int{17, 1}
}
func (m *SpendView_Opaque) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpendView_Opaque) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpendView_Opaque.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpendView_Opaque) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpendView_Opaque.Merge(m, src)
}
func (m *SpendView_Opaque) XXX_Size() int {
	return m.Size()
}
func (m *SpendView_Opaque) XXX_DiscardUnknown() {
	xxx_messageInfo_SpendView_Opaque.DiscardUnknown(m)
}

var xxx_messageInfo_SpendView_Opaque proto.InternalMessageInfo

func (m *SpendView_Opaque) GetSpend() *Spend {
	if m != nil {
		return m.Spend
	}
	return nil
}

type SpendPlan struct {
	// The plaintext note we plan to spend.
	Note *Note `protobuf:"bytes,1,opt,name=note,proto3" json:"note,omitempty"`
	// The position of the note we plan to spend.
	Position uint64 `protobuf:"varint,2,opt,name=position,proto3" json:"position,omitempty"`
	// The randomizer to use for the spend.
	Randomizer []byte `protobuf:"bytes,3,opt,name=randomizer,proto3" json:"randomizer,omitempty"`
	// The blinding factor to use for the value commitment.
	ValueBlinding []byte `protobuf:"bytes,4,opt,name=value_blinding,json=valueBlinding,proto3" json:"value_blinding,omitempty"`
	// The first blinding factor to use for the ZK spend proof.
	ProofBlindingR []byte `protobuf:"bytes,5,opt,name=proof_blinding_r,json=proofBlindingR,proto3" json:"proof_blinding_r,omitempty"`
	// The second blinding factor to use for the ZK spend proof.
	ProofBlindingS []byte `protobuf:"bytes,6,opt,name=proof_blinding_s,json=proofBlindingS,proto3" json:"proof_blinding_s,omitempty"`
}

func (m *SpendPlan) Reset()         { *m = SpendPlan{} }
func (m *SpendPlan) String() string { return proto.CompactTextString(m) }
func (*SpendPlan) ProtoMessage()    {}
func (*SpendPlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_26a9f446de1cd73c, []int{18}
}
func (m *SpendPlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpendPlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpendPlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpendPlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpendPlan.Merge(m, src)
}
func (m *SpendPlan) XXX_Size() int {
	return m.Size()
}
func (m *SpendPlan) XXX_DiscardUnknown() {
	xxx_messageInfo_SpendPlan.DiscardUnknown(m)
}

var xxx_messageInfo_SpendPlan proto.InternalMessageInfo

func (m *SpendPlan) GetNote() *Note {
	if m != nil {
		return m.Note
	}
	return nil
}

func (m *SpendPlan) GetPosition() uint64 {
	if m != nil {
		return m.Position
	}
	return 0
}

func (m *SpendPlan) GetRandomizer() []byte {
	if m != nil {
		return m.Randomizer
	}
	return nil
}

func (m *SpendPlan) GetValueBlinding() []byte {
	if m != nil {
		return m.ValueBlinding
	}
	return nil
}

func (m *SpendPlan) GetProofBlindingR() []byte {
	if m != nil {
		return m.ProofBlindingR
	}
	return nil
}

func (m *SpendPlan) GetProofBlindingS() []byte {
	if m != nil {
		return m.ProofBlindingS
	}
	return nil
}

// Creates a new shielded note.
type Output struct {
	// The effecting data for the output.
	Body *OutputBody `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// The output proof is authorizing data.
	Proof *ZKOutputProof `protobuf:"bytes,2,opt,name=proof,proto3" json:"proof,omitempty"`
}

func (m *Output) Reset()         { *m = Output{} }
func (m *Output) String() string { return proto.CompactTextString(m) }
func (*Output) ProtoMessage()    {}
func (*Output) Descriptor() ([]byte, []int) {
	return fileDescriptor_26a9f446de1cd73c, []int{19}
}
func (m *Output) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Output) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Output.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Output) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Output.Merge(m, src)
}
func (m *Output) XXX_Size() int {
	return m.Size()
}
func (m *Output) XXX_DiscardUnknown() {
	xxx_messageInfo_Output.DiscardUnknown(m)
}

var xxx_messageInfo_Output proto.InternalMessageInfo

func (m *Output) GetBody() *OutputBody {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *Output) GetProof() *ZKOutputProof {
	if m != nil {
		return m.Proof
	}
	return nil
}

// The body of an output description, containing only the effecting data
// describing changes to the ledger, and not the authorizing data that allows
// those changes to be performed.
type OutputBody struct {
	// The minimal data required to scan and process the new output note.
	NotePayload *NotePayload `protobuf:"bytes,1,opt,name=note_payload,json=notePayload,proto3" json:"note_payload,omitempty"`
	// A commitment to the value of the output note. 32 bytes.
	BalanceCommitment *v12.BalanceCommitment `protobuf:"bytes,2,opt,name=balance_commitment,json=balanceCommitment,proto3" json:"balance_commitment,omitempty"`
	// An encrypted key for decrypting the memo.
	WrappedMemoKey []byte `protobuf:"bytes,3,opt,name=wrapped_memo_key,json=wrappedMemoKey,proto3" json:"wrapped_memo_key,omitempty"`
	// The key material used for note encryption, wrapped in encryption to the
	// sender's outgoing viewing key. 48 bytes.
	OvkWrappedKey []byte `protobuf:"bytes,4,opt,name=ovk_wrapped_key,json=ovkWrappedKey,proto3" json:"ovk_wrapped_key,omitempty"`
}

func (m *OutputBody) Reset()         { *m = OutputBody{} }
func (m *OutputBody) String() string { return proto.CompactTextString(m) }
func (*OutputBody) ProtoMessage()    {}
func (*OutputBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_26a9f446de1cd73c, []int{20}
}
func (m *OutputBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OutputBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OutputBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OutputBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutputBody.Merge(m, src)
}
func (m *OutputBody) XXX_Size() int {
	return m.Size()
}
func (m *OutputBody) XXX_DiscardUnknown() {
	xxx_messageInfo_OutputBody.DiscardUnknown(m)
}

var xxx_messageInfo_OutputBody proto.InternalMessageInfo

func (m *OutputBody) GetNotePayload() *NotePayload {
	if m != nil {
		return m.NotePayload
	}
	return nil
}

func (m *OutputBody) GetBalanceCommitment() *v12.BalanceCommitment {
	if m != nil {
		return m.BalanceCommitment
	}
	return nil
}

func (m *OutputBody) GetWrappedMemoKey() []byte {
	if m != nil {
		return m.WrappedMemoKey
	}
	return nil
}

func (m *OutputBody) GetOvkWrappedKey() []byte {
	if m != nil {
		return m.OvkWrappedKey
	}
	return nil
}

type OutputView struct {
	// Types that are valid to be assigned to OutputView:
	//
	//	*OutputView_Visible_
	//	*OutputView_Opaque_
	OutputView isOutputView_OutputView `protobuf_oneof:"output_view"`
}

func (m *OutputView) Reset()         { *m = OutputView{} }
func (m *OutputView) String() string { return proto.CompactTextString(m) }
func (*OutputView) ProtoMessage()    {}
func (*OutputView) Descriptor() ([]byte, []int) {
	return fileDescriptor_26a9f446de1cd73c, []int{21}
}
func (m *OutputView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OutputView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OutputView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OutputView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutputView.Merge(m, src)
}
func (m *OutputView) XXX_Size() int {
	return m.Size()
}
func (m *OutputView) XXX_DiscardUnknown() {
	xxx_messageInfo_OutputView.DiscardUnknown(m)
}

var xxx_messageInfo_OutputView proto.InternalMessageInfo

type isOutputView_OutputView interface {
	isOutputView_OutputView()
	MarshalTo([]byte) (int, error)
	Size() int
}

type OutputView_Visible_ struct {
	Visible *OutputView_Visible `protobuf:"bytes,1,opt,name=visible,proto3,oneof" json:"visible,omitempty"`
}
type OutputView_Opaque_ struct {
	Opaque *OutputView_Opaque `protobuf:"bytes,2,opt,name=opaque,proto3,oneof" json:"opaque,omitempty"`
}

func (*OutputView_Visible_) isOutputView_OutputView() {}
func (*OutputView_Opaque_) isOutputView_OutputView()  {}

func (m *OutputView) GetOutputView() isOutputView_OutputView {
	if m != nil {
		return m.OutputView
	}
	return nil
}

func (m *OutputView) GetVisible() *OutputView_Visible {
	if x, ok := m.GetOutputView().(*OutputView_Visible_); ok {
		return x.Visible
	}
	return nil
}

func (m *OutputView) GetOpaque() *OutputView_Opaque {
	if x, ok := m.GetOutputView().(*OutputView_Opaque_); ok {
		return x.Opaque
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*OutputView) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*OutputView_Visible_)(nil),
		(*OutputView_Opaque_)(nil),
	}
}

type OutputView_Visible struct {
	Output     *Output         `protobuf:"bytes,1,opt,name=output,proto3" json:"output,omitempty"`
	Note       *NoteView       `protobuf:"bytes,2,opt,name=note,proto3" json:"note,omitempty"`
	PayloadKey *v11.PayloadKey `protobuf:"bytes,3,opt,name=payload_key,json=payloadKey,proto3" json:"payload_key,omitempty"`
}

func (m *OutputView_Visible) Reset()         { *m = OutputView_Visible{} }
func (m *OutputView_Visible) String() string { return proto.CompactTextString(m) }
func (*OutputView_Visible) ProtoMessage()    {}
func (*OutputView_Visible) Descriptor() ([]byte, []int) {
	return fileDescriptor_26a9f446de1cd73c, []int{21, 0}
}
func (m *OutputView_Visible) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OutputView_Visible) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OutputView_Visible.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OutputView_Visible) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutputView_Visible.Merge(m, src)
}
func (m *OutputView_Visible) XXX_Size() int {
	return m.Size()
}
func (m *OutputView_Visible) XXX_DiscardUnknown() {
	xxx_messageInfo_OutputView_Visible.DiscardUnknown(m)
}

var xxx_messageInfo_OutputView_Visible proto.InternalMessageInfo

func (m *OutputView_Visible) GetOutput() *Output {
	if m != nil {
		return m.Output
	}
	return nil
}

func (m *OutputView_Visible) GetNote() *NoteView {
	if m != nil {
		return m.Note
	}
	return nil
}

func (m *OutputView_Visible) GetPayloadKey() *v11.PayloadKey {
	if m != nil {
		return m.PayloadKey
	}
	return nil
}

type OutputView_Opaque struct {
	Output *Output `protobuf:"bytes,1,opt,name=output,proto3" json:"output,omitempty"`
}

func (m *OutputView_Opaque) Reset()         { *m = OutputView_Opaque{} }
func (m *OutputView_Opaque) String() string { return proto.CompactTextString(m) }
func (*OutputView_Opaque) ProtoMessage()    {}
func (*OutputView_Opaque) Descriptor() ([]byte, []int) {
	return fileDescriptor_26a9f446de1cd73c, []int{21, 1}
}
func (m *OutputView_Opaque) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OutputView_Opaque) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OutputView_Opaque.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OutputView_Opaque) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutputView_Opaque.Merge(m, src)
}
func (m *OutputView_Opaque) XXX_Size() int {
	return m.Size()
}
func (m *OutputView_Opaque) XXX_DiscardUnknown() {
	xxx_messageInfo_OutputView_Opaque.DiscardUnknown(m)
}

var xxx_messageInfo_OutputView_Opaque proto.InternalMessageInfo

func (m *OutputView_Opaque) GetOutput() *Output {
	if m != nil {
		return m.Output
	}
	return nil
}

type OutputPlan struct {
	// The value to send to this output.
	Value *v12.Value `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	// The destination address to send it to.
	DestAddress *v11.Address `protobuf:"bytes,2,opt,name=dest_address,json=destAddress,proto3" json:"dest_address,omitempty"`
	// The rseed to use for the new note.
	Rseed []byte `protobuf:"bytes,3,opt,name=rseed,proto3" json:"rseed,omitempty"`
	// The blinding factor to use for the value commitment.
	ValueBlinding []byte `protobuf:"bytes,4,opt,name=value_blinding,json=valueBlinding,proto3" json:"value_blinding,omitempty"`
	// The first blinding factor to use for the ZK output proof.
	ProofBlindingR []byte `protobuf:"bytes,5,opt,name=proof_blinding_r,json=proofBlindingR,proto3" json:"proof_blinding_r,omitempty"`
	// The second blinding factor to use for the ZK output proof.
	ProofBlindingS []byte `protobuf:"bytes,6,opt,name=proof_blinding_s,json=proofBlindingS,proto3" json:"proof_blinding_s,omitempty"`
}

func (m *OutputPlan) Reset()         { *m = OutputPlan{} }
func (m *OutputPlan) String() string { return proto.CompactTextString(m) }
func (*OutputPlan) ProtoMessage()    {}
func (*OutputPlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_26a9f446de1cd73c, []int{22}
}
func (m *OutputPlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OutputPlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OutputPlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OutputPlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutputPlan.Merge(m, src)
}
func (m *OutputPlan) XXX_Size() int {
	return m.Size()
}
func (m *OutputPlan) XXX_DiscardUnknown() {
	xxx_messageInfo_OutputPlan.DiscardUnknown(m)
}

var xxx_messageInfo_OutputPlan proto.InternalMessageInfo

func (m *OutputPlan) GetValue() *v12.Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *OutputPlan) GetDestAddress() *v11.Address {
	if m != nil {
		return m.DestAddress
	}
	return nil
}

func (m *OutputPlan) GetRseed() []byte {
	if m != nil {
		return m.Rseed
	}
	return nil
}

func (m *OutputPlan) GetValueBlinding() []byte {
	if m != nil {
		return m.ValueBlinding
	}
	return nil
}

func (m *OutputPlan) GetProofBlindingR() []byte {
	if m != nil {
		return m.ProofBlindingR
	}
	return nil
}

func (m *OutputPlan) GetProofBlindingS() []byte {
	if m != nil {
		return m.ProofBlindingS
	}
	return nil
}

// Requests information on an asset by asset id
type AssetMetadataByIdRequest struct {
	// The asset id to request information on.
	AssetId *v12.AssetId `protobuf:"bytes,2,opt,name=asset_id,json=assetId,proto3" json:"asset_id,omitempty"`
}

func (m *AssetMetadataByIdRequest) Reset()         { *m = AssetMetadataByIdRequest{} }
func (m *AssetMetadataByIdRequest) String() string { return proto.CompactTextString(m) }
func (*AssetMetadataByIdRequest) ProtoMessage()    {}
func (*AssetMetadataByIdRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_26a9f446de1cd73c, []int{23}
}
func (m *AssetMetadataByIdRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AssetMetadataByIdRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AssetMetadataByIdRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AssetMetadataByIdRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AssetMetadataByIdRequest.Merge(m, src)
}
func (m *AssetMetadataByIdRequest) XXX_Size() int {
	return m.Size()
}
func (m *AssetMetadataByIdRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AssetMetadataByIdRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AssetMetadataByIdRequest proto.InternalMessageInfo

func (m *AssetMetadataByIdRequest) GetAssetId() *v12.AssetId {
	if m != nil {
		return m.AssetId
	}
	return nil
}

type AssetMetadataByIdResponse struct {
	// If present, information on the requested asset.
	//
	// If the requested asset was unknown, this field will not be present.
	DenomMetadata *v12.Metadata `protobuf:"bytes,1,opt,name=denom_metadata,json=denomMetadata,proto3" json:"denom_metadata,omitempty"`
}

func (m *AssetMetadataByIdResponse) Reset()         { *m = AssetMetadataByIdResponse{} }
func (m *AssetMetadataByIdResponse) String() string { return proto.CompactTextString(m) }
func (*AssetMetadataByIdResponse) ProtoMessage()    {}
func (*AssetMetadataByIdResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_26a9f446de1cd73c, []int{24}
}
func (m *AssetMetadataByIdResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AssetMetadataByIdResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AssetMetadataByIdResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AssetMetadataByIdResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AssetMetadataByIdResponse.Merge(m, src)
}
func (m *AssetMetadataByIdResponse) XXX_Size() int {
	return m.Size()
}
func (m *AssetMetadataByIdResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AssetMetadataByIdResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AssetMetadataByIdResponse proto.InternalMessageInfo

func (m *AssetMetadataByIdResponse) GetDenomMetadata() *v12.Metadata {
	if m != nil {
		return m.DenomMetadata
	}
	return nil
}

// Requests information on an asset by multiple asset ids
type AssetMetadataByIdsRequest struct {
	// The asset IDs to request information on. Note that node is neither required
	// nor expected to stream responses in the same order as this array.
	AssetId []*v12.AssetId `protobuf:"bytes,1,rep,name=asset_id,json=assetId,proto3" json:"asset_id,omitempty"`
}

func (m *AssetMetadataByIdsRequest) Reset()         { *m = AssetMetadataByIdsRequest{} }
func (m *AssetMetadataByIdsRequest) String() string { return proto.CompactTextString(m) }
func (*AssetMetadataByIdsRequest) ProtoMessage()    {}
func (*AssetMetadataByIdsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_26a9f446de1cd73c, []int{25}
}
func (m *AssetMetadataByIdsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AssetMetadataByIdsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AssetMetadataByIdsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AssetMetadataByIdsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AssetMetadataByIdsRequest.Merge(m, src)
}
func (m *AssetMetadataByIdsRequest) XXX_Size() int {
	return m.Size()
}
func (m *AssetMetadataByIdsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AssetMetadataByIdsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AssetMetadataByIdsRequest proto.InternalMessageInfo

func (m *AssetMetadataByIdsRequest) GetAssetId() []*v12.AssetId {
	if m != nil {
		return m.AssetId
	}
	return nil
}

type AssetMetadataByIdsResponse struct {
	// A single asset metadata streamed from the node.
	DenomMetadata *v12.Metadata `protobuf:"bytes,1,opt,name=denom_metadata,json=denomMetadata,proto3" json:"denom_metadata,omitempty"`
}

func (m *AssetMetadataByIdsResponse) Reset()         { *m = AssetMetadataByIdsResponse{} }
func (m *AssetMetadataByIdsResponse) String() string { return proto.CompactTextString(m) }
func (*AssetMetadataByIdsResponse) ProtoMessage()    {}
func (*AssetMetadataByIdsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_26a9f446de1cd73c, []int{26}
}
func (m *AssetMetadataByIdsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AssetMetadataByIdsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AssetMetadataByIdsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AssetMetadataByIdsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AssetMetadataByIdsResponse.Merge(m, src)
}
func (m *AssetMetadataByIdsResponse) XXX_Size() int {
	return m.Size()
}
func (m *AssetMetadataByIdsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AssetMetadataByIdsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AssetMetadataByIdsResponse proto.InternalMessageInfo

func (m *AssetMetadataByIdsResponse) GetDenomMetadata() *v12.Metadata {
	if m != nil {
		return m.DenomMetadata
	}
	return nil
}

func init() {
	proto.RegisterType((*ShieldedPoolParameters)(nil), "penumbra.core.component.shielded_pool.v1.ShieldedPoolParameters")
	proto.RegisterType((*GenesisContent)(nil), "penumbra.core.component.shielded_pool.v1.GenesisContent")
	proto.RegisterType((*GenesisContent_Allocation)(nil), "penumbra.core.component.shielded_pool.v1.GenesisContent.Allocation")
	proto.RegisterType((*FmdMetaParameters)(nil), "penumbra.core.component.shielded_pool.v1.FmdMetaParameters")
	proto.RegisterType((*FmdMetaParameters_AlgorithmSlidingWindow)(nil), "penumbra.core.component.shielded_pool.v1.FmdMetaParameters.AlgorithmSlidingWindow")
	proto.RegisterType((*FmdMetaParametersAlgorithmState)(nil), "penumbra.core.component.shielded_pool.v1.FmdMetaParametersAlgorithmState")
	proto.RegisterType((*FmdMetaParametersAlgorithmState_FixedState)(nil), "penumbra.core.component.shielded_pool.v1.FmdMetaParametersAlgorithmState.FixedState")
	proto.RegisterType((*FmdMetaParametersAlgorithmState_SlidingWindowState)(nil), "penumbra.core.component.shielded_pool.v1.FmdMetaParametersAlgorithmState.SlidingWindowState")
	proto.RegisterType((*FmdParameters)(nil), "penumbra.core.component.shielded_pool.v1.FmdParameters")
	proto.RegisterType((*Note)(nil), "penumbra.core.component.shielded_pool.v1.Note")
	proto.RegisterType((*NoteView)(nil), "penumbra.core.component.shielded_pool.v1.NoteView")
	proto.RegisterType((*NoteCiphertext)(nil), "penumbra.core.component.shielded_pool.v1.NoteCiphertext")
	proto.RegisterType((*NotePayload)(nil), "penumbra.core.component.shielded_pool.v1.NotePayload")
	proto.RegisterType((*ZKOutputProof)(nil), "penumbra.core.component.shielded_pool.v1.ZKOutputProof")
	proto.RegisterType((*ZKSpendProof)(nil), "penumbra.core.component.shielded_pool.v1.ZKSpendProof")
	proto.RegisterType((*ZKNullifierDerivationProof)(nil), "penumbra.core.component.shielded_pool.v1.ZKNullifierDerivationProof")
	proto.RegisterType((*Spend)(nil), "penumbra.core.component.shielded_pool.v1.Spend")
	proto.RegisterType((*EventSpend)(nil), "penumbra.core.component.shielded_pool.v1.EventSpend")
	proto.RegisterType((*EventOutput)(nil), "penumbra.core.component.shielded_pool.v1.EventOutput")
	proto.RegisterType((*EventBroadcastClue)(nil), "penumbra.core.component.shielded_pool.v1.EventBroadcastClue")
	proto.RegisterType((*SpendBody)(nil), "penumbra.core.component.shielded_pool.v1.SpendBody")
	proto.RegisterType((*SpendView)(nil), "penumbra.core.component.shielded_pool.v1.SpendView")
	proto.RegisterType((*SpendView_Visible)(nil), "penumbra.core.component.shielded_pool.v1.SpendView.Visible")
	proto.RegisterType((*SpendView_Opaque)(nil), "penumbra.core.component.shielded_pool.v1.SpendView.Opaque")
	proto.RegisterType((*SpendPlan)(nil), "penumbra.core.component.shielded_pool.v1.SpendPlan")
	proto.RegisterType((*Output)(nil), "penumbra.core.component.shielded_pool.v1.Output")
	proto.RegisterType((*OutputBody)(nil), "penumbra.core.component.shielded_pool.v1.OutputBody")
	proto.RegisterType((*OutputView)(nil), "penumbra.core.component.shielded_pool.v1.OutputView")
	proto.RegisterType((*OutputView_Visible)(nil), "penumbra.core.component.shielded_pool.v1.OutputView.Visible")
	proto.RegisterType((*OutputView_Opaque)(nil), "penumbra.core.component.shielded_pool.v1.OutputView.Opaque")
	proto.RegisterType((*OutputPlan)(nil), "penumbra.core.component.shielded_pool.v1.OutputPlan")
	proto.RegisterType((*AssetMetadataByIdRequest)(nil), "penumbra.core.component.shielded_pool.v1.AssetMetadataByIdRequest")
	proto.RegisterType((*AssetMetadataByIdResponse)(nil), "penumbra.core.component.shielded_pool.v1.AssetMetadataByIdResponse")
	proto.RegisterType((*AssetMetadataByIdsRequest)(nil), "penumbra.core.component.shielded_pool.v1.AssetMetadataByIdsRequest")
	proto.RegisterType((*AssetMetadataByIdsResponse)(nil), "penumbra.core.component.shielded_pool.v1.AssetMetadataByIdsResponse")
}

func init() {
	proto.RegisterFile("penumbra/core/component/shielded_pool/v1/shielded_pool.proto", fileDescriptor_26a9f446de1cd73c)
}

var fileDescriptor_26a9f446de1cd73c = []byte{
	// 1981 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x59, 0xcf, 0x73, 0x1b, 0x49,
	0x15, 0xf6, 0xc8, 0xbf, 0x92, 0x67, 0xc9, 0xd9, 0x34, 0x21, 0x18, 0x01, 0xde, 0x30, 0x6c, 0xb2,
	0xde, 0x5a, 0x4a, 0x5e, 0x39, 0xd9, 0xcd, 0xe2, 0xe4, 0x80, 0xa5, 0x6c, 0xe2, 0x60, 0xb2, 0x11,
	0xed, 0xc4, 0x49, 0xa5, 0x5c, 0x35, 0xd5, 0x9a, 0x69, 0x59, 0x53, 0x9e, 0x99, 0x9e, 0x9d, 0x6e,
	0xc9, 0x16, 0x5c, 0xb6, 0xa8, 0x02, 0x0e, 0x5c, 0x60, 0xab, 0x28, 0x38, 0xec, 0x65, 0x39, 0x72,
	0xe6, 0x8f, 0xa0, 0x38, 0x2d, 0x37, 0x6e, 0x50, 0x09, 0x5c, 0xb8, 0x70, 0xe3, 0xc0, 0x89, 0xea,
	0x1f, 0x33, 0xd2, 0x48, 0x96, 0x4b, 0x8a, 0x5d, 0xc5, 0x25, 0x99, 0xe9, 0xfe, 0xde, 0xf7, 0xbe,
	0xf7, 0x5e, 0xf7, 0xeb, 0x1e, 0x19, 0xee, 0xc6, 0x34, 0xea, 0x84, 0xcd, 0x84, 0xac, 0xbb, 0x2c,
	0xa1, 0xeb, 0x2e, 0x0b, 0x63, 0x16, 0xd1, 0x48, 0xac, 0xf3, 0xb6, 0x4f, 0x03, 0x8f, 0x7a, 0x4e,
	0xcc, 0x58, 0xb0, 0xde, 0xad, 0xe6, 0x07, 0x2a, 0x71, 0xc2, 0x04, 0x43, 0x6b, 0xa9, 0x75, 0x45,
	0x5a, 0x57, 0x32, 0xeb, 0x4a, 0x1e, 0xdc, 0xad, 0x96, 0xed, 0xbc, 0x1f, 0xc2, 0x39, 0x15, 0x92,
	0x55, 0x3d, 0x68, 0xb6, 0xf2, 0xda, 0x58, 0x2d, 0xae, 0xc2, 0x72, 0x37, 0x45, 0x5e, 0xcb, 0x23,
	0x0f, 0x69, 0x8f, 0x4b, 0x80, 0xfc, 0xdf, 0x20, 0x56, 0xf3, 0x88, 0xa8, 0x13, 0x4a, 0x40, 0xd4,
	0x09, 0xcd, 0xfc, 0x5b, 0xf9, 0x79, 0x71, 0xdc, 0x26, 0xbc, 0x2d, 0x21, 0xfa, 0xc9, 0xa0, 0x36,
	0xfa, 0xa8, 0xa4, 0x17, 0x0b, 0xb6, 0xee, 0x51, 0x97, 0xb4, 0x6e, 0xde, 0xbe, 0xed, 0xb4, 0x42,
	0x4f, 0xa2, 0x07, 0xdf, 0x8d, 0xcd, 0xad, 0xb1, 0x36, 0x89, 0xc7, 0x49, 0xce, 0x48, 0x0e, 0x8c,
	0x46, 0xa4, 0xad, 0x84, 0x8e, 0x59, 0xa4, 0x31, 0xdb, 0xff, 0xb0, 0xe0, 0xea, 0xae, 0x49, 0x6b,
	0x83, 0xb1, 0xa0, 0x41, 0x12, 0x12, 0x52, 0x41, 0x13, 0x8e, 0x28, 0xbc, 0xd1, 0xf2, 0x8f, 0xa9,
	0x27, 0x55, 0x38, 0xb1, 0x1c, 0xe7, 0x2b, 0xd6, 0x35, 0x6b, 0x6d, 0x69, 0xe3, 0x76, 0x65, 0xd2,
	0x0a, 0x55, 0xee, 0x87, 0x5e, 0x9f, 0xb2, 0x56, 0x58, 0xb1, 0xf0, 0xb2, 0x22, 0x4d, 0xc7, 0x39,
	0x72, 0xe1, 0x92, 0x74, 0x10, 0x52, 0x41, 0x52, 0x2f, 0x05, 0xe5, 0xe5, 0xce, 0x54, 0x5e, 0x1e,
	0x51, 0x41, 0xfa, 0x9e, 0x70, 0xa9, 0x35, 0x30, 0xc4, 0xed, 0x4f, 0x67, 0x61, 0xf9, 0x01, 0x8d,
	0x28, 0xf7, 0x79, 0x9d, 0x45, 0x82, 0x46, 0x02, 0x25, 0x70, 0x25, 0xc7, 0x93, 0x0f, 0xf1, 0xfb,
	0x93, 0x3b, 0x3f, 0x39, 0x7d, 0x18, 0xf1, 0xe1, 0x71, 0x99, 0xd2, 0x25, 0x12, 0x04, 0xcc, 0x25,
	0xc2, 0x67, 0x11, 0x5f, 0x99, 0xbd, 0x36, 0xbb, 0xb6, 0xb4, 0x51, 0x9f, 0xdc, 0x55, 0x3e, 0x84,
	0xca, 0x56, 0xc6, 0x85, 0x07, 0x79, 0xcb, 0x9f, 0x59, 0x00, 0xfd, 0x39, 0x74, 0x0b, 0x16, 0x48,
	0xc8, 0x3a, 0x91, 0x30, 0xb1, 0x7d, 0x73, 0xc8, 0xa1, 0x5c, 0xbf, 0xdd, 0x6a, 0x65, 0x4b, 0x61,
	0xb0, 0xc1, 0xa2, 0x2b, 0x30, 0xef, 0xd1, 0x88, 0x85, 0xaa, 0x1a, 0x17, 0xb1, 0x7e, 0x41, 0x1f,
	0xc2, 0x22, 0xf1, 0xbc, 0x84, 0x72, 0xa9, 0x5e, 0x92, 0xad, 0x0e, 0x91, 0xa9, 0xdd, 0x22, 0xd9,
	0x34, 0x0a, 0xa7, 0x70, 0xfb, 0xf3, 0x59, 0xb8, 0x3c, 0x52, 0x27, 0xf4, 0x3e, 0x7c, 0x4d, 0x56,
	0xff, 0x20, 0x21, 0x2e, 0x75, 0x62, 0x9a, 0xf8, 0xcc, 0x73, 0x9a, 0x01, 0x73, 0x0f, 0x75, 0x21,
	0xe6, 0xf0, 0x95, 0x56, 0xe8, 0x3d, 0x90, 0xb3, 0x0d, 0x35, 0x59, 0x53, 0x73, 0x68, 0x03, 0xae,
	0xe8, 0xb5, 0x19, 0x27, 0xd4, 0xf5, 0xb9, 0xcf, 0x22, 0xa7, 0xe9, 0x0b, 0xbd, 0x72, 0x4a, 0xdb,
	0x33, 0x18, 0xa9, 0xd9, 0x46, 0x3a, 0x59, 0xf3, 0x05, 0x47, 0x3f, 0x81, 0x65, 0x1e, 0xf8, 0x9e,
	0x1f, 0x1d, 0x38, 0x47, 0x7e, 0xe4, 0xb1, 0x23, 0x13, 0x01, 0x3e, 0xc3, 0x3a, 0xab, 0x6c, 0x05,
	0x07, 0x2c, 0xf1, 0x45, 0x3b, 0xdc, 0xd5, 0xd4, 0xcf, 0x14, 0xf3, 0xf6, 0x0c, 0x2e, 0xf1, 0xc1,
	0x81, 0xf2, 0xaf, 0x2d, 0xb8, 0x7a, 0x32, 0x16, 0x6d, 0xc0, 0x57, 0xb5, 0x1e, 0xa7, 0x13, 0x7b,
	0x44, 0xa4, 0x69, 0xd0, 0x09, 0x28, 0xe1, 0xaf, 0xe8, 0xc9, 0xa7, 0x6a, 0x4e, 0x27, 0x81, 0xa3,
	0x3a, 0xac, 0x0a, 0x92, 0x1c, 0x50, 0x41, 0x3d, 0xc7, 0xa3, 0x82, 0xba, 0xaa, 0xf0, 0xd2, 0x32,
	0x8d, 0x4d, 0x65, 0x02, 0x7f, 0x23, 0x45, 0xdd, 0xcb, 0x40, 0x0d, 0x9a, 0x68, 0xc7, 0xb5, 0x25,
	0xb8, 0x48, 0x52, 0x49, 0xf6, 0x7f, 0x0b, 0xf0, 0xe6, 0x48, 0x78, 0x7d, 0xc5, 0x82, 0x08, 0x8a,
	0x02, 0x98, 0x57, 0x79, 0x35, 0xeb, 0xe8, 0xc9, 0x19, 0x12, 0x97, 0x67, 0xae, 0xdc, 0x97, 0xb4,
	0xea, 0x71, 0x7b, 0x06, 0x6b, 0x27, 0xe8, 0x67, 0xd6, 0x48, 0xc1, 0x74, 0x63, 0xd8, 0x3f, 0x3f,
	0xbf, 0xb9, 0x4a, 0xa4, 0xfe, 0x87, 0x4a, 0x57, 0x04, 0xe8, 0xcb, 0x2b, 0xff, 0x00, 0xd0, 0xa8,
	0x11, 0xba, 0x05, 0x57, 0x49, 0x1c, 0x27, 0xec, 0xd8, 0x0f, 0x65, 0x05, 0xdd, 0xa0, 0x43, 0x1d,
	0x37, 0xdb, 0x72, 0x25, 0x7c, 0x65, 0x60, 0xb6, 0x1e, 0x74, 0x68, 0x5d, 0xce, 0xd5, 0x16, 0x61,
	0x9e, 0x4b, 0x73, 0xdb, 0x85, 0x52, 0xae, 0x51, 0xa2, 0xeb, 0xb0, 0x3c, 0xb4, 0xb2, 0x35, 0x4f,
	0x29, 0xce, 0x2d, 0xe9, 0x77, 0x01, 0x11, 0xee, 0xb0, 0x96, 0xde, 0x32, 0x4e, 0x9b, 0xfa, 0x07,
	0x6d, 0xa1, 0xb2, 0x34, 0x87, 0x2f, 0x11, 0xfe, 0xb8, 0xa5, 0xb6, 0xcb, 0xb6, 0x1a, 0xb6, 0x7f,
	0x69, 0xc1, 0xdc, 0xc7, 0x4c, 0x50, 0x74, 0x13, 0xe6, 0xbb, 0x24, 0xe8, 0x50, 0x53, 0xc6, 0x6f,
	0x0d, 0xa5, 0x53, 0x1f, 0x9e, 0xdd, 0x6a, 0x65, 0x4f, 0x82, 0xb0, 0xc6, 0xca, 0x76, 0x90, 0x70,
	0x4a, 0x3d, 0xc5, 0x5e, 0xc4, 0xfa, 0xe5, 0x0c, 0xed, 0xe0, 0xb7, 0x16, 0x5c, 0x90, 0x6a, 0xf6,
	0x7c, 0x7a, 0x84, 0x6e, 0xe7, 0x15, 0x7d, 0xfb, 0x54, 0x45, 0xd2, 0xe2, 0x74, 0x55, 0x77, 0x87,
	0x55, 0xd9, 0xa7, 0xab, 0x52, 0x8c, 0x99, 0xb2, 0x1b, 0xb0, 0x2c, 0x85, 0xd5, 0xfd, 0xb8, 0x4d,
	0x13, 0x41, 0x8f, 0x55, 0x2b, 0xf4, 0xa3, 0x88, 0x26, 0x4a, 0x5e, 0x11, 0xeb, 0x17, 0xfb, 0x9f,
	0x16, 0x2c, 0x49, 0x60, 0x83, 0xf4, 0x02, 0x46, 0x3c, 0xd4, 0x80, 0x4b, 0x11, 0x93, 0xc5, 0x67,
	0x61, 0xe8, 0x8b, 0x90, 0x66, 0xfd, 0xf6, 0xed, 0x01, 0xef, 0xea, 0x18, 0xae, 0xc8, 0xf3, 0x57,
	0x9e, 0x1c, 0xb2, 0xf8, 0xf5, 0x0c, 0x8e, 0x97, 0xa5, 0x7d, 0xff, 0x1d, 0x7d, 0x07, 0x4a, 0x34,
	0x6e, 0xd3, 0x90, 0x26, 0x24, 0x70, 0x0e, 0x69, 0xcf, 0x44, 0x59, 0xcc, 0x06, 0x77, 0x68, 0x0f,
	0x39, 0xb0, 0x4c, 0x23, 0xc5, 0x4b, 0x3d, 0x47, 0x12, 0x98, 0x98, 0x3f, 0x9c, 0x7c, 0x97, 0xe4,
	0xc3, 0xc5, 0xa5, 0x8c, 0x4f, 0x4e, 0xd8, 0xd7, 0xa1, 0xf4, 0x62, 0xe7, 0x71, 0x47, 0xc4, 0x1d,
	0xd1, 0x48, 0x18, 0x6b, 0x8d, 0x49, 0xc7, 0x5b, 0x50, 0x7c, 0xb1, 0xb3, 0x1b, 0xd3, 0xc8, 0x3b,
	0x0d, 0xb5, 0x01, 0xe5, 0x17, 0x3b, 0x1f, 0x77, 0x82, 0xc0, 0x6f, 0xf9, 0x34, 0xb9, 0x47, 0x13,
	0xbf, 0xab, 0x0e, 0xa9, 0xd3, 0x6c, 0xfe, 0x6d, 0xc1, 0xbc, 0x22, 0x46, 0x0f, 0x60, 0xae, 0xc9,
	0xbc, 0x9e, 0xc9, 0xeb, 0xcd, 0x29, 0xce, 0x68, 0x69, 0x5e, 0x63, 0x5e, 0x0f, 0x2b, 0x02, 0xf4,
	0x18, 0x2e, 0x90, 0x8e, 0x68, 0x3b, 0xdc, 0x3f, 0x30, 0x4d, 0xe5, 0xd6, 0x48, 0x91, 0xf2, 0x17,
	0xaa, 0x94, 0x64, 0xab, 0x23, 0xda, 0xbb, 0xfe, 0x41, 0x44, 0x44, 0x27, 0xa1, 0x78, 0x91, 0xe8,
	0x57, 0xf4, 0x43, 0x98, 0x8f, 0x65, 0x08, 0x26, 0xf9, 0x1f, 0x4c, 0x2e, 0x6d, 0x30, 0x69, 0x58,
	0x93, 0xd8, 0x4f, 0x01, 0x3e, 0xea, 0xd2, 0x48, 0xa4, 0x51, 0x5f, 0x8c, 0xd2, 0x8c, 0x99, 0xd0,
	0xdf, 0x19, 0xcf, 0xaf, 0x97, 0x56, 0x96, 0x62, 0xdc, 0xb7, 0xb5, 0x1d, 0x58, 0x52, 0xb4, 0xba,
	0x98, 0xe7, 0xbf, 0x60, 0xed, 0x5f, 0x58, 0x80, 0x94, 0x87, 0x5a, 0xc2, 0x88, 0xe7, 0x12, 0x2e,
	0x64, 0xb3, 0x43, 0xdf, 0x83, 0x39, 0xb7, 0xbf, 0xbb, 0xaf, 0x8f, 0xcf, 0xb4, 0xbc, 0xef, 0x76,
	0xab, 0x15, 0x69, 0x84, 0x95, 0x09, 0xfa, 0x00, 0x0a, 0xe2, 0xd8, 0x94, 0xe8, 0xc6, 0x50, 0xd0,
	0xe6, 0x52, 0xdd, 0xad, 0x56, 0x9e, 0x24, 0x24, 0xe2, 0x44, 0x9d, 0x6f, 0x0f, 0x3d, 0x5c, 0x10,
	0xc7, 0xf6, 0x7f, 0x2c, 0xb8, 0x98, 0x15, 0x1d, 0x3d, 0x07, 0xd4, 0x24, 0x01, 0x89, 0xdc, 0x13,
	0x82, 0x7d, 0x67, 0x5c, 0xb3, 0xa9, 0x69, 0x8b, 0x81, 0x70, 0x2f, 0x37, 0x87, 0x87, 0xf2, 0xb5,
	0x59, 0x78, 0xfd, 0xda, 0xa0, 0xfb, 0x50, 0x48, 0x0e, 0x57, 0xe6, 0x46, 0x56, 0xcf, 0x69, 0x6b,
	0x71, 0x8f, 0x26, 0x7e, 0xcb, 0xd7, 0xb7, 0xbc, 0x1d, 0xda, 0xc3, 0x85, 0xe4, 0xd0, 0xfe, 0xe3,
	0xac, 0x09, 0x5c, 0x35, 0xd6, 0x67, 0xb0, 0xd8, 0xf5, 0xb9, 0xdf, 0x0c, 0xd2, 0xe4, 0xdf, 0x99,
	0x72, 0xcf, 0x48, 0x96, 0xca, 0x9e, 0xa6, 0xd8, 0x9e, 0xc1, 0x29, 0x1b, 0x7a, 0x02, 0x0b, 0x2c,
	0x26, 0x9f, 0x74, 0xa8, 0xa9, 0xcd, 0xe6, 0xeb, 0xf0, 0x3e, 0x56, 0x0c, 0xdb, 0x33, 0xd8, 0x70,
	0x95, 0x7f, 0x67, 0xc1, 0xa2, 0x71, 0x86, 0x3e, 0x82, 0x79, 0x2e, 0x91, 0x46, 0xf8, 0xfa, 0x94,
	0x0e, 0xb0, 0xb6, 0x46, 0xf7, 0x61, 0x4e, 0x35, 0x45, 0x2d, 0x73, 0x63, 0xba, 0xa6, 0xa8, 0x0e,
	0x06, 0x65, 0x5f, 0x7e, 0x0c, 0x0b, 0x5a, 0xee, 0x39, 0x09, 0xab, 0x15, 0x01, 0xd4, 0x83, 0xd3,
	0xf5, 0xe9, 0x91, 0xfd, 0xf3, 0x82, 0x29, 0x5b, 0x23, 0x20, 0x11, 0xaa, 0x19, 0xd1, 0xda, 0x43,
	0x65, 0x3a, 0xd1, 0x5a, 0x30, 0x2a, 0xc3, 0x85, 0x98, 0x71, 0x5f, 0xae, 0x0d, 0x73, 0x23, 0xc8,
	0xde, 0xd1, 0x2a, 0x40, 0x42, 0x22, 0x8f, 0x85, 0xfe, 0x8f, 0x69, 0xa2, 0x5a, 0x56, 0x11, 0x0f,
	0x8c, 0xc8, 0xeb, 0x87, 0x3a, 0x5f, 0x9d, 0x66, 0xe0, 0x47, 0xf2, 0xae, 0xa3, 0x16, 0x66, 0x11,
	0x97, 0xd4, 0x68, 0xcd, 0x0c, 0xa2, 0x35, 0x78, 0x43, 0xf5, 0xab, 0x0c, 0xe6, 0x24, 0x2b, 0xf3,
	0x0a, 0xb8, 0xac, 0xc6, 0x53, 0x20, 0x3e, 0x01, 0xc9, 0xd5, 0x6e, 0x19, 0x46, 0xee, 0xda, 0x5f,
	0x58, 0xb0, 0x60, 0xfa, 0xd3, 0x76, 0xae, 0xdb, 0xdf, 0x9a, 0x3c, 0x0b, 0xda, 0x7e, 0xa0, 0xdd,
	0x3f, 0x4a, 0xbb, 0x73, 0x61, 0xda, 0xef, 0xd7, 0xdc, 0xc9, 0x97, 0xb6, 0xe7, 0xcf, 0x0a, 0x00,
	0x7d, 0x1f, 0xe8, 0x39, 0x14, 0x55, 0x1f, 0x8d, 0xf5, 0x45, 0xc0, 0xe8, 0x7d, 0x7f, 0xba, 0xaa,
	0x99, 0x5b, 0x04, 0x5e, 0x8a, 0x06, 0xae, 0x14, 0x27, 0xf7, 0xad, 0xc2, 0x39, 0xf4, 0xad, 0x35,
	0x78, 0xe3, 0x28, 0x21, 0x71, 0x4c, 0xe5, 0x97, 0x77, 0xc8, 0xd4, 0xed, 0x42, 0xaf, 0x83, 0x65,
	0x33, 0xfe, 0x88, 0x86, 0x4c, 0xde, 0x2f, 0x6e, 0xc0, 0x25, 0xd6, 0x3d, 0x74, 0x52, 0xb4, 0x04,
	0x9a, 0xc5, 0xc0, 0xba, 0x87, 0xcf, 0xf4, 0xe8, 0x0e, 0xed, 0xd9, 0x3f, 0x9d, 0x4b, 0x93, 0xa2,
	0x3a, 0xcf, 0xf3, 0xe1, 0xce, 0x73, 0x77, 0xda, 0xfa, 0x8d, 0x6b, 0x3d, 0x4f, 0x87, 0x5a, 0xcf,
	0x9d, 0xd7, 0x22, 0x1e, 0xe9, 0x3d, 0x7f, 0x1b, 0xe8, 0x3d, 0xdb, 0xb0, 0xc0, 0x14, 0xd4, 0x68,
	0x7f, 0x6f, 0x5a, 0x17, 0xd8, 0xd8, 0x9f, 0x57, 0xfb, 0x41, 0x35, 0x58, 0x32, 0xcb, 0x2b, 0x2b,
	0xd5, 0xe8, 0x3d, 0x39, 0xbd, 0xd6, 0x9a, 0xe5, 0x23, 0x8f, 0x04, 0x88, 0xb3, 0xe7, 0x32, 0xce,
	0x5a, 0xd8, 0xb9, 0xc5, 0x57, 0x2b, 0xc1, 0x92, 0x7e, 0xd2, 0x6d, 0xec, 0x37, 0xd9, 0xce, 0x50,
	0x7d, 0xec, 0xb5, 0xbe, 0x34, 0xb6, 0xa0, 0xe8, 0x51, 0x2e, 0x9c, 0xf4, 0x0a, 0x5f, 0x98, 0xe8,
	0xc3, 0x62, 0x49, 0xda, 0x98, 0x97, 0xfe, 0x67, 0xc1, 0xec, 0xe0, 0x67, 0xc1, 0xff, 0xb1, 0xab,
	0xed, 0xc1, 0xca, 0x96, 0x0c, 0x56, 0x7e, 0x8c, 0x7a, 0x44, 0x90, 0x5a, 0xef, 0xa1, 0x87, 0xe9,
	0x27, 0x1d, 0xca, 0x05, 0xda, 0x84, 0x0b, 0x2a, 0x11, 0x8e, 0xef, 0x99, 0x58, 0xdf, 0x1c, 0x97,
	0x27, 0xc5, 0xf1, 0xd0, 0xc3, 0x8b, 0x44, 0x3f, 0xd8, 0x1e, 0x7c, 0xfd, 0x04, 0x5e, 0x1e, 0xb3,
	0x88, 0x53, 0xf4, 0x00, 0x96, 0xd5, 0x8f, 0x36, 0xea, 0xb7, 0x35, 0x39, 0x6b, 0xca, 0x70, 0x6d,
	0x1c, 0x7d, 0xca, 0x82, 0x4b, 0xca, 0x2e, 0x7d, 0xb5, 0x9f, 0x9d, 0xe0, 0x85, 0x9f, 0x24, 0xdf,
	0x52, 0x3f, 0x68, 0x4d, 0x2e, 0x9f, 0x42, 0xf9, 0x24, 0xe2, 0x73, 0xd6, 0xbf, 0xf1, 0x97, 0x02,
	0x14, 0x7f, 0xd4, 0xa1, 0x49, 0x6f, 0x97, 0x26, 0x5d, 0xdf, 0xa5, 0xe8, 0x73, 0x0b, 0x2e, 0x8f,
	0x38, 0x46, 0xb5, 0xc9, 0x77, 0xc1, 0xb8, 0x62, 0x96, 0xeb, 0x67, 0xe2, 0x30, 0x81, 0x7f, 0x61,
	0x01, 0x1a, 0xcd, 0x0b, 0x3a, 0x0b, 0x77, 0x5a, 0xae, 0xf2, 0xbd, 0xb3, 0x91, 0x68, 0x85, 0xef,
	0x59, 0xb5, 0x4f, 0x67, 0xff, 0xf4, 0x72, 0xd5, 0xfa, 0xf2, 0xe5, 0xaa, 0xf5, 0xf7, 0x97, 0xab,
	0xd6, 0xaf, 0x5e, 0xad, 0xce, 0x7c, 0xf9, 0x6a, 0x75, 0xe6, 0xaf, 0xaf, 0x56, 0x67, 0xe0, 0xbb,
	0x2e, 0x0b, 0x27, 0xf6, 0x52, 0xbb, 0x9c, 0xfb, 0xfd, 0x34, 0x61, 0x82, 0x35, 0xac, 0x17, 0xde,
	0x81, 0x2f, 0xda, 0x9d, 0xa6, 0xb4, 0x5b, 0x77, 0x19, 0x0f, 0x19, 0x5f, 0x4f, 0x68, 0x40, 0x7a,
	0x34, 0x59, 0xef, 0x6e, 0x64, 0x8f, 0x6e, 0x9b, 0xf8, 0x11, 0x5f, 0x9f, 0xf4, 0x8f, 0x0d, 0x77,
	0x72, 0x03, 0xdd, 0xea, 0xef, 0x0b, 0x73, 0x8d, 0x7a, 0x7d, 0xf7, 0x0f, 0x85, 0xb7, 0x1b, 0xa9,
	0xd8, 0xba, 0x14, 0x5b, 0xcf, 0xc4, 0x0e, 0x4a, 0xab, 0xec, 0x55, 0xff, 0xdc, 0x47, 0xee, 0x4b,
	0xe4, 0x7e, 0x86, 0xdc, 0x1f, 0x44, 0xee, 0xef, 0x55, 0x5f, 0x16, 0x6e, 0x4e, 0x88, 0xdc, 0x7f,
	0xd0, 0xa8, 0xa5, 0x39, 0xfe, 0x57, 0xe1, 0xdd, 0xd4, 0x6a, 0x73, 0x53, 0x9a, 0xc9, 0x7f, 0x8d,
	0xdd, 0xe6, 0xe6, 0xa0, 0xe1, 0xe6, 0xe6, 0x5e, 0xb5, 0xb9, 0xa0, 0x7e, 0xc2, 0xbf, 0xf9, 0xbf,
	0x00, 0x00, 0x00, 0xff, 0xff, 0x43, 0xe1, 0xc9, 0xc2, 0x6e, 0x19, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QueryServiceClient is the client API for QueryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryServiceClient interface {
	AssetMetadataById(ctx context.Context, in *AssetMetadataByIdRequest, opts ...grpc.CallOption) (*AssetMetadataByIdResponse, error)
	// Requests a stream of asset metadata, given an array of asset IDs. Responses
	// may be streamed in a different order from that of the asset IDs in the
	// request, and asset IDs unknown to the node will not receive any response
	// objects -- that is, the number of responses may be smaller than the length
	// of the asset IDs array.
	AssetMetadataByIds(ctx context.Context, in *AssetMetadataByIdsRequest, opts ...grpc.CallOption) (QueryService_AssetMetadataByIdsClient, error)
}

type queryServiceClient struct {
	cc grpc1.ClientConn
}

func NewQueryServiceClient(cc grpc1.ClientConn) QueryServiceClient {
	return &queryServiceClient{cc}
}

func (c *queryServiceClient) AssetMetadataById(ctx context.Context, in *AssetMetadataByIdRequest, opts ...grpc.CallOption) (*AssetMetadataByIdResponse, error) {
	out := new(AssetMetadataByIdResponse)
	err := c.cc.Invoke(ctx, "/penumbra.core.component.shielded_pool.v1.QueryService/AssetMetadataById", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryServiceClient) AssetMetadataByIds(ctx context.Context, in *AssetMetadataByIdsRequest, opts ...grpc.CallOption) (QueryService_AssetMetadataByIdsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_QueryService_serviceDesc.Streams[0], "/penumbra.core.component.shielded_pool.v1.QueryService/AssetMetadataByIds", opts...)
	if err != nil {
		return nil, err
	}
	x := &queryServiceAssetMetadataByIdsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type QueryService_AssetMetadataByIdsClient interface {
	Recv() (*AssetMetadataByIdsResponse, error)
	grpc.ClientStream
}

type queryServiceAssetMetadataByIdsClient struct {
	grpc.ClientStream
}

func (x *queryServiceAssetMetadataByIdsClient) Recv() (*AssetMetadataByIdsResponse, error) {
	m := new(AssetMetadataByIdsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// QueryServiceServer is the server API for QueryService service.
type QueryServiceServer interface {
	AssetMetadataById(context.Context, *AssetMetadataByIdRequest) (*AssetMetadataByIdResponse, error)
	// Requests a stream of asset metadata, given an array of asset IDs. Responses
	// may be streamed in a different order from that of the asset IDs in the
	// request, and asset IDs unknown to the node will not receive any response
	// objects -- that is, the number of responses may be smaller than the length
	// of the asset IDs array.
	AssetMetadataByIds(*AssetMetadataByIdsRequest, QueryService_AssetMetadataByIdsServer) error
}

// UnimplementedQueryServiceServer can be embedded to have forward compatible implementations.
type UnimplementedQueryServiceServer struct {
}

func (*UnimplementedQueryServiceServer) AssetMetadataById(ctx context.Context, req *AssetMetadataByIdRequest) (*AssetMetadataByIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AssetMetadataById not implemented")
}
func (*UnimplementedQueryServiceServer) AssetMetadataByIds(req *AssetMetadataByIdsRequest, srv QueryService_AssetMetadataByIdsServer) error {
	return status.Errorf(codes.Unimplemented, "method AssetMetadataByIds not implemented")
}

func RegisterQueryServiceServer(s grpc1.Server, srv QueryServiceServer) {
	s.RegisterService(&_QueryService_serviceDesc, srv)
}

func _QueryService_AssetMetadataById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssetMetadataByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServiceServer).AssetMetadataById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/penumbra.core.component.shielded_pool.v1.QueryService/AssetMetadataById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServiceServer).AssetMetadataById(ctx, req.(*AssetMetadataByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueryService_AssetMetadataByIds_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AssetMetadataByIdsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryServiceServer).AssetMetadataByIds(m, &queryServiceAssetMetadataByIdsServer{stream})
}

type QueryService_AssetMetadataByIdsServer interface {
	Send(*AssetMetadataByIdsResponse) error
	grpc.ServerStream
}

type queryServiceAssetMetadataByIdsServer struct {
	grpc.ServerStream
}

func (x *queryServiceAssetMetadataByIdsServer) Send(m *AssetMetadataByIdsResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _QueryService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "penumbra.core.component.shielded_pool.v1.QueryService",
	HandlerType: (*QueryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AssetMetadataById",
			Handler:    _QueryService_AssetMetadataById_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "AssetMetadataByIds",
			Handler:       _QueryService_AssetMetadataByIds_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "penumbra/core/component/shielded_pool/v1/shielded_pool.proto",
}

func (m *ShieldedPoolParameters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShieldedPoolParameters) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShieldedPoolParameters) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FmdMetaParams != nil {
		{
			size, err := m.FmdMetaParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.FixedFmdParams != nil {
		{
			size, err := m.FixedFmdParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GenesisContent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenesisContent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenesisContent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Allocations) > 0 {
		for iNdEx := len(m.Allocations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Allocations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintShieldedPool(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.ShieldedPoolParams != nil {
		{
			size, err := m.ShieldedPoolParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GenesisContent_Allocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenesisContent_Allocation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenesisContent_Allocation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Address != nil {
		{
			size, err := m.Address.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintShieldedPool(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x12
	}
	if m.Amount != nil {
		{
			size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FmdMetaParameters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FmdMetaParameters) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FmdMetaParameters) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Algorithm != nil {
		{
			size := m.Algorithm.Size()
			i -= size
			if _, err := m.Algorithm.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.FmdGracePeriodBlocks != 0 {
		i = encodeVarintShieldedPool(dAtA, i, uint64(m.FmdGracePeriodBlocks))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FmdMetaParameters_FixedPrecisionBits) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FmdMetaParameters_FixedPrecisionBits) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintShieldedPool(dAtA, i, uint64(m.FixedPrecisionBits))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *FmdMetaParameters_SlidingWindow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FmdMetaParameters_SlidingWindow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SlidingWindow != nil {
		{
			size, err := m.SlidingWindow.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *FmdMetaParameters_AlgorithmSlidingWindow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FmdMetaParameters_AlgorithmSlidingWindow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FmdMetaParameters_AlgorithmSlidingWindow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TargetedDetectionsPerWindow != 0 {
		i = encodeVarintShieldedPool(dAtA, i, uint64(m.TargetedDetectionsPerWindow))
		i--
		dAtA[i] = 0x10
	}
	if m.WindowUpdatePeriods != 0 {
		i = encodeVarintShieldedPool(dAtA, i, uint64(m.WindowUpdatePeriods))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FmdMetaParametersAlgorithmState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FmdMetaParametersAlgorithmState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FmdMetaParametersAlgorithmState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != nil {
		{
			size := m.State.Size()
			i -= size
			if _, err := m.State.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *FmdMetaParametersAlgorithmState_Fixed) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FmdMetaParametersAlgorithmState_Fixed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Fixed != nil {
		{
			size, err := m.Fixed.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *FmdMetaParametersAlgorithmState_SlidingWindow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FmdMetaParametersAlgorithmState_SlidingWindow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SlidingWindow != nil {
		{
			size, err := m.SlidingWindow.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *FmdMetaParametersAlgorithmState_FixedState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FmdMetaParametersAlgorithmState_FixedState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FmdMetaParametersAlgorithmState_FixedState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *FmdMetaParametersAlgorithmState_SlidingWindowState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FmdMetaParametersAlgorithmState_SlidingWindowState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FmdMetaParametersAlgorithmState_SlidingWindowState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ApproximateClueCount != 0 {
		i = encodeVarintShieldedPool(dAtA, i, uint64(m.ApproximateClueCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FmdParameters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FmdParameters) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FmdParameters) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AsOfBlockHeight != 0 {
		i = encodeVarintShieldedPool(dAtA, i, uint64(m.AsOfBlockHeight))
		i--
		dAtA[i] = 0x10
	}
	if m.PrecisionBits != 0 {
		i = encodeVarintShieldedPool(dAtA, i, uint64(m.PrecisionBits))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Note) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Note) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Note) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Address != nil {
		{
			size, err := m.Address.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Rseed) > 0 {
		i -= len(m.Rseed)
		copy(dAtA[i:], m.Rseed)
		i = encodeVarintShieldedPool(dAtA, i, uint64(len(m.Rseed)))
		i--
		dAtA[i] = 0x12
	}
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NoteView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NoteView) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NoteView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Address != nil {
		{
			size, err := m.Address.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Rseed) > 0 {
		i -= len(m.Rseed)
		copy(dAtA[i:], m.Rseed)
		i = encodeVarintShieldedPool(dAtA, i, uint64(len(m.Rseed)))
		i--
		dAtA[i] = 0x12
	}
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NoteCiphertext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NoteCiphertext) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NoteCiphertext) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Inner) > 0 {
		i -= len(m.Inner)
		copy(dAtA[i:], m.Inner)
		i = encodeVarintShieldedPool(dAtA, i, uint64(len(m.Inner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NotePayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NotePayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NotePayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EncryptedNote != nil {
		{
			size, err := m.EncryptedNote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.EphemeralKey) > 0 {
		i -= len(m.EphemeralKey)
		copy(dAtA[i:], m.EphemeralKey)
		i = encodeVarintShieldedPool(dAtA, i, uint64(len(m.EphemeralKey)))
		i--
		dAtA[i] = 0x12
	}
	if m.NoteCommitment != nil {
		{
			size, err := m.NoteCommitment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ZKOutputProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZKOutputProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZKOutputProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Inner) > 0 {
		i -= len(m.Inner)
		copy(dAtA[i:], m.Inner)
		i = encodeVarintShieldedPool(dAtA, i, uint64(len(m.Inner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ZKSpendProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZKSpendProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZKSpendProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Inner) > 0 {
		i -= len(m.Inner)
		copy(dAtA[i:], m.Inner)
		i = encodeVarintShieldedPool(dAtA, i, uint64(len(m.Inner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ZKNullifierDerivationProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZKNullifierDerivationProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZKNullifierDerivationProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Inner) > 0 {
		i -= len(m.Inner)
		copy(dAtA[i:], m.Inner)
		i = encodeVarintShieldedPool(dAtA, i, uint64(len(m.Inner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Spend) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Spend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Spend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Proof != nil {
		{
			size, err := m.Proof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.AuthSig != nil {
		{
			size, err := m.AuthSig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Body != nil {
		{
			size, err := m.Body.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSpend) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSpend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSpend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Nullifier != nil {
		{
			size, err := m.Nullifier.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NoteCommitment != nil {
		{
			size, err := m.NoteCommitment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventBroadcastClue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventBroadcastClue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventBroadcastClue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Tx != nil {
		{
			size, err := m.Tx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Clue != nil {
		{
			size, err := m.Clue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpendBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpendBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpendBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Nullifier != nil {
		{
			size, err := m.Nullifier.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Rk != nil {
		{
			size, err := m.Rk.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.BalanceCommitment != nil {
		{
			size, err := m.BalanceCommitment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpendView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpendView) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpendView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SpendView != nil {
		{
			size := m.SpendView.Size()
			i -= size
			if _, err := m.SpendView.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *SpendView_Visible_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpendView_Visible_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Visible != nil {
		{
			size, err := m.Visible.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *SpendView_Opaque_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpendView_Opaque_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Opaque != nil {
		{
			size, err := m.Opaque.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *SpendView_Visible) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpendView_Visible) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpendView_Visible) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Note != nil {
		{
			size, err := m.Note.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Spend != nil {
		{
			size, err := m.Spend.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpendView_Opaque) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpendView_Opaque) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpendView_Opaque) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Spend != nil {
		{
			size, err := m.Spend.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpendPlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpendPlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpendPlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProofBlindingS) > 0 {
		i -= len(m.ProofBlindingS)
		copy(dAtA[i:], m.ProofBlindingS)
		i = encodeVarintShieldedPool(dAtA, i, uint64(len(m.ProofBlindingS)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ProofBlindingR) > 0 {
		i -= len(m.ProofBlindingR)
		copy(dAtA[i:], m.ProofBlindingR)
		i = encodeVarintShieldedPool(dAtA, i, uint64(len(m.ProofBlindingR)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ValueBlinding) > 0 {
		i -= len(m.ValueBlinding)
		copy(dAtA[i:], m.ValueBlinding)
		i = encodeVarintShieldedPool(dAtA, i, uint64(len(m.ValueBlinding)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Randomizer) > 0 {
		i -= len(m.Randomizer)
		copy(dAtA[i:], m.Randomizer)
		i = encodeVarintShieldedPool(dAtA, i, uint64(len(m.Randomizer)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Position != 0 {
		i = encodeVarintShieldedPool(dAtA, i, uint64(m.Position))
		i--
		dAtA[i] = 0x10
	}
	if m.Note != nil {
		{
			size, err := m.Note.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Output) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Output) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Output) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Proof != nil {
		{
			size, err := m.Proof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Body != nil {
		{
			size, err := m.Body.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OutputBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OutputBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutputBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OvkWrappedKey) > 0 {
		i -= len(m.OvkWrappedKey)
		copy(dAtA[i:], m.OvkWrappedKey)
		i = encodeVarintShieldedPool(dAtA, i, uint64(len(m.OvkWrappedKey)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.WrappedMemoKey) > 0 {
		i -= len(m.WrappedMemoKey)
		copy(dAtA[i:], m.WrappedMemoKey)
		i = encodeVarintShieldedPool(dAtA, i, uint64(len(m.WrappedMemoKey)))
		i--
		dAtA[i] = 0x1a
	}
	if m.BalanceCommitment != nil {
		{
			size, err := m.BalanceCommitment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.NotePayload != nil {
		{
			size, err := m.NotePayload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OutputView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OutputView) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutputView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OutputView != nil {
		{
			size := m.OutputView.Size()
			i -= size
			if _, err := m.OutputView.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *OutputView_Visible_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutputView_Visible_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Visible != nil {
		{
			size, err := m.Visible.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *OutputView_Opaque_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutputView_Opaque_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Opaque != nil {
		{
			size, err := m.Opaque.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *OutputView_Visible) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OutputView_Visible) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutputView_Visible) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PayloadKey != nil {
		{
			size, err := m.PayloadKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Note != nil {
		{
			size, err := m.Note.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Output != nil {
		{
			size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OutputView_Opaque) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OutputView_Opaque) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutputView_Opaque) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Output != nil {
		{
			size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OutputPlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OutputPlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutputPlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProofBlindingS) > 0 {
		i -= len(m.ProofBlindingS)
		copy(dAtA[i:], m.ProofBlindingS)
		i = encodeVarintShieldedPool(dAtA, i, uint64(len(m.ProofBlindingS)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ProofBlindingR) > 0 {
		i -= len(m.ProofBlindingR)
		copy(dAtA[i:], m.ProofBlindingR)
		i = encodeVarintShieldedPool(dAtA, i, uint64(len(m.ProofBlindingR)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ValueBlinding) > 0 {
		i -= len(m.ValueBlinding)
		copy(dAtA[i:], m.ValueBlinding)
		i = encodeVarintShieldedPool(dAtA, i, uint64(len(m.ValueBlinding)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Rseed) > 0 {
		i -= len(m.Rseed)
		copy(dAtA[i:], m.Rseed)
		i = encodeVarintShieldedPool(dAtA, i, uint64(len(m.Rseed)))
		i--
		dAtA[i] = 0x1a
	}
	if m.DestAddress != nil {
		{
			size, err := m.DestAddress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AssetMetadataByIdRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AssetMetadataByIdRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AssetMetadataByIdRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AssetId != nil {
		{
			size, err := m.AssetId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *AssetMetadataByIdResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AssetMetadataByIdResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AssetMetadataByIdResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DenomMetadata != nil {
		{
			size, err := m.DenomMetadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AssetMetadataByIdsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AssetMetadataByIdsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AssetMetadataByIdsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AssetId) > 0 {
		for iNdEx := len(m.AssetId) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AssetId[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintShieldedPool(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AssetMetadataByIdsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AssetMetadataByIdsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AssetMetadataByIdsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DenomMetadata != nil {
		{
			size, err := m.DenomMetadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintShieldedPool(dAtA []byte, offset int, v uint64) int {
	offset -= sovShieldedPool(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ShieldedPoolParameters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FixedFmdParams != nil {
		l = m.FixedFmdParams.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	if m.FmdMetaParams != nil {
		l = m.FmdMetaParams.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func (m *GenesisContent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShieldedPoolParams != nil {
		l = m.ShieldedPoolParams.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	if len(m.Allocations) > 0 {
		for _, e := range m.Allocations {
			l = e.Size()
			n += 1 + l + sovShieldedPool(uint64(l))
		}
	}
	return n
}

func (m *GenesisContent_Allocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Amount != nil {
		l = m.Amount.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	if m.Address != nil {
		l = m.Address.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func (m *FmdMetaParameters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FmdGracePeriodBlocks != 0 {
		n += 1 + sovShieldedPool(uint64(m.FmdGracePeriodBlocks))
	}
	if m.Algorithm != nil {
		n += m.Algorithm.Size()
	}
	return n
}

func (m *FmdMetaParameters_FixedPrecisionBits) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovShieldedPool(uint64(m.FixedPrecisionBits))
	return n
}
func (m *FmdMetaParameters_SlidingWindow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SlidingWindow != nil {
		l = m.SlidingWindow.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}
func (m *FmdMetaParameters_AlgorithmSlidingWindow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WindowUpdatePeriods != 0 {
		n += 1 + sovShieldedPool(uint64(m.WindowUpdatePeriods))
	}
	if m.TargetedDetectionsPerWindow != 0 {
		n += 1 + sovShieldedPool(uint64(m.TargetedDetectionsPerWindow))
	}
	return n
}

func (m *FmdMetaParametersAlgorithmState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != nil {
		n += m.State.Size()
	}
	return n
}

func (m *FmdMetaParametersAlgorithmState_Fixed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Fixed != nil {
		l = m.Fixed.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}
func (m *FmdMetaParametersAlgorithmState_SlidingWindow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SlidingWindow != nil {
		l = m.SlidingWindow.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}
func (m *FmdMetaParametersAlgorithmState_FixedState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *FmdMetaParametersAlgorithmState_SlidingWindowState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApproximateClueCount != 0 {
		n += 1 + sovShieldedPool(uint64(m.ApproximateClueCount))
	}
	return n
}

func (m *FmdParameters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PrecisionBits != 0 {
		n += 1 + sovShieldedPool(uint64(m.PrecisionBits))
	}
	if m.AsOfBlockHeight != 0 {
		n += 1 + sovShieldedPool(uint64(m.AsOfBlockHeight))
	}
	return n
}

func (m *Note) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	l = len(m.Rseed)
	if l > 0 {
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	if m.Address != nil {
		l = m.Address.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func (m *NoteView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	l = len(m.Rseed)
	if l > 0 {
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	if m.Address != nil {
		l = m.Address.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func (m *NoteCiphertext) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Inner)
	if l > 0 {
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func (m *NotePayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoteCommitment != nil {
		l = m.NoteCommitment.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	l = len(m.EphemeralKey)
	if l > 0 {
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	if m.EncryptedNote != nil {
		l = m.EncryptedNote.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func (m *ZKOutputProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Inner)
	if l > 0 {
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func (m *ZKSpendProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Inner)
	if l > 0 {
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func (m *ZKNullifierDerivationProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Inner)
	if l > 0 {
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func (m *Spend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Body != nil {
		l = m.Body.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	if m.AuthSig != nil {
		l = m.AuthSig.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	if m.Proof != nil {
		l = m.Proof.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func (m *EventSpend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nullifier != nil {
		l = m.Nullifier.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func (m *EventOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoteCommitment != nil {
		l = m.NoteCommitment.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func (m *EventBroadcastClue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Clue != nil {
		l = m.Clue.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	if m.Tx != nil {
		l = m.Tx.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func (m *SpendBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BalanceCommitment != nil {
		l = m.BalanceCommitment.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	if m.Rk != nil {
		l = m.Rk.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	if m.Nullifier != nil {
		l = m.Nullifier.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func (m *SpendView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SpendView != nil {
		n += m.SpendView.Size()
	}
	return n
}

func (m *SpendView_Visible_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Visible != nil {
		l = m.Visible.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}
func (m *SpendView_Opaque_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Opaque != nil {
		l = m.Opaque.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}
func (m *SpendView_Visible) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spend != nil {
		l = m.Spend.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	if m.Note != nil {
		l = m.Note.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func (m *SpendView_Opaque) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spend != nil {
		l = m.Spend.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func (m *SpendPlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Note != nil {
		l = m.Note.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	if m.Position != 0 {
		n += 1 + sovShieldedPool(uint64(m.Position))
	}
	l = len(m.Randomizer)
	if l > 0 {
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	l = len(m.ValueBlinding)
	if l > 0 {
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	l = len(m.ProofBlindingR)
	if l > 0 {
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	l = len(m.ProofBlindingS)
	if l > 0 {
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func (m *Output) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Body != nil {
		l = m.Body.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	if m.Proof != nil {
		l = m.Proof.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func (m *OutputBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NotePayload != nil {
		l = m.NotePayload.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	if m.BalanceCommitment != nil {
		l = m.BalanceCommitment.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	l = len(m.WrappedMemoKey)
	if l > 0 {
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	l = len(m.OvkWrappedKey)
	if l > 0 {
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func (m *OutputView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OutputView != nil {
		n += m.OutputView.Size()
	}
	return n
}

func (m *OutputView_Visible_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Visible != nil {
		l = m.Visible.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}
func (m *OutputView_Opaque_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Opaque != nil {
		l = m.Opaque.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}
func (m *OutputView_Visible) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Output != nil {
		l = m.Output.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	if m.Note != nil {
		l = m.Note.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	if m.PayloadKey != nil {
		l = m.PayloadKey.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func (m *OutputView_Opaque) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Output != nil {
		l = m.Output.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func (m *OutputPlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	if m.DestAddress != nil {
		l = m.DestAddress.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	l = len(m.Rseed)
	if l > 0 {
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	l = len(m.ValueBlinding)
	if l > 0 {
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	l = len(m.ProofBlindingR)
	if l > 0 {
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	l = len(m.ProofBlindingS)
	if l > 0 {
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func (m *AssetMetadataByIdRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AssetId != nil {
		l = m.AssetId.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func (m *AssetMetadataByIdResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DenomMetadata != nil {
		l = m.DenomMetadata.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func (m *AssetMetadataByIdsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AssetId) > 0 {
		for _, e := range m.AssetId {
			l = e.Size()
			n += 1 + l + sovShieldedPool(uint64(l))
		}
	}
	return n
}

func (m *AssetMetadataByIdsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DenomMetadata != nil {
		l = m.DenomMetadata.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func sovShieldedPool(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozShieldedPool(x uint64) (n int) {
	return sovShieldedPool(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ShieldedPoolParameters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShieldedPoolParameters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShieldedPoolParameters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FixedFmdParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FixedFmdParams == nil {
				m.FixedFmdParams = &FmdParameters{}
			}
			if err := m.FixedFmdParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FmdMetaParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FmdMetaParams == nil {
				m.FmdMetaParams = &FmdMetaParameters{}
			}
			if err := m.FmdMetaParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenesisContent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenesisContent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenesisContent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShieldedPoolParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShieldedPoolParams == nil {
				m.ShieldedPoolParams = &ShieldedPoolParameters{}
			}
			if err := m.ShieldedPoolParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Allocations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Allocations = append(m.Allocations, &GenesisContent_Allocation{})
			if err := m.Allocations[len(m.Allocations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenesisContent_Allocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Allocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Allocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Amount == nil {
				m.Amount = &v1.Amount{}
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Address == nil {
				m.Address = &v11.Address{}
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FmdMetaParameters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FmdMetaParameters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FmdMetaParameters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FmdGracePeriodBlocks", wireType)
			}
			m.FmdGracePeriodBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FmdGracePeriodBlocks |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FixedPrecisionBits", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Algorithm = &FmdMetaParameters_FixedPrecisionBits{v}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlidingWindow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FmdMetaParameters_AlgorithmSlidingWindow{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Algorithm = &FmdMetaParameters_SlidingWindow{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FmdMetaParameters_AlgorithmSlidingWindow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlgorithmSlidingWindow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlgorithmSlidingWindow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowUpdatePeriods", wireType)
			}
			m.WindowUpdatePeriods = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WindowUpdatePeriods |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetedDetectionsPerWindow", wireType)
			}
			m.TargetedDetectionsPerWindow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetedDetectionsPerWindow |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FmdMetaParametersAlgorithmState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FmdMetaParametersAlgorithmState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FmdMetaParametersAlgorithmState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fixed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FmdMetaParametersAlgorithmState_FixedState{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.State = &FmdMetaParametersAlgorithmState_Fixed{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlidingWindow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FmdMetaParametersAlgorithmState_SlidingWindowState{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.State = &FmdMetaParametersAlgorithmState_SlidingWindow{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FmdMetaParametersAlgorithmState_FixedState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FixedState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FixedState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FmdMetaParametersAlgorithmState_SlidingWindowState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SlidingWindowState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SlidingWindowState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApproximateClueCount", wireType)
			}
			m.ApproximateClueCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApproximateClueCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FmdParameters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FmdParameters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FmdParameters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrecisionBits", wireType)
			}
			m.PrecisionBits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrecisionBits |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsOfBlockHeight", wireType)
			}
			m.AsOfBlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AsOfBlockHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Note) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Note: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Note: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &v12.Value{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rseed", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rseed = append(m.Rseed[:0], dAtA[iNdEx:postIndex]...)
			if m.Rseed == nil {
				m.Rseed = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Address == nil {
				m.Address = &v11.Address{}
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NoteView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NoteView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NoteView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &v12.ValueView{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rseed", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rseed = append(m.Rseed[:0], dAtA[iNdEx:postIndex]...)
			if m.Rseed == nil {
				m.Rseed = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Address == nil {
				m.Address = &v11.AddressView{}
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NoteCiphertext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NoteCiphertext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NoteCiphertext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inner = append(m.Inner[:0], dAtA[iNdEx:postIndex]...)
			if m.Inner == nil {
				m.Inner = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NotePayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotePayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotePayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoteCommitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NoteCommitment == nil {
				m.NoteCommitment = &v13.StateCommitment{}
			}
			if err := m.NoteCommitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EphemeralKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EphemeralKey = append(m.EphemeralKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EphemeralKey == nil {
				m.EphemeralKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedNote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EncryptedNote == nil {
				m.EncryptedNote = &NoteCiphertext{}
			}
			if err := m.EncryptedNote.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZKOutputProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZKOutputProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZKOutputProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inner = append(m.Inner[:0], dAtA[iNdEx:postIndex]...)
			if m.Inner == nil {
				m.Inner = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZKSpendProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZKSpendProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZKSpendProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inner = append(m.Inner[:0], dAtA[iNdEx:postIndex]...)
			if m.Inner == nil {
				m.Inner = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZKNullifierDerivationProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZKNullifierDerivationProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZKNullifierDerivationProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inner = append(m.Inner[:0], dAtA[iNdEx:postIndex]...)
			if m.Inner == nil {
				m.Inner = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Spend) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Spend: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Spend: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Body == nil {
				m.Body = &SpendBody{}
			}
			if err := m.Body.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthSig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuthSig == nil {
				m.AuthSig = &v14.SpendAuthSignature{}
			}
			if err := m.AuthSig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proof == nil {
				m.Proof = &ZKSpendProof{}
			}
			if err := m.Proof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSpend) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSpend: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSpend: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nullifier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Nullifier == nil {
				m.Nullifier = &v15.Nullifier{}
			}
			if err := m.Nullifier.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoteCommitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NoteCommitment == nil {
				m.NoteCommitment = &v13.StateCommitment{}
			}
			if err := m.NoteCommitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventBroadcastClue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventBroadcastClue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventBroadcastClue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Clue == nil {
				m.Clue = &v16.Clue{}
			}
			if err := m.Clue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tx == nil {
				m.Tx = &v17.TransactionId{}
			}
			if err := m.Tx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpendBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpendBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpendBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BalanceCommitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BalanceCommitment == nil {
				m.BalanceCommitment = &v12.BalanceCommitment{}
			}
			if err := m.BalanceCommitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rk == nil {
				m.Rk = &v14.SpendVerificationKey{}
			}
			if err := m.Rk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nullifier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Nullifier == nil {
				m.Nullifier = &v15.Nullifier{}
			}
			if err := m.Nullifier.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpendView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpendView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpendView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visible", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SpendView_Visible{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SpendView = &SpendView_Visible_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opaque", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SpendView_Opaque{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SpendView = &SpendView_Opaque_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpendView_Visible) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Visible: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Visible: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spend == nil {
				m.Spend = &Spend{}
			}
			if err := m.Spend.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Note", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Note == nil {
				m.Note = &NoteView{}
			}
			if err := m.Note.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpendView_Opaque) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Opaque: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Opaque: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spend == nil {
				m.Spend = &Spend{}
			}
			if err := m.Spend.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpendPlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpendPlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpendPlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Note", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Note == nil {
				m.Note = &Note{}
			}
			if err := m.Note.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			m.Position = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Position |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Randomizer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Randomizer = append(m.Randomizer[:0], dAtA[iNdEx:postIndex]...)
			if m.Randomizer == nil {
				m.Randomizer = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueBlinding", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueBlinding = append(m.ValueBlinding[:0], dAtA[iNdEx:postIndex]...)
			if m.ValueBlinding == nil {
				m.ValueBlinding = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofBlindingR", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofBlindingR = append(m.ProofBlindingR[:0], dAtA[iNdEx:postIndex]...)
			if m.ProofBlindingR == nil {
				m.ProofBlindingR = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofBlindingS", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofBlindingS = append(m.ProofBlindingS[:0], dAtA[iNdEx:postIndex]...)
			if m.ProofBlindingS == nil {
				m.ProofBlindingS = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Output) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Output: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Output: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Body == nil {
				m.Body = &OutputBody{}
			}
			if err := m.Body.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proof == nil {
				m.Proof = &ZKOutputProof{}
			}
			if err := m.Proof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutputBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OutputBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OutputBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotePayload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NotePayload == nil {
				m.NotePayload = &NotePayload{}
			}
			if err := m.NotePayload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BalanceCommitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BalanceCommitment == nil {
				m.BalanceCommitment = &v12.BalanceCommitment{}
			}
			if err := m.BalanceCommitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WrappedMemoKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WrappedMemoKey = append(m.WrappedMemoKey[:0], dAtA[iNdEx:postIndex]...)
			if m.WrappedMemoKey == nil {
				m.WrappedMemoKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OvkWrappedKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OvkWrappedKey = append(m.OvkWrappedKey[:0], dAtA[iNdEx:postIndex]...)
			if m.OvkWrappedKey == nil {
				m.OvkWrappedKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutputView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OutputView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OutputView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visible", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OutputView_Visible{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.OutputView = &OutputView_Visible_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opaque", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OutputView_Opaque{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.OutputView = &OutputView_Opaque_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutputView_Visible) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Visible: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Visible: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output == nil {
				m.Output = &Output{}
			}
			if err := m.Output.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Note", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Note == nil {
				m.Note = &NoteView{}
			}
			if err := m.Note.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PayloadKey == nil {
				m.PayloadKey = &v11.PayloadKey{}
			}
			if err := m.PayloadKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutputView_Opaque) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Opaque: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Opaque: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output == nil {
				m.Output = &Output{}
			}
			if err := m.Output.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutputPlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OutputPlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OutputPlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &v12.Value{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DestAddress == nil {
				m.DestAddress = &v11.Address{}
			}
			if err := m.DestAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rseed", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rseed = append(m.Rseed[:0], dAtA[iNdEx:postIndex]...)
			if m.Rseed == nil {
				m.Rseed = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueBlinding", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueBlinding = append(m.ValueBlinding[:0], dAtA[iNdEx:postIndex]...)
			if m.ValueBlinding == nil {
				m.ValueBlinding = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofBlindingR", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofBlindingR = append(m.ProofBlindingR[:0], dAtA[iNdEx:postIndex]...)
			if m.ProofBlindingR == nil {
				m.ProofBlindingR = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofBlindingS", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofBlindingS = append(m.ProofBlindingS[:0], dAtA[iNdEx:postIndex]...)
			if m.ProofBlindingS == nil {
				m.ProofBlindingS = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AssetMetadataByIdRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssetMetadataByIdRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssetMetadataByIdRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AssetId == nil {
				m.AssetId = &v12.AssetId{}
			}
			if err := m.AssetId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AssetMetadataByIdResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssetMetadataByIdResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssetMetadataByIdResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenomMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DenomMetadata == nil {
				m.DenomMetadata = &v12.Metadata{}
			}
			if err := m.DenomMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AssetMetadataByIdsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssetMetadataByIdsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssetMetadataByIdsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetId = append(m.AssetId, &v12.AssetId{})
			if err := m.AssetId[len(m.AssetId)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AssetMetadataByIdsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssetMetadataByIdsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssetMetadataByIdsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenomMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DenomMetadata == nil {
				m.DenomMetadata = &v12.Metadata{}
			}
			if err := m.DenomMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipShieldedPool(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthShieldedPool
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupShieldedPool
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthShieldedPool
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthShieldedPool        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowShieldedPool          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupShieldedPool = fmt.Errorf("proto: unexpected end of group")
)
