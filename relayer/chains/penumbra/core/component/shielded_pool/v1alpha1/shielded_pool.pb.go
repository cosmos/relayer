// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: penumbra/core/component/shielded_pool/v1alpha1/shielded_pool.proto

package shielded_poolv1alpha1

import (
	context "context"
	fmt "fmt"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	v1alpha1 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/asset/v1alpha1"
	v1alpha11 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/keys/v1alpha1"
	v1alpha14 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/num/v1alpha1"
	v1alpha13 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/crypto/decaf377_rdsa/v1alpha1"
	v1alpha12 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/crypto/tct/v1alpha1"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Note struct {
	Value   *v1alpha1.Value    `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	Rseed   []byte             `protobuf:"bytes,2,opt,name=rseed,proto3" json:"rseed,omitempty"`
	Address *v1alpha11.Address `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *Note) Reset()         { *m = Note{} }
func (m *Note) String() string { return proto.CompactTextString(m) }
func (*Note) ProtoMessage()    {}
func (*Note) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa12195337df7d3c, []int{0}
}
func (m *Note) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Note) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Note.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Note) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Note.Merge(m, src)
}
func (m *Note) XXX_Size() int {
	return m.Size()
}
func (m *Note) XXX_DiscardUnknown() {
	xxx_messageInfo_Note.DiscardUnknown(m)
}

var xxx_messageInfo_Note proto.InternalMessageInfo

func (m *Note) GetValue() *v1alpha1.Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Note) GetRseed() []byte {
	if m != nil {
		return m.Rseed
	}
	return nil
}

func (m *Note) GetAddress() *v1alpha11.Address {
	if m != nil {
		return m.Address
	}
	return nil
}

type NoteView struct {
	Value   *v1alpha1.ValueView    `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	Rseed   []byte                 `protobuf:"bytes,2,opt,name=rseed,proto3" json:"rseed,omitempty"`
	Address *v1alpha11.AddressView `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *NoteView) Reset()         { *m = NoteView{} }
func (m *NoteView) String() string { return proto.CompactTextString(m) }
func (*NoteView) ProtoMessage()    {}
func (*NoteView) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa12195337df7d3c, []int{1}
}
func (m *NoteView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NoteView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NoteView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NoteView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NoteView.Merge(m, src)
}
func (m *NoteView) XXX_Size() int {
	return m.Size()
}
func (m *NoteView) XXX_DiscardUnknown() {
	xxx_messageInfo_NoteView.DiscardUnknown(m)
}

var xxx_messageInfo_NoteView proto.InternalMessageInfo

func (m *NoteView) GetValue() *v1alpha1.ValueView {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *NoteView) GetRseed() []byte {
	if m != nil {
		return m.Rseed
	}
	return nil
}

func (m *NoteView) GetAddress() *v1alpha11.AddressView {
	if m != nil {
		return m.Address
	}
	return nil
}

// An encrypted note.
// 132 = 1(type) + 11(d) + 8(amount) + 32(asset_id) + 32(rcm) + 32(pk_d) + 16(MAC) bytes.
type NoteCiphertext struct {
	Inner []byte `protobuf:"bytes,1,opt,name=inner,proto3" json:"inner,omitempty"`
}

func (m *NoteCiphertext) Reset()         { *m = NoteCiphertext{} }
func (m *NoteCiphertext) String() string { return proto.CompactTextString(m) }
func (*NoteCiphertext) ProtoMessage()    {}
func (*NoteCiphertext) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa12195337df7d3c, []int{2}
}
func (m *NoteCiphertext) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NoteCiphertext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NoteCiphertext.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NoteCiphertext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NoteCiphertext.Merge(m, src)
}
func (m *NoteCiphertext) XXX_Size() int {
	return m.Size()
}
func (m *NoteCiphertext) XXX_DiscardUnknown() {
	xxx_messageInfo_NoteCiphertext.DiscardUnknown(m)
}

var xxx_messageInfo_NoteCiphertext proto.InternalMessageInfo

func (m *NoteCiphertext) GetInner() []byte {
	if m != nil {
		return m.Inner
	}
	return nil
}

// The body of an output description, including only the minimal
// data required to scan and process the output.
type NotePayload struct {
	// The note commitment for the output note. 32 bytes.
	NoteCommitment *v1alpha12.StateCommitment `protobuf:"bytes,1,opt,name=note_commitment,json=noteCommitment,proto3" json:"note_commitment,omitempty"`
	// The encoding of an ephemeral public key. 32 bytes.
	EphemeralKey []byte `protobuf:"bytes,2,opt,name=ephemeral_key,json=ephemeralKey,proto3" json:"ephemeral_key,omitempty"`
	// An encryption of the newly created note.
	// 132 = 1(type) + 11(d) + 8(amount) + 32(asset_id) + 32(rcm) + 32(pk_d) + 16(MAC) bytes.
	EncryptedNote *NoteCiphertext `protobuf:"bytes,3,opt,name=encrypted_note,json=encryptedNote,proto3" json:"encrypted_note,omitempty"`
}

func (m *NotePayload) Reset()         { *m = NotePayload{} }
func (m *NotePayload) String() string { return proto.CompactTextString(m) }
func (*NotePayload) ProtoMessage()    {}
func (*NotePayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa12195337df7d3c, []int{3}
}
func (m *NotePayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NotePayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NotePayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NotePayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotePayload.Merge(m, src)
}
func (m *NotePayload) XXX_Size() int {
	return m.Size()
}
func (m *NotePayload) XXX_DiscardUnknown() {
	xxx_messageInfo_NotePayload.DiscardUnknown(m)
}

var xxx_messageInfo_NotePayload proto.InternalMessageInfo

func (m *NotePayload) GetNoteCommitment() *v1alpha12.StateCommitment {
	if m != nil {
		return m.NoteCommitment
	}
	return nil
}

func (m *NotePayload) GetEphemeralKey() []byte {
	if m != nil {
		return m.EphemeralKey
	}
	return nil
}

func (m *NotePayload) GetEncryptedNote() *NoteCiphertext {
	if m != nil {
		return m.EncryptedNote
	}
	return nil
}

// A Penumbra ZK output proof.
type ZKOutputProof struct {
	Inner []byte `protobuf:"bytes,1,opt,name=inner,proto3" json:"inner,omitempty"`
}

func (m *ZKOutputProof) Reset()         { *m = ZKOutputProof{} }
func (m *ZKOutputProof) String() string { return proto.CompactTextString(m) }
func (*ZKOutputProof) ProtoMessage()    {}
func (*ZKOutputProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa12195337df7d3c, []int{4}
}
func (m *ZKOutputProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZKOutputProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZKOutputProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZKOutputProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZKOutputProof.Merge(m, src)
}
func (m *ZKOutputProof) XXX_Size() int {
	return m.Size()
}
func (m *ZKOutputProof) XXX_DiscardUnknown() {
	xxx_messageInfo_ZKOutputProof.DiscardUnknown(m)
}

var xxx_messageInfo_ZKOutputProof proto.InternalMessageInfo

func (m *ZKOutputProof) GetInner() []byte {
	if m != nil {
		return m.Inner
	}
	return nil
}

// A Penumbra ZK spend proof.
type ZKSpendProof struct {
	Inner []byte `protobuf:"bytes,1,opt,name=inner,proto3" json:"inner,omitempty"`
}

func (m *ZKSpendProof) Reset()         { *m = ZKSpendProof{} }
func (m *ZKSpendProof) String() string { return proto.CompactTextString(m) }
func (*ZKSpendProof) ProtoMessage()    {}
func (*ZKSpendProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa12195337df7d3c, []int{5}
}
func (m *ZKSpendProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZKSpendProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZKSpendProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZKSpendProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZKSpendProof.Merge(m, src)
}
func (m *ZKSpendProof) XXX_Size() int {
	return m.Size()
}
func (m *ZKSpendProof) XXX_DiscardUnknown() {
	xxx_messageInfo_ZKSpendProof.DiscardUnknown(m)
}

var xxx_messageInfo_ZKSpendProof proto.InternalMessageInfo

func (m *ZKSpendProof) GetInner() []byte {
	if m != nil {
		return m.Inner
	}
	return nil
}

// A Penumbra ZK nullifier derivation proof.
type ZKNullifierDerivationProof struct {
	Inner []byte `protobuf:"bytes,1,opt,name=inner,proto3" json:"inner,omitempty"`
}

func (m *ZKNullifierDerivationProof) Reset()         { *m = ZKNullifierDerivationProof{} }
func (m *ZKNullifierDerivationProof) String() string { return proto.CompactTextString(m) }
func (*ZKNullifierDerivationProof) ProtoMessage()    {}
func (*ZKNullifierDerivationProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa12195337df7d3c, []int{6}
}
func (m *ZKNullifierDerivationProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZKNullifierDerivationProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZKNullifierDerivationProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZKNullifierDerivationProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZKNullifierDerivationProof.Merge(m, src)
}
func (m *ZKNullifierDerivationProof) XXX_Size() int {
	return m.Size()
}
func (m *ZKNullifierDerivationProof) XXX_DiscardUnknown() {
	xxx_messageInfo_ZKNullifierDerivationProof.DiscardUnknown(m)
}

var xxx_messageInfo_ZKNullifierDerivationProof proto.InternalMessageInfo

func (m *ZKNullifierDerivationProof) GetInner() []byte {
	if m != nil {
		return m.Inner
	}
	return nil
}

// Spends a shielded note.
type Spend struct {
	// The effecting data of the spend.
	Body *SpendBody `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// The authorizing signature for the spend.
	AuthSig *v1alpha13.SpendAuthSignature `protobuf:"bytes,2,opt,name=auth_sig,json=authSig,proto3" json:"auth_sig,omitempty"`
	// The proof that the spend is well-formed is authorizing data.
	Proof *ZKSpendProof `protobuf:"bytes,3,opt,name=proof,proto3" json:"proof,omitempty"`
}

func (m *Spend) Reset()         { *m = Spend{} }
func (m *Spend) String() string { return proto.CompactTextString(m) }
func (*Spend) ProtoMessage()    {}
func (*Spend) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa12195337df7d3c, []int{7}
}
func (m *Spend) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Spend) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Spend.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Spend) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Spend.Merge(m, src)
}
func (m *Spend) XXX_Size() int {
	return m.Size()
}
func (m *Spend) XXX_DiscardUnknown() {
	xxx_messageInfo_Spend.DiscardUnknown(m)
}

var xxx_messageInfo_Spend proto.InternalMessageInfo

func (m *Spend) GetBody() *SpendBody {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *Spend) GetAuthSig() *v1alpha13.SpendAuthSignature {
	if m != nil {
		return m.AuthSig
	}
	return nil
}

func (m *Spend) GetProof() *ZKSpendProof {
	if m != nil {
		return m.Proof
	}
	return nil
}

// The body of a spend description, containing only the effecting data
// describing changes to the ledger, and not the authorizing data that allows
// those changes to be performed.
type SpendBody struct {
	// A commitment to the value of the input note.
	BalanceCommitment *v1alpha1.BalanceCommitment `protobuf:"bytes,1,opt,name=balance_commitment,json=balanceCommitment,proto3" json:"balance_commitment,omitempty"`
	// The nullifier of the input note.
	Nullifier []byte `protobuf:"bytes,3,opt,name=nullifier,proto3" json:"nullifier,omitempty"`
	// The randomized validating key for the spend authorization signature.
	Rk []byte `protobuf:"bytes,4,opt,name=rk,proto3" json:"rk,omitempty"`
}

func (m *SpendBody) Reset()         { *m = SpendBody{} }
func (m *SpendBody) String() string { return proto.CompactTextString(m) }
func (*SpendBody) ProtoMessage()    {}
func (*SpendBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa12195337df7d3c, []int{8}
}
func (m *SpendBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpendBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpendBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpendBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpendBody.Merge(m, src)
}
func (m *SpendBody) XXX_Size() int {
	return m.Size()
}
func (m *SpendBody) XXX_DiscardUnknown() {
	xxx_messageInfo_SpendBody.DiscardUnknown(m)
}

var xxx_messageInfo_SpendBody proto.InternalMessageInfo

func (m *SpendBody) GetBalanceCommitment() *v1alpha1.BalanceCommitment {
	if m != nil {
		return m.BalanceCommitment
	}
	return nil
}

func (m *SpendBody) GetNullifier() []byte {
	if m != nil {
		return m.Nullifier
	}
	return nil
}

func (m *SpendBody) GetRk() []byte {
	if m != nil {
		return m.Rk
	}
	return nil
}

type SpendView struct {
	// Types that are valid to be assigned to SpendView:
	//
	//	*SpendView_Visible_
	//	*SpendView_Opaque_
	SpendView isSpendView_SpendView `protobuf_oneof:"spend_view"`
}

func (m *SpendView) Reset()         { *m = SpendView{} }
func (m *SpendView) String() string { return proto.CompactTextString(m) }
func (*SpendView) ProtoMessage()    {}
func (*SpendView) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa12195337df7d3c, []int{9}
}
func (m *SpendView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpendView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpendView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpendView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpendView.Merge(m, src)
}
func (m *SpendView) XXX_Size() int {
	return m.Size()
}
func (m *SpendView) XXX_DiscardUnknown() {
	xxx_messageInfo_SpendView.DiscardUnknown(m)
}

var xxx_messageInfo_SpendView proto.InternalMessageInfo

type isSpendView_SpendView interface {
	isSpendView_SpendView()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SpendView_Visible_ struct {
	Visible *SpendView_Visible `protobuf:"bytes,1,opt,name=visible,proto3,oneof" json:"visible,omitempty"`
}
type SpendView_Opaque_ struct {
	Opaque *SpendView_Opaque `protobuf:"bytes,2,opt,name=opaque,proto3,oneof" json:"opaque,omitempty"`
}

func (*SpendView_Visible_) isSpendView_SpendView() {}
func (*SpendView_Opaque_) isSpendView_SpendView()  {}

func (m *SpendView) GetSpendView() isSpendView_SpendView {
	if m != nil {
		return m.SpendView
	}
	return nil
}

func (m *SpendView) GetVisible() *SpendView_Visible {
	if x, ok := m.GetSpendView().(*SpendView_Visible_); ok {
		return x.Visible
	}
	return nil
}

func (m *SpendView) GetOpaque() *SpendView_Opaque {
	if x, ok := m.GetSpendView().(*SpendView_Opaque_); ok {
		return x.Opaque
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SpendView) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SpendView_Visible_)(nil),
		(*SpendView_Opaque_)(nil),
	}
}

type SpendView_Visible struct {
	Spend *Spend    `protobuf:"bytes,1,opt,name=spend,proto3" json:"spend,omitempty"`
	Note  *NoteView `protobuf:"bytes,2,opt,name=note,proto3" json:"note,omitempty"`
}

func (m *SpendView_Visible) Reset()         { *m = SpendView_Visible{} }
func (m *SpendView_Visible) String() string { return proto.CompactTextString(m) }
func (*SpendView_Visible) ProtoMessage()    {}
func (*SpendView_Visible) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa12195337df7d3c, []int{9, 0}
}
func (m *SpendView_Visible) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpendView_Visible) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpendView_Visible.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpendView_Visible) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpendView_Visible.Merge(m, src)
}
func (m *SpendView_Visible) XXX_Size() int {
	return m.Size()
}
func (m *SpendView_Visible) XXX_DiscardUnknown() {
	xxx_messageInfo_SpendView_Visible.DiscardUnknown(m)
}

var xxx_messageInfo_SpendView_Visible proto.InternalMessageInfo

func (m *SpendView_Visible) GetSpend() *Spend {
	if m != nil {
		return m.Spend
	}
	return nil
}

func (m *SpendView_Visible) GetNote() *NoteView {
	if m != nil {
		return m.Note
	}
	return nil
}

type SpendView_Opaque struct {
	Spend *Spend `protobuf:"bytes,1,opt,name=spend,proto3" json:"spend,omitempty"`
}

func (m *SpendView_Opaque) Reset()         { *m = SpendView_Opaque{} }
func (m *SpendView_Opaque) String() string { return proto.CompactTextString(m) }
func (*SpendView_Opaque) ProtoMessage()    {}
func (*SpendView_Opaque) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa12195337df7d3c, []int{9, 1}
}
func (m *SpendView_Opaque) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpendView_Opaque) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpendView_Opaque.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpendView_Opaque) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpendView_Opaque.Merge(m, src)
}
func (m *SpendView_Opaque) XXX_Size() int {
	return m.Size()
}
func (m *SpendView_Opaque) XXX_DiscardUnknown() {
	xxx_messageInfo_SpendView_Opaque.DiscardUnknown(m)
}

var xxx_messageInfo_SpendView_Opaque proto.InternalMessageInfo

func (m *SpendView_Opaque) GetSpend() *Spend {
	if m != nil {
		return m.Spend
	}
	return nil
}

type SpendPlan struct {
	// The plaintext note we plan to spend.
	Note *Note `protobuf:"bytes,1,opt,name=note,proto3" json:"note,omitempty"`
	// The position of the note we plan to spend.
	Position uint64 `protobuf:"varint,2,opt,name=position,proto3" json:"position,omitempty"`
	// The randomizer to use for the spend.
	Randomizer []byte `protobuf:"bytes,3,opt,name=randomizer,proto3" json:"randomizer,omitempty"`
	// The blinding factor to use for the value commitment.
	ValueBlinding []byte `protobuf:"bytes,4,opt,name=value_blinding,json=valueBlinding,proto3" json:"value_blinding,omitempty"`
	// The first blinding factor to use for the ZK spend proof.
	ProofBlindingR []byte `protobuf:"bytes,5,opt,name=proof_blinding_r,json=proofBlindingR,proto3" json:"proof_blinding_r,omitempty"`
	// The second blinding factor to use for the ZK spend proof.
	ProofBlindingS []byte `protobuf:"bytes,6,opt,name=proof_blinding_s,json=proofBlindingS,proto3" json:"proof_blinding_s,omitempty"`
}

func (m *SpendPlan) Reset()         { *m = SpendPlan{} }
func (m *SpendPlan) String() string { return proto.CompactTextString(m) }
func (*SpendPlan) ProtoMessage()    {}
func (*SpendPlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa12195337df7d3c, []int{10}
}
func (m *SpendPlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpendPlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpendPlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpendPlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpendPlan.Merge(m, src)
}
func (m *SpendPlan) XXX_Size() int {
	return m.Size()
}
func (m *SpendPlan) XXX_DiscardUnknown() {
	xxx_messageInfo_SpendPlan.DiscardUnknown(m)
}

var xxx_messageInfo_SpendPlan proto.InternalMessageInfo

func (m *SpendPlan) GetNote() *Note {
	if m != nil {
		return m.Note
	}
	return nil
}

func (m *SpendPlan) GetPosition() uint64 {
	if m != nil {
		return m.Position
	}
	return 0
}

func (m *SpendPlan) GetRandomizer() []byte {
	if m != nil {
		return m.Randomizer
	}
	return nil
}

func (m *SpendPlan) GetValueBlinding() []byte {
	if m != nil {
		return m.ValueBlinding
	}
	return nil
}

func (m *SpendPlan) GetProofBlindingR() []byte {
	if m != nil {
		return m.ProofBlindingR
	}
	return nil
}

func (m *SpendPlan) GetProofBlindingS() []byte {
	if m != nil {
		return m.ProofBlindingS
	}
	return nil
}

// Creates a new shielded note.
type Output struct {
	// The effecting data for the output.
	Body *OutputBody `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// The output proof is authorizing data.
	Proof *ZKOutputProof `protobuf:"bytes,2,opt,name=proof,proto3" json:"proof,omitempty"`
}

func (m *Output) Reset()         { *m = Output{} }
func (m *Output) String() string { return proto.CompactTextString(m) }
func (*Output) ProtoMessage()    {}
func (*Output) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa12195337df7d3c, []int{11}
}
func (m *Output) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Output) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Output.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Output) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Output.Merge(m, src)
}
func (m *Output) XXX_Size() int {
	return m.Size()
}
func (m *Output) XXX_DiscardUnknown() {
	xxx_messageInfo_Output.DiscardUnknown(m)
}

var xxx_messageInfo_Output proto.InternalMessageInfo

func (m *Output) GetBody() *OutputBody {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *Output) GetProof() *ZKOutputProof {
	if m != nil {
		return m.Proof
	}
	return nil
}

// The body of an output description, containing only the effecting data
// describing changes to the ledger, and not the authorizing data that allows
// those changes to be performed.
type OutputBody struct {
	// The minimal data required to scan and process the new output note.
	NotePayload *NotePayload `protobuf:"bytes,1,opt,name=note_payload,json=notePayload,proto3" json:"note_payload,omitempty"`
	// A commitment to the value of the output note. 32 bytes.
	BalanceCommitment *v1alpha1.BalanceCommitment `protobuf:"bytes,2,opt,name=balance_commitment,json=balanceCommitment,proto3" json:"balance_commitment,omitempty"`
	// An encrypted key for decrypting the memo.
	WrappedMemoKey []byte `protobuf:"bytes,3,opt,name=wrapped_memo_key,json=wrappedMemoKey,proto3" json:"wrapped_memo_key,omitempty"`
	// The key material used for note encryption, wrapped in encryption to the
	// sender's outgoing viewing key. 80 bytes.
	OvkWrappedKey []byte `protobuf:"bytes,4,opt,name=ovk_wrapped_key,json=ovkWrappedKey,proto3" json:"ovk_wrapped_key,omitempty"`
}

func (m *OutputBody) Reset()         { *m = OutputBody{} }
func (m *OutputBody) String() string { return proto.CompactTextString(m) }
func (*OutputBody) ProtoMessage()    {}
func (*OutputBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa12195337df7d3c, []int{12}
}
func (m *OutputBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OutputBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OutputBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OutputBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutputBody.Merge(m, src)
}
func (m *OutputBody) XXX_Size() int {
	return m.Size()
}
func (m *OutputBody) XXX_DiscardUnknown() {
	xxx_messageInfo_OutputBody.DiscardUnknown(m)
}

var xxx_messageInfo_OutputBody proto.InternalMessageInfo

func (m *OutputBody) GetNotePayload() *NotePayload {
	if m != nil {
		return m.NotePayload
	}
	return nil
}

func (m *OutputBody) GetBalanceCommitment() *v1alpha1.BalanceCommitment {
	if m != nil {
		return m.BalanceCommitment
	}
	return nil
}

func (m *OutputBody) GetWrappedMemoKey() []byte {
	if m != nil {
		return m.WrappedMemoKey
	}
	return nil
}

func (m *OutputBody) GetOvkWrappedKey() []byte {
	if m != nil {
		return m.OvkWrappedKey
	}
	return nil
}

type OutputView struct {
	// Types that are valid to be assigned to OutputView:
	//
	//	*OutputView_Visible_
	//	*OutputView_Opaque_
	OutputView isOutputView_OutputView `protobuf_oneof:"output_view"`
}

func (m *OutputView) Reset()         { *m = OutputView{} }
func (m *OutputView) String() string { return proto.CompactTextString(m) }
func (*OutputView) ProtoMessage()    {}
func (*OutputView) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa12195337df7d3c, []int{13}
}
func (m *OutputView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OutputView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OutputView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OutputView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutputView.Merge(m, src)
}
func (m *OutputView) XXX_Size() int {
	return m.Size()
}
func (m *OutputView) XXX_DiscardUnknown() {
	xxx_messageInfo_OutputView.DiscardUnknown(m)
}

var xxx_messageInfo_OutputView proto.InternalMessageInfo

type isOutputView_OutputView interface {
	isOutputView_OutputView()
	MarshalTo([]byte) (int, error)
	Size() int
}

type OutputView_Visible_ struct {
	Visible *OutputView_Visible `protobuf:"bytes,1,opt,name=visible,proto3,oneof" json:"visible,omitempty"`
}
type OutputView_Opaque_ struct {
	Opaque *OutputView_Opaque `protobuf:"bytes,2,opt,name=opaque,proto3,oneof" json:"opaque,omitempty"`
}

func (*OutputView_Visible_) isOutputView_OutputView() {}
func (*OutputView_Opaque_) isOutputView_OutputView()  {}

func (m *OutputView) GetOutputView() isOutputView_OutputView {
	if m != nil {
		return m.OutputView
	}
	return nil
}

func (m *OutputView) GetVisible() *OutputView_Visible {
	if x, ok := m.GetOutputView().(*OutputView_Visible_); ok {
		return x.Visible
	}
	return nil
}

func (m *OutputView) GetOpaque() *OutputView_Opaque {
	if x, ok := m.GetOutputView().(*OutputView_Opaque_); ok {
		return x.Opaque
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*OutputView) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*OutputView_Visible_)(nil),
		(*OutputView_Opaque_)(nil),
	}
}

type OutputView_Visible struct {
	Output     *Output               `protobuf:"bytes,1,opt,name=output,proto3" json:"output,omitempty"`
	Note       *NoteView             `protobuf:"bytes,2,opt,name=note,proto3" json:"note,omitempty"`
	PayloadKey *v1alpha11.PayloadKey `protobuf:"bytes,3,opt,name=payload_key,json=payloadKey,proto3" json:"payload_key,omitempty"`
}

func (m *OutputView_Visible) Reset()         { *m = OutputView_Visible{} }
func (m *OutputView_Visible) String() string { return proto.CompactTextString(m) }
func (*OutputView_Visible) ProtoMessage()    {}
func (*OutputView_Visible) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa12195337df7d3c, []int{13, 0}
}
func (m *OutputView_Visible) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OutputView_Visible) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OutputView_Visible.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OutputView_Visible) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutputView_Visible.Merge(m, src)
}
func (m *OutputView_Visible) XXX_Size() int {
	return m.Size()
}
func (m *OutputView_Visible) XXX_DiscardUnknown() {
	xxx_messageInfo_OutputView_Visible.DiscardUnknown(m)
}

var xxx_messageInfo_OutputView_Visible proto.InternalMessageInfo

func (m *OutputView_Visible) GetOutput() *Output {
	if m != nil {
		return m.Output
	}
	return nil
}

func (m *OutputView_Visible) GetNote() *NoteView {
	if m != nil {
		return m.Note
	}
	return nil
}

func (m *OutputView_Visible) GetPayloadKey() *v1alpha11.PayloadKey {
	if m != nil {
		return m.PayloadKey
	}
	return nil
}

type OutputView_Opaque struct {
	Output *Output `protobuf:"bytes,1,opt,name=output,proto3" json:"output,omitempty"`
}

func (m *OutputView_Opaque) Reset()         { *m = OutputView_Opaque{} }
func (m *OutputView_Opaque) String() string { return proto.CompactTextString(m) }
func (*OutputView_Opaque) ProtoMessage()    {}
func (*OutputView_Opaque) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa12195337df7d3c, []int{13, 1}
}
func (m *OutputView_Opaque) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OutputView_Opaque) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OutputView_Opaque.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OutputView_Opaque) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutputView_Opaque.Merge(m, src)
}
func (m *OutputView_Opaque) XXX_Size() int {
	return m.Size()
}
func (m *OutputView_Opaque) XXX_DiscardUnknown() {
	xxx_messageInfo_OutputView_Opaque.DiscardUnknown(m)
}

var xxx_messageInfo_OutputView_Opaque proto.InternalMessageInfo

func (m *OutputView_Opaque) GetOutput() *Output {
	if m != nil {
		return m.Output
	}
	return nil
}

type OutputPlan struct {
	// The value to send to this output.
	Value *v1alpha1.Value `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	// The destination address to send it to.
	DestAddress *v1alpha11.Address `protobuf:"bytes,2,opt,name=dest_address,json=destAddress,proto3" json:"dest_address,omitempty"`
	// The rseed to use for the new note.
	Rseed []byte `protobuf:"bytes,3,opt,name=rseed,proto3" json:"rseed,omitempty"`
	// The blinding factor to use for the value commitment.
	ValueBlinding []byte `protobuf:"bytes,4,opt,name=value_blinding,json=valueBlinding,proto3" json:"value_blinding,omitempty"`
	// The first blinding factor to use for the ZK output proof.
	ProofBlindingR []byte `protobuf:"bytes,5,opt,name=proof_blinding_r,json=proofBlindingR,proto3" json:"proof_blinding_r,omitempty"`
	// The second blinding factor to use for the ZK output proof.
	ProofBlindingS []byte `protobuf:"bytes,6,opt,name=proof_blinding_s,json=proofBlindingS,proto3" json:"proof_blinding_s,omitempty"`
}

func (m *OutputPlan) Reset()         { *m = OutputPlan{} }
func (m *OutputPlan) String() string { return proto.CompactTextString(m) }
func (*OutputPlan) ProtoMessage()    {}
func (*OutputPlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa12195337df7d3c, []int{14}
}
func (m *OutputPlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OutputPlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OutputPlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OutputPlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutputPlan.Merge(m, src)
}
func (m *OutputPlan) XXX_Size() int {
	return m.Size()
}
func (m *OutputPlan) XXX_DiscardUnknown() {
	xxx_messageInfo_OutputPlan.DiscardUnknown(m)
}

var xxx_messageInfo_OutputPlan proto.InternalMessageInfo

func (m *OutputPlan) GetValue() *v1alpha1.Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *OutputPlan) GetDestAddress() *v1alpha11.Address {
	if m != nil {
		return m.DestAddress
	}
	return nil
}

func (m *OutputPlan) GetRseed() []byte {
	if m != nil {
		return m.Rseed
	}
	return nil
}

func (m *OutputPlan) GetValueBlinding() []byte {
	if m != nil {
		return m.ValueBlinding
	}
	return nil
}

func (m *OutputPlan) GetProofBlindingR() []byte {
	if m != nil {
		return m.ProofBlindingR
	}
	return nil
}

func (m *OutputPlan) GetProofBlindingS() []byte {
	if m != nil {
		return m.ProofBlindingS
	}
	return nil
}

// Requests information on an asset by asset id
type DenomMetadataByIdRequest struct {
	// The expected chain id (empty string if no expectation).
	ChainId string `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// The asset id to request information on.
	AssetId *v1alpha1.AssetId `protobuf:"bytes,2,opt,name=asset_id,json=assetId,proto3" json:"asset_id,omitempty"`
}

func (m *DenomMetadataByIdRequest) Reset()         { *m = DenomMetadataByIdRequest{} }
func (m *DenomMetadataByIdRequest) String() string { return proto.CompactTextString(m) }
func (*DenomMetadataByIdRequest) ProtoMessage()    {}
func (*DenomMetadataByIdRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa12195337df7d3c, []int{15}
}
func (m *DenomMetadataByIdRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DenomMetadataByIdRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DenomMetadataByIdRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DenomMetadataByIdRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DenomMetadataByIdRequest.Merge(m, src)
}
func (m *DenomMetadataByIdRequest) XXX_Size() int {
	return m.Size()
}
func (m *DenomMetadataByIdRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DenomMetadataByIdRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DenomMetadataByIdRequest proto.InternalMessageInfo

func (m *DenomMetadataByIdRequest) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *DenomMetadataByIdRequest) GetAssetId() *v1alpha1.AssetId {
	if m != nil {
		return m.AssetId
	}
	return nil
}

type DenomMetadataByIdResponse struct {
	// If present, information on the requested asset.
	//
	// If the requested asset was unknown, this field will not be present.
	DenomMetadata *v1alpha1.DenomMetadata `protobuf:"bytes,1,opt,name=denom_metadata,json=denomMetadata,proto3" json:"denom_metadata,omitempty"`
}

func (m *DenomMetadataByIdResponse) Reset()         { *m = DenomMetadataByIdResponse{} }
func (m *DenomMetadataByIdResponse) String() string { return proto.CompactTextString(m) }
func (*DenomMetadataByIdResponse) ProtoMessage()    {}
func (*DenomMetadataByIdResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa12195337df7d3c, []int{16}
}
func (m *DenomMetadataByIdResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DenomMetadataByIdResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DenomMetadataByIdResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DenomMetadataByIdResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DenomMetadataByIdResponse.Merge(m, src)
}
func (m *DenomMetadataByIdResponse) XXX_Size() int {
	return m.Size()
}
func (m *DenomMetadataByIdResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DenomMetadataByIdResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DenomMetadataByIdResponse proto.InternalMessageInfo

func (m *DenomMetadataByIdResponse) GetDenomMetadata() *v1alpha1.DenomMetadata {
	if m != nil {
		return m.DenomMetadata
	}
	return nil
}

// Genesis data for the shielded pool component.
type GenesisContent struct {
	// The allocations present at genesis
	Allocations []*GenesisContent_Allocation `protobuf:"bytes,2,rep,name=allocations,proto3" json:"allocations,omitempty"`
}

func (m *GenesisContent) Reset()         { *m = GenesisContent{} }
func (m *GenesisContent) String() string { return proto.CompactTextString(m) }
func (*GenesisContent) ProtoMessage()    {}
func (*GenesisContent) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa12195337df7d3c, []int{17}
}
func (m *GenesisContent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenesisContent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenesisContent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenesisContent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenesisContent.Merge(m, src)
}
func (m *GenesisContent) XXX_Size() int {
	return m.Size()
}
func (m *GenesisContent) XXX_DiscardUnknown() {
	xxx_messageInfo_GenesisContent.DiscardUnknown(m)
}

var xxx_messageInfo_GenesisContent proto.InternalMessageInfo

func (m *GenesisContent) GetAllocations() []*GenesisContent_Allocation {
	if m != nil {
		return m.Allocations
	}
	return nil
}

type GenesisContent_Allocation struct {
	Amount  *v1alpha14.Amount  `protobuf:"bytes,1,opt,name=amount,proto3" json:"amount,omitempty"`
	Denom   string             `protobuf:"bytes,2,opt,name=denom,proto3" json:"denom,omitempty"`
	Address *v1alpha11.Address `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *GenesisContent_Allocation) Reset()         { *m = GenesisContent_Allocation{} }
func (m *GenesisContent_Allocation) String() string { return proto.CompactTextString(m) }
func (*GenesisContent_Allocation) ProtoMessage()    {}
func (*GenesisContent_Allocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa12195337df7d3c, []int{17, 0}
}
func (m *GenesisContent_Allocation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenesisContent_Allocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenesisContent_Allocation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenesisContent_Allocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenesisContent_Allocation.Merge(m, src)
}
func (m *GenesisContent_Allocation) XXX_Size() int {
	return m.Size()
}
func (m *GenesisContent_Allocation) XXX_DiscardUnknown() {
	xxx_messageInfo_GenesisContent_Allocation.DiscardUnknown(m)
}

var xxx_messageInfo_GenesisContent_Allocation proto.InternalMessageInfo

func (m *GenesisContent_Allocation) GetAmount() *v1alpha14.Amount {
	if m != nil {
		return m.Amount
	}
	return nil
}

func (m *GenesisContent_Allocation) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *GenesisContent_Allocation) GetAddress() *v1alpha11.Address {
	if m != nil {
		return m.Address
	}
	return nil
}

func init() {
	proto.RegisterType((*Note)(nil), "penumbra.core.component.shielded_pool.v1alpha1.Note")
	proto.RegisterType((*NoteView)(nil), "penumbra.core.component.shielded_pool.v1alpha1.NoteView")
	proto.RegisterType((*NoteCiphertext)(nil), "penumbra.core.component.shielded_pool.v1alpha1.NoteCiphertext")
	proto.RegisterType((*NotePayload)(nil), "penumbra.core.component.shielded_pool.v1alpha1.NotePayload")
	proto.RegisterType((*ZKOutputProof)(nil), "penumbra.core.component.shielded_pool.v1alpha1.ZKOutputProof")
	proto.RegisterType((*ZKSpendProof)(nil), "penumbra.core.component.shielded_pool.v1alpha1.ZKSpendProof")
	proto.RegisterType((*ZKNullifierDerivationProof)(nil), "penumbra.core.component.shielded_pool.v1alpha1.ZKNullifierDerivationProof")
	proto.RegisterType((*Spend)(nil), "penumbra.core.component.shielded_pool.v1alpha1.Spend")
	proto.RegisterType((*SpendBody)(nil), "penumbra.core.component.shielded_pool.v1alpha1.SpendBody")
	proto.RegisterType((*SpendView)(nil), "penumbra.core.component.shielded_pool.v1alpha1.SpendView")
	proto.RegisterType((*SpendView_Visible)(nil), "penumbra.core.component.shielded_pool.v1alpha1.SpendView.Visible")
	proto.RegisterType((*SpendView_Opaque)(nil), "penumbra.core.component.shielded_pool.v1alpha1.SpendView.Opaque")
	proto.RegisterType((*SpendPlan)(nil), "penumbra.core.component.shielded_pool.v1alpha1.SpendPlan")
	proto.RegisterType((*Output)(nil), "penumbra.core.component.shielded_pool.v1alpha1.Output")
	proto.RegisterType((*OutputBody)(nil), "penumbra.core.component.shielded_pool.v1alpha1.OutputBody")
	proto.RegisterType((*OutputView)(nil), "penumbra.core.component.shielded_pool.v1alpha1.OutputView")
	proto.RegisterType((*OutputView_Visible)(nil), "penumbra.core.component.shielded_pool.v1alpha1.OutputView.Visible")
	proto.RegisterType((*OutputView_Opaque)(nil), "penumbra.core.component.shielded_pool.v1alpha1.OutputView.Opaque")
	proto.RegisterType((*OutputPlan)(nil), "penumbra.core.component.shielded_pool.v1alpha1.OutputPlan")
	proto.RegisterType((*DenomMetadataByIdRequest)(nil), "penumbra.core.component.shielded_pool.v1alpha1.DenomMetadataByIdRequest")
	proto.RegisterType((*DenomMetadataByIdResponse)(nil), "penumbra.core.component.shielded_pool.v1alpha1.DenomMetadataByIdResponse")
	proto.RegisterType((*GenesisContent)(nil), "penumbra.core.component.shielded_pool.v1alpha1.GenesisContent")
	proto.RegisterType((*GenesisContent_Allocation)(nil), "penumbra.core.component.shielded_pool.v1alpha1.GenesisContent.Allocation")
}

func init() {
	proto.RegisterFile("penumbra/core/component/shielded_pool/v1alpha1/shielded_pool.proto", fileDescriptor_aa12195337df7d3c)
}

var fileDescriptor_aa12195337df7d3c = []byte{
	// 1410 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x58, 0xcd, 0x6f, 0x1b, 0x45,
	0x14, 0xcf, 0x3a, 0x8e, 0x93, 0x3c, 0x3b, 0x6e, 0x3b, 0xe2, 0xe0, 0x5a, 0xc8, 0xaa, 0xdc, 0x36,
	0x58, 0x42, 0xb5, 0x55, 0x17, 0x28, 0x75, 0x69, 0xd5, 0xd8, 0x95, 0x9a, 0xc8, 0x34, 0x35, 0x6b,
	0x35, 0xa0, 0x10, 0xba, 0x1a, 0x7b, 0xa7, 0xf1, 0xca, 0xbb, 0x3b, 0xdb, 0xfd, 0x70, 0x30, 0x37,
	0xee, 0x1c, 0xb8, 0x21, 0x2e, 0x95, 0xf8, 0x10, 0x42, 0x95, 0xf8, 0x03, 0xf8, 0x0f, 0x10, 0xa7,
	0x8a, 0x13, 0x47, 0x94, 0xde, 0xb8, 0xf5, 0x3f, 0x40, 0xf3, 0xb1, 0xeb, 0x5d, 0x27, 0x8d, 0x6a,
	0x37, 0x12, 0x17, 0x6b, 0xe7, 0xed, 0xef, 0xfd, 0xde, 0xe7, 0xbc, 0x99, 0x35, 0x34, 0x1d, 0x62,
	0x07, 0x56, 0xcf, 0xc5, 0xb5, 0x3e, 0x75, 0x49, 0xad, 0x4f, 0x2d, 0x87, 0xda, 0xc4, 0xf6, 0x6b,
	0xde, 0xc0, 0x20, 0xa6, 0x4e, 0x74, 0xcd, 0xa1, 0xd4, 0xac, 0x8d, 0xae, 0x62, 0xd3, 0x19, 0xe0,
	0xab, 0x49, 0x71, 0xd5, 0x71, 0xa9, 0x4f, 0x51, 0x35, 0xe4, 0xa8, 0x32, 0x8e, 0x6a, 0xc4, 0x51,
	0x4d, 0x82, 0x43, 0x8e, 0xe2, 0xfa, 0xc4, 0xa6, 0x3b, 0x76, 0x7c, 0x5a, 0xf3, 0xfb, 0xfe, 0xc4,
	0x82, 0xdf, 0xf7, 0x05, 0x6f, 0xb1, 0x31, 0x8d, 0xd3, 0x49, 0x1f, 0x3f, 0xbe, 0x76, 0xfd, 0xba,
	0xe6, 0xea, 0x1e, 0x9e, 0x68, 0x24, 0xc4, 0x52, 0xb7, 0x92, 0x8c, 0x0b, 0x7b, 0x1e, 0x89, 0xd9,
	0xe0, 0x4b, 0x89, 0x5c, 0x4f, 0x22, 0x87, 0x64, 0xec, 0x4d, 0x80, 0x6c, 0x25, 0x71, 0x97, 0x92,
	0x38, 0x3b, 0xb0, 0x26, 0x30, 0x3b, 0xb0, 0x04, 0xaa, 0xfc, 0x9d, 0x02, 0xe9, 0x6d, 0xea, 0x13,
	0x74, 0x03, 0x96, 0x46, 0xd8, 0x0c, 0x48, 0x41, 0xb9, 0xa0, 0x54, 0xb2, 0xf5, 0x8b, 0x53, 0x49,
	0x12, 0x1e, 0x84, 0x04, 0xd5, 0x1d, 0x06, 0x55, 0x85, 0x06, 0x7a, 0x0b, 0x96, 0x5c, 0x8f, 0x10,
	0xbd, 0x90, 0xba, 0xa0, 0x54, 0x72, 0xaa, 0x58, 0xa0, 0xdb, 0xb0, 0x8c, 0x75, 0xdd, 0x25, 0x9e,
	0x57, 0x58, 0xe4, 0x94, 0x97, 0xa6, 0x28, 0xb9, 0xaf, 0x11, 0xe3, 0x86, 0xc0, 0xaa, 0xa1, 0x52,
	0xf9, 0x27, 0x05, 0x56, 0x98, 0x67, 0x3b, 0x06, 0x39, 0x40, 0xb7, 0x92, 0xde, 0xbd, 0xf3, 0x1a,
	0xde, 0x31, 0xbd, 0x93, 0x3d, 0x6c, 0x4e, 0x7b, 0x58, 0x79, 0x1d, 0x0f, 0x39, 0x6f, 0xe4, 0xe5,
	0x3a, 0xe4, 0x99, 0x93, 0x2d, 0xc3, 0x19, 0x10, 0xd7, 0x27, 0x5f, 0xfa, 0xcc, 0x96, 0x61, 0xdb,
	0xc4, 0xe5, 0xae, 0xe6, 0x54, 0xb1, 0x28, 0xbf, 0x54, 0x20, 0xcb, 0x80, 0x1d, 0x3c, 0x36, 0x29,
	0xd6, 0xd1, 0x0e, 0x9c, 0xb1, 0xa9, 0x4f, 0xb4, 0x3e, 0xb5, 0x2c, 0xc3, 0xb7, 0x88, 0xed, 0xcb,
	0xd0, 0xae, 0xc4, 0x7c, 0xe0, 0x5d, 0x54, 0x65, 0x0d, 0x16, 0x39, 0xd1, 0xf5, 0xb1, 0x4f, 0x5a,
	0x91, 0x92, 0x9a, 0x67, 0x2c, 0x93, 0x35, 0xba, 0x08, 0x6b, 0xc4, 0x19, 0x10, 0x8b, 0xb8, 0xd8,
	0xd4, 0x86, 0x64, 0x2c, 0x23, 0xce, 0x45, 0xc2, 0x36, 0x19, 0x23, 0x02, 0x79, 0x62, 0x73, 0x76,
	0xa2, 0x6b, 0x8c, 0x40, 0xc6, 0x7f, 0x7b, 0xc6, 0x9d, 0x51, 0x4d, 0x86, 0xae, 0xae, 0x45, 0xac,
	0xec, 0x45, 0xf9, 0x32, 0xac, 0xed, 0xb6, 0x1f, 0x04, 0xbe, 0x13, 0xf8, 0x1d, 0x97, 0xd2, 0xc7,
	0xaf, 0x48, 0xcd, 0x25, 0xc8, 0xed, 0xb6, 0xbb, 0x0e, 0xb1, 0xf5, 0x93, 0x50, 0x75, 0x28, 0xee,
	0xb6, 0xb7, 0x03, 0xd3, 0x34, 0x1e, 0x1b, 0xc4, 0xbd, 0x4b, 0x5c, 0x63, 0x84, 0x7d, 0x83, 0xda,
	0x27, 0xe9, 0x7c, 0x9d, 0x82, 0x25, 0x4e, 0x8c, 0xee, 0x43, 0xba, 0x47, 0xf5, 0xb1, 0xcc, 0xf1,
	0x8d, 0x59, 0xe3, 0xe4, 0x24, 0x4d, 0xaa, 0x8f, 0x55, 0x4e, 0x83, 0x1e, 0xc2, 0x0a, 0x0e, 0xfc,
	0x81, 0xe6, 0x19, 0xfb, 0x3c, 0xc1, 0xd9, 0x7a, 0xe3, 0x48, 0xd9, 0x92, 0xbb, 0x3c, 0x49, 0xb5,
	0x11, 0xf8, 0x83, 0xae, 0xb1, 0x6f, 0x63, 0x3f, 0x70, 0x89, 0xba, 0x8c, 0xc5, 0x12, 0xa9, 0xb0,
	0xe4, 0xb0, 0x70, 0x64, 0x39, 0x3e, 0x9a, 0xd5, 0xcd, 0x78, 0x1a, 0x55, 0x41, 0x55, 0xfe, 0x5e,
	0x81, 0xd5, 0xc8, 0x7d, 0xf4, 0x08, 0x50, 0x0f, 0x9b, 0xd8, 0xee, 0x1f, 0xd3, 0x79, 0xb5, 0x93,
	0x37, 0x55, 0x53, 0xe8, 0xc5, 0x7a, 0xef, 0x5c, 0x6f, 0x5a, 0x84, 0xde, 0x86, 0x55, 0x3b, 0xac,
	0x11, 0x8f, 0x22, 0xa7, 0x4e, 0x04, 0x28, 0x0f, 0x29, 0x77, 0x58, 0x48, 0x73, 0x71, 0xca, 0x1d,
	0x96, 0xff, 0x5a, 0x94, 0xbe, 0xf1, 0x3d, 0xfe, 0x05, 0x2c, 0x8f, 0x0c, 0xcf, 0xe8, 0x99, 0xe1,
	0x2e, 0xdf, 0x98, 0xab, 0x4c, 0x8c, 0xab, 0xba, 0x23, 0x88, 0x36, 0x17, 0xd4, 0x90, 0x13, 0xed,
	0x42, 0x86, 0x3a, 0xf8, 0x49, 0x40, 0x64, 0xc5, 0xee, 0xcc, 0xcf, 0xfe, 0x80, 0xf3, 0x6c, 0x2e,
	0xa8, 0x92, 0xb1, 0xf8, 0xb3, 0x02, 0xcb, 0xd2, 0x24, 0x6a, 0xc3, 0x92, 0xc7, 0x90, 0x32, 0x88,
	0xf7, 0xe7, 0x32, 0xa3, 0x0a, 0x0e, 0xf4, 0x31, 0xa4, 0xf9, 0xfe, 0x14, 0x2e, 0x7f, 0x38, 0xcf,
	0xfe, 0xe4, 0xf3, 0x8a, 0xb3, 0x14, 0x1f, 0x42, 0x46, 0xb8, 0x7e, 0xaa, 0x4e, 0x36, 0x73, 0x00,
	0xfc, 0x41, 0x1b, 0x19, 0xe4, 0xa0, 0xfc, 0x4d, 0x4a, 0x16, 0xb5, 0x63, 0x62, 0x1b, 0x6d, 0xca,
	0x00, 0x84, 0x9d, 0xf7, 0xe6, 0x09, 0x40, 0x38, 0x8f, 0x8a, 0xb0, 0xe2, 0x50, 0xcf, 0x60, 0x7b,
	0x9e, 0xa7, 0x23, 0xad, 0x46, 0x6b, 0x54, 0x02, 0x70, 0xb1, 0xad, 0x53, 0xcb, 0xf8, 0x2a, 0xea,
	0xbb, 0x98, 0x04, 0x5d, 0x86, 0x3c, 0x3f, 0x08, 0xb4, 0x9e, 0x69, 0xd8, 0xba, 0x61, 0xef, 0xcb,
	0x26, 0x5c, 0xe3, 0xd2, 0xa6, 0x14, 0xa2, 0x0a, 0x9c, 0xe5, 0x9b, 0x26, 0x82, 0x69, 0x6e, 0x61,
	0x89, 0x03, 0xf3, 0x5c, 0x1e, 0x02, 0xd5, 0x63, 0x90, 0x5e, 0x21, 0x73, 0x0c, 0xb2, 0x5b, 0xfe,
	0x4d, 0x81, 0x8c, 0x98, 0x81, 0x68, 0x3b, 0x31, 0x84, 0x1a, 0xb3, 0xe6, 0x42, 0xb0, 0xc4, 0xa6,
	0x50, 0x37, 0x1c, 0x17, 0xa2, 0x3b, 0x6e, 0xcd, 0x3e, 0x2e, 0x62, 0xc3, 0x39, 0x9c, 0x17, 0x4f,
	0x53, 0x00, 0x13, 0x4b, 0xe8, 0x11, 0xe4, 0xf8, 0x39, 0xe5, 0x88, 0x73, 0x4b, 0xfa, 0x7e, 0x73,
	0x9e, 0x3a, 0xca, 0xa3, 0x4f, 0xcd, 0xda, 0xb1, 0x73, 0xf0, 0xf8, 0x81, 0x94, 0x3a, 0xb5, 0x81,
	0x54, 0x81, 0xb3, 0x07, 0x2e, 0x76, 0x1c, 0xa2, 0x6b, 0x16, 0xb1, 0x28, 0x3f, 0x12, 0x45, 0x7f,
	0xe4, 0xa5, 0xfc, 0x3e, 0xb1, 0x28, 0x3b, 0x14, 0xd7, 0xe1, 0x0c, 0x1d, 0x0d, 0xb5, 0x10, 0xcd,
	0x80, 0xb2, 0x49, 0xe8, 0x68, 0xf8, 0xa9, 0x90, 0xb6, 0xc9, 0xb8, 0xfc, 0x4b, 0x3a, 0x4c, 0x10,
	0x9f, 0x5a, 0x8f, 0xa6, 0xa7, 0x56, 0x73, 0xbe, 0xba, 0xbe, 0x6a, 0x6c, 0x7d, 0x3e, 0x35, 0xb6,
	0x36, 0xde, 0x80, 0xfe, 0xc8, 0xdc, 0x7a, 0x19, 0x9b, 0x5b, 0xdb, 0x90, 0xa1, 0x1c, 0x2a, 0xe3,
	0xf8, 0x60, 0x3e, 0x43, 0xaa, 0x64, 0x39, 0xdd, 0xd1, 0x85, 0x36, 0x21, 0x2b, 0x5b, 0x30, 0x2a,
	0xe1, 0xd1, 0x6b, 0x60, 0xf2, 0xbe, 0x26, 0x5b, 0xac, 0x4d, 0xc6, 0x2a, 0x38, 0xd1, 0x73, 0xf1,
	0xb3, 0x68, 0x08, 0x9e, 0x72, 0xc4, 0xcd, 0x35, 0xc8, 0x8a, 0x27, 0x31, 0x08, 0x7f, 0x88, 0x76,
	0x12, 0x9f, 0x84, 0x6f, 0x70, 0xc1, 0xbe, 0x07, 0x39, 0x9d, 0x78, 0xbe, 0x16, 0xde, 0x56, 0x53,
	0x33, 0xdc, 0xa7, 0xb3, 0x4c, 0x53, 0x2e, 0x26, 0xf7, 0xe0, 0xc5, 0xf8, 0x3d, 0xf8, 0x7f, 0x9c,
	0x8e, 0x07, 0x50, 0xb8, 0x4b, 0x6c, 0x6a, 0xdd, 0x27, 0x3e, 0xd6, 0xb1, 0x8f, 0x9b, 0xe3, 0x2d,
	0x5d, 0x25, 0x4f, 0x02, 0xe2, 0xf9, 0xe8, 0x3c, 0xac, 0xf4, 0x07, 0xd8, 0xb0, 0x35, 0x43, 0x8c,
	0x9d, 0x55, 0x75, 0x99, 0xaf, 0xb7, 0x74, 0x74, 0x07, 0x56, 0x78, 0xbe, 0xd8, 0x2b, 0x91, 0x8c,
	0xcb, 0x27, 0xa7, 0x73, 0x83, 0x2d, 0xb7, 0x74, 0x75, 0x19, 0x8b, 0x87, 0x32, 0x85, 0xf3, 0xc7,
	0x18, 0xf6, 0x1c, 0x6a, 0x7b, 0x04, 0xa9, 0x90, 0xd7, 0xd9, 0x4b, 0xcd, 0x92, 0x6f, 0x65, 0xcd,
	0xde, 0x3d, 0xd9, 0x48, 0x82, 0x50, 0x5d, 0xd3, 0xe3, 0x4b, 0x36, 0x57, 0xf3, 0xf7, 0x88, 0x4d,
	0x3c, 0xc3, 0x6b, 0x51, 0xdb, 0x67, 0xb3, 0x69, 0x08, 0x59, 0x6c, 0x9a, 0xb4, 0xcf, 0xef, 0xb1,
	0xac, 0xaa, 0x8b, 0x95, 0x6c, 0x7d, 0x6b, 0xd6, 0x26, 0x4c, 0x92, 0x56, 0x37, 0x22, 0x46, 0x35,
	0xce, 0x5e, 0x7c, 0xaa, 0x00, 0x4c, 0xde, 0xa1, 0x06, 0x64, 0xb0, 0x45, 0x83, 0xe8, 0xf2, 0x57,
	0x9e, 0x32, 0xcb, 0xbe, 0x10, 0x27, 0xd9, 0xe3, 0x48, 0x55, 0x6a, 0xb0, 0x2e, 0xe2, 0xb1, 0xf1,
	0xd4, 0xaf, 0xaa, 0x62, 0xf1, 0xa6, 0xdf, 0x7b, 0xf5, 0xdf, 0x15, 0xc8, 0x7d, 0x12, 0x10, 0x77,
	0xdc, 0x25, 0xee, 0xc8, 0xe8, 0x13, 0xf4, 0xab, 0x02, 0xe7, 0x8e, 0xd4, 0x08, 0x6d, 0xce, 0x9a,
	0x9f, 0x57, 0xf5, 0x57, 0x71, 0xeb, 0x14, 0x98, 0x44, 0xc3, 0x34, 0x9f, 0x2d, 0xfe, 0x71, 0x58,
	0x52, 0x9e, 0x1f, 0x96, 0x94, 0x7f, 0x0e, 0x4b, 0xca, 0xb7, 0x2f, 0x4a, 0x0b, 0xcf, 0x5f, 0x94,
	0x16, 0xfe, 0x7e, 0x51, 0x5a, 0x80, 0x7a, 0x9f, 0x5a, 0x33, 0x1a, 0x6a, 0x9e, 0xeb, 0x4a, 0x79,
	0x87, 0x52, 0xb3, 0xc3, 0xbe, 0xd3, 0x3b, 0xca, 0xae, 0xb3, 0x6f, 0xf8, 0x83, 0xa0, 0xc7, 0xb4,
	0x6b, 0x7d, 0xea, 0x59, 0xd4, 0xab, 0xb9, 0xc4, 0xc4, 0x63, 0xe2, 0xd6, 0x46, 0xf5, 0xe8, 0x91,
	0xef, 0x10, 0xaf, 0x36, 0xdb, 0xbf, 0x24, 0x37, 0x13, 0xe2, 0x50, 0xfa, 0x63, 0x2a, 0xdd, 0x69,
	0xb5, 0xba, 0xcf, 0x52, 0x57, 0x3a, 0xa1, 0xfb, 0x2d, 0xe6, 0x7e, 0x2b, 0x72, 0x3f, 0xee, 0x66,
	0x75, 0x47, 0xaa, 0xfd, 0x39, 0xc1, 0xef, 0x31, 0xfc, 0x5e, 0x84, 0xdf, 0x8b, 0xe3, 0xf7, 0x42,
	0xfc, 0x61, 0xea, 0xc6, 0x4c, 0xf8, 0xbd, 0x7b, 0x9d, 0x66, 0x58, 0x84, 0x7f, 0x53, 0x57, 0x43,
	0xdd, 0x46, 0x83, 0x29, 0xb3, 0x5f, 0xa9, 0xdd, 0x68, 0xc4, 0xd5, 0x1b, 0x8d, 0x50, 0xbf, 0x97,
	0xe1, 0xff, 0x7c, 0x5c, 0xfb, 0x2f, 0x00, 0x00, 0xff, 0xff, 0xc9, 0xf4, 0x69, 0xcc, 0x4b, 0x12,
	0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QueryServiceClient is the client API for QueryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryServiceClient interface {
	DenomMetadataById(ctx context.Context, in *DenomMetadataByIdRequest, opts ...grpc.CallOption) (*DenomMetadataByIdResponse, error)
}

type queryServiceClient struct {
	cc grpc1.ClientConn
}

func NewQueryServiceClient(cc grpc1.ClientConn) QueryServiceClient {
	return &queryServiceClient{cc}
}

func (c *queryServiceClient) DenomMetadataById(ctx context.Context, in *DenomMetadataByIdRequest, opts ...grpc.CallOption) (*DenomMetadataByIdResponse, error) {
	out := new(DenomMetadataByIdResponse)
	err := c.cc.Invoke(ctx, "/penumbra.core.component.shielded_pool.v1alpha1.QueryService/DenomMetadataById", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueryServiceServer is the server API for QueryService service.
type QueryServiceServer interface {
	DenomMetadataById(context.Context, *DenomMetadataByIdRequest) (*DenomMetadataByIdResponse, error)
}

// UnimplementedQueryServiceServer can be embedded to have forward compatible implementations.
type UnimplementedQueryServiceServer struct {
}

func (*UnimplementedQueryServiceServer) DenomMetadataById(ctx context.Context, req *DenomMetadataByIdRequest) (*DenomMetadataByIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DenomMetadataById not implemented")
}

func RegisterQueryServiceServer(s grpc1.Server, srv QueryServiceServer) {
	s.RegisterService(&_QueryService_serviceDesc, srv)
}

func _QueryService_DenomMetadataById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DenomMetadataByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServiceServer).DenomMetadataById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/penumbra.core.component.shielded_pool.v1alpha1.QueryService/DenomMetadataById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServiceServer).DenomMetadataById(ctx, req.(*DenomMetadataByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _QueryService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "penumbra.core.component.shielded_pool.v1alpha1.QueryService",
	HandlerType: (*QueryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DenomMetadataById",
			Handler:    _QueryService_DenomMetadataById_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "penumbra/core/component/shielded_pool/v1alpha1/shielded_pool.proto",
}

func (m *Note) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Note) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Note) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Address != nil {
		{
			size, err := m.Address.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Rseed) > 0 {
		i -= len(m.Rseed)
		copy(dAtA[i:], m.Rseed)
		i = encodeVarintShieldedPool(dAtA, i, uint64(len(m.Rseed)))
		i--
		dAtA[i] = 0x12
	}
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NoteView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NoteView) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NoteView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Address != nil {
		{
			size, err := m.Address.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Rseed) > 0 {
		i -= len(m.Rseed)
		copy(dAtA[i:], m.Rseed)
		i = encodeVarintShieldedPool(dAtA, i, uint64(len(m.Rseed)))
		i--
		dAtA[i] = 0x12
	}
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NoteCiphertext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NoteCiphertext) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NoteCiphertext) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Inner) > 0 {
		i -= len(m.Inner)
		copy(dAtA[i:], m.Inner)
		i = encodeVarintShieldedPool(dAtA, i, uint64(len(m.Inner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NotePayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NotePayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NotePayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EncryptedNote != nil {
		{
			size, err := m.EncryptedNote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.EphemeralKey) > 0 {
		i -= len(m.EphemeralKey)
		copy(dAtA[i:], m.EphemeralKey)
		i = encodeVarintShieldedPool(dAtA, i, uint64(len(m.EphemeralKey)))
		i--
		dAtA[i] = 0x12
	}
	if m.NoteCommitment != nil {
		{
			size, err := m.NoteCommitment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ZKOutputProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZKOutputProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZKOutputProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Inner) > 0 {
		i -= len(m.Inner)
		copy(dAtA[i:], m.Inner)
		i = encodeVarintShieldedPool(dAtA, i, uint64(len(m.Inner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ZKSpendProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZKSpendProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZKSpendProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Inner) > 0 {
		i -= len(m.Inner)
		copy(dAtA[i:], m.Inner)
		i = encodeVarintShieldedPool(dAtA, i, uint64(len(m.Inner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ZKNullifierDerivationProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZKNullifierDerivationProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZKNullifierDerivationProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Inner) > 0 {
		i -= len(m.Inner)
		copy(dAtA[i:], m.Inner)
		i = encodeVarintShieldedPool(dAtA, i, uint64(len(m.Inner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Spend) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Spend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Spend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Proof != nil {
		{
			size, err := m.Proof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.AuthSig != nil {
		{
			size, err := m.AuthSig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Body != nil {
		{
			size, err := m.Body.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpendBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpendBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpendBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Rk) > 0 {
		i -= len(m.Rk)
		copy(dAtA[i:], m.Rk)
		i = encodeVarintShieldedPool(dAtA, i, uint64(len(m.Rk)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Nullifier) > 0 {
		i -= len(m.Nullifier)
		copy(dAtA[i:], m.Nullifier)
		i = encodeVarintShieldedPool(dAtA, i, uint64(len(m.Nullifier)))
		i--
		dAtA[i] = 0x1a
	}
	if m.BalanceCommitment != nil {
		{
			size, err := m.BalanceCommitment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpendView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpendView) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpendView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SpendView != nil {
		{
			size := m.SpendView.Size()
			i -= size
			if _, err := m.SpendView.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *SpendView_Visible_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpendView_Visible_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Visible != nil {
		{
			size, err := m.Visible.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *SpendView_Opaque_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpendView_Opaque_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Opaque != nil {
		{
			size, err := m.Opaque.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *SpendView_Visible) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpendView_Visible) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpendView_Visible) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Note != nil {
		{
			size, err := m.Note.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Spend != nil {
		{
			size, err := m.Spend.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpendView_Opaque) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpendView_Opaque) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpendView_Opaque) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Spend != nil {
		{
			size, err := m.Spend.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpendPlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpendPlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpendPlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProofBlindingS) > 0 {
		i -= len(m.ProofBlindingS)
		copy(dAtA[i:], m.ProofBlindingS)
		i = encodeVarintShieldedPool(dAtA, i, uint64(len(m.ProofBlindingS)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ProofBlindingR) > 0 {
		i -= len(m.ProofBlindingR)
		copy(dAtA[i:], m.ProofBlindingR)
		i = encodeVarintShieldedPool(dAtA, i, uint64(len(m.ProofBlindingR)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ValueBlinding) > 0 {
		i -= len(m.ValueBlinding)
		copy(dAtA[i:], m.ValueBlinding)
		i = encodeVarintShieldedPool(dAtA, i, uint64(len(m.ValueBlinding)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Randomizer) > 0 {
		i -= len(m.Randomizer)
		copy(dAtA[i:], m.Randomizer)
		i = encodeVarintShieldedPool(dAtA, i, uint64(len(m.Randomizer)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Position != 0 {
		i = encodeVarintShieldedPool(dAtA, i, uint64(m.Position))
		i--
		dAtA[i] = 0x10
	}
	if m.Note != nil {
		{
			size, err := m.Note.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Output) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Output) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Output) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Proof != nil {
		{
			size, err := m.Proof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Body != nil {
		{
			size, err := m.Body.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OutputBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OutputBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutputBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OvkWrappedKey) > 0 {
		i -= len(m.OvkWrappedKey)
		copy(dAtA[i:], m.OvkWrappedKey)
		i = encodeVarintShieldedPool(dAtA, i, uint64(len(m.OvkWrappedKey)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.WrappedMemoKey) > 0 {
		i -= len(m.WrappedMemoKey)
		copy(dAtA[i:], m.WrappedMemoKey)
		i = encodeVarintShieldedPool(dAtA, i, uint64(len(m.WrappedMemoKey)))
		i--
		dAtA[i] = 0x1a
	}
	if m.BalanceCommitment != nil {
		{
			size, err := m.BalanceCommitment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.NotePayload != nil {
		{
			size, err := m.NotePayload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OutputView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OutputView) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutputView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OutputView != nil {
		{
			size := m.OutputView.Size()
			i -= size
			if _, err := m.OutputView.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *OutputView_Visible_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutputView_Visible_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Visible != nil {
		{
			size, err := m.Visible.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *OutputView_Opaque_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutputView_Opaque_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Opaque != nil {
		{
			size, err := m.Opaque.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *OutputView_Visible) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OutputView_Visible) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutputView_Visible) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PayloadKey != nil {
		{
			size, err := m.PayloadKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Note != nil {
		{
			size, err := m.Note.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Output != nil {
		{
			size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OutputView_Opaque) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OutputView_Opaque) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutputView_Opaque) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Output != nil {
		{
			size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OutputPlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OutputPlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutputPlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProofBlindingS) > 0 {
		i -= len(m.ProofBlindingS)
		copy(dAtA[i:], m.ProofBlindingS)
		i = encodeVarintShieldedPool(dAtA, i, uint64(len(m.ProofBlindingS)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ProofBlindingR) > 0 {
		i -= len(m.ProofBlindingR)
		copy(dAtA[i:], m.ProofBlindingR)
		i = encodeVarintShieldedPool(dAtA, i, uint64(len(m.ProofBlindingR)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ValueBlinding) > 0 {
		i -= len(m.ValueBlinding)
		copy(dAtA[i:], m.ValueBlinding)
		i = encodeVarintShieldedPool(dAtA, i, uint64(len(m.ValueBlinding)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Rseed) > 0 {
		i -= len(m.Rseed)
		copy(dAtA[i:], m.Rseed)
		i = encodeVarintShieldedPool(dAtA, i, uint64(len(m.Rseed)))
		i--
		dAtA[i] = 0x1a
	}
	if m.DestAddress != nil {
		{
			size, err := m.DestAddress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DenomMetadataByIdRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DenomMetadataByIdRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DenomMetadataByIdRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AssetId != nil {
		{
			size, err := m.AssetId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintShieldedPool(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DenomMetadataByIdResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DenomMetadataByIdResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DenomMetadataByIdResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DenomMetadata != nil {
		{
			size, err := m.DenomMetadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GenesisContent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenesisContent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenesisContent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Allocations) > 0 {
		for iNdEx := len(m.Allocations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Allocations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintShieldedPool(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *GenesisContent_Allocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenesisContent_Allocation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenesisContent_Allocation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Address != nil {
		{
			size, err := m.Address.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintShieldedPool(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x12
	}
	if m.Amount != nil {
		{
			size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShieldedPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintShieldedPool(dAtA []byte, offset int, v uint64) int {
	offset -= sovShieldedPool(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Note) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	l = len(m.Rseed)
	if l > 0 {
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	if m.Address != nil {
		l = m.Address.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func (m *NoteView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	l = len(m.Rseed)
	if l > 0 {
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	if m.Address != nil {
		l = m.Address.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func (m *NoteCiphertext) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Inner)
	if l > 0 {
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func (m *NotePayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoteCommitment != nil {
		l = m.NoteCommitment.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	l = len(m.EphemeralKey)
	if l > 0 {
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	if m.EncryptedNote != nil {
		l = m.EncryptedNote.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func (m *ZKOutputProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Inner)
	if l > 0 {
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func (m *ZKSpendProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Inner)
	if l > 0 {
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func (m *ZKNullifierDerivationProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Inner)
	if l > 0 {
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func (m *Spend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Body != nil {
		l = m.Body.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	if m.AuthSig != nil {
		l = m.AuthSig.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	if m.Proof != nil {
		l = m.Proof.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func (m *SpendBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BalanceCommitment != nil {
		l = m.BalanceCommitment.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	l = len(m.Nullifier)
	if l > 0 {
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	l = len(m.Rk)
	if l > 0 {
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func (m *SpendView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SpendView != nil {
		n += m.SpendView.Size()
	}
	return n
}

func (m *SpendView_Visible_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Visible != nil {
		l = m.Visible.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}
func (m *SpendView_Opaque_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Opaque != nil {
		l = m.Opaque.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}
func (m *SpendView_Visible) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spend != nil {
		l = m.Spend.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	if m.Note != nil {
		l = m.Note.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func (m *SpendView_Opaque) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spend != nil {
		l = m.Spend.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func (m *SpendPlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Note != nil {
		l = m.Note.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	if m.Position != 0 {
		n += 1 + sovShieldedPool(uint64(m.Position))
	}
	l = len(m.Randomizer)
	if l > 0 {
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	l = len(m.ValueBlinding)
	if l > 0 {
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	l = len(m.ProofBlindingR)
	if l > 0 {
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	l = len(m.ProofBlindingS)
	if l > 0 {
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func (m *Output) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Body != nil {
		l = m.Body.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	if m.Proof != nil {
		l = m.Proof.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func (m *OutputBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NotePayload != nil {
		l = m.NotePayload.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	if m.BalanceCommitment != nil {
		l = m.BalanceCommitment.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	l = len(m.WrappedMemoKey)
	if l > 0 {
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	l = len(m.OvkWrappedKey)
	if l > 0 {
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func (m *OutputView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OutputView != nil {
		n += m.OutputView.Size()
	}
	return n
}

func (m *OutputView_Visible_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Visible != nil {
		l = m.Visible.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}
func (m *OutputView_Opaque_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Opaque != nil {
		l = m.Opaque.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}
func (m *OutputView_Visible) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Output != nil {
		l = m.Output.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	if m.Note != nil {
		l = m.Note.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	if m.PayloadKey != nil {
		l = m.PayloadKey.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func (m *OutputView_Opaque) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Output != nil {
		l = m.Output.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func (m *OutputPlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	if m.DestAddress != nil {
		l = m.DestAddress.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	l = len(m.Rseed)
	if l > 0 {
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	l = len(m.ValueBlinding)
	if l > 0 {
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	l = len(m.ProofBlindingR)
	if l > 0 {
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	l = len(m.ProofBlindingS)
	if l > 0 {
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func (m *DenomMetadataByIdRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	if m.AssetId != nil {
		l = m.AssetId.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func (m *DenomMetadataByIdResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DenomMetadata != nil {
		l = m.DenomMetadata.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func (m *GenesisContent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Allocations) > 0 {
		for _, e := range m.Allocations {
			l = e.Size()
			n += 1 + l + sovShieldedPool(uint64(l))
		}
	}
	return n
}

func (m *GenesisContent_Allocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Amount != nil {
		l = m.Amount.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	if m.Address != nil {
		l = m.Address.Size()
		n += 1 + l + sovShieldedPool(uint64(l))
	}
	return n
}

func sovShieldedPool(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozShieldedPool(x uint64) (n int) {
	return sovShieldedPool(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Note) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Note: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Note: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &v1alpha1.Value{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rseed", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rseed = append(m.Rseed[:0], dAtA[iNdEx:postIndex]...)
			if m.Rseed == nil {
				m.Rseed = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Address == nil {
				m.Address = &v1alpha11.Address{}
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NoteView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NoteView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NoteView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &v1alpha1.ValueView{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rseed", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rseed = append(m.Rseed[:0], dAtA[iNdEx:postIndex]...)
			if m.Rseed == nil {
				m.Rseed = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Address == nil {
				m.Address = &v1alpha11.AddressView{}
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NoteCiphertext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NoteCiphertext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NoteCiphertext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inner = append(m.Inner[:0], dAtA[iNdEx:postIndex]...)
			if m.Inner == nil {
				m.Inner = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NotePayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotePayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotePayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoteCommitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NoteCommitment == nil {
				m.NoteCommitment = &v1alpha12.StateCommitment{}
			}
			if err := m.NoteCommitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EphemeralKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EphemeralKey = append(m.EphemeralKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EphemeralKey == nil {
				m.EphemeralKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedNote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EncryptedNote == nil {
				m.EncryptedNote = &NoteCiphertext{}
			}
			if err := m.EncryptedNote.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZKOutputProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZKOutputProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZKOutputProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inner = append(m.Inner[:0], dAtA[iNdEx:postIndex]...)
			if m.Inner == nil {
				m.Inner = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZKSpendProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZKSpendProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZKSpendProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inner = append(m.Inner[:0], dAtA[iNdEx:postIndex]...)
			if m.Inner == nil {
				m.Inner = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZKNullifierDerivationProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZKNullifierDerivationProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZKNullifierDerivationProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inner = append(m.Inner[:0], dAtA[iNdEx:postIndex]...)
			if m.Inner == nil {
				m.Inner = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Spend) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Spend: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Spend: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Body == nil {
				m.Body = &SpendBody{}
			}
			if err := m.Body.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthSig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuthSig == nil {
				m.AuthSig = &v1alpha13.SpendAuthSignature{}
			}
			if err := m.AuthSig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proof == nil {
				m.Proof = &ZKSpendProof{}
			}
			if err := m.Proof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpendBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpendBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpendBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BalanceCommitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BalanceCommitment == nil {
				m.BalanceCommitment = &v1alpha1.BalanceCommitment{}
			}
			if err := m.BalanceCommitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nullifier", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nullifier = append(m.Nullifier[:0], dAtA[iNdEx:postIndex]...)
			if m.Nullifier == nil {
				m.Nullifier = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rk = append(m.Rk[:0], dAtA[iNdEx:postIndex]...)
			if m.Rk == nil {
				m.Rk = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpendView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpendView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpendView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visible", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SpendView_Visible{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SpendView = &SpendView_Visible_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opaque", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SpendView_Opaque{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SpendView = &SpendView_Opaque_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpendView_Visible) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Visible: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Visible: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spend == nil {
				m.Spend = &Spend{}
			}
			if err := m.Spend.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Note", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Note == nil {
				m.Note = &NoteView{}
			}
			if err := m.Note.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpendView_Opaque) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Opaque: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Opaque: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spend == nil {
				m.Spend = &Spend{}
			}
			if err := m.Spend.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpendPlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpendPlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpendPlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Note", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Note == nil {
				m.Note = &Note{}
			}
			if err := m.Note.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			m.Position = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Position |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Randomizer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Randomizer = append(m.Randomizer[:0], dAtA[iNdEx:postIndex]...)
			if m.Randomizer == nil {
				m.Randomizer = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueBlinding", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueBlinding = append(m.ValueBlinding[:0], dAtA[iNdEx:postIndex]...)
			if m.ValueBlinding == nil {
				m.ValueBlinding = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofBlindingR", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofBlindingR = append(m.ProofBlindingR[:0], dAtA[iNdEx:postIndex]...)
			if m.ProofBlindingR == nil {
				m.ProofBlindingR = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofBlindingS", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofBlindingS = append(m.ProofBlindingS[:0], dAtA[iNdEx:postIndex]...)
			if m.ProofBlindingS == nil {
				m.ProofBlindingS = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Output) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Output: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Output: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Body == nil {
				m.Body = &OutputBody{}
			}
			if err := m.Body.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proof == nil {
				m.Proof = &ZKOutputProof{}
			}
			if err := m.Proof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutputBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OutputBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OutputBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotePayload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NotePayload == nil {
				m.NotePayload = &NotePayload{}
			}
			if err := m.NotePayload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BalanceCommitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BalanceCommitment == nil {
				m.BalanceCommitment = &v1alpha1.BalanceCommitment{}
			}
			if err := m.BalanceCommitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WrappedMemoKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WrappedMemoKey = append(m.WrappedMemoKey[:0], dAtA[iNdEx:postIndex]...)
			if m.WrappedMemoKey == nil {
				m.WrappedMemoKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OvkWrappedKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OvkWrappedKey = append(m.OvkWrappedKey[:0], dAtA[iNdEx:postIndex]...)
			if m.OvkWrappedKey == nil {
				m.OvkWrappedKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutputView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OutputView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OutputView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visible", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OutputView_Visible{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.OutputView = &OutputView_Visible_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opaque", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OutputView_Opaque{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.OutputView = &OutputView_Opaque_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutputView_Visible) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Visible: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Visible: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output == nil {
				m.Output = &Output{}
			}
			if err := m.Output.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Note", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Note == nil {
				m.Note = &NoteView{}
			}
			if err := m.Note.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PayloadKey == nil {
				m.PayloadKey = &v1alpha11.PayloadKey{}
			}
			if err := m.PayloadKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutputView_Opaque) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Opaque: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Opaque: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output == nil {
				m.Output = &Output{}
			}
			if err := m.Output.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutputPlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OutputPlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OutputPlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &v1alpha1.Value{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DestAddress == nil {
				m.DestAddress = &v1alpha11.Address{}
			}
			if err := m.DestAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rseed", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rseed = append(m.Rseed[:0], dAtA[iNdEx:postIndex]...)
			if m.Rseed == nil {
				m.Rseed = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueBlinding", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueBlinding = append(m.ValueBlinding[:0], dAtA[iNdEx:postIndex]...)
			if m.ValueBlinding == nil {
				m.ValueBlinding = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofBlindingR", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofBlindingR = append(m.ProofBlindingR[:0], dAtA[iNdEx:postIndex]...)
			if m.ProofBlindingR == nil {
				m.ProofBlindingR = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofBlindingS", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofBlindingS = append(m.ProofBlindingS[:0], dAtA[iNdEx:postIndex]...)
			if m.ProofBlindingS == nil {
				m.ProofBlindingS = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DenomMetadataByIdRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DenomMetadataByIdRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DenomMetadataByIdRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AssetId == nil {
				m.AssetId = &v1alpha1.AssetId{}
			}
			if err := m.AssetId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DenomMetadataByIdResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DenomMetadataByIdResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DenomMetadataByIdResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenomMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DenomMetadata == nil {
				m.DenomMetadata = &v1alpha1.DenomMetadata{}
			}
			if err := m.DenomMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenesisContent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenesisContent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenesisContent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Allocations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Allocations = append(m.Allocations, &GenesisContent_Allocation{})
			if err := m.Allocations[len(m.Allocations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenesisContent_Allocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Allocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Allocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Amount == nil {
				m.Amount = &v1alpha14.Amount{}
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShieldedPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Address == nil {
				m.Address = &v1alpha11.Address{}
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShieldedPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShieldedPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipShieldedPool(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowShieldedPool
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowShieldedPool
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthShieldedPool
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupShieldedPool
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthShieldedPool
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthShieldedPool        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowShieldedPool          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupShieldedPool = fmt.Errorf("proto: unexpected end of group")
)
