// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: penumbra/core/component/fee/v1/fee.proto

package feev1

import (
	context "context"
	fmt "fmt"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	v11 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/asset/v1"
	v1 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/num/v1"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// The tier for the fee.
type FeeTier_Tier int32

const (
	FeeTier_TIER_UNSPECIFIED FeeTier_Tier = 0
	FeeTier_TIER_LOW         FeeTier_Tier = 1
	FeeTier_TIER_MEDIUM      FeeTier_Tier = 2
	FeeTier_TIER_HIGH        FeeTier_Tier = 3
)

var FeeTier_Tier_name = map[int32]string{
	0: "TIER_UNSPECIFIED",
	1: "TIER_LOW",
	2: "TIER_MEDIUM",
	3: "TIER_HIGH",
}

var FeeTier_Tier_value = map[string]int32{
	"TIER_UNSPECIFIED": 0,
	"TIER_LOW":         1,
	"TIER_MEDIUM":      2,
	"TIER_HIGH":        3,
}

func (x FeeTier_Tier) String() string {
	return proto.EnumName(FeeTier_Tier_name, int32(x))
}

func (FeeTier_Tier) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_80e267509eb0355f, []int{2, 0}
}

// Specifies fees paid by a transaction.
type Fee struct {
	// The amount of the token used to pay fees.
	Amount *v1.Amount `protobuf:"bytes,1,opt,name=amount,proto3" json:"amount,omitempty"`
	// If present, the asset ID of the token used to pay fees.
	// If absent, specifies the staking token implicitly.
	AssetId *v11.AssetId `protobuf:"bytes,2,opt,name=asset_id,json=assetId,proto3" json:"asset_id,omitempty"`
}

func (m *Fee) Reset()         { *m = Fee{} }
func (m *Fee) String() string { return proto.CompactTextString(m) }
func (*Fee) ProtoMessage()    {}
func (*Fee) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e267509eb0355f, []int{0}
}
func (m *Fee) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Fee) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Fee.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Fee) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Fee.Merge(m, src)
}
func (m *Fee) XXX_Size() int {
	return m.Size()
}
func (m *Fee) XXX_DiscardUnknown() {
	xxx_messageInfo_Fee.DiscardUnknown(m)
}

var xxx_messageInfo_Fee proto.InternalMessageInfo

func (m *Fee) GetAmount() *v1.Amount {
	if m != nil {
		return m.Amount
	}
	return nil
}

func (m *Fee) GetAssetId() *v11.AssetId {
	if m != nil {
		return m.AssetId
	}
	return nil
}

type GasPrices struct {
	// The asset ID of the fee token these prices are for.
	//
	// If absent, specifies the staking token implicitly.
	AssetId *v11.AssetId `protobuf:"bytes,15,opt,name=asset_id,json=assetId,proto3" json:"asset_id,omitempty"`
	// The price per unit block space in terms of the staking token, with an implicit 1,000 denominator.
	BlockSpacePrice uint64 `protobuf:"varint,1,opt,name=block_space_price,json=blockSpacePrice,proto3" json:"block_space_price,omitempty"`
	// The price per unit compact block space in terms of the staking token, with an implicit 1,000 denominator.
	CompactBlockSpacePrice uint64 `protobuf:"varint,2,opt,name=compact_block_space_price,json=compactBlockSpacePrice,proto3" json:"compact_block_space_price,omitempty"`
	// The price per unit verification cost in terms of the staking token, with an implicit 1,000 denominator.
	VerificationPrice uint64 `protobuf:"varint,3,opt,name=verification_price,json=verificationPrice,proto3" json:"verification_price,omitempty"`
	// The price per unit execution cost in terms of the staking token, with an implicit 1,000 denominator.
	ExecutionPrice uint64 `protobuf:"varint,4,opt,name=execution_price,json=executionPrice,proto3" json:"execution_price,omitempty"`
}

func (m *GasPrices) Reset()         { *m = GasPrices{} }
func (m *GasPrices) String() string { return proto.CompactTextString(m) }
func (*GasPrices) ProtoMessage()    {}
func (*GasPrices) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e267509eb0355f, []int{1}
}
func (m *GasPrices) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GasPrices) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GasPrices.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GasPrices) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GasPrices.Merge(m, src)
}
func (m *GasPrices) XXX_Size() int {
	return m.Size()
}
func (m *GasPrices) XXX_DiscardUnknown() {
	xxx_messageInfo_GasPrices.DiscardUnknown(m)
}

var xxx_messageInfo_GasPrices proto.InternalMessageInfo

func (m *GasPrices) GetAssetId() *v11.AssetId {
	if m != nil {
		return m.AssetId
	}
	return nil
}

func (m *GasPrices) GetBlockSpacePrice() uint64 {
	if m != nil {
		return m.BlockSpacePrice
	}
	return 0
}

func (m *GasPrices) GetCompactBlockSpacePrice() uint64 {
	if m != nil {
		return m.CompactBlockSpacePrice
	}
	return 0
}

func (m *GasPrices) GetVerificationPrice() uint64 {
	if m != nil {
		return m.VerificationPrice
	}
	return 0
}

func (m *GasPrices) GetExecutionPrice() uint64 {
	if m != nil {
		return m.ExecutionPrice
	}
	return 0
}

type FeeTier struct {
	// The selected fee tier.
	FeeTier FeeTier_Tier `protobuf:"varint,1,opt,name=fee_tier,json=feeTier,proto3,enum=penumbra.core.component.fee.v1.FeeTier_Tier" json:"fee_tier,omitempty"`
}

func (m *FeeTier) Reset()         { *m = FeeTier{} }
func (m *FeeTier) String() string { return proto.CompactTextString(m) }
func (*FeeTier) ProtoMessage()    {}
func (*FeeTier) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e267509eb0355f, []int{2}
}
func (m *FeeTier) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeeTier) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeeTier.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeeTier) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeeTier.Merge(m, src)
}
func (m *FeeTier) XXX_Size() int {
	return m.Size()
}
func (m *FeeTier) XXX_DiscardUnknown() {
	xxx_messageInfo_FeeTier.DiscardUnknown(m)
}

var xxx_messageInfo_FeeTier proto.InternalMessageInfo

func (m *FeeTier) GetFeeTier() FeeTier_Tier {
	if m != nil {
		return m.FeeTier
	}
	return FeeTier_TIER_UNSPECIFIED
}

// Fee component configuration data.
type FeeParameters struct {
	// Fixed gas prices in the native token used to compute transactions' base
	// fees.
	//
	// In the future, this should be removed and replaced with parameters for
	// dynamic gas pricing.
	FixedGasPrices *GasPrices `protobuf:"bytes,1,opt,name=fixed_gas_prices,json=fixedGasPrices,proto3" json:"fixed_gas_prices,omitempty"`
	// Fixed gas prices in other tokens used to compute transactions' base fees.
	//
	// In the future, this should be removed and replaced with fixed multiples of
	// the native token's price (so that there is one set of dynamically
	// determined gas prices in the native token, and derived gas prices in other
	// alternative tokens).
	//
	// If this is empty, no other tokens are accepted for gas.
	FixedAltGasPrices []*GasPrices `protobuf:"bytes,2,rep,name=fixed_alt_gas_prices,json=fixedAltGasPrices,proto3" json:"fixed_alt_gas_prices,omitempty"`
}

func (m *FeeParameters) Reset()         { *m = FeeParameters{} }
func (m *FeeParameters) String() string { return proto.CompactTextString(m) }
func (*FeeParameters) ProtoMessage()    {}
func (*FeeParameters) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e267509eb0355f, []int{3}
}
func (m *FeeParameters) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeeParameters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeeParameters.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeeParameters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeeParameters.Merge(m, src)
}
func (m *FeeParameters) XXX_Size() int {
	return m.Size()
}
func (m *FeeParameters) XXX_DiscardUnknown() {
	xxx_messageInfo_FeeParameters.DiscardUnknown(m)
}

var xxx_messageInfo_FeeParameters proto.InternalMessageInfo

func (m *FeeParameters) GetFixedGasPrices() *GasPrices {
	if m != nil {
		return m.FixedGasPrices
	}
	return nil
}

func (m *FeeParameters) GetFixedAltGasPrices() []*GasPrices {
	if m != nil {
		return m.FixedAltGasPrices
	}
	return nil
}

// Fee-specific genesis content.
type GenesisContent struct {
	// The FeeParameters present at genesis.
	FeeParams *FeeParameters `protobuf:"bytes,1,opt,name=fee_params,json=feeParams,proto3" json:"fee_params,omitempty"`
}

func (m *GenesisContent) Reset()         { *m = GenesisContent{} }
func (m *GenesisContent) String() string { return proto.CompactTextString(m) }
func (*GenesisContent) ProtoMessage()    {}
func (*GenesisContent) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e267509eb0355f, []int{4}
}
func (m *GenesisContent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenesisContent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenesisContent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenesisContent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenesisContent.Merge(m, src)
}
func (m *GenesisContent) XXX_Size() int {
	return m.Size()
}
func (m *GenesisContent) XXX_DiscardUnknown() {
	xxx_messageInfo_GenesisContent.DiscardUnknown(m)
}

var xxx_messageInfo_GenesisContent proto.InternalMessageInfo

func (m *GenesisContent) GetFeeParams() *FeeParameters {
	if m != nil {
		return m.FeeParams
	}
	return nil
}

type CurrentGasPricesRequest struct {
}

func (m *CurrentGasPricesRequest) Reset()         { *m = CurrentGasPricesRequest{} }
func (m *CurrentGasPricesRequest) String() string { return proto.CompactTextString(m) }
func (*CurrentGasPricesRequest) ProtoMessage()    {}
func (*CurrentGasPricesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e267509eb0355f, []int{5}
}
func (m *CurrentGasPricesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CurrentGasPricesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CurrentGasPricesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CurrentGasPricesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CurrentGasPricesRequest.Merge(m, src)
}
func (m *CurrentGasPricesRequest) XXX_Size() int {
	return m.Size()
}
func (m *CurrentGasPricesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CurrentGasPricesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CurrentGasPricesRequest proto.InternalMessageInfo

type CurrentGasPricesResponse struct {
	// The current gas prices, in the preferred (native) token.
	GasPrices *GasPrices `protobuf:"bytes,1,opt,name=gas_prices,json=gasPrices,proto3" json:"gas_prices,omitempty"`
	// Other gas prices for other accepted tokens.
	AltGasPrices []*GasPrices `protobuf:"bytes,2,rep,name=alt_gas_prices,json=altGasPrices,proto3" json:"alt_gas_prices,omitempty"`
}

func (m *CurrentGasPricesResponse) Reset()         { *m = CurrentGasPricesResponse{} }
func (m *CurrentGasPricesResponse) String() string { return proto.CompactTextString(m) }
func (*CurrentGasPricesResponse) ProtoMessage()    {}
func (*CurrentGasPricesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e267509eb0355f, []int{6}
}
func (m *CurrentGasPricesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CurrentGasPricesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CurrentGasPricesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CurrentGasPricesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CurrentGasPricesResponse.Merge(m, src)
}
func (m *CurrentGasPricesResponse) XXX_Size() int {
	return m.Size()
}
func (m *CurrentGasPricesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CurrentGasPricesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CurrentGasPricesResponse proto.InternalMessageInfo

func (m *CurrentGasPricesResponse) GetGasPrices() *GasPrices {
	if m != nil {
		return m.GasPrices
	}
	return nil
}

func (m *CurrentGasPricesResponse) GetAltGasPrices() []*GasPrices {
	if m != nil {
		return m.AltGasPrices
	}
	return nil
}

func init() {
	proto.RegisterEnum("penumbra.core.component.fee.v1.FeeTier_Tier", FeeTier_Tier_name, FeeTier_Tier_value)
	proto.RegisterType((*Fee)(nil), "penumbra.core.component.fee.v1.Fee")
	proto.RegisterType((*GasPrices)(nil), "penumbra.core.component.fee.v1.GasPrices")
	proto.RegisterType((*FeeTier)(nil), "penumbra.core.component.fee.v1.FeeTier")
	proto.RegisterType((*FeeParameters)(nil), "penumbra.core.component.fee.v1.FeeParameters")
	proto.RegisterType((*GenesisContent)(nil), "penumbra.core.component.fee.v1.GenesisContent")
	proto.RegisterType((*CurrentGasPricesRequest)(nil), "penumbra.core.component.fee.v1.CurrentGasPricesRequest")
	proto.RegisterType((*CurrentGasPricesResponse)(nil), "penumbra.core.component.fee.v1.CurrentGasPricesResponse")
}

func init() {
	proto.RegisterFile("penumbra/core/component/fee/v1/fee.proto", fileDescriptor_80e267509eb0355f)
}

var fileDescriptor_80e267509eb0355f = []byte{
	// 732 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x94, 0x4f, 0x4f, 0xdb, 0x48,
	0x18, 0xc6, 0x63, 0x27, 0x82, 0x64, 0x80, 0x24, 0x58, 0x68, 0x17, 0xd0, 0xca, 0x8b, 0x7c, 0x59,
	0x16, 0x15, 0x5b, 0x49, 0x2b, 0xb5, 0x4d, 0x4f, 0x24, 0xc4, 0x21, 0x15, 0x14, 0xd7, 0x01, 0x2a,
	0xa1, 0xa8, 0xd1, 0xc4, 0x79, 0x03, 0x56, 0x63, 0x3b, 0xf5, 0x8c, 0x53, 0xf8, 0x00, 0xed, 0xb9,
	0xa7, 0x1e, 0x7b, 0xe8, 0xb1, 0x77, 0xee, 0x3d, 0x56, 0x3d, 0x71, 0xec, 0xb1, 0x0a, 0xb7, 0x7e,
	0x8a, 0x6a, 0xc6, 0x89, 0x93, 0x80, 0x0a, 0x45, 0x5c, 0x92, 0xf9, 0xf3, 0x7b, 0x9e, 0x79, 0xdf,
	0xc7, 0xa3, 0x41, 0xab, 0x5d, 0x70, 0x03, 0xa7, 0xe9, 0x63, 0xcd, 0xf2, 0x7c, 0xd0, 0x2c, 0xcf,
	0xe9, 0x7a, 0x2e, 0xb8, 0x54, 0x6b, 0x03, 0x68, 0xbd, 0x1c, 0xfb, 0x53, 0xbb, 0xbe, 0x47, 0x3d,
	0x49, 0x1e, 0x92, 0x2a, 0x23, 0xd5, 0x88, 0x54, 0x19, 0xd2, 0xcb, 0x2d, 0x2b, 0x93, 0x4e, 0x98,
	0x10, 0xa0, 0xcc, 0x81, 0x0f, 0x42, 0x8f, 0x65, 0x79, 0x92, 0x71, 0x03, 0x87, 0x11, 0x6e, 0xe0,
	0x84, 0xfb, 0xca, 0x1b, 0x14, 0xd7, 0x01, 0xa4, 0x07, 0x68, 0x0a, 0x3b, 0x5e, 0xe0, 0xd2, 0x45,
	0x61, 0x45, 0x58, 0x9d, 0xc9, 0xff, 0xa3, 0x4e, 0x9e, 0xcd, 0x04, 0xbd, 0x9c, 0xba, 0xc1, 0x19,
	0x73, 0xc0, 0x4a, 0x05, 0x94, 0xe4, 0x67, 0x35, 0xec, 0xd6, 0xa2, 0xc8, 0x75, 0xff, 0x5e, 0xd2,
	0x85, 0xa5, 0x30, 0x25, 0x1b, 0x54, 0x5b, 0xe6, 0x34, 0x0e, 0x07, 0xca, 0x3b, 0x11, 0xa5, 0x2a,
	0x98, 0x18, 0xbe, 0x6d, 0x01, 0x99, 0x70, 0xca, 0xdc, 0xce, 0x49, 0x5a, 0x43, 0xf3, 0xcd, 0x8e,
	0x67, 0xbd, 0x6a, 0x90, 0x2e, 0xb6, 0xa0, 0xd1, 0x65, 0x8e, 0xbc, 0x8d, 0x84, 0x99, 0xe1, 0x1b,
	0x35, 0xb6, 0xce, 0x0f, 0x92, 0x1e, 0xa3, 0x25, 0x16, 0x23, 0xb6, 0x68, 0xe3, 0xaa, 0x46, 0xe4,
	0x9a, 0xbf, 0x06, 0x40, 0xf1, 0x92, 0x74, 0x1d, 0x49, 0x3d, 0xf0, 0xed, 0xb6, 0x6d, 0x61, 0x6a,
	0x7b, 0xee, 0x40, 0x13, 0xe7, 0x9a, 0xf9, 0xf1, 0x9d, 0x10, 0xff, 0x0f, 0x65, 0xe0, 0x04, 0xac,
	0x60, 0x8c, 0x4d, 0x70, 0x36, 0x1d, 0x2d, 0x73, 0x50, 0xf9, 0x28, 0xa0, 0x69, 0x1d, 0x60, 0xcf,
	0x06, 0x5f, 0xaa, 0xa0, 0x64, 0x1b, 0xa0, 0x41, 0x6d, 0xf0, 0x79, 0x07, 0xe9, 0xfc, 0x3d, 0xf5,
	0xfa, 0x4b, 0xa0, 0x0e, 0xa4, 0x2a, 0xfb, 0x31, 0xa7, 0xdb, 0xe1, 0x4c, 0x79, 0x8a, 0x12, 0xdc,
	0x70, 0x01, 0x65, 0xf7, 0xaa, 0x65, 0xb3, 0xb1, 0xff, 0xac, 0x66, 0x94, 0x4b, 0x55, 0xbd, 0x5a,
	0xde, 0xcc, 0xc6, 0xa4, 0x59, 0x94, 0xe4, 0xab, 0xdb, 0xbb, 0x2f, 0xb2, 0x82, 0x94, 0x41, 0x33,
	0x7c, 0xb6, 0x53, 0xde, 0xac, 0xee, 0xef, 0x64, 0x45, 0x69, 0x0e, 0xa5, 0xf8, 0xc2, 0x56, 0xb5,
	0xb2, 0x95, 0x8d, 0x2b, 0x5f, 0x04, 0x34, 0xa7, 0x03, 0x18, 0xd8, 0xc7, 0x0e, 0x50, 0xf0, 0x89,
	0x54, 0x43, 0xd9, 0xb6, 0x7d, 0x02, 0xad, 0xc6, 0x11, 0x26, 0x61, 0x6f, 0x64, 0x70, 0x6f, 0xfe,
	0xbf, 0xa9, 0xdc, 0xe8, 0x93, 0x9b, 0x69, 0x6e, 0x31, 0xba, 0x02, 0x87, 0x68, 0x21, 0x34, 0xc5,
	0x1d, 0x3a, 0x6e, 0x2c, 0xae, 0xc4, 0x6f, 0x67, 0x3c, 0xcf, 0x6d, 0x36, 0x3a, 0x34, 0x5a, 0x52,
	0x5e, 0xa2, 0x74, 0x05, 0x5c, 0x20, 0x36, 0x29, 0x79, 0x2e, 0x05, 0x97, 0x4a, 0xdb, 0x08, 0xb1,
	0xa4, 0xbb, 0xac, 0xa9, 0x61, 0xf1, 0xeb, 0x7f, 0x90, 0xf5, 0x28, 0x05, 0x33, 0xd5, 0x1e, 0x4c,
	0x89, 0xb2, 0x84, 0xfe, 0x2e, 0x05, 0xbe, 0x0f, 0xee, 0xe8, 0x4c, 0x13, 0x5e, 0x07, 0x40, 0xa8,
	0x72, 0x26, 0xa0, 0xc5, 0xab, 0x7b, 0xa4, 0xeb, 0xb9, 0x04, 0xa4, 0x2d, 0x84, 0xee, 0x12, 0x61,
	0xea, 0x28, 0x4a, 0x6f, 0x17, 0xa5, 0xef, 0x9a, 0xdb, 0x2c, 0x1e, 0x8b, 0x2c, 0xff, 0x41, 0x40,
	0xb3, 0xcf, 0x03, 0xf0, 0x4f, 0x6b, 0xe0, 0xf7, 0xd8, 0x85, 0x7e, 0x2b, 0xa0, 0xec, 0xe5, 0x46,
	0xa4, 0x87, 0x37, 0xd9, 0xff, 0x26, 0x96, 0xe5, 0x47, 0xb7, 0x17, 0x86, 0x99, 0x15, 0xcf, 0xc4,
	0xaf, 0x7d, 0x59, 0x38, 0xef, 0xcb, 0xc2, 0x8f, 0xbe, 0x2c, 0xbc, 0xbf, 0x90, 0x63, 0xe7, 0x17,
	0x72, 0xec, 0xfb, 0x85, 0x1c, 0x43, 0x8a, 0xe5, 0x39, 0x37, 0xf8, 0x16, 0x93, 0xec, 0x23, 0xb2,
	0xa7, 0xcf, 0x10, 0x0e, 0x8d, 0x23, 0x9b, 0x1e, 0x07, 0x4d, 0x06, 0x69, 0x96, 0x47, 0x1c, 0x8f,
	0x68, 0x3e, 0x74, 0xf0, 0x29, 0xf8, 0x5a, 0x2f, 0x1f, 0x0d, 0xad, 0x63, 0x6c, 0xbb, 0x44, 0xbb,
	0xfe, 0xd9, 0x7e, 0xd2, 0x06, 0xe8, 0xe5, 0x3e, 0x89, 0x09, 0xa3, 0x54, 0xd2, 0x3f, 0x8b, 0xb2,
	0x31, 0xac, 0xa2, 0xc4, 0xaa, 0x28, 0x45, 0x55, 0xe8, 0x00, 0xea, 0x41, 0xee, 0xdb, 0x08, 0xa8,
	0x33, 0xa0, 0x1e, 0x01, 0x75, 0x1d, 0xa0, 0x7e, 0x90, 0xeb, 0x8b, 0x6b, 0xd7, 0x03, 0xf5, 0x8a,
	0x51, 0xdc, 0x01, 0x8a, 0x5b, 0x98, 0xe2, 0x9f, 0xa2, 0x32, 0x84, 0x0b, 0x05, 0x46, 0xb3, 0xdf,
	0x01, 0x5e, 0x28, 0xe8, 0x00, 0x85, 0xc2, 0x41, 0xae, 0x39, 0xc5, 0x1f, 0xfc, 0xfb, 0xbf, 0x02,
	0x00, 0x00, 0xff, 0xff, 0x3a, 0xdd, 0x61, 0xb6, 0x80, 0x06, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QueryServiceClient is the client API for QueryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryServiceClient interface {
	// Get the current gas prices.
	CurrentGasPrices(ctx context.Context, in *CurrentGasPricesRequest, opts ...grpc.CallOption) (*CurrentGasPricesResponse, error)
}

type queryServiceClient struct {
	cc grpc1.ClientConn
}

func NewQueryServiceClient(cc grpc1.ClientConn) QueryServiceClient {
	return &queryServiceClient{cc}
}

func (c *queryServiceClient) CurrentGasPrices(ctx context.Context, in *CurrentGasPricesRequest, opts ...grpc.CallOption) (*CurrentGasPricesResponse, error) {
	out := new(CurrentGasPricesResponse)
	err := c.cc.Invoke(ctx, "/penumbra.core.component.fee.v1.QueryService/CurrentGasPrices", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueryServiceServer is the server API for QueryService service.
type QueryServiceServer interface {
	// Get the current gas prices.
	CurrentGasPrices(context.Context, *CurrentGasPricesRequest) (*CurrentGasPricesResponse, error)
}

// UnimplementedQueryServiceServer can be embedded to have forward compatible implementations.
type UnimplementedQueryServiceServer struct {
}

func (*UnimplementedQueryServiceServer) CurrentGasPrices(ctx context.Context, req *CurrentGasPricesRequest) (*CurrentGasPricesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CurrentGasPrices not implemented")
}

func RegisterQueryServiceServer(s grpc1.Server, srv QueryServiceServer) {
	s.RegisterService(&_QueryService_serviceDesc, srv)
}

func _QueryService_CurrentGasPrices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CurrentGasPricesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServiceServer).CurrentGasPrices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/penumbra.core.component.fee.v1.QueryService/CurrentGasPrices",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServiceServer).CurrentGasPrices(ctx, req.(*CurrentGasPricesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _QueryService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "penumbra.core.component.fee.v1.QueryService",
	HandlerType: (*QueryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CurrentGasPrices",
			Handler:    _QueryService_CurrentGasPrices_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "penumbra/core/component/fee/v1/fee.proto",
}

func (m *Fee) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Fee) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Fee) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AssetId != nil {
		{
			size, err := m.AssetId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFee(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Amount != nil {
		{
			size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFee(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GasPrices) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GasPrices) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GasPrices) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AssetId != nil {
		{
			size, err := m.AssetId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFee(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.ExecutionPrice != 0 {
		i = encodeVarintFee(dAtA, i, uint64(m.ExecutionPrice))
		i--
		dAtA[i] = 0x20
	}
	if m.VerificationPrice != 0 {
		i = encodeVarintFee(dAtA, i, uint64(m.VerificationPrice))
		i--
		dAtA[i] = 0x18
	}
	if m.CompactBlockSpacePrice != 0 {
		i = encodeVarintFee(dAtA, i, uint64(m.CompactBlockSpacePrice))
		i--
		dAtA[i] = 0x10
	}
	if m.BlockSpacePrice != 0 {
		i = encodeVarintFee(dAtA, i, uint64(m.BlockSpacePrice))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FeeTier) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeeTier) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeeTier) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FeeTier != 0 {
		i = encodeVarintFee(dAtA, i, uint64(m.FeeTier))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FeeParameters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeeParameters) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeeParameters) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FixedAltGasPrices) > 0 {
		for iNdEx := len(m.FixedAltGasPrices) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FixedAltGasPrices[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFee(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.FixedGasPrices != nil {
		{
			size, err := m.FixedGasPrices.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFee(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GenesisContent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenesisContent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenesisContent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FeeParams != nil {
		{
			size, err := m.FeeParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFee(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CurrentGasPricesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CurrentGasPricesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CurrentGasPricesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *CurrentGasPricesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CurrentGasPricesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CurrentGasPricesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AltGasPrices) > 0 {
		for iNdEx := len(m.AltGasPrices) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AltGasPrices[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFee(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.GasPrices != nil {
		{
			size, err := m.GasPrices.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFee(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintFee(dAtA []byte, offset int, v uint64) int {
	offset -= sovFee(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Fee) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Amount != nil {
		l = m.Amount.Size()
		n += 1 + l + sovFee(uint64(l))
	}
	if m.AssetId != nil {
		l = m.AssetId.Size()
		n += 1 + l + sovFee(uint64(l))
	}
	return n
}

func (m *GasPrices) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockSpacePrice != 0 {
		n += 1 + sovFee(uint64(m.BlockSpacePrice))
	}
	if m.CompactBlockSpacePrice != 0 {
		n += 1 + sovFee(uint64(m.CompactBlockSpacePrice))
	}
	if m.VerificationPrice != 0 {
		n += 1 + sovFee(uint64(m.VerificationPrice))
	}
	if m.ExecutionPrice != 0 {
		n += 1 + sovFee(uint64(m.ExecutionPrice))
	}
	if m.AssetId != nil {
		l = m.AssetId.Size()
		n += 1 + l + sovFee(uint64(l))
	}
	return n
}

func (m *FeeTier) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FeeTier != 0 {
		n += 1 + sovFee(uint64(m.FeeTier))
	}
	return n
}

func (m *FeeParameters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FixedGasPrices != nil {
		l = m.FixedGasPrices.Size()
		n += 1 + l + sovFee(uint64(l))
	}
	if len(m.FixedAltGasPrices) > 0 {
		for _, e := range m.FixedAltGasPrices {
			l = e.Size()
			n += 1 + l + sovFee(uint64(l))
		}
	}
	return n
}

func (m *GenesisContent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FeeParams != nil {
		l = m.FeeParams.Size()
		n += 1 + l + sovFee(uint64(l))
	}
	return n
}

func (m *CurrentGasPricesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *CurrentGasPricesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GasPrices != nil {
		l = m.GasPrices.Size()
		n += 1 + l + sovFee(uint64(l))
	}
	if len(m.AltGasPrices) > 0 {
		for _, e := range m.AltGasPrices {
			l = e.Size()
			n += 1 + l + sovFee(uint64(l))
		}
	}
	return n
}

func sovFee(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFee(x uint64) (n int) {
	return sovFee(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Fee) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFee
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Fee: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Fee: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFee
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFee
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFee
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Amount == nil {
				m.Amount = &v1.Amount{}
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFee
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFee
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFee
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AssetId == nil {
				m.AssetId = &v11.AssetId{}
			}
			if err := m.AssetId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFee(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFee
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GasPrices) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFee
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GasPrices: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GasPrices: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockSpacePrice", wireType)
			}
			m.BlockSpacePrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFee
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockSpacePrice |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactBlockSpacePrice", wireType)
			}
			m.CompactBlockSpacePrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFee
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompactBlockSpacePrice |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerificationPrice", wireType)
			}
			m.VerificationPrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFee
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VerificationPrice |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutionPrice", wireType)
			}
			m.ExecutionPrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFee
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExecutionPrice |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFee
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFee
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFee
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AssetId == nil {
				m.AssetId = &v11.AssetId{}
			}
			if err := m.AssetId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFee(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFee
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeeTier) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFee
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeeTier: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeeTier: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeTier", wireType)
			}
			m.FeeTier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFee
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FeeTier |= FeeTier_Tier(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFee(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFee
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeeParameters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFee
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeeParameters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeeParameters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FixedGasPrices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFee
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFee
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFee
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FixedGasPrices == nil {
				m.FixedGasPrices = &GasPrices{}
			}
			if err := m.FixedGasPrices.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FixedAltGasPrices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFee
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFee
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFee
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FixedAltGasPrices = append(m.FixedAltGasPrices, &GasPrices{})
			if err := m.FixedAltGasPrices[len(m.FixedAltGasPrices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFee(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFee
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenesisContent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFee
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenesisContent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenesisContent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFee
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFee
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFee
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FeeParams == nil {
				m.FeeParams = &FeeParameters{}
			}
			if err := m.FeeParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFee(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFee
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CurrentGasPricesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFee
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CurrentGasPricesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CurrentGasPricesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFee(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFee
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CurrentGasPricesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFee
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CurrentGasPricesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CurrentGasPricesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasPrices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFee
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFee
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFee
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GasPrices == nil {
				m.GasPrices = &GasPrices{}
			}
			if err := m.GasPrices.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AltGasPrices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFee
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFee
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFee
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AltGasPrices = append(m.AltGasPrices, &GasPrices{})
			if err := m.AltGasPrices[len(m.AltGasPrices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFee(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFee
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFee(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFee
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFee
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFee
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFee
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFee
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFee
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFee        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFee          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFee = fmt.Errorf("proto: unexpected end of group")
)
