// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: penumbra/core/component/dex/v1/dex.proto

package dexv1

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	v14 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/asset/v1"
	v11 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/component/fee/v1"
	v1 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/component/sct/v1"
	v17 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/component/shielded_pool/v1"
	v15 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/keys/v1"
	v13 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/num/v1"
	v16 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/txhash/v1"
	v12 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/crypto/tct/v1"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type PositionState_PositionStateEnum int32

const (
	PositionState_POSITION_STATE_ENUM_UNSPECIFIED PositionState_PositionStateEnum = 0
	// The position has been opened, is active, has reserves and accumulated
	// fees, and can be traded against.
	PositionState_POSITION_STATE_ENUM_OPENED PositionState_PositionStateEnum = 1
	// The position has been closed, is inactive and can no longer be traded
	// against, but still has reserves and accumulated fees.
	PositionState_POSITION_STATE_ENUM_CLOSED PositionState_PositionStateEnum = 2
	// The final reserves and accumulated fees have been withdrawn, leaving an
	// empty, inactive position awaiting (possible) retroactive rewards.
	//
	// Positions can be withdrawn from multiple times, incrementing a sequence
	// number each time.
	PositionState_POSITION_STATE_ENUM_WITHDRAWN PositionState_PositionStateEnum = 3
	// Deprecated.
	PositionState_POSITION_STATE_ENUM_CLAIMED PositionState_PositionStateEnum = 4 // Deprecated: Do not use.
)

var PositionState_PositionStateEnum_name = map[int32]string{
	0: "POSITION_STATE_ENUM_UNSPECIFIED",
	1: "POSITION_STATE_ENUM_OPENED",
	2: "POSITION_STATE_ENUM_CLOSED",
	3: "POSITION_STATE_ENUM_WITHDRAWN",
	4: "POSITION_STATE_ENUM_CLAIMED",
}

var PositionState_PositionStateEnum_value = map[string]int32{
	"POSITION_STATE_ENUM_UNSPECIFIED": 0,
	"POSITION_STATE_ENUM_OPENED":      1,
	"POSITION_STATE_ENUM_CLOSED":      2,
	"POSITION_STATE_ENUM_WITHDRAWN":   3,
	"POSITION_STATE_ENUM_CLAIMED":     4,
}

func (x PositionState_PositionStateEnum) String() string {
	return proto.EnumName(PositionState_PositionStateEnum_name, int32(x))
}

func (PositionState_PositionStateEnum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{20, 0}
}

// A Penumbra ZK swap proof.
type ZKSwapProof struct {
	Inner []byte `protobuf:"bytes,1,opt,name=inner,proto3" json:"inner,omitempty"`
}

func (m *ZKSwapProof) Reset()         { *m = ZKSwapProof{} }
func (m *ZKSwapProof) String() string { return proto.CompactTextString(m) }
func (*ZKSwapProof) ProtoMessage()    {}
func (*ZKSwapProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{0}
}
func (m *ZKSwapProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZKSwapProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZKSwapProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZKSwapProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZKSwapProof.Merge(m, src)
}
func (m *ZKSwapProof) XXX_Size() int {
	return m.Size()
}
func (m *ZKSwapProof) XXX_DiscardUnknown() {
	xxx_messageInfo_ZKSwapProof.DiscardUnknown(m)
}

var xxx_messageInfo_ZKSwapProof proto.InternalMessageInfo

func (m *ZKSwapProof) GetInner() []byte {
	if m != nil {
		return m.Inner
	}
	return nil
}

// A Penumbra ZK swap claim proof.
type ZKSwapClaimProof struct {
	Inner []byte `protobuf:"bytes,1,opt,name=inner,proto3" json:"inner,omitempty"`
}

func (m *ZKSwapClaimProof) Reset()         { *m = ZKSwapClaimProof{} }
func (m *ZKSwapClaimProof) String() string { return proto.CompactTextString(m) }
func (*ZKSwapClaimProof) ProtoMessage()    {}
func (*ZKSwapClaimProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{1}
}
func (m *ZKSwapClaimProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZKSwapClaimProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZKSwapClaimProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZKSwapClaimProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZKSwapClaimProof.Merge(m, src)
}
func (m *ZKSwapClaimProof) XXX_Size() int {
	return m.Size()
}
func (m *ZKSwapClaimProof) XXX_DiscardUnknown() {
	xxx_messageInfo_ZKSwapClaimProof.DiscardUnknown(m)
}

var xxx_messageInfo_ZKSwapClaimProof proto.InternalMessageInfo

func (m *ZKSwapClaimProof) GetInner() []byte {
	if m != nil {
		return m.Inner
	}
	return nil
}

// A transaction action that submits a swap to the dex.
type Swap struct {
	// Contains the Swap proof.
	Proof *ZKSwapProof `protobuf:"bytes,1,opt,name=proof,proto3" json:"proof,omitempty"`
	// Encapsulates the authorized fields of the Swap action, used in signing.
	Body *SwapBody `protobuf:"bytes,4,opt,name=body,proto3" json:"body,omitempty"`
}

func (m *Swap) Reset()         { *m = Swap{} }
func (m *Swap) String() string { return proto.CompactTextString(m) }
func (*Swap) ProtoMessage()    {}
func (*Swap) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{2}
}
func (m *Swap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Swap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Swap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Swap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Swap.Merge(m, src)
}
func (m *Swap) XXX_Size() int {
	return m.Size()
}
func (m *Swap) XXX_DiscardUnknown() {
	xxx_messageInfo_Swap.DiscardUnknown(m)
}

var xxx_messageInfo_Swap proto.InternalMessageInfo

func (m *Swap) GetProof() *ZKSwapProof {
	if m != nil {
		return m.Proof
	}
	return nil
}

func (m *Swap) GetBody() *SwapBody {
	if m != nil {
		return m.Body
	}
	return nil
}

// A transaction action that obtains assets previously confirmed
// via a Swap transaction. Does not include a spend authorization
// signature, as it is only capable of consuming the NFT from a
// Swap transaction.
type SwapClaim struct {
	// Contains the SwapClaim proof.
	Proof *ZKSwapClaimProof `protobuf:"bytes,1,opt,name=proof,proto3" json:"proof,omitempty"`
	// Encapsulates the authorized fields of the SwapClaim action, used in signing.
	Body *SwapClaimBody `protobuf:"bytes,2,opt,name=body,proto3" json:"body,omitempty"`
	// The epoch duration of the chain when the swap claim took place.
	EpochDuration uint64 `protobuf:"varint,7,opt,name=epoch_duration,json=epochDuration,proto3" json:"epoch_duration,omitempty"`
}

func (m *SwapClaim) Reset()         { *m = SwapClaim{} }
func (m *SwapClaim) String() string { return proto.CompactTextString(m) }
func (*SwapClaim) ProtoMessage()    {}
func (*SwapClaim) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{3}
}
func (m *SwapClaim) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapClaim) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapClaim.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapClaim) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapClaim.Merge(m, src)
}
func (m *SwapClaim) XXX_Size() int {
	return m.Size()
}
func (m *SwapClaim) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapClaim.DiscardUnknown(m)
}

var xxx_messageInfo_SwapClaim proto.InternalMessageInfo

func (m *SwapClaim) GetProof() *ZKSwapClaimProof {
	if m != nil {
		return m.Proof
	}
	return nil
}

func (m *SwapClaim) GetBody() *SwapClaimBody {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *SwapClaim) GetEpochDuration() uint64 {
	if m != nil {
		return m.EpochDuration
	}
	return 0
}

// Encapsulates the authorized fields of the SwapClaim action, used in signing.
type SwapClaimBody struct {
	// The nullifier for the Swap commitment to be consumed.
	Nullifier *v1.Nullifier `protobuf:"bytes,1,opt,name=nullifier,proto3" json:"nullifier,omitempty"`
	// The fee allows `SwapClaim` without an additional `Spend`.
	Fee *v11.Fee `protobuf:"bytes,2,opt,name=fee,proto3" json:"fee,omitempty"`
	// Note output for asset 1.
	Output_1Commitment *v12.StateCommitment `protobuf:"bytes,3,opt,name=output_1_commitment,json=output1Commitment,proto3" json:"output_1_commitment,omitempty"`
	// Note output for asset 2.
	Output_2Commitment *v12.StateCommitment `protobuf:"bytes,4,opt,name=output_2_commitment,json=output2Commitment,proto3" json:"output_2_commitment,omitempty"`
	// Input and output amounts, and asset IDs for the assets in the swap.
	OutputData *BatchSwapOutputData `protobuf:"bytes,6,opt,name=output_data,json=outputData,proto3" json:"output_data,omitempty"`
}

func (m *SwapClaimBody) Reset()         { *m = SwapClaimBody{} }
func (m *SwapClaimBody) String() string { return proto.CompactTextString(m) }
func (*SwapClaimBody) ProtoMessage()    {}
func (*SwapClaimBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{4}
}
func (m *SwapClaimBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapClaimBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapClaimBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapClaimBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapClaimBody.Merge(m, src)
}
func (m *SwapClaimBody) XXX_Size() int {
	return m.Size()
}
func (m *SwapClaimBody) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapClaimBody.DiscardUnknown(m)
}

var xxx_messageInfo_SwapClaimBody proto.InternalMessageInfo

func (m *SwapClaimBody) GetNullifier() *v1.Nullifier {
	if m != nil {
		return m.Nullifier
	}
	return nil
}

func (m *SwapClaimBody) GetFee() *v11.Fee {
	if m != nil {
		return m.Fee
	}
	return nil
}

func (m *SwapClaimBody) GetOutput_1Commitment() *v12.StateCommitment {
	if m != nil {
		return m.Output_1Commitment
	}
	return nil
}

func (m *SwapClaimBody) GetOutput_2Commitment() *v12.StateCommitment {
	if m != nil {
		return m.Output_2Commitment
	}
	return nil
}

func (m *SwapClaimBody) GetOutputData() *BatchSwapOutputData {
	if m != nil {
		return m.OutputData
	}
	return nil
}

// The authorized data of a Swap transaction.
type SwapBody struct {
	// The trading pair to swap.
	TradingPair *TradingPair `protobuf:"bytes,1,opt,name=trading_pair,json=tradingPair,proto3" json:"trading_pair,omitempty"`
	// The amount for asset 1.
	Delta_1I *v13.Amount `protobuf:"bytes,2,opt,name=delta_1_i,json=delta1I,proto3" json:"delta_1_i,omitempty"`
	// The amount for asset 2.
	Delta_2I *v13.Amount `protobuf:"bytes,3,opt,name=delta_2_i,json=delta2I,proto3" json:"delta_2_i,omitempty"`
	// A commitment to a prepaid fee for the future SwapClaim.
	// This is recorded separately from delta_j_i because it's shielded;
	// in the future we'll want separate commitments to each delta_j_i
	// anyways in order to prove consistency with flow encryption.
	FeeCommitment *v14.BalanceCommitment `protobuf:"bytes,4,opt,name=fee_commitment,json=feeCommitment,proto3" json:"fee_commitment,omitempty"`
	// The swap commitment and encryption of the swap data.
	Payload *SwapPayload `protobuf:"bytes,5,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *SwapBody) Reset()         { *m = SwapBody{} }
func (m *SwapBody) String() string { return proto.CompactTextString(m) }
func (*SwapBody) ProtoMessage()    {}
func (*SwapBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{5}
}
func (m *SwapBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapBody.Merge(m, src)
}
func (m *SwapBody) XXX_Size() int {
	return m.Size()
}
func (m *SwapBody) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapBody.DiscardUnknown(m)
}

var xxx_messageInfo_SwapBody proto.InternalMessageInfo

func (m *SwapBody) GetTradingPair() *TradingPair {
	if m != nil {
		return m.TradingPair
	}
	return nil
}

func (m *SwapBody) GetDelta_1I() *v13.Amount {
	if m != nil {
		return m.Delta_1I
	}
	return nil
}

func (m *SwapBody) GetDelta_2I() *v13.Amount {
	if m != nil {
		return m.Delta_2I
	}
	return nil
}

func (m *SwapBody) GetFeeCommitment() *v14.BalanceCommitment {
	if m != nil {
		return m.FeeCommitment
	}
	return nil
}

func (m *SwapBody) GetPayload() *SwapPayload {
	if m != nil {
		return m.Payload
	}
	return nil
}

type SwapPayload struct {
	Commitment    *v12.StateCommitment `protobuf:"bytes,1,opt,name=commitment,proto3" json:"commitment,omitempty"`
	EncryptedSwap []byte               `protobuf:"bytes,2,opt,name=encrypted_swap,json=encryptedSwap,proto3" json:"encrypted_swap,omitempty"`
}

func (m *SwapPayload) Reset()         { *m = SwapPayload{} }
func (m *SwapPayload) String() string { return proto.CompactTextString(m) }
func (*SwapPayload) ProtoMessage()    {}
func (*SwapPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{6}
}
func (m *SwapPayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapPayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapPayload.Merge(m, src)
}
func (m *SwapPayload) XXX_Size() int {
	return m.Size()
}
func (m *SwapPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapPayload.DiscardUnknown(m)
}

var xxx_messageInfo_SwapPayload proto.InternalMessageInfo

func (m *SwapPayload) GetCommitment() *v12.StateCommitment {
	if m != nil {
		return m.Commitment
	}
	return nil
}

func (m *SwapPayload) GetEncryptedSwap() []byte {
	if m != nil {
		return m.EncryptedSwap
	}
	return nil
}

type SwapPlaintext struct {
	// The trading pair to swap.
	TradingPair *TradingPair `protobuf:"bytes,1,opt,name=trading_pair,json=tradingPair,proto3" json:"trading_pair,omitempty"`
	// Input amount of asset 1
	Delta_1I *v13.Amount `protobuf:"bytes,2,opt,name=delta_1_i,json=delta1I,proto3" json:"delta_1_i,omitempty"`
	// Input amount of asset 2
	Delta_2I *v13.Amount `protobuf:"bytes,3,opt,name=delta_2_i,json=delta2I,proto3" json:"delta_2_i,omitempty"`
	// Pre-paid fee to claim the swap
	ClaimFee *v11.Fee `protobuf:"bytes,4,opt,name=claim_fee,json=claimFee,proto3" json:"claim_fee,omitempty"`
	// Address that will claim the swap outputs via SwapClaim.
	ClaimAddress *v15.Address `protobuf:"bytes,5,opt,name=claim_address,json=claimAddress,proto3" json:"claim_address,omitempty"`
	// Swap rseed (blinding factors are derived from this)
	Rseed []byte `protobuf:"bytes,6,opt,name=rseed,proto3" json:"rseed,omitempty"`
}

func (m *SwapPlaintext) Reset()         { *m = SwapPlaintext{} }
func (m *SwapPlaintext) String() string { return proto.CompactTextString(m) }
func (*SwapPlaintext) ProtoMessage()    {}
func (*SwapPlaintext) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{7}
}
func (m *SwapPlaintext) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapPlaintext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapPlaintext.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapPlaintext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapPlaintext.Merge(m, src)
}
func (m *SwapPlaintext) XXX_Size() int {
	return m.Size()
}
func (m *SwapPlaintext) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapPlaintext.DiscardUnknown(m)
}

var xxx_messageInfo_SwapPlaintext proto.InternalMessageInfo

func (m *SwapPlaintext) GetTradingPair() *TradingPair {
	if m != nil {
		return m.TradingPair
	}
	return nil
}

func (m *SwapPlaintext) GetDelta_1I() *v13.Amount {
	if m != nil {
		return m.Delta_1I
	}
	return nil
}

func (m *SwapPlaintext) GetDelta_2I() *v13.Amount {
	if m != nil {
		return m.Delta_2I
	}
	return nil
}

func (m *SwapPlaintext) GetClaimFee() *v11.Fee {
	if m != nil {
		return m.ClaimFee
	}
	return nil
}

func (m *SwapPlaintext) GetClaimAddress() *v15.Address {
	if m != nil {
		return m.ClaimAddress
	}
	return nil
}

func (m *SwapPlaintext) GetRseed() []byte {
	if m != nil {
		return m.Rseed
	}
	return nil
}

type SwapPlan struct {
	// The plaintext version of the swap to be performed.
	SwapPlaintext *SwapPlaintext `protobuf:"bytes,1,opt,name=swap_plaintext,json=swapPlaintext,proto3" json:"swap_plaintext,omitempty"`
	// The blinding factor for the fee commitment. The fee in the SwapPlan is private to prevent linkability with the SwapClaim.
	FeeBlinding []byte `protobuf:"bytes,2,opt,name=fee_blinding,json=feeBlinding,proto3" json:"fee_blinding,omitempty"`
	// The first blinding factor to use for the ZK swap proof.
	ProofBlindingR []byte `protobuf:"bytes,3,opt,name=proof_blinding_r,json=proofBlindingR,proto3" json:"proof_blinding_r,omitempty"`
	// The second blinding factor to use for the ZK swap proof.
	ProofBlindingS []byte `protobuf:"bytes,4,opt,name=proof_blinding_s,json=proofBlindingS,proto3" json:"proof_blinding_s,omitempty"`
}

func (m *SwapPlan) Reset()         { *m = SwapPlan{} }
func (m *SwapPlan) String() string { return proto.CompactTextString(m) }
func (*SwapPlan) ProtoMessage()    {}
func (*SwapPlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{8}
}
func (m *SwapPlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapPlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapPlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapPlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapPlan.Merge(m, src)
}
func (m *SwapPlan) XXX_Size() int {
	return m.Size()
}
func (m *SwapPlan) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapPlan.DiscardUnknown(m)
}

var xxx_messageInfo_SwapPlan proto.InternalMessageInfo

func (m *SwapPlan) GetSwapPlaintext() *SwapPlaintext {
	if m != nil {
		return m.SwapPlaintext
	}
	return nil
}

func (m *SwapPlan) GetFeeBlinding() []byte {
	if m != nil {
		return m.FeeBlinding
	}
	return nil
}

func (m *SwapPlan) GetProofBlindingR() []byte {
	if m != nil {
		return m.ProofBlindingR
	}
	return nil
}

func (m *SwapPlan) GetProofBlindingS() []byte {
	if m != nil {
		return m.ProofBlindingS
	}
	return nil
}

type SwapClaimPlan struct {
	// The plaintext version of the swap to be performed.
	SwapPlaintext *SwapPlaintext `protobuf:"bytes,1,opt,name=swap_plaintext,json=swapPlaintext,proto3" json:"swap_plaintext,omitempty"`
	// The position of the swap commitment.
	Position uint64 `protobuf:"varint,2,opt,name=position,proto3" json:"position,omitempty"`
	// Input and output amounts for the Swap.
	OutputData *BatchSwapOutputData `protobuf:"bytes,3,opt,name=output_data,json=outputData,proto3" json:"output_data,omitempty"`
	// The epoch duration, used in proving.
	EpochDuration uint64 `protobuf:"varint,4,opt,name=epoch_duration,json=epochDuration,proto3" json:"epoch_duration,omitempty"`
	// The first blinding factor to use for the ZK swap claim proof.
	ProofBlindingR []byte `protobuf:"bytes,5,opt,name=proof_blinding_r,json=proofBlindingR,proto3" json:"proof_blinding_r,omitempty"`
	// The second blinding factor to use for the ZK swap claim proof.
	ProofBlindingS []byte `protobuf:"bytes,6,opt,name=proof_blinding_s,json=proofBlindingS,proto3" json:"proof_blinding_s,omitempty"`
}

func (m *SwapClaimPlan) Reset()         { *m = SwapClaimPlan{} }
func (m *SwapClaimPlan) String() string { return proto.CompactTextString(m) }
func (*SwapClaimPlan) ProtoMessage()    {}
func (*SwapClaimPlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{9}
}
func (m *SwapClaimPlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapClaimPlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapClaimPlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapClaimPlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapClaimPlan.Merge(m, src)
}
func (m *SwapClaimPlan) XXX_Size() int {
	return m.Size()
}
func (m *SwapClaimPlan) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapClaimPlan.DiscardUnknown(m)
}

var xxx_messageInfo_SwapClaimPlan proto.InternalMessageInfo

func (m *SwapClaimPlan) GetSwapPlaintext() *SwapPlaintext {
	if m != nil {
		return m.SwapPlaintext
	}
	return nil
}

func (m *SwapClaimPlan) GetPosition() uint64 {
	if m != nil {
		return m.Position
	}
	return 0
}

func (m *SwapClaimPlan) GetOutputData() *BatchSwapOutputData {
	if m != nil {
		return m.OutputData
	}
	return nil
}

func (m *SwapClaimPlan) GetEpochDuration() uint64 {
	if m != nil {
		return m.EpochDuration
	}
	return 0
}

func (m *SwapClaimPlan) GetProofBlindingR() []byte {
	if m != nil {
		return m.ProofBlindingR
	}
	return nil
}

func (m *SwapClaimPlan) GetProofBlindingS() []byte {
	if m != nil {
		return m.ProofBlindingS
	}
	return nil
}

type SwapView struct {
	// Types that are valid to be assigned to SwapView:
	//	*SwapView_Visible_
	//	*SwapView_Opaque_
	SwapView isSwapView_SwapView `protobuf_oneof:"swap_view"`
}

func (m *SwapView) Reset()         { *m = SwapView{} }
func (m *SwapView) String() string { return proto.CompactTextString(m) }
func (*SwapView) ProtoMessage()    {}
func (*SwapView) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{10}
}
func (m *SwapView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapView.Merge(m, src)
}
func (m *SwapView) XXX_Size() int {
	return m.Size()
}
func (m *SwapView) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapView.DiscardUnknown(m)
}

var xxx_messageInfo_SwapView proto.InternalMessageInfo

type isSwapView_SwapView interface {
	isSwapView_SwapView()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SwapView_Visible_ struct {
	Visible *SwapView_Visible `protobuf:"bytes,1,opt,name=visible,proto3,oneof" json:"visible,omitempty"`
}
type SwapView_Opaque_ struct {
	Opaque *SwapView_Opaque `protobuf:"bytes,2,opt,name=opaque,proto3,oneof" json:"opaque,omitempty"`
}

func (*SwapView_Visible_) isSwapView_SwapView() {}
func (*SwapView_Opaque_) isSwapView_SwapView()  {}

func (m *SwapView) GetSwapView() isSwapView_SwapView {
	if m != nil {
		return m.SwapView
	}
	return nil
}

func (m *SwapView) GetVisible() *SwapView_Visible {
	if x, ok := m.GetSwapView().(*SwapView_Visible_); ok {
		return x.Visible
	}
	return nil
}

func (m *SwapView) GetOpaque() *SwapView_Opaque {
	if x, ok := m.GetSwapView().(*SwapView_Opaque_); ok {
		return x.Opaque
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SwapView) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SwapView_Visible_)(nil),
		(*SwapView_Opaque_)(nil),
	}
}

type SwapView_Visible struct {
	// The underlying Swap action being viewed.
	Swap *Swap `protobuf:"bytes,1,opt,name=swap,proto3" json:"swap,omitempty"`
	// The plaintext of the encrypted swap.
	SwapPlaintext *SwapPlaintext `protobuf:"bytes,3,opt,name=swap_plaintext,json=swapPlaintext,proto3" json:"swap_plaintext,omitempty"`
	// Optionally, a transaction hash for the transaction that claimed this
	// swap.
	//
	// Presence of this field signals that the swap outputs have been claimed
	// and that the claim transaction is known to the view server.  Absence of
	// this field does not indicate anything about the state of the swap.
	//
	// This field allows frontends to more easily crossreference the sequence of
	// Swap/SwapClaim actions.
	ClaimTx *v16.TransactionId `protobuf:"bytes,4,opt,name=claim_tx,json=claimTx,proto3" json:"claim_tx,omitempty"`
	// Optionally, if the swap has been confirmed, the batch price it received.
	//
	// As soon as the swap is detected, the view server can in principle record
	// the relevant BSOD and provide it as part of the view.  This allows providing
	// info about the execution of the swap.
	BatchSwapOutputData *BatchSwapOutputData `protobuf:"bytes,20,opt,name=batch_swap_output_data,json=batchSwapOutputData,proto3" json:"batch_swap_output_data,omitempty"`
	// Optionally, if the swap has been confirmed, the output note of asset 1.
	//
	// This is the note that will be minted by the SwapClaim action.
	Output_1 *v17.NoteView `protobuf:"bytes,30,opt,name=output_1,json=output1,proto3" json:"output_1,omitempty"`
	// Optionally, if the swap has been confirmed, the output note of asset 2.
	//
	// This is the note that will be minted by the SwapClaim action.
	Output_2 *v17.NoteView `protobuf:"bytes,31,opt,name=output_2,json=output2,proto3" json:"output_2,omitempty"`
	// Optionally, metadata about asset 1 in the `swap`'s trading pair.
	Asset_1Metadata *v14.Metadata `protobuf:"bytes,40,opt,name=asset_1_metadata,json=asset1Metadata,proto3" json:"asset_1_metadata,omitempty"`
	// Optionally, metadata about asset 2 in the `swap`'s trading pair.
	Asset_2Metadata *v14.Metadata `protobuf:"bytes,41,opt,name=asset_2_metadata,json=asset2Metadata,proto3" json:"asset_2_metadata,omitempty"`
}

func (m *SwapView_Visible) Reset()         { *m = SwapView_Visible{} }
func (m *SwapView_Visible) String() string { return proto.CompactTextString(m) }
func (*SwapView_Visible) ProtoMessage()    {}
func (*SwapView_Visible) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{10, 0}
}
func (m *SwapView_Visible) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapView_Visible) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapView_Visible.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapView_Visible) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapView_Visible.Merge(m, src)
}
func (m *SwapView_Visible) XXX_Size() int {
	return m.Size()
}
func (m *SwapView_Visible) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapView_Visible.DiscardUnknown(m)
}

var xxx_messageInfo_SwapView_Visible proto.InternalMessageInfo

func (m *SwapView_Visible) GetSwap() *Swap {
	if m != nil {
		return m.Swap
	}
	return nil
}

func (m *SwapView_Visible) GetSwapPlaintext() *SwapPlaintext {
	if m != nil {
		return m.SwapPlaintext
	}
	return nil
}

func (m *SwapView_Visible) GetClaimTx() *v16.TransactionId {
	if m != nil {
		return m.ClaimTx
	}
	return nil
}

func (m *SwapView_Visible) GetBatchSwapOutputData() *BatchSwapOutputData {
	if m != nil {
		return m.BatchSwapOutputData
	}
	return nil
}

func (m *SwapView_Visible) GetOutput_1() *v17.NoteView {
	if m != nil {
		return m.Output_1
	}
	return nil
}

func (m *SwapView_Visible) GetOutput_2() *v17.NoteView {
	if m != nil {
		return m.Output_2
	}
	return nil
}

func (m *SwapView_Visible) GetAsset_1Metadata() *v14.Metadata {
	if m != nil {
		return m.Asset_1Metadata
	}
	return nil
}

func (m *SwapView_Visible) GetAsset_2Metadata() *v14.Metadata {
	if m != nil {
		return m.Asset_2Metadata
	}
	return nil
}

type SwapView_Opaque struct {
	Swap *Swap `protobuf:"bytes,1,opt,name=swap,proto3" json:"swap,omitempty"`
	// Optionally, if the swap has been confirmed, the batch price it received.
	//
	// As soon as the swap is detected, the view server can in principle record
	// the relevant BSOD and provide it as part of the view.  This allows providing
	// info about the execution of the swap.
	BatchSwapOutputData *BatchSwapOutputData `protobuf:"bytes,20,opt,name=batch_swap_output_data,json=batchSwapOutputData,proto3" json:"batch_swap_output_data,omitempty"`
	// Optionally, if the swap has been confirmed, the output value of asset 1.
	//
	// This is the value of the note that will be minted by the SwapClaim action.
	// Note that unlike the `Visible` variant, this is only a `ValueView` since
	// the details of the note (in particular the claim address) are not publicly known.
	Output_1Value *v14.ValueView `protobuf:"bytes,30,opt,name=output_1_value,json=output1Value,proto3" json:"output_1_value,omitempty"`
	// Optionally, if the swap has been confirmed, the output value of asset 2.
	//
	// This is the note that will be minted by the SwapClaim action.
	// Note that unlike the `Visible` variant, this is only a `ValueView` since
	// the details of the note (in particular the claim address) are not publicly known.
	Output_2Value *v14.ValueView `protobuf:"bytes,31,opt,name=output_2_value,json=output2Value,proto3" json:"output_2_value,omitempty"`
	// Optionally, metadata about asset 1 in the `swap`'s trading pair.
	Asset_1Metadata *v14.Metadata `protobuf:"bytes,40,opt,name=asset_1_metadata,json=asset1Metadata,proto3" json:"asset_1_metadata,omitempty"`
	// Optionally, metadata about asset 2 in the `swap`'s trading pair.
	Asset_2Metadata *v14.Metadata `protobuf:"bytes,41,opt,name=asset_2_metadata,json=asset2Metadata,proto3" json:"asset_2_metadata,omitempty"`
}

func (m *SwapView_Opaque) Reset()         { *m = SwapView_Opaque{} }
func (m *SwapView_Opaque) String() string { return proto.CompactTextString(m) }
func (*SwapView_Opaque) ProtoMessage()    {}
func (*SwapView_Opaque) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{10, 1}
}
func (m *SwapView_Opaque) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapView_Opaque) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapView_Opaque.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapView_Opaque) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapView_Opaque.Merge(m, src)
}
func (m *SwapView_Opaque) XXX_Size() int {
	return m.Size()
}
func (m *SwapView_Opaque) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapView_Opaque.DiscardUnknown(m)
}

var xxx_messageInfo_SwapView_Opaque proto.InternalMessageInfo

func (m *SwapView_Opaque) GetSwap() *Swap {
	if m != nil {
		return m.Swap
	}
	return nil
}

func (m *SwapView_Opaque) GetBatchSwapOutputData() *BatchSwapOutputData {
	if m != nil {
		return m.BatchSwapOutputData
	}
	return nil
}

func (m *SwapView_Opaque) GetOutput_1Value() *v14.ValueView {
	if m != nil {
		return m.Output_1Value
	}
	return nil
}

func (m *SwapView_Opaque) GetOutput_2Value() *v14.ValueView {
	if m != nil {
		return m.Output_2Value
	}
	return nil
}

func (m *SwapView_Opaque) GetAsset_1Metadata() *v14.Metadata {
	if m != nil {
		return m.Asset_1Metadata
	}
	return nil
}

func (m *SwapView_Opaque) GetAsset_2Metadata() *v14.Metadata {
	if m != nil {
		return m.Asset_2Metadata
	}
	return nil
}

type SwapClaimView struct {
	// Types that are valid to be assigned to SwapClaimView:
	//
	//	*SwapClaimView_Visible_
	//	*SwapClaimView_Opaque_
	SwapClaimView isSwapClaimView_SwapClaimView `protobuf_oneof:"swap_claim_view"`
}

func (m *SwapClaimView) Reset()         { *m = SwapClaimView{} }
func (m *SwapClaimView) String() string { return proto.CompactTextString(m) }
func (*SwapClaimView) ProtoMessage()    {}
func (*SwapClaimView) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{11}
}
func (m *SwapClaimView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapClaimView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapClaimView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapClaimView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapClaimView.Merge(m, src)
}
func (m *SwapClaimView) XXX_Size() int {
	return m.Size()
}
func (m *SwapClaimView) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapClaimView.DiscardUnknown(m)
}

var xxx_messageInfo_SwapClaimView proto.InternalMessageInfo

type isSwapClaimView_SwapClaimView interface {
	isSwapClaimView_SwapClaimView()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SwapClaimView_Visible_ struct {
	Visible *SwapClaimView_Visible `protobuf:"bytes,1,opt,name=visible,proto3,oneof" json:"visible,omitempty"`
}
type SwapClaimView_Opaque_ struct {
	Opaque *SwapClaimView_Opaque `protobuf:"bytes,2,opt,name=opaque,proto3,oneof" json:"opaque,omitempty"`
}

func (*SwapClaimView_Visible_) isSwapClaimView_SwapClaimView() {}
func (*SwapClaimView_Opaque_) isSwapClaimView_SwapClaimView()  {}

func (m *SwapClaimView) GetSwapClaimView() isSwapClaimView_SwapClaimView {
	if m != nil {
		return m.SwapClaimView
	}
	return nil
}

func (m *SwapClaimView) GetVisible() *SwapClaimView_Visible {
	if x, ok := m.GetSwapClaimView().(*SwapClaimView_Visible_); ok {
		return x.Visible
	}
	return nil
}

func (m *SwapClaimView) GetOpaque() *SwapClaimView_Opaque {
	if x, ok := m.GetSwapClaimView().(*SwapClaimView_Opaque_); ok {
		return x.Opaque
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SwapClaimView) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SwapClaimView_Visible_)(nil),
		(*SwapClaimView_Opaque_)(nil),
	}
}

type SwapClaimView_Visible struct {
	SwapClaim *SwapClaim    `protobuf:"bytes,1,opt,name=swap_claim,json=swapClaim,proto3" json:"swap_claim,omitempty"`
	Output_1  *v17.NoteView `protobuf:"bytes,2,opt,name=output_1,json=output1,proto3" json:"output_1,omitempty"`
	Output_2  *v17.NoteView `protobuf:"bytes,3,opt,name=output_2,json=output2,proto3" json:"output_2,omitempty"`
	// Optionally, a transaction hash for the transaction that created the swap
	// this action claims.
	//
	// This field allows frontends to more easily crossreference the sequence of
	// Swap/SwapClaim actions.
	SwapTx *v16.TransactionId `protobuf:"bytes,4,opt,name=swap_tx,json=swapTx,proto3" json:"swap_tx,omitempty"`
}

func (m *SwapClaimView_Visible) Reset()         { *m = SwapClaimView_Visible{} }
func (m *SwapClaimView_Visible) String() string { return proto.CompactTextString(m) }
func (*SwapClaimView_Visible) ProtoMessage()    {}
func (*SwapClaimView_Visible) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{11, 0}
}
func (m *SwapClaimView_Visible) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapClaimView_Visible) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapClaimView_Visible.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapClaimView_Visible) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapClaimView_Visible.Merge(m, src)
}
func (m *SwapClaimView_Visible) XXX_Size() int {
	return m.Size()
}
func (m *SwapClaimView_Visible) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapClaimView_Visible.DiscardUnknown(m)
}

var xxx_messageInfo_SwapClaimView_Visible proto.InternalMessageInfo

func (m *SwapClaimView_Visible) GetSwapClaim() *SwapClaim {
	if m != nil {
		return m.SwapClaim
	}
	return nil
}

func (m *SwapClaimView_Visible) GetOutput_1() *v17.NoteView {
	if m != nil {
		return m.Output_1
	}
	return nil
}

func (m *SwapClaimView_Visible) GetOutput_2() *v17.NoteView {
	if m != nil {
		return m.Output_2
	}
	return nil
}

func (m *SwapClaimView_Visible) GetSwapTx() *v16.TransactionId {
	if m != nil {
		return m.SwapTx
	}
	return nil
}

type SwapClaimView_Opaque struct {
	SwapClaim *SwapClaim `protobuf:"bytes,1,opt,name=swap_claim,json=swapClaim,proto3" json:"swap_claim,omitempty"`
}

func (m *SwapClaimView_Opaque) Reset()         { *m = SwapClaimView_Opaque{} }
func (m *SwapClaimView_Opaque) String() string { return proto.CompactTextString(m) }
func (*SwapClaimView_Opaque) ProtoMessage()    {}
func (*SwapClaimView_Opaque) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{11, 1}
}
func (m *SwapClaimView_Opaque) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapClaimView_Opaque) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapClaimView_Opaque.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapClaimView_Opaque) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapClaimView_Opaque.Merge(m, src)
}
func (m *SwapClaimView_Opaque) XXX_Size() int {
	return m.Size()
}
func (m *SwapClaimView_Opaque) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapClaimView_Opaque.DiscardUnknown(m)
}

var xxx_messageInfo_SwapClaimView_Opaque proto.InternalMessageInfo

func (m *SwapClaimView_Opaque) GetSwapClaim() *SwapClaim {
	if m != nil {
		return m.SwapClaim
	}
	return nil
}

// Holds two asset IDs. Ordering doesn't reflect trading direction. Instead, we
// require `asset_1 < asset_2` as field elements, to ensure a canonical
// representation of an unordered pair.
type TradingPair struct {
	// The first asset of the pair.
	Asset_1 *v14.AssetId `protobuf:"bytes,1,opt,name=asset_1,json=asset1,proto3" json:"asset_1,omitempty"`
	// The second asset of the pair.
	Asset_2 *v14.AssetId `protobuf:"bytes,2,opt,name=asset_2,json=asset2,proto3" json:"asset_2,omitempty"`
}

func (m *TradingPair) Reset()         { *m = TradingPair{} }
func (m *TradingPair) String() string { return proto.CompactTextString(m) }
func (*TradingPair) ProtoMessage()    {}
func (*TradingPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{12}
}
func (m *TradingPair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TradingPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TradingPair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TradingPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TradingPair.Merge(m, src)
}
func (m *TradingPair) XXX_Size() int {
	return m.Size()
}
func (m *TradingPair) XXX_DiscardUnknown() {
	xxx_messageInfo_TradingPair.DiscardUnknown(m)
}

var xxx_messageInfo_TradingPair proto.InternalMessageInfo

func (m *TradingPair) GetAsset_1() *v14.AssetId {
	if m != nil {
		return m.Asset_1
	}
	return nil
}

func (m *TradingPair) GetAsset_2() *v14.AssetId {
	if m != nil {
		return m.Asset_2
	}
	return nil
}

// Encodes a trading pair starting from asset `start`
// and ending on asset `end`.
type DirectedTradingPair struct {
	// The start asset of the pair.
	Start *v14.AssetId `protobuf:"bytes,1,opt,name=start,proto3" json:"start,omitempty"`
	// The end asset of the pair.
	End *v14.AssetId `protobuf:"bytes,2,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *DirectedTradingPair) Reset()         { *m = DirectedTradingPair{} }
func (m *DirectedTradingPair) String() string { return proto.CompactTextString(m) }
func (*DirectedTradingPair) ProtoMessage()    {}
func (*DirectedTradingPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{13}
}
func (m *DirectedTradingPair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DirectedTradingPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DirectedTradingPair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DirectedTradingPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DirectedTradingPair.Merge(m, src)
}
func (m *DirectedTradingPair) XXX_Size() int {
	return m.Size()
}
func (m *DirectedTradingPair) XXX_DiscardUnknown() {
	xxx_messageInfo_DirectedTradingPair.DiscardUnknown(m)
}

var xxx_messageInfo_DirectedTradingPair proto.InternalMessageInfo

func (m *DirectedTradingPair) GetStart() *v14.AssetId {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *DirectedTradingPair) GetEnd() *v14.AssetId {
	if m != nil {
		return m.End
	}
	return nil
}

// Records the result of a batch swap on-chain.
//
// Used as a public input to a swap claim proof, as it implies the effective
// clearing price for the batch.
type BatchSwapOutputData struct {
	// The total amount of asset 1 that was input to the batch swap.
	Delta_1 *v13.Amount `protobuf:"bytes,1,opt,name=delta_1,json=delta1,proto3" json:"delta_1,omitempty"`
	// The total amount of asset 2 that was input to the batch swap.
	Delta_2 *v13.Amount `protobuf:"bytes,2,opt,name=delta_2,json=delta2,proto3" json:"delta_2,omitempty"`
	// The total amount of asset 1 that was output from the batch swap for 2=>1 trades.
	Lambda_1 *v13.Amount `protobuf:"bytes,3,opt,name=lambda_1,json=lambda1,proto3" json:"lambda_1,omitempty"`
	// The total amount of asset 2 that was output from the batch swap for 1=>2 trades.
	Lambda_2 *v13.Amount `protobuf:"bytes,4,opt,name=lambda_2,json=lambda2,proto3" json:"lambda_2,omitempty"`
	// The total amount of asset 1 that was returned unfilled from the batch swap for 1=>2 trades.
	Unfilled_1 *v13.Amount `protobuf:"bytes,5,opt,name=unfilled_1,json=unfilled1,proto3" json:"unfilled_1,omitempty"`
	// The total amount of asset 2 that was returned unfilled from the batch swap for 2=>1 trades.
	Unfilled_2 *v13.Amount `protobuf:"bytes,6,opt,name=unfilled_2,json=unfilled2,proto3" json:"unfilled_2,omitempty"`
	// The height for which the batch swap data is valid.
	Height uint64 `protobuf:"varint,7,opt,name=height,proto3" json:"height,omitempty"`
	// The trading pair associated with the batch swap.
	TradingPair *TradingPair `protobuf:"bytes,8,opt,name=trading_pair,json=tradingPair,proto3" json:"trading_pair,omitempty"`
	// The starting block height of the epoch for which the batch swap data is valid.
	EpochStartingHeight uint64 `protobuf:"varint,9,opt,name=epoch_starting_height,json=epochStartingHeight,proto3" json:"epoch_starting_height,omitempty"` // Deprecated: Do not use.
	// The prefix (epoch, block) of the position where this batch swap occurred.
	SctPositionPrefix uint64 `protobuf:"varint,10,opt,name=sct_position_prefix,json=sctPositionPrefix,proto3" json:"sct_position_prefix,omitempty"`
}

func (m *BatchSwapOutputData) Reset()         { *m = BatchSwapOutputData{} }
func (m *BatchSwapOutputData) String() string { return proto.CompactTextString(m) }
func (*BatchSwapOutputData) ProtoMessage()    {}
func (*BatchSwapOutputData) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{14}
}
func (m *BatchSwapOutputData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchSwapOutputData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchSwapOutputData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchSwapOutputData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchSwapOutputData.Merge(m, src)
}
func (m *BatchSwapOutputData) XXX_Size() int {
	return m.Size()
}
func (m *BatchSwapOutputData) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchSwapOutputData.DiscardUnknown(m)
}

var xxx_messageInfo_BatchSwapOutputData proto.InternalMessageInfo

func (m *BatchSwapOutputData) GetDelta_1() *v13.Amount {
	if m != nil {
		return m.Delta_1
	}
	return nil
}

func (m *BatchSwapOutputData) GetDelta_2() *v13.Amount {
	if m != nil {
		return m.Delta_2
	}
	return nil
}

func (m *BatchSwapOutputData) GetLambda_1() *v13.Amount {
	if m != nil {
		return m.Lambda_1
	}
	return nil
}

func (m *BatchSwapOutputData) GetLambda_2() *v13.Amount {
	if m != nil {
		return m.Lambda_2
	}
	return nil
}

func (m *BatchSwapOutputData) GetUnfilled_1() *v13.Amount {
	if m != nil {
		return m.Unfilled_1
	}
	return nil
}

func (m *BatchSwapOutputData) GetUnfilled_2() *v13.Amount {
	if m != nil {
		return m.Unfilled_2
	}
	return nil
}

func (m *BatchSwapOutputData) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *BatchSwapOutputData) GetTradingPair() *TradingPair {
	if m != nil {
		return m.TradingPair
	}
	return nil
}

// Deprecated: Do not use.
func (m *BatchSwapOutputData) GetEpochStartingHeight() uint64 {
	if m != nil {
		return m.EpochStartingHeight
	}
	return 0
}

func (m *BatchSwapOutputData) GetSctPositionPrefix() uint64 {
	if m != nil {
		return m.SctPositionPrefix
	}
	return 0
}

// The trading function for a specific pair.
// For a pair (asset_1, asset_2), a trading function is defined by:
// `phi(R) = p*R_1 + q*R_2` and `gamma = 1 - fee`.
// The trading function is frequently referred to as "phi".
type TradingFunction struct {
	Component *BareTradingFunction `protobuf:"bytes,1,opt,name=component,proto3" json:"component,omitempty"`
	Pair      *TradingPair         `protobuf:"bytes,2,opt,name=pair,proto3" json:"pair,omitempty"`
}

func (m *TradingFunction) Reset()         { *m = TradingFunction{} }
func (m *TradingFunction) String() string { return proto.CompactTextString(m) }
func (*TradingFunction) ProtoMessage()    {}
func (*TradingFunction) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{15}
}
func (m *TradingFunction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TradingFunction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TradingFunction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TradingFunction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TradingFunction.Merge(m, src)
}
func (m *TradingFunction) XXX_Size() int {
	return m.Size()
}
func (m *TradingFunction) XXX_DiscardUnknown() {
	xxx_messageInfo_TradingFunction.DiscardUnknown(m)
}

var xxx_messageInfo_TradingFunction proto.InternalMessageInfo

func (m *TradingFunction) GetComponent() *BareTradingFunction {
	if m != nil {
		return m.Component
	}
	return nil
}

func (m *TradingFunction) GetPair() *TradingPair {
	if m != nil {
		return m.Pair
	}
	return nil
}

// The minimum amount of data describing a trading function.
//
// This implicitly treats the trading function as being between assets 1 and 2,
// without specifying what those assets are, to avoid duplicating data (each
// asset ID alone is twice the size of the trading function).
type BareTradingFunction struct {
	Fee uint32 `protobuf:"varint,1,opt,name=fee,proto3" json:"fee,omitempty"`
	// This is not actually an amount, it's an integer the same width as an amount
	P *v13.Amount `protobuf:"bytes,2,opt,name=p,proto3" json:"p,omitempty"`
	// This is not actually an amount, it's an integer the same width as an amount
	Q *v13.Amount `protobuf:"bytes,3,opt,name=q,proto3" json:"q,omitempty"`
}

func (m *BareTradingFunction) Reset()         { *m = BareTradingFunction{} }
func (m *BareTradingFunction) String() string { return proto.CompactTextString(m) }
func (*BareTradingFunction) ProtoMessage()    {}
func (*BareTradingFunction) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{16}
}
func (m *BareTradingFunction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BareTradingFunction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BareTradingFunction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BareTradingFunction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BareTradingFunction.Merge(m, src)
}
func (m *BareTradingFunction) XXX_Size() int {
	return m.Size()
}
func (m *BareTradingFunction) XXX_DiscardUnknown() {
	xxx_messageInfo_BareTradingFunction.DiscardUnknown(m)
}

var xxx_messageInfo_BareTradingFunction proto.InternalMessageInfo

func (m *BareTradingFunction) GetFee() uint32 {
	if m != nil {
		return m.Fee
	}
	return 0
}

func (m *BareTradingFunction) GetP() *v13.Amount {
	if m != nil {
		return m.P
	}
	return nil
}

func (m *BareTradingFunction) GetQ() *v13.Amount {
	if m != nil {
		return m.Q
	}
	return nil
}

// The reserves of a position.
//
// Like a position, this implicitly treats the trading function as being
// between assets 1 and 2, without specifying what those assets are, to avoid
// duplicating data (each asset ID alone is four times the size of the
// reserves).
type Reserves struct {
	R1 *v13.Amount `protobuf:"bytes,1,opt,name=r1,proto3" json:"r1,omitempty"`
	R2 *v13.Amount `protobuf:"bytes,2,opt,name=r2,proto3" json:"r2,omitempty"`
}

func (m *Reserves) Reset()         { *m = Reserves{} }
func (m *Reserves) String() string { return proto.CompactTextString(m) }
func (*Reserves) ProtoMessage()    {}
func (*Reserves) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{17}
}
func (m *Reserves) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Reserves) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Reserves.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Reserves) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Reserves.Merge(m, src)
}
func (m *Reserves) XXX_Size() int {
	return m.Size()
}
func (m *Reserves) XXX_DiscardUnknown() {
	xxx_messageInfo_Reserves.DiscardUnknown(m)
}

var xxx_messageInfo_Reserves proto.InternalMessageInfo

func (m *Reserves) GetR1() *v13.Amount {
	if m != nil {
		return m.R1
	}
	return nil
}

func (m *Reserves) GetR2() *v13.Amount {
	if m != nil {
		return m.R2
	}
	return nil
}

// Data identifying a position.
type Position struct {
	Phi *TradingFunction `protobuf:"bytes,1,opt,name=phi,proto3" json:"phi,omitempty"`
	// A random value used to disambiguate different positions with the exact same
	// trading function.  The chain should reject newly created positions with the
	// same nonce as an existing position.  This ensures that `PositionId`s will
	// be unique, and allows us to track position ownership with a
	// sequence of stateful NFTs based on the `PositionId`.
	Nonce    []byte         `protobuf:"bytes,2,opt,name=nonce,proto3" json:"nonce,omitempty"`
	State    *PositionState `protobuf:"bytes,3,opt,name=state,proto3" json:"state,omitempty"`
	Reserves *Reserves      `protobuf:"bytes,4,opt,name=reserves,proto3" json:"reserves,omitempty"`
	// / If set to true, the position is a limit-order and will be closed
	// / immediately after being filled.
	CloseOnFill bool `protobuf:"varint,5,opt,name=close_on_fill,json=closeOnFill,proto3" json:"close_on_fill,omitempty"`
}

func (m *Position) Reset()         { *m = Position{} }
func (m *Position) String() string { return proto.CompactTextString(m) }
func (*Position) ProtoMessage()    {}
func (*Position) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{18}
}
func (m *Position) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Position) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Position.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Position) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Position.Merge(m, src)
}
func (m *Position) XXX_Size() int {
	return m.Size()
}
func (m *Position) XXX_DiscardUnknown() {
	xxx_messageInfo_Position.DiscardUnknown(m)
}

var xxx_messageInfo_Position proto.InternalMessageInfo

func (m *Position) GetPhi() *TradingFunction {
	if m != nil {
		return m.Phi
	}
	return nil
}

func (m *Position) GetNonce() []byte {
	if m != nil {
		return m.Nonce
	}
	return nil
}

func (m *Position) GetState() *PositionState {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *Position) GetReserves() *Reserves {
	if m != nil {
		return m.Reserves
	}
	return nil
}

func (m *Position) GetCloseOnFill() bool {
	if m != nil {
		return m.CloseOnFill
	}
	return false
}

// A hash of a `Position`.
type PositionId struct {
	// The bytes of the position ID.
	Inner []byte `protobuf:"bytes,1,opt,name=inner,proto3" json:"inner,omitempty"`
	// Alternatively, a Bech32m-encoded string representation of the `inner`
	// bytes.
	//
	// NOTE: implementations are not required to support parsing this field.
	// Implementations should prefer to encode the bytes in all messages they
	// produce. Implementations must not accept messages with both `inner` and
	// `alt_bech32m` set.
	AltBech32M string `protobuf:"bytes,2,opt,name=alt_bech32m,json=altBech32m,proto3" json:"alt_bech32m,omitempty"`
}

func (m *PositionId) Reset()         { *m = PositionId{} }
func (m *PositionId) String() string { return proto.CompactTextString(m) }
func (*PositionId) ProtoMessage()    {}
func (*PositionId) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{19}
}
func (m *PositionId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PositionId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PositionId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PositionId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PositionId.Merge(m, src)
}
func (m *PositionId) XXX_Size() int {
	return m.Size()
}
func (m *PositionId) XXX_DiscardUnknown() {
	xxx_messageInfo_PositionId.DiscardUnknown(m)
}

var xxx_messageInfo_PositionId proto.InternalMessageInfo

func (m *PositionId) GetInner() []byte {
	if m != nil {
		return m.Inner
	}
	return nil
}

func (m *PositionId) GetAltBech32M() string {
	if m != nil {
		return m.AltBech32M
	}
	return ""
}

// The state of a position.
type PositionState struct {
	State PositionState_PositionStateEnum `protobuf:"varint,1,opt,name=state,proto3,enum=penumbra.core.component.dex.v1.PositionState_PositionStateEnum" json:"state,omitempty"`
	// Only meaningful if `state` is `POSITION_STATE_ENUM_WITHDRAWN`.
	//
	// The sequence number allows multiple withdrawals from the same position.
	Sequence uint64 `protobuf:"varint,2,opt,name=sequence,proto3" json:"sequence,omitempty"`
}

func (m *PositionState) Reset()         { *m = PositionState{} }
func (m *PositionState) String() string { return proto.CompactTextString(m) }
func (*PositionState) ProtoMessage()    {}
func (*PositionState) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{20}
}
func (m *PositionState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PositionState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PositionState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PositionState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PositionState.Merge(m, src)
}
func (m *PositionState) XXX_Size() int {
	return m.Size()
}
func (m *PositionState) XXX_DiscardUnknown() {
	xxx_messageInfo_PositionState.DiscardUnknown(m)
}

var xxx_messageInfo_PositionState proto.InternalMessageInfo

func (m *PositionState) GetState() PositionState_PositionStateEnum {
	if m != nil {
		return m.State
	}
	return PositionState_POSITION_STATE_ENUM_UNSPECIFIED
}

func (m *PositionState) GetSequence() uint64 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

// An LPNFT tracking both ownership and state of a position.
//
// Tracking the state as part of the LPNFT means that all LP-related actions can
// be authorized by spending funds: a state transition (e.g., closing a
// position) is modeled as spending an "open position LPNFT" and minting a
// "closed position LPNFT" for the same (globally unique) position ID.
//
// This means that the LP mechanics can be agnostic to the mechanism used to
// record custody and spend authorization.  For instance, they can be recorded
// in the shielded pool, where custody is based on off-chain keys, or they could
// be recorded in a programmatic on-chain account (in the future, e.g., to
// support interchain accounts).  This also means that LP-related actions don't
// require any cryptographic implementation (proofs, signatures, etc), other
// than hooking into the value commitment mechanism used for transaction
// balances.
type LpNft struct {
	PositionId *PositionId    `protobuf:"bytes,1,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
	State      *PositionState `protobuf:"bytes,2,opt,name=state,proto3" json:"state,omitempty"`
}

func (m *LpNft) Reset()         { *m = LpNft{} }
func (m *LpNft) String() string { return proto.CompactTextString(m) }
func (*LpNft) ProtoMessage()    {}
func (*LpNft) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{21}
}
func (m *LpNft) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LpNft) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LpNft.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LpNft) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LpNft.Merge(m, src)
}
func (m *LpNft) XXX_Size() int {
	return m.Size()
}
func (m *LpNft) XXX_DiscardUnknown() {
	xxx_messageInfo_LpNft.DiscardUnknown(m)
}

var xxx_messageInfo_LpNft proto.InternalMessageInfo

func (m *LpNft) GetPositionId() *PositionId {
	if m != nil {
		return m.PositionId
	}
	return nil
}

func (m *LpNft) GetState() *PositionState {
	if m != nil {
		return m.State
	}
	return nil
}

// A transaction action that opens a new position.
//
// This action's contribution to the transaction's value balance is to consume
// the initial reserves and contribute an opened position NFT.
type PositionOpen struct {
	// Contains the data defining the position, sufficient to compute its `PositionId`.
	//
	// Positions are immutable, so the `PositionData` (and hence the `PositionId`)
	// are unchanged over the entire lifetime of the position.
	Position *Position `protobuf:"bytes,1,opt,name=position,proto3" json:"position,omitempty"`
}

func (m *PositionOpen) Reset()         { *m = PositionOpen{} }
func (m *PositionOpen) String() string { return proto.CompactTextString(m) }
func (*PositionOpen) ProtoMessage()    {}
func (*PositionOpen) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{22}
}
func (m *PositionOpen) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PositionOpen) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PositionOpen.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PositionOpen) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PositionOpen.Merge(m, src)
}
func (m *PositionOpen) XXX_Size() int {
	return m.Size()
}
func (m *PositionOpen) XXX_DiscardUnknown() {
	xxx_messageInfo_PositionOpen.DiscardUnknown(m)
}

var xxx_messageInfo_PositionOpen proto.InternalMessageInfo

func (m *PositionOpen) GetPosition() *Position {
	if m != nil {
		return m.Position
	}
	return nil
}

// A transaction action that closes a position.
//
// This action's contribution to the transaction's value balance is to consume
// an opened position NFT and contribute a closed position NFT.
//
// Closing a position does not immediately withdraw funds, because Penumbra
// transactions (like any ZK transaction model) are early-binding: the prover
// must know the state transition they prove knowledge of, and they cannot know
// the final reserves with certainty until after the position has been deactivated.
type PositionClose struct {
	PositionId *PositionId `protobuf:"bytes,1,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
}

func (m *PositionClose) Reset()         { *m = PositionClose{} }
func (m *PositionClose) String() string { return proto.CompactTextString(m) }
func (*PositionClose) ProtoMessage()    {}
func (*PositionClose) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{23}
}
func (m *PositionClose) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PositionClose) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PositionClose.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PositionClose) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PositionClose.Merge(m, src)
}
func (m *PositionClose) XXX_Size() int {
	return m.Size()
}
func (m *PositionClose) XXX_DiscardUnknown() {
	xxx_messageInfo_PositionClose.DiscardUnknown(m)
}

var xxx_messageInfo_PositionClose proto.InternalMessageInfo

func (m *PositionClose) GetPositionId() *PositionId {
	if m != nil {
		return m.PositionId
	}
	return nil
}

// A transaction action that withdraws funds from a closed position.
//
// This action's contribution to the transaction's value balance is to consume a
// closed position NFT and contribute a withdrawn position NFT, as well as all
// of the funds that were in the position at the time of closing.
type PositionWithdraw struct {
	PositionId *PositionId `protobuf:"bytes,1,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
	// A transparent (zero blinding factor) commitment to the position's final reserves and fees.
	//
	// The chain will check this commitment by recomputing it with the on-chain state.
	ReservesCommitment *v14.BalanceCommitment `protobuf:"bytes,2,opt,name=reserves_commitment,json=reservesCommitment,proto3" json:"reserves_commitment,omitempty"`
	// The sequence number of the withdrawal.
	//
	// This allows multiple withdrawals from the same position, rather than a single reward claim.
	Sequence uint64 `protobuf:"varint,3,opt,name=sequence,proto3" json:"sequence,omitempty"`
}

func (m *PositionWithdraw) Reset()         { *m = PositionWithdraw{} }
func (m *PositionWithdraw) String() string { return proto.CompactTextString(m) }
func (*PositionWithdraw) ProtoMessage()    {}
func (*PositionWithdraw) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{24}
}
func (m *PositionWithdraw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PositionWithdraw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PositionWithdraw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PositionWithdraw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PositionWithdraw.Merge(m, src)
}
func (m *PositionWithdraw) XXX_Size() int {
	return m.Size()
}
func (m *PositionWithdraw) XXX_DiscardUnknown() {
	xxx_messageInfo_PositionWithdraw.DiscardUnknown(m)
}

var xxx_messageInfo_PositionWithdraw proto.InternalMessageInfo

func (m *PositionWithdraw) GetPositionId() *PositionId {
	if m != nil {
		return m.PositionId
	}
	return nil
}

func (m *PositionWithdraw) GetReservesCommitment() *v14.BalanceCommitment {
	if m != nil {
		return m.ReservesCommitment
	}
	return nil
}

func (m *PositionWithdraw) GetSequence() uint64 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

// Deprecated.
type PositionRewardClaim struct {
	PositionId        *PositionId            `protobuf:"bytes,1,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
	RewardsCommitment *v14.BalanceCommitment `protobuf:"bytes,2,opt,name=rewards_commitment,json=rewardsCommitment,proto3" json:"rewards_commitment,omitempty"`
}

func (m *PositionRewardClaim) Reset()         { *m = PositionRewardClaim{} }
func (m *PositionRewardClaim) String() string { return proto.CompactTextString(m) }
func (*PositionRewardClaim) ProtoMessage()    {}
func (*PositionRewardClaim) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{25}
}
func (m *PositionRewardClaim) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PositionRewardClaim) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PositionRewardClaim.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PositionRewardClaim) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PositionRewardClaim.Merge(m, src)
}
func (m *PositionRewardClaim) XXX_Size() int {
	return m.Size()
}
func (m *PositionRewardClaim) XXX_DiscardUnknown() {
	xxx_messageInfo_PositionRewardClaim.DiscardUnknown(m)
}

var xxx_messageInfo_PositionRewardClaim proto.InternalMessageInfo

func (m *PositionRewardClaim) GetPositionId() *PositionId {
	if m != nil {
		return m.PositionId
	}
	return nil
}

func (m *PositionRewardClaim) GetRewardsCommitment() *v14.BalanceCommitment {
	if m != nil {
		return m.RewardsCommitment
	}
	return nil
}

// Contains the entire execution of a particular swap.
type SwapExecution struct {
	Traces []*SwapExecution_Trace `protobuf:"bytes,1,rep,name=traces,proto3" json:"traces,omitempty"`
	// The total input amount for this execution.
	Input *v14.Value `protobuf:"bytes,2,opt,name=input,proto3" json:"input,omitempty"`
	// The total output amount for this execution.
	Output *v14.Value `protobuf:"bytes,3,opt,name=output,proto3" json:"output,omitempty"`
}

func (m *SwapExecution) Reset()         { *m = SwapExecution{} }
func (m *SwapExecution) String() string { return proto.CompactTextString(m) }
func (*SwapExecution) ProtoMessage()    {}
func (*SwapExecution) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{26}
}
func (m *SwapExecution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapExecution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapExecution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapExecution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapExecution.Merge(m, src)
}
func (m *SwapExecution) XXX_Size() int {
	return m.Size()
}
func (m *SwapExecution) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapExecution.DiscardUnknown(m)
}

var xxx_messageInfo_SwapExecution proto.InternalMessageInfo

func (m *SwapExecution) GetTraces() []*SwapExecution_Trace {
	if m != nil {
		return m.Traces
	}
	return nil
}

func (m *SwapExecution) GetInput() *v14.Value {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *SwapExecution) GetOutput() *v14.Value {
	if m != nil {
		return m.Output
	}
	return nil
}

// Contains all individual steps consisting of a trade trace.
type SwapExecution_Trace struct {
	// Each step in the trade trace.
	Value []*v14.Value `protobuf:"bytes,1,rep,name=value,proto3" json:"value,omitempty"`
}

func (m *SwapExecution_Trace) Reset()         { *m = SwapExecution_Trace{} }
func (m *SwapExecution_Trace) String() string { return proto.CompactTextString(m) }
func (*SwapExecution_Trace) ProtoMessage()    {}
func (*SwapExecution_Trace) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{26, 0}
}
func (m *SwapExecution_Trace) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapExecution_Trace) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapExecution_Trace.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapExecution_Trace) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapExecution_Trace.Merge(m, src)
}
func (m *SwapExecution_Trace) XXX_Size() int {
	return m.Size()
}
func (m *SwapExecution_Trace) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapExecution_Trace.DiscardUnknown(m)
}

var xxx_messageInfo_SwapExecution_Trace proto.InternalMessageInfo

func (m *SwapExecution_Trace) GetValue() []*v14.Value {
	if m != nil {
		return m.Value
	}
	return nil
}

// Contains private and public data for withdrawing funds from a closed position.
type PositionWithdrawPlan struct {
	Reserves   *Reserves    `protobuf:"bytes,1,opt,name=reserves,proto3" json:"reserves,omitempty"`
	PositionId *PositionId  `protobuf:"bytes,2,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
	Pair       *TradingPair `protobuf:"bytes,3,opt,name=pair,proto3" json:"pair,omitempty"`
	// The sequence number of the withdrawal.
	Sequence uint64 `protobuf:"varint,4,opt,name=sequence,proto3" json:"sequence,omitempty"`
	// Any accumulated rewards assigned to this position.
	Rewards []*v14.Value `protobuf:"bytes,5,rep,name=rewards,proto3" json:"rewards,omitempty"`
}

func (m *PositionWithdrawPlan) Reset()         { *m = PositionWithdrawPlan{} }
func (m *PositionWithdrawPlan) String() string { return proto.CompactTextString(m) }
func (*PositionWithdrawPlan) ProtoMessage()    {}
func (*PositionWithdrawPlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{27}
}
func (m *PositionWithdrawPlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PositionWithdrawPlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PositionWithdrawPlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PositionWithdrawPlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PositionWithdrawPlan.Merge(m, src)
}
func (m *PositionWithdrawPlan) XXX_Size() int {
	return m.Size()
}
func (m *PositionWithdrawPlan) XXX_DiscardUnknown() {
	xxx_messageInfo_PositionWithdrawPlan.DiscardUnknown(m)
}

var xxx_messageInfo_PositionWithdrawPlan proto.InternalMessageInfo

func (m *PositionWithdrawPlan) GetReserves() *Reserves {
	if m != nil {
		return m.Reserves
	}
	return nil
}

func (m *PositionWithdrawPlan) GetPositionId() *PositionId {
	if m != nil {
		return m.PositionId
	}
	return nil
}

func (m *PositionWithdrawPlan) GetPair() *TradingPair {
	if m != nil {
		return m.Pair
	}
	return nil
}

func (m *PositionWithdrawPlan) GetSequence() uint64 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

func (m *PositionWithdrawPlan) GetRewards() []*v14.Value {
	if m != nil {
		return m.Rewards
	}
	return nil
}

// Deprecated.
type PositionRewardClaimPlan struct {
	Reserves *Reserves `protobuf:"bytes,1,opt,name=reserves,proto3" json:"reserves,omitempty"`
}

func (m *PositionRewardClaimPlan) Reset()         { *m = PositionRewardClaimPlan{} }
func (m *PositionRewardClaimPlan) String() string { return proto.CompactTextString(m) }
func (*PositionRewardClaimPlan) ProtoMessage()    {}
func (*PositionRewardClaimPlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{28}
}
func (m *PositionRewardClaimPlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PositionRewardClaimPlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PositionRewardClaimPlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PositionRewardClaimPlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PositionRewardClaimPlan.Merge(m, src)
}
func (m *PositionRewardClaimPlan) XXX_Size() int {
	return m.Size()
}
func (m *PositionRewardClaimPlan) XXX_DiscardUnknown() {
	xxx_messageInfo_PositionRewardClaimPlan.DiscardUnknown(m)
}

var xxx_messageInfo_PositionRewardClaimPlan proto.InternalMessageInfo

func (m *PositionRewardClaimPlan) GetReserves() *Reserves {
	if m != nil {
		return m.Reserves
	}
	return nil
}

// Requests batch swap data associated with a given height and trading pair from the view service.
type BatchSwapOutputDataRequest struct {
	Height      uint64       `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
	TradingPair *TradingPair `protobuf:"bytes,3,opt,name=trading_pair,json=tradingPair,proto3" json:"trading_pair,omitempty"`
}

func (m *BatchSwapOutputDataRequest) Reset()         { *m = BatchSwapOutputDataRequest{} }
func (m *BatchSwapOutputDataRequest) String() string { return proto.CompactTextString(m) }
func (*BatchSwapOutputDataRequest) ProtoMessage()    {}
func (*BatchSwapOutputDataRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{29}
}
func (m *BatchSwapOutputDataRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchSwapOutputDataRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchSwapOutputDataRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchSwapOutputDataRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchSwapOutputDataRequest.Merge(m, src)
}
func (m *BatchSwapOutputDataRequest) XXX_Size() int {
	return m.Size()
}
func (m *BatchSwapOutputDataRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchSwapOutputDataRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BatchSwapOutputDataRequest proto.InternalMessageInfo

func (m *BatchSwapOutputDataRequest) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *BatchSwapOutputDataRequest) GetTradingPair() *TradingPair {
	if m != nil {
		return m.TradingPair
	}
	return nil
}

type BatchSwapOutputDataResponse struct {
	Data *BatchSwapOutputData `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *BatchSwapOutputDataResponse) Reset()         { *m = BatchSwapOutputDataResponse{} }
func (m *BatchSwapOutputDataResponse) String() string { return proto.CompactTextString(m) }
func (*BatchSwapOutputDataResponse) ProtoMessage()    {}
func (*BatchSwapOutputDataResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{30}
}
func (m *BatchSwapOutputDataResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchSwapOutputDataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchSwapOutputDataResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchSwapOutputDataResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchSwapOutputDataResponse.Merge(m, src)
}
func (m *BatchSwapOutputDataResponse) XXX_Size() int {
	return m.Size()
}
func (m *BatchSwapOutputDataResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchSwapOutputDataResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BatchSwapOutputDataResponse proto.InternalMessageInfo

func (m *BatchSwapOutputDataResponse) GetData() *BatchSwapOutputData {
	if m != nil {
		return m.Data
	}
	return nil
}

type SwapExecutionRequest struct {
	Height      uint64               `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
	TradingPair *DirectedTradingPair `protobuf:"bytes,3,opt,name=trading_pair,json=tradingPair,proto3" json:"trading_pair,omitempty"`
}

func (m *SwapExecutionRequest) Reset()         { *m = SwapExecutionRequest{} }
func (m *SwapExecutionRequest) String() string { return proto.CompactTextString(m) }
func (*SwapExecutionRequest) ProtoMessage()    {}
func (*SwapExecutionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{31}
}
func (m *SwapExecutionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapExecutionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapExecutionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapExecutionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapExecutionRequest.Merge(m, src)
}
func (m *SwapExecutionRequest) XXX_Size() int {
	return m.Size()
}
func (m *SwapExecutionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapExecutionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SwapExecutionRequest proto.InternalMessageInfo

func (m *SwapExecutionRequest) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *SwapExecutionRequest) GetTradingPair() *DirectedTradingPair {
	if m != nil {
		return m.TradingPair
	}
	return nil
}

type SwapExecutionResponse struct {
	SwapExecution *SwapExecution `protobuf:"bytes,1,opt,name=swap_execution,json=swapExecution,proto3" json:"swap_execution,omitempty"`
}

func (m *SwapExecutionResponse) Reset()         { *m = SwapExecutionResponse{} }
func (m *SwapExecutionResponse) String() string { return proto.CompactTextString(m) }
func (*SwapExecutionResponse) ProtoMessage()    {}
func (*SwapExecutionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{32}
}
func (m *SwapExecutionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapExecutionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapExecutionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapExecutionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapExecutionResponse.Merge(m, src)
}
func (m *SwapExecutionResponse) XXX_Size() int {
	return m.Size()
}
func (m *SwapExecutionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapExecutionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SwapExecutionResponse proto.InternalMessageInfo

func (m *SwapExecutionResponse) GetSwapExecution() *SwapExecution {
	if m != nil {
		return m.SwapExecution
	}
	return nil
}

type ArbExecutionRequest struct {
	Height uint64 `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
}

func (m *ArbExecutionRequest) Reset()         { *m = ArbExecutionRequest{} }
func (m *ArbExecutionRequest) String() string { return proto.CompactTextString(m) }
func (*ArbExecutionRequest) ProtoMessage()    {}
func (*ArbExecutionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{33}
}
func (m *ArbExecutionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArbExecutionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArbExecutionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArbExecutionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArbExecutionRequest.Merge(m, src)
}
func (m *ArbExecutionRequest) XXX_Size() int {
	return m.Size()
}
func (m *ArbExecutionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ArbExecutionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ArbExecutionRequest proto.InternalMessageInfo

func (m *ArbExecutionRequest) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

type ArbExecutionResponse struct {
	SwapExecution *SwapExecution `protobuf:"bytes,1,opt,name=swap_execution,json=swapExecution,proto3" json:"swap_execution,omitempty"`
	Height        uint64         `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
}

func (m *ArbExecutionResponse) Reset()         { *m = ArbExecutionResponse{} }
func (m *ArbExecutionResponse) String() string { return proto.CompactTextString(m) }
func (*ArbExecutionResponse) ProtoMessage()    {}
func (*ArbExecutionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{34}
}
func (m *ArbExecutionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArbExecutionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArbExecutionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArbExecutionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArbExecutionResponse.Merge(m, src)
}
func (m *ArbExecutionResponse) XXX_Size() int {
	return m.Size()
}
func (m *ArbExecutionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ArbExecutionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ArbExecutionResponse proto.InternalMessageInfo

func (m *ArbExecutionResponse) GetSwapExecution() *SwapExecution {
	if m != nil {
		return m.SwapExecution
	}
	return nil
}

func (m *ArbExecutionResponse) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

type SwapExecutionsRequest struct {
	// If present, only return swap executions occurring after the given height.
	StartHeight uint64 `protobuf:"varint,2,opt,name=start_height,json=startHeight,proto3" json:"start_height,omitempty"`
	// If present, only return swap executions occurring before the given height.
	EndHeight uint64 `protobuf:"varint,3,opt,name=end_height,json=endHeight,proto3" json:"end_height,omitempty"`
	// If present, filter swap executions by the given trading pair.
	TradingPair *DirectedTradingPair `protobuf:"bytes,4,opt,name=trading_pair,json=tradingPair,proto3" json:"trading_pair,omitempty"`
}

func (m *SwapExecutionsRequest) Reset()         { *m = SwapExecutionsRequest{} }
func (m *SwapExecutionsRequest) String() string { return proto.CompactTextString(m) }
func (*SwapExecutionsRequest) ProtoMessage()    {}
func (*SwapExecutionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{35}
}
func (m *SwapExecutionsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapExecutionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapExecutionsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapExecutionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapExecutionsRequest.Merge(m, src)
}
func (m *SwapExecutionsRequest) XXX_Size() int {
	return m.Size()
}
func (m *SwapExecutionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapExecutionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SwapExecutionsRequest proto.InternalMessageInfo

func (m *SwapExecutionsRequest) GetStartHeight() uint64 {
	if m != nil {
		return m.StartHeight
	}
	return 0
}

func (m *SwapExecutionsRequest) GetEndHeight() uint64 {
	if m != nil {
		return m.EndHeight
	}
	return 0
}

func (m *SwapExecutionsRequest) GetTradingPair() *DirectedTradingPair {
	if m != nil {
		return m.TradingPair
	}
	return nil
}

type SwapExecutionsResponse struct {
	SwapExecution *SwapExecution       `protobuf:"bytes,1,opt,name=swap_execution,json=swapExecution,proto3" json:"swap_execution,omitempty"`
	Height        uint64               `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
	TradingPair   *DirectedTradingPair `protobuf:"bytes,3,opt,name=trading_pair,json=tradingPair,proto3" json:"trading_pair,omitempty"`
}

func (m *SwapExecutionsResponse) Reset()         { *m = SwapExecutionsResponse{} }
func (m *SwapExecutionsResponse) String() string { return proto.CompactTextString(m) }
func (*SwapExecutionsResponse) ProtoMessage()    {}
func (*SwapExecutionsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{36}
}
func (m *SwapExecutionsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapExecutionsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapExecutionsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapExecutionsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapExecutionsResponse.Merge(m, src)
}
func (m *SwapExecutionsResponse) XXX_Size() int {
	return m.Size()
}
func (m *SwapExecutionsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapExecutionsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SwapExecutionsResponse proto.InternalMessageInfo

func (m *SwapExecutionsResponse) GetSwapExecution() *SwapExecution {
	if m != nil {
		return m.SwapExecution
	}
	return nil
}

func (m *SwapExecutionsResponse) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *SwapExecutionsResponse) GetTradingPair() *DirectedTradingPair {
	if m != nil {
		return m.TradingPair
	}
	return nil
}

type ArbExecutionsRequest struct {
	// If present, only return arb executions occurring after the given height.
	StartHeight uint64 `protobuf:"varint,2,opt,name=start_height,json=startHeight,proto3" json:"start_height,omitempty"`
	// If present, only return arb executions occurring before the given height.
	EndHeight uint64 `protobuf:"varint,3,opt,name=end_height,json=endHeight,proto3" json:"end_height,omitempty"`
}

func (m *ArbExecutionsRequest) Reset()         { *m = ArbExecutionsRequest{} }
func (m *ArbExecutionsRequest) String() string { return proto.CompactTextString(m) }
func (*ArbExecutionsRequest) ProtoMessage()    {}
func (*ArbExecutionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{37}
}
func (m *ArbExecutionsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArbExecutionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArbExecutionsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArbExecutionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArbExecutionsRequest.Merge(m, src)
}
func (m *ArbExecutionsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ArbExecutionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ArbExecutionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ArbExecutionsRequest proto.InternalMessageInfo

func (m *ArbExecutionsRequest) GetStartHeight() uint64 {
	if m != nil {
		return m.StartHeight
	}
	return 0
}

func (m *ArbExecutionsRequest) GetEndHeight() uint64 {
	if m != nil {
		return m.EndHeight
	}
	return 0
}

type ArbExecutionsResponse struct {
	SwapExecution *SwapExecution `protobuf:"bytes,1,opt,name=swap_execution,json=swapExecution,proto3" json:"swap_execution,omitempty"`
	Height        uint64         `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
}

func (m *ArbExecutionsResponse) Reset()         { *m = ArbExecutionsResponse{} }
func (m *ArbExecutionsResponse) String() string { return proto.CompactTextString(m) }
func (*ArbExecutionsResponse) ProtoMessage()    {}
func (*ArbExecutionsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{38}
}
func (m *ArbExecutionsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArbExecutionsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArbExecutionsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArbExecutionsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArbExecutionsResponse.Merge(m, src)
}
func (m *ArbExecutionsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ArbExecutionsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ArbExecutionsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ArbExecutionsResponse proto.InternalMessageInfo

func (m *ArbExecutionsResponse) GetSwapExecution() *SwapExecution {
	if m != nil {
		return m.SwapExecution
	}
	return nil
}

func (m *ArbExecutionsResponse) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

type LiquidityPositionsRequest struct {
	// If true, include closed and withdrawn positions.
	IncludeClosed bool `protobuf:"varint,4,opt,name=include_closed,json=includeClosed,proto3" json:"include_closed,omitempty"`
}

func (m *LiquidityPositionsRequest) Reset()         { *m = LiquidityPositionsRequest{} }
func (m *LiquidityPositionsRequest) String() string { return proto.CompactTextString(m) }
func (*LiquidityPositionsRequest) ProtoMessage()    {}
func (*LiquidityPositionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{39}
}
func (m *LiquidityPositionsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LiquidityPositionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LiquidityPositionsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LiquidityPositionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiquidityPositionsRequest.Merge(m, src)
}
func (m *LiquidityPositionsRequest) XXX_Size() int {
	return m.Size()
}
func (m *LiquidityPositionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LiquidityPositionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LiquidityPositionsRequest proto.InternalMessageInfo

func (m *LiquidityPositionsRequest) GetIncludeClosed() bool {
	if m != nil {
		return m.IncludeClosed
	}
	return false
}

type LiquidityPositionsResponse struct {
	Data *Position `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *LiquidityPositionsResponse) Reset()         { *m = LiquidityPositionsResponse{} }
func (m *LiquidityPositionsResponse) String() string { return proto.CompactTextString(m) }
func (*LiquidityPositionsResponse) ProtoMessage()    {}
func (*LiquidityPositionsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{40}
}
func (m *LiquidityPositionsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LiquidityPositionsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LiquidityPositionsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LiquidityPositionsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiquidityPositionsResponse.Merge(m, src)
}
func (m *LiquidityPositionsResponse) XXX_Size() int {
	return m.Size()
}
func (m *LiquidityPositionsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LiquidityPositionsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LiquidityPositionsResponse proto.InternalMessageInfo

func (m *LiquidityPositionsResponse) GetData() *Position {
	if m != nil {
		return m.Data
	}
	return nil
}

type LiquidityPositionByIdRequest struct {
	PositionId *PositionId `protobuf:"bytes,2,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
}

func (m *LiquidityPositionByIdRequest) Reset()         { *m = LiquidityPositionByIdRequest{} }
func (m *LiquidityPositionByIdRequest) String() string { return proto.CompactTextString(m) }
func (*LiquidityPositionByIdRequest) ProtoMessage()    {}
func (*LiquidityPositionByIdRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{41}
}
func (m *LiquidityPositionByIdRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LiquidityPositionByIdRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LiquidityPositionByIdRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LiquidityPositionByIdRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiquidityPositionByIdRequest.Merge(m, src)
}
func (m *LiquidityPositionByIdRequest) XXX_Size() int {
	return m.Size()
}
func (m *LiquidityPositionByIdRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LiquidityPositionByIdRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LiquidityPositionByIdRequest proto.InternalMessageInfo

func (m *LiquidityPositionByIdRequest) GetPositionId() *PositionId {
	if m != nil {
		return m.PositionId
	}
	return nil
}

type LiquidityPositionByIdResponse struct {
	Data *Position `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *LiquidityPositionByIdResponse) Reset()         { *m = LiquidityPositionByIdResponse{} }
func (m *LiquidityPositionByIdResponse) String() string { return proto.CompactTextString(m) }
func (*LiquidityPositionByIdResponse) ProtoMessage()    {}
func (*LiquidityPositionByIdResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{42}
}
func (m *LiquidityPositionByIdResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LiquidityPositionByIdResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LiquidityPositionByIdResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LiquidityPositionByIdResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiquidityPositionByIdResponse.Merge(m, src)
}
func (m *LiquidityPositionByIdResponse) XXX_Size() int {
	return m.Size()
}
func (m *LiquidityPositionByIdResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LiquidityPositionByIdResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LiquidityPositionByIdResponse proto.InternalMessageInfo

func (m *LiquidityPositionByIdResponse) GetData() *Position {
	if m != nil {
		return m.Data
	}
	return nil
}

type LiquidityPositionsByIdRequest struct {
	PositionId []*PositionId `protobuf:"bytes,2,rep,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
}

func (m *LiquidityPositionsByIdRequest) Reset()         { *m = LiquidityPositionsByIdRequest{} }
func (m *LiquidityPositionsByIdRequest) String() string { return proto.CompactTextString(m) }
func (*LiquidityPositionsByIdRequest) ProtoMessage()    {}
func (*LiquidityPositionsByIdRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{43}
}
func (m *LiquidityPositionsByIdRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LiquidityPositionsByIdRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LiquidityPositionsByIdRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LiquidityPositionsByIdRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiquidityPositionsByIdRequest.Merge(m, src)
}
func (m *LiquidityPositionsByIdRequest) XXX_Size() int {
	return m.Size()
}
func (m *LiquidityPositionsByIdRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LiquidityPositionsByIdRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LiquidityPositionsByIdRequest proto.InternalMessageInfo

func (m *LiquidityPositionsByIdRequest) GetPositionId() []*PositionId {
	if m != nil {
		return m.PositionId
	}
	return nil
}

type LiquidityPositionsByIdResponse struct {
	Data *Position `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *LiquidityPositionsByIdResponse) Reset()         { *m = LiquidityPositionsByIdResponse{} }
func (m *LiquidityPositionsByIdResponse) String() string { return proto.CompactTextString(m) }
func (*LiquidityPositionsByIdResponse) ProtoMessage()    {}
func (*LiquidityPositionsByIdResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{44}
}
func (m *LiquidityPositionsByIdResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LiquidityPositionsByIdResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LiquidityPositionsByIdResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LiquidityPositionsByIdResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiquidityPositionsByIdResponse.Merge(m, src)
}
func (m *LiquidityPositionsByIdResponse) XXX_Size() int {
	return m.Size()
}
func (m *LiquidityPositionsByIdResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LiquidityPositionsByIdResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LiquidityPositionsByIdResponse proto.InternalMessageInfo

func (m *LiquidityPositionsByIdResponse) GetData() *Position {
	if m != nil {
		return m.Data
	}
	return nil
}

type LiquidityPositionsByPriceRequest struct {
	// The directed trading pair to request positions for
	TradingPair *DirectedTradingPair `protobuf:"bytes,2,opt,name=trading_pair,json=tradingPair,proto3" json:"trading_pair,omitempty"`
	// The maximum number of positions to return.
	Limit uint64 `protobuf:"varint,5,opt,name=limit,proto3" json:"limit,omitempty"`
}

func (m *LiquidityPositionsByPriceRequest) Reset()         { *m = LiquidityPositionsByPriceRequest{} }
func (m *LiquidityPositionsByPriceRequest) String() string { return proto.CompactTextString(m) }
func (*LiquidityPositionsByPriceRequest) ProtoMessage()    {}
func (*LiquidityPositionsByPriceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{45}
}
func (m *LiquidityPositionsByPriceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LiquidityPositionsByPriceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LiquidityPositionsByPriceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LiquidityPositionsByPriceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiquidityPositionsByPriceRequest.Merge(m, src)
}
func (m *LiquidityPositionsByPriceRequest) XXX_Size() int {
	return m.Size()
}
func (m *LiquidityPositionsByPriceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LiquidityPositionsByPriceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LiquidityPositionsByPriceRequest proto.InternalMessageInfo

func (m *LiquidityPositionsByPriceRequest) GetTradingPair() *DirectedTradingPair {
	if m != nil {
		return m.TradingPair
	}
	return nil
}

func (m *LiquidityPositionsByPriceRequest) GetLimit() uint64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type LiquidityPositionsByPriceResponse struct {
	Data *Position   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Id   *PositionId `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *LiquidityPositionsByPriceResponse) Reset()         { *m = LiquidityPositionsByPriceResponse{} }
func (m *LiquidityPositionsByPriceResponse) String() string { return proto.CompactTextString(m) }
func (*LiquidityPositionsByPriceResponse) ProtoMessage()    {}
func (*LiquidityPositionsByPriceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{46}
}
func (m *LiquidityPositionsByPriceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LiquidityPositionsByPriceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LiquidityPositionsByPriceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LiquidityPositionsByPriceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiquidityPositionsByPriceResponse.Merge(m, src)
}
func (m *LiquidityPositionsByPriceResponse) XXX_Size() int {
	return m.Size()
}
func (m *LiquidityPositionsByPriceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LiquidityPositionsByPriceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LiquidityPositionsByPriceResponse proto.InternalMessageInfo

func (m *LiquidityPositionsByPriceResponse) GetData() *Position {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *LiquidityPositionsByPriceResponse) GetId() *PositionId {
	if m != nil {
		return m.Id
	}
	return nil
}

type SpreadRequest struct {
	TradingPair *TradingPair `protobuf:"bytes,2,opt,name=trading_pair,json=tradingPair,proto3" json:"trading_pair,omitempty"`
}

func (m *SpreadRequest) Reset()         { *m = SpreadRequest{} }
func (m *SpreadRequest) String() string { return proto.CompactTextString(m) }
func (*SpreadRequest) ProtoMessage()    {}
func (*SpreadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{47}
}
func (m *SpreadRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpreadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpreadRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpreadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpreadRequest.Merge(m, src)
}
func (m *SpreadRequest) XXX_Size() int {
	return m.Size()
}
func (m *SpreadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SpreadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SpreadRequest proto.InternalMessageInfo

func (m *SpreadRequest) GetTradingPair() *TradingPair {
	if m != nil {
		return m.TradingPair
	}
	return nil
}

type SpreadResponse struct {
	// The best position when trading 1 => 2.
	Best_1To_2Position *Position `protobuf:"bytes,1,opt,name=best_1_to_2_position,json=best1To2Position,proto3" json:"best_1_to_2_position,omitempty"`
	// The best position when trading 2 => 1.
	Best_2To_1Position *Position `protobuf:"bytes,2,opt,name=best_2_to_1_position,json=best2To1Position,proto3" json:"best_2_to_1_position,omitempty"`
	// An approximation of the effective price when trading 1 => 2.
	ApproxEffectivePrice_1To_2 float64 `protobuf:"fixed64,3,opt,name=approx_effective_price_1_to_2,json=approxEffectivePrice1To2,proto3" json:"approx_effective_price_1_to_2,omitempty"`
	// An approximation of the effective price when trading 2 => 1.
	ApproxEffectivePrice_2To_1 float64 `protobuf:"fixed64,4,opt,name=approx_effective_price_2_to_1,json=approxEffectivePrice2To1,proto3" json:"approx_effective_price_2_to_1,omitempty"`
}

func (m *SpreadResponse) Reset()         { *m = SpreadResponse{} }
func (m *SpreadResponse) String() string { return proto.CompactTextString(m) }
func (*SpreadResponse) ProtoMessage()    {}
func (*SpreadResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{48}
}
func (m *SpreadResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpreadResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpreadResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpreadResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpreadResponse.Merge(m, src)
}
func (m *SpreadResponse) XXX_Size() int {
	return m.Size()
}
func (m *SpreadResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SpreadResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SpreadResponse proto.InternalMessageInfo

func (m *SpreadResponse) GetBest_1To_2Position() *Position {
	if m != nil {
		return m.Best_1To_2Position
	}
	return nil
}

func (m *SpreadResponse) GetBest_2To_1Position() *Position {
	if m != nil {
		return m.Best_2To_1Position
	}
	return nil
}

func (m *SpreadResponse) GetApproxEffectivePrice_1To_2() float64 {
	if m != nil {
		return m.ApproxEffectivePrice_1To_2
	}
	return 0
}

func (m *SpreadResponse) GetApproxEffectivePrice_2To_1() float64 {
	if m != nil {
		return m.ApproxEffectivePrice_2To_1
	}
	return 0
}

type SimulateTradeRequest struct {
	Input   *v14.Value                    `protobuf:"bytes,1,opt,name=input,proto3" json:"input,omitempty"`
	Output  *v14.AssetId                  `protobuf:"bytes,2,opt,name=output,proto3" json:"output,omitempty"`
	Routing *SimulateTradeRequest_Routing `protobuf:"bytes,3,opt,name=routing,proto3" json:"routing,omitempty"`
}

func (m *SimulateTradeRequest) Reset()         { *m = SimulateTradeRequest{} }
func (m *SimulateTradeRequest) String() string { return proto.CompactTextString(m) }
func (*SimulateTradeRequest) ProtoMessage()    {}
func (*SimulateTradeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{49}
}
func (m *SimulateTradeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SimulateTradeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SimulateTradeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SimulateTradeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SimulateTradeRequest.Merge(m, src)
}
func (m *SimulateTradeRequest) XXX_Size() int {
	return m.Size()
}
func (m *SimulateTradeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SimulateTradeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SimulateTradeRequest proto.InternalMessageInfo

func (m *SimulateTradeRequest) GetInput() *v14.Value {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *SimulateTradeRequest) GetOutput() *v14.AssetId {
	if m != nil {
		return m.Output
	}
	return nil
}

func (m *SimulateTradeRequest) GetRouting() *SimulateTradeRequest_Routing {
	if m != nil {
		return m.Routing
	}
	return nil
}

type SimulateTradeRequest_Routing struct {
	// Types that are valid to be assigned to Setting:
	//
	//	*SimulateTradeRequest_Routing_Default_
	//	*SimulateTradeRequest_Routing_SingleHop_
	Setting isSimulateTradeRequest_Routing_Setting `protobuf_oneof:"setting"`
}

func (m *SimulateTradeRequest_Routing) Reset()         { *m = SimulateTradeRequest_Routing{} }
func (m *SimulateTradeRequest_Routing) String() string { return proto.CompactTextString(m) }
func (*SimulateTradeRequest_Routing) ProtoMessage()    {}
func (*SimulateTradeRequest_Routing) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{49, 0}
}
func (m *SimulateTradeRequest_Routing) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SimulateTradeRequest_Routing) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SimulateTradeRequest_Routing.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SimulateTradeRequest_Routing) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SimulateTradeRequest_Routing.Merge(m, src)
}
func (m *SimulateTradeRequest_Routing) XXX_Size() int {
	return m.Size()
}
func (m *SimulateTradeRequest_Routing) XXX_DiscardUnknown() {
	xxx_messageInfo_SimulateTradeRequest_Routing.DiscardUnknown(m)
}

var xxx_messageInfo_SimulateTradeRequest_Routing proto.InternalMessageInfo

type isSimulateTradeRequest_Routing_Setting interface {
	isSimulateTradeRequest_Routing_Setting()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SimulateTradeRequest_Routing_Default_ struct {
	Default *SimulateTradeRequest_Routing_Default `protobuf:"bytes,1,opt,name=default,proto3,oneof" json:"default,omitempty"`
}
type SimulateTradeRequest_Routing_SingleHop_ struct {
	SingleHop *SimulateTradeRequest_Routing_SingleHop `protobuf:"bytes,2,opt,name=single_hop,json=singleHop,proto3,oneof" json:"single_hop,omitempty"`
}

func (*SimulateTradeRequest_Routing_Default_) isSimulateTradeRequest_Routing_Setting()   {}
func (*SimulateTradeRequest_Routing_SingleHop_) isSimulateTradeRequest_Routing_Setting() {}

func (m *SimulateTradeRequest_Routing) GetSetting() isSimulateTradeRequest_Routing_Setting {
	if m != nil {
		return m.Setting
	}
	return nil
}

func (m *SimulateTradeRequest_Routing) GetDefault() *SimulateTradeRequest_Routing_Default {
	if x, ok := m.GetSetting().(*SimulateTradeRequest_Routing_Default_); ok {
		return x.Default
	}
	return nil
}

func (m *SimulateTradeRequest_Routing) GetSingleHop() *SimulateTradeRequest_Routing_SingleHop {
	if x, ok := m.GetSetting().(*SimulateTradeRequest_Routing_SingleHop_); ok {
		return x.SingleHop
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SimulateTradeRequest_Routing) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SimulateTradeRequest_Routing_Default_)(nil),
		(*SimulateTradeRequest_Routing_SingleHop_)(nil),
	}
}

type SimulateTradeRequest_Routing_SingleHop struct {
}

func (m *SimulateTradeRequest_Routing_SingleHop) Reset() {
	*m = SimulateTradeRequest_Routing_SingleHop{}
}
func (m *SimulateTradeRequest_Routing_SingleHop) String() string { return proto.CompactTextString(m) }
func (*SimulateTradeRequest_Routing_SingleHop) ProtoMessage()    {}
func (*SimulateTradeRequest_Routing_SingleHop) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{49, 0, 0}
}
func (m *SimulateTradeRequest_Routing_SingleHop) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SimulateTradeRequest_Routing_SingleHop) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SimulateTradeRequest_Routing_SingleHop.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SimulateTradeRequest_Routing_SingleHop) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SimulateTradeRequest_Routing_SingleHop.Merge(m, src)
}
func (m *SimulateTradeRequest_Routing_SingleHop) XXX_Size() int {
	return m.Size()
}
func (m *SimulateTradeRequest_Routing_SingleHop) XXX_DiscardUnknown() {
	xxx_messageInfo_SimulateTradeRequest_Routing_SingleHop.DiscardUnknown(m)
}

var xxx_messageInfo_SimulateTradeRequest_Routing_SingleHop proto.InternalMessageInfo

type SimulateTradeRequest_Routing_Default struct {
}

func (m *SimulateTradeRequest_Routing_Default) Reset()         { *m = SimulateTradeRequest_Routing_Default{} }
func (m *SimulateTradeRequest_Routing_Default) String() string { return proto.CompactTextString(m) }
func (*SimulateTradeRequest_Routing_Default) ProtoMessage()    {}
func (*SimulateTradeRequest_Routing_Default) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{49, 0, 1}
}
func (m *SimulateTradeRequest_Routing_Default) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SimulateTradeRequest_Routing_Default) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SimulateTradeRequest_Routing_Default.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SimulateTradeRequest_Routing_Default) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SimulateTradeRequest_Routing_Default.Merge(m, src)
}
func (m *SimulateTradeRequest_Routing_Default) XXX_Size() int {
	return m.Size()
}
func (m *SimulateTradeRequest_Routing_Default) XXX_DiscardUnknown() {
	xxx_messageInfo_SimulateTradeRequest_Routing_Default.DiscardUnknown(m)
}

var xxx_messageInfo_SimulateTradeRequest_Routing_Default proto.InternalMessageInfo

type SimulateTradeResponse struct {
	Output *SwapExecution `protobuf:"bytes,1,opt,name=output,proto3" json:"output,omitempty"`
	// Estimated input amount that will not be swapped due to liquidity
	Unfilled *v14.Value `protobuf:"bytes,2,opt,name=unfilled,proto3" json:"unfilled,omitempty"`
}

func (m *SimulateTradeResponse) Reset()         { *m = SimulateTradeResponse{} }
func (m *SimulateTradeResponse) String() string { return proto.CompactTextString(m) }
func (*SimulateTradeResponse) ProtoMessage()    {}
func (*SimulateTradeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{50}
}
func (m *SimulateTradeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SimulateTradeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SimulateTradeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SimulateTradeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SimulateTradeResponse.Merge(m, src)
}
func (m *SimulateTradeResponse) XXX_Size() int {
	return m.Size()
}
func (m *SimulateTradeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SimulateTradeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SimulateTradeResponse proto.InternalMessageInfo

func (m *SimulateTradeResponse) GetOutput() *SwapExecution {
	if m != nil {
		return m.Output
	}
	return nil
}

func (m *SimulateTradeResponse) GetUnfilled() *v14.Value {
	if m != nil {
		return m.Unfilled
	}
	return nil
}

type EventSwap struct {
	// The trading pair to swap.
	TradingPair *TradingPair `protobuf:"bytes,1,opt,name=trading_pair,json=tradingPair,proto3" json:"trading_pair,omitempty"`
	// The amount for asset 1.
	Delta_1I *v13.Amount `protobuf:"bytes,2,opt,name=delta_1_i,json=delta1I,proto3" json:"delta_1_i,omitempty"`
	// The amount for asset 2.
	Delta_2I *v13.Amount `protobuf:"bytes,3,opt,name=delta_2_i,json=delta2I,proto3" json:"delta_2_i,omitempty"`
	// The swap commitment.
	SwapCommitment *v12.StateCommitment `protobuf:"bytes,4,opt,name=swap_commitment,json=swapCommitment,proto3" json:"swap_commitment,omitempty"`
}

func (m *EventSwap) Reset()         { *m = EventSwap{} }
func (m *EventSwap) String() string { return proto.CompactTextString(m) }
func (*EventSwap) ProtoMessage()    {}
func (*EventSwap) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{51}
}
func (m *EventSwap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSwap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSwap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSwap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSwap.Merge(m, src)
}
func (m *EventSwap) XXX_Size() int {
	return m.Size()
}
func (m *EventSwap) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSwap.DiscardUnknown(m)
}

var xxx_messageInfo_EventSwap proto.InternalMessageInfo

func (m *EventSwap) GetTradingPair() *TradingPair {
	if m != nil {
		return m.TradingPair
	}
	return nil
}

func (m *EventSwap) GetDelta_1I() *v13.Amount {
	if m != nil {
		return m.Delta_1I
	}
	return nil
}

func (m *EventSwap) GetDelta_2I() *v13.Amount {
	if m != nil {
		return m.Delta_2I
	}
	return nil
}

func (m *EventSwap) GetSwapCommitment() *v12.StateCommitment {
	if m != nil {
		return m.SwapCommitment
	}
	return nil
}

type EventSwapClaim struct {
	// The trading pair that is subject of the swap claim.
	TradingPair *TradingPair `protobuf:"bytes,1,opt,name=trading_pair,json=tradingPair,proto3" json:"trading_pair,omitempty"`
	// Note commitment for the first asset.
	Output_1Commitment *v12.StateCommitment `protobuf:"bytes,2,opt,name=output_1_commitment,json=output1Commitment,proto3" json:"output_1_commitment,omitempty"`
	// Note commitment for the second asset.
	Output_2Commitment *v12.StateCommitment `protobuf:"bytes,3,opt,name=output_2_commitment,json=output2Commitment,proto3" json:"output_2_commitment,omitempty"`
	// The nullifier for the swap commitment.
	Nullifier *v1.Nullifier `protobuf:"bytes,4,opt,name=nullifier,proto3" json:"nullifier,omitempty"`
}

func (m *EventSwapClaim) Reset()         { *m = EventSwapClaim{} }
func (m *EventSwapClaim) String() string { return proto.CompactTextString(m) }
func (*EventSwapClaim) ProtoMessage()    {}
func (*EventSwapClaim) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{52}
}
func (m *EventSwapClaim) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSwapClaim) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSwapClaim.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSwapClaim) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSwapClaim.Merge(m, src)
}
func (m *EventSwapClaim) XXX_Size() int {
	return m.Size()
}
func (m *EventSwapClaim) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSwapClaim.DiscardUnknown(m)
}

var xxx_messageInfo_EventSwapClaim proto.InternalMessageInfo

func (m *EventSwapClaim) GetTradingPair() *TradingPair {
	if m != nil {
		return m.TradingPair
	}
	return nil
}

func (m *EventSwapClaim) GetOutput_1Commitment() *v12.StateCommitment {
	if m != nil {
		return m.Output_1Commitment
	}
	return nil
}

func (m *EventSwapClaim) GetOutput_2Commitment() *v12.StateCommitment {
	if m != nil {
		return m.Output_2Commitment
	}
	return nil
}

func (m *EventSwapClaim) GetNullifier() *v1.Nullifier {
	if m != nil {
		return m.Nullifier
	}
	return nil
}

type EventPositionOpen struct {
	// Position ID.
	PositionId *PositionId `protobuf:"bytes,1,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
	// The trading pair to open.
	TradingPair *TradingPair `protobuf:"bytes,2,opt,name=trading_pair,json=tradingPair,proto3" json:"trading_pair,omitempty"`
	// The amount for asset 1.
	Reserves_1 *v13.Amount `protobuf:"bytes,3,opt,name=reserves_1,json=reserves1,proto3" json:"reserves_1,omitempty"`
	// The amount for asset 2.
	Reserves_2 *v13.Amount `protobuf:"bytes,4,opt,name=reserves_2,json=reserves2,proto3" json:"reserves_2,omitempty"`
	// The trading fee for the position, expressed in basis points.
	// e.g. 2% fee is expressed as 200, 100% fee is expressed as 10000;
	TradingFee uint32 `protobuf:"varint,5,opt,name=trading_fee,json=tradingFee,proto3" json:"trading_fee,omitempty"`
}

func (m *EventPositionOpen) Reset()         { *m = EventPositionOpen{} }
func (m *EventPositionOpen) String() string { return proto.CompactTextString(m) }
func (*EventPositionOpen) ProtoMessage()    {}
func (*EventPositionOpen) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{53}
}
func (m *EventPositionOpen) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventPositionOpen) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventPositionOpen.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventPositionOpen) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventPositionOpen.Merge(m, src)
}
func (m *EventPositionOpen) XXX_Size() int {
	return m.Size()
}
func (m *EventPositionOpen) XXX_DiscardUnknown() {
	xxx_messageInfo_EventPositionOpen.DiscardUnknown(m)
}

var xxx_messageInfo_EventPositionOpen proto.InternalMessageInfo

func (m *EventPositionOpen) GetPositionId() *PositionId {
	if m != nil {
		return m.PositionId
	}
	return nil
}

func (m *EventPositionOpen) GetTradingPair() *TradingPair {
	if m != nil {
		return m.TradingPair
	}
	return nil
}

func (m *EventPositionOpen) GetReserves_1() *v13.Amount {
	if m != nil {
		return m.Reserves_1
	}
	return nil
}

func (m *EventPositionOpen) GetReserves_2() *v13.Amount {
	if m != nil {
		return m.Reserves_2
	}
	return nil
}

func (m *EventPositionOpen) GetTradingFee() uint32 {
	if m != nil {
		return m.TradingFee
	}
	return 0
}

type EventPositionClose struct {
	// The ID of the closed position
	PositionId *PositionId `protobuf:"bytes,1,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
}

func (m *EventPositionClose) Reset()         { *m = EventPositionClose{} }
func (m *EventPositionClose) String() string { return proto.CompactTextString(m) }
func (*EventPositionClose) ProtoMessage()    {}
func (*EventPositionClose) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{54}
}
func (m *EventPositionClose) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventPositionClose) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventPositionClose.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventPositionClose) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventPositionClose.Merge(m, src)
}
func (m *EventPositionClose) XXX_Size() int {
	return m.Size()
}
func (m *EventPositionClose) XXX_DiscardUnknown() {
	xxx_messageInfo_EventPositionClose.DiscardUnknown(m)
}

var xxx_messageInfo_EventPositionClose proto.InternalMessageInfo

func (m *EventPositionClose) GetPositionId() *PositionId {
	if m != nil {
		return m.PositionId
	}
	return nil
}

type EventQueuePositionClose struct {
	// The ID of the position queued that is closed for closure.
	PositionId *PositionId `protobuf:"bytes,1,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
}

func (m *EventQueuePositionClose) Reset()         { *m = EventQueuePositionClose{} }
func (m *EventQueuePositionClose) String() string { return proto.CompactTextString(m) }
func (*EventQueuePositionClose) ProtoMessage()    {}
func (*EventQueuePositionClose) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{55}
}
func (m *EventQueuePositionClose) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventQueuePositionClose) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventQueuePositionClose.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventQueuePositionClose) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventQueuePositionClose.Merge(m, src)
}
func (m *EventQueuePositionClose) XXX_Size() int {
	return m.Size()
}
func (m *EventQueuePositionClose) XXX_DiscardUnknown() {
	xxx_messageInfo_EventQueuePositionClose.DiscardUnknown(m)
}

var xxx_messageInfo_EventQueuePositionClose proto.InternalMessageInfo

func (m *EventQueuePositionClose) GetPositionId() *PositionId {
	if m != nil {
		return m.PositionId
	}
	return nil
}

type EventPositionWithdraw struct {
	// The ID of the withdrawn position.
	PositionId *PositionId `protobuf:"bytes,1,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
	// The trading pair of the withdrawn position.
	TradingPair *TradingPair `protobuf:"bytes,2,opt,name=trading_pair,json=tradingPair,proto3" json:"trading_pair,omitempty"`
	// The reserves of asset 1 of the withdrawn position.
	Reserves_1 *v13.Amount `protobuf:"bytes,3,opt,name=reserves_1,json=reserves1,proto3" json:"reserves_1,omitempty"`
	// The reserves of asset 2 of the withdrawn position.
	Reserves_2 *v13.Amount `protobuf:"bytes,4,opt,name=reserves_2,json=reserves2,proto3" json:"reserves_2,omitempty"`
	// The sequence number of the withdrawal.
	Sequence uint64 `protobuf:"varint,5,opt,name=sequence,proto3" json:"sequence,omitempty"`
}

func (m *EventPositionWithdraw) Reset()         { *m = EventPositionWithdraw{} }
func (m *EventPositionWithdraw) String() string { return proto.CompactTextString(m) }
func (*EventPositionWithdraw) ProtoMessage()    {}
func (*EventPositionWithdraw) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{56}
}
func (m *EventPositionWithdraw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventPositionWithdraw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventPositionWithdraw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventPositionWithdraw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventPositionWithdraw.Merge(m, src)
}
func (m *EventPositionWithdraw) XXX_Size() int {
	return m.Size()
}
func (m *EventPositionWithdraw) XXX_DiscardUnknown() {
	xxx_messageInfo_EventPositionWithdraw.DiscardUnknown(m)
}

var xxx_messageInfo_EventPositionWithdraw proto.InternalMessageInfo

func (m *EventPositionWithdraw) GetPositionId() *PositionId {
	if m != nil {
		return m.PositionId
	}
	return nil
}

func (m *EventPositionWithdraw) GetTradingPair() *TradingPair {
	if m != nil {
		return m.TradingPair
	}
	return nil
}

func (m *EventPositionWithdraw) GetReserves_1() *v13.Amount {
	if m != nil {
		return m.Reserves_1
	}
	return nil
}

func (m *EventPositionWithdraw) GetReserves_2() *v13.Amount {
	if m != nil {
		return m.Reserves_2
	}
	return nil
}

func (m *EventPositionWithdraw) GetSequence() uint64 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

type EventPositionExecution struct {
	// The ID of the position executed against.
	PositionId *PositionId `protobuf:"bytes,1,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
	// The trading pair of the position executed against.
	TradingPair *TradingPair `protobuf:"bytes,2,opt,name=trading_pair,json=tradingPair,proto3" json:"trading_pair,omitempty"`
	// The reserves of asset 1 of the position after execution.
	Reserves_1 *v13.Amount `protobuf:"bytes,3,opt,name=reserves_1,json=reserves1,proto3" json:"reserves_1,omitempty"`
	// The reserves of asset 2 of the position after execution.
	Reserves_2 *v13.Amount `protobuf:"bytes,4,opt,name=reserves_2,json=reserves2,proto3" json:"reserves_2,omitempty"`
	// The reserves of asset 1 of the position before execution.
	PrevReserves_1 *v13.Amount `protobuf:"bytes,5,opt,name=prev_reserves_1,json=prevReserves1,proto3" json:"prev_reserves_1,omitempty"`
	// The reserves of asset 2 of the position before execution.
	PrevReserves_2 *v13.Amount `protobuf:"bytes,6,opt,name=prev_reserves_2,json=prevReserves2,proto3" json:"prev_reserves_2,omitempty"`
	// Context: the end-to-end route that was being traversed during execution.
	Context *DirectedTradingPair `protobuf:"bytes,7,opt,name=context,proto3" json:"context,omitempty"`
}

func (m *EventPositionExecution) Reset()         { *m = EventPositionExecution{} }
func (m *EventPositionExecution) String() string { return proto.CompactTextString(m) }
func (*EventPositionExecution) ProtoMessage()    {}
func (*EventPositionExecution) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{57}
}
func (m *EventPositionExecution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventPositionExecution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventPositionExecution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventPositionExecution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventPositionExecution.Merge(m, src)
}
func (m *EventPositionExecution) XXX_Size() int {
	return m.Size()
}
func (m *EventPositionExecution) XXX_DiscardUnknown() {
	xxx_messageInfo_EventPositionExecution.DiscardUnknown(m)
}

var xxx_messageInfo_EventPositionExecution proto.InternalMessageInfo

func (m *EventPositionExecution) GetPositionId() *PositionId {
	if m != nil {
		return m.PositionId
	}
	return nil
}

func (m *EventPositionExecution) GetTradingPair() *TradingPair {
	if m != nil {
		return m.TradingPair
	}
	return nil
}

func (m *EventPositionExecution) GetReserves_1() *v13.Amount {
	if m != nil {
		return m.Reserves_1
	}
	return nil
}

func (m *EventPositionExecution) GetReserves_2() *v13.Amount {
	if m != nil {
		return m.Reserves_2
	}
	return nil
}

func (m *EventPositionExecution) GetPrevReserves_1() *v13.Amount {
	if m != nil {
		return m.PrevReserves_1
	}
	return nil
}

func (m *EventPositionExecution) GetPrevReserves_2() *v13.Amount {
	if m != nil {
		return m.PrevReserves_2
	}
	return nil
}

func (m *EventPositionExecution) GetContext() *DirectedTradingPair {
	if m != nil {
		return m.Context
	}
	return nil
}

type EventBatchSwap struct {
	// The BatchSwapOutputData containing the results of the batch swap.
	BatchSwapOutputData *BatchSwapOutputData `protobuf:"bytes,1,opt,name=batch_swap_output_data,json=batchSwapOutputData,proto3" json:"batch_swap_output_data,omitempty"`
	// The record of execution for the batch swap in the 1 -> 2 direction.
	SwapExecution_1For_2 *SwapExecution `protobuf:"bytes,2,opt,name=swap_execution_1_for_2,json=swapExecution1For2,proto3" json:"swap_execution_1_for_2,omitempty"`
	// The record of execution for the batch swap in the 2 -> 1 direction.
	SwapExecution_2For_1 *SwapExecution `protobuf:"bytes,3,opt,name=swap_execution_2_for_1,json=swapExecution2For1,proto3" json:"swap_execution_2_for_1,omitempty"`
}

func (m *EventBatchSwap) Reset()         { *m = EventBatchSwap{} }
func (m *EventBatchSwap) String() string { return proto.CompactTextString(m) }
func (*EventBatchSwap) ProtoMessage()    {}
func (*EventBatchSwap) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{58}
}
func (m *EventBatchSwap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventBatchSwap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventBatchSwap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventBatchSwap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventBatchSwap.Merge(m, src)
}
func (m *EventBatchSwap) XXX_Size() int {
	return m.Size()
}
func (m *EventBatchSwap) XXX_DiscardUnknown() {
	xxx_messageInfo_EventBatchSwap.DiscardUnknown(m)
}

var xxx_messageInfo_EventBatchSwap proto.InternalMessageInfo

func (m *EventBatchSwap) GetBatchSwapOutputData() *BatchSwapOutputData {
	if m != nil {
		return m.BatchSwapOutputData
	}
	return nil
}

func (m *EventBatchSwap) GetSwapExecution_1For_2() *SwapExecution {
	if m != nil {
		return m.SwapExecution_1For_2
	}
	return nil
}

func (m *EventBatchSwap) GetSwapExecution_2For_1() *SwapExecution {
	if m != nil {
		return m.SwapExecution_2For_1
	}
	return nil
}

type EventArbExecution struct {
	// The height at which the arb execution occurred.
	Height uint64 `protobuf:"varint,1,opt,name=height,proto3" json:"height,omitempty"`
	// The record of execution for the arb execution.
	SwapExecution *SwapExecution `protobuf:"bytes,2,opt,name=swap_execution,json=swapExecution,proto3" json:"swap_execution,omitempty"`
}

func (m *EventArbExecution) Reset()         { *m = EventArbExecution{} }
func (m *EventArbExecution) String() string { return proto.CompactTextString(m) }
func (*EventArbExecution) ProtoMessage()    {}
func (*EventArbExecution) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{59}
}
func (m *EventArbExecution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventArbExecution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventArbExecution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventArbExecution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventArbExecution.Merge(m, src)
}
func (m *EventArbExecution) XXX_Size() int {
	return m.Size()
}
func (m *EventArbExecution) XXX_DiscardUnknown() {
	xxx_messageInfo_EventArbExecution.DiscardUnknown(m)
}

var xxx_messageInfo_EventArbExecution proto.InternalMessageInfo

func (m *EventArbExecution) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *EventArbExecution) GetSwapExecution() *SwapExecution {
	if m != nil {
		return m.SwapExecution
	}
	return nil
}

// Indicates that value was added to the DEX.
type EventValueCircuitBreakerCredit struct {
	// The asset ID being deposited into the DEX.
	AssetId *v14.AssetId `protobuf:"bytes,1,opt,name=asset_id,json=assetId,proto3" json:"asset_id,omitempty"`
	// The previous balance of the asset in the DEX.
	PreviousBalance *v13.Amount `protobuf:"bytes,2,opt,name=previous_balance,json=previousBalance,proto3" json:"previous_balance,omitempty"`
	// The new balance of the asset in the DEX.
	NewBalance *v13.Amount `protobuf:"bytes,3,opt,name=new_balance,json=newBalance,proto3" json:"new_balance,omitempty"`
}

func (m *EventValueCircuitBreakerCredit) Reset()         { *m = EventValueCircuitBreakerCredit{} }
func (m *EventValueCircuitBreakerCredit) String() string { return proto.CompactTextString(m) }
func (*EventValueCircuitBreakerCredit) ProtoMessage()    {}
func (*EventValueCircuitBreakerCredit) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{60}
}
func (m *EventValueCircuitBreakerCredit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventValueCircuitBreakerCredit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventValueCircuitBreakerCredit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventValueCircuitBreakerCredit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventValueCircuitBreakerCredit.Merge(m, src)
}
func (m *EventValueCircuitBreakerCredit) XXX_Size() int {
	return m.Size()
}
func (m *EventValueCircuitBreakerCredit) XXX_DiscardUnknown() {
	xxx_messageInfo_EventValueCircuitBreakerCredit.DiscardUnknown(m)
}

var xxx_messageInfo_EventValueCircuitBreakerCredit proto.InternalMessageInfo

func (m *EventValueCircuitBreakerCredit) GetAssetId() *v14.AssetId {
	if m != nil {
		return m.AssetId
	}
	return nil
}

func (m *EventValueCircuitBreakerCredit) GetPreviousBalance() *v13.Amount {
	if m != nil {
		return m.PreviousBalance
	}
	return nil
}

func (m *EventValueCircuitBreakerCredit) GetNewBalance() *v13.Amount {
	if m != nil {
		return m.NewBalance
	}
	return nil
}

// Indicates that value is leaving the DEX.
type EventValueCircuitBreakerDebit struct {
	// The asset ID being deposited into the DEX.
	AssetId *v14.AssetId `protobuf:"bytes,1,opt,name=asset_id,json=assetId,proto3" json:"asset_id,omitempty"`
	// The previous balance of the asset in the DEX.
	PreviousBalance *v13.Amount `protobuf:"bytes,2,opt,name=previous_balance,json=previousBalance,proto3" json:"previous_balance,omitempty"`
	// The new balance of the asset in the DEX.
	NewBalance *v13.Amount `protobuf:"bytes,3,opt,name=new_balance,json=newBalance,proto3" json:"new_balance,omitempty"`
}

func (m *EventValueCircuitBreakerDebit) Reset()         { *m = EventValueCircuitBreakerDebit{} }
func (m *EventValueCircuitBreakerDebit) String() string { return proto.CompactTextString(m) }
func (*EventValueCircuitBreakerDebit) ProtoMessage()    {}
func (*EventValueCircuitBreakerDebit) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{61}
}
func (m *EventValueCircuitBreakerDebit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventValueCircuitBreakerDebit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventValueCircuitBreakerDebit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventValueCircuitBreakerDebit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventValueCircuitBreakerDebit.Merge(m, src)
}
func (m *EventValueCircuitBreakerDebit) XXX_Size() int {
	return m.Size()
}
func (m *EventValueCircuitBreakerDebit) XXX_DiscardUnknown() {
	xxx_messageInfo_EventValueCircuitBreakerDebit.DiscardUnknown(m)
}

var xxx_messageInfo_EventValueCircuitBreakerDebit proto.InternalMessageInfo

func (m *EventValueCircuitBreakerDebit) GetAssetId() *v14.AssetId {
	if m != nil {
		return m.AssetId
	}
	return nil
}

func (m *EventValueCircuitBreakerDebit) GetPreviousBalance() *v13.Amount {
	if m != nil {
		return m.PreviousBalance
	}
	return nil
}

func (m *EventValueCircuitBreakerDebit) GetNewBalance() *v13.Amount {
	if m != nil {
		return m.NewBalance
	}
	return nil
}

type DexParameters struct {
	// Whether or not the DEX is enabled.
	IsEnabled bool `protobuf:"varint,1,opt,name=is_enabled,json=isEnabled,proto3" json:"is_enabled,omitempty"`
	// The list of fixed candidates for routing.
	FixedCandidates []*v14.AssetId `protobuf:"bytes,2,rep,name=fixed_candidates,json=fixedCandidates,proto3" json:"fixed_candidates,omitempty"`
	// The number of hops to traverse while routing from A to B.
	MaxHops uint32 `protobuf:"varint,3,opt,name=max_hops,json=maxHops,proto3" json:"max_hops,omitempty"`
	// The maximum number of positions per trading pair.
	// If this number is exceeded, positions with the least
	// inventory get evicted from the DEX.
	MaxPositionsPerPair uint32 `protobuf:"varint,4,opt,name=max_positions_per_pair,json=maxPositionsPerPair,proto3" json:"max_positions_per_pair,omitempty"`
	// The maximum number of routing and execution steps to be performed
	// for a single pair
	MaxExecutionBudget uint32 `protobuf:"varint,5,opt,name=max_execution_budget,json=maxExecutionBudget,proto3" json:"max_execution_budget,omitempty"`
}

func (m *DexParameters) Reset()         { *m = DexParameters{} }
func (m *DexParameters) String() string { return proto.CompactTextString(m) }
func (*DexParameters) ProtoMessage()    {}
func (*DexParameters) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{62}
}
func (m *DexParameters) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DexParameters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DexParameters.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DexParameters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DexParameters.Merge(m, src)
}
func (m *DexParameters) XXX_Size() int {
	return m.Size()
}
func (m *DexParameters) XXX_DiscardUnknown() {
	xxx_messageInfo_DexParameters.DiscardUnknown(m)
}

var xxx_messageInfo_DexParameters proto.InternalMessageInfo

func (m *DexParameters) GetIsEnabled() bool {
	if m != nil {
		return m.IsEnabled
	}
	return false
}

func (m *DexParameters) GetFixedCandidates() []*v14.AssetId {
	if m != nil {
		return m.FixedCandidates
	}
	return nil
}

func (m *DexParameters) GetMaxHops() uint32 {
	if m != nil {
		return m.MaxHops
	}
	return 0
}

func (m *DexParameters) GetMaxPositionsPerPair() uint32 {
	if m != nil {
		return m.MaxPositionsPerPair
	}
	return 0
}

func (m *DexParameters) GetMaxExecutionBudget() uint32 {
	if m != nil {
		return m.MaxExecutionBudget
	}
	return 0
}

type GenesisContent struct {
	// The initial parameters for the DEX.
	DexParams *DexParameters `protobuf:"bytes,1,opt,name=dex_params,json=dexParams,proto3" json:"dex_params,omitempty"`
}

func (m *GenesisContent) Reset()         { *m = GenesisContent{} }
func (m *GenesisContent) String() string { return proto.CompactTextString(m) }
func (*GenesisContent) ProtoMessage()    {}
func (*GenesisContent) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{63}
}
func (m *GenesisContent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenesisContent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenesisContent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenesisContent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenesisContent.Merge(m, src)
}
func (m *GenesisContent) XXX_Size() int {
	return m.Size()
}
func (m *GenesisContent) XXX_DiscardUnknown() {
	xxx_messageInfo_GenesisContent.DiscardUnknown(m)
}

var xxx_messageInfo_GenesisContent proto.InternalMessageInfo

func (m *GenesisContent) GetDexParams() *DexParameters {
	if m != nil {
		return m.DexParams
	}
	return nil
}

type CandlestickData struct {
	// The height of the candlestick data.
	Height uint64 `protobuf:"varint,1,opt,name=height,proto3" json:"height,omitempty"`
	// The first observed price during the block execution.
	Open float64 `protobuf:"fixed64,2,opt,name=open,proto3" json:"open,omitempty"`
	// The last observed price during the block execution.
	Close float64 `protobuf:"fixed64,3,opt,name=close,proto3" json:"close,omitempty"`
	// The highest observed price during the block execution.
	High float64 `protobuf:"fixed64,4,opt,name=high,proto3" json:"high,omitempty"`
	// The lowest observed price during the block execution.
	Low float64 `protobuf:"fixed64,5,opt,name=low,proto3" json:"low,omitempty"`
	// The volume that traded "directly", during individual position executions.
	DirectVolume float64 `protobuf:"fixed64,6,opt,name=direct_volume,json=directVolume,proto3" json:"direct_volume,omitempty"`
	// The volume that traded as part of swaps, which could have traversed multiple routes.
	SwapVolume float64 `protobuf:"fixed64,7,opt,name=swap_volume,json=swapVolume,proto3" json:"swap_volume,omitempty"`
}

func (m *CandlestickData) Reset()         { *m = CandlestickData{} }
func (m *CandlestickData) String() string { return proto.CompactTextString(m) }
func (*CandlestickData) ProtoMessage()    {}
func (*CandlestickData) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{64}
}
func (m *CandlestickData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CandlestickData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CandlestickData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CandlestickData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CandlestickData.Merge(m, src)
}
func (m *CandlestickData) XXX_Size() int {
	return m.Size()
}
func (m *CandlestickData) XXX_DiscardUnknown() {
	xxx_messageInfo_CandlestickData.DiscardUnknown(m)
}

var xxx_messageInfo_CandlestickData proto.InternalMessageInfo

func (m *CandlestickData) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *CandlestickData) GetOpen() float64 {
	if m != nil {
		return m.Open
	}
	return 0
}

func (m *CandlestickData) GetClose() float64 {
	if m != nil {
		return m.Close
	}
	return 0
}

func (m *CandlestickData) GetHigh() float64 {
	if m != nil {
		return m.High
	}
	return 0
}

func (m *CandlestickData) GetLow() float64 {
	if m != nil {
		return m.Low
	}
	return 0
}

func (m *CandlestickData) GetDirectVolume() float64 {
	if m != nil {
		return m.DirectVolume
	}
	return 0
}

func (m *CandlestickData) GetSwapVolume() float64 {
	if m != nil {
		return m.SwapVolume
	}
	return 0
}

type CandlestickDataRequest struct {
	// The directed trading pair to request candlestick data for.
	//
	// NOTE: the returned data will only have trades from the SOURCE asset to the
	// DEST asset, not the other direction. Make another request if you want both
	// sets of data.
	Pair *DirectedTradingPair `protobuf:"bytes,1,opt,name=pair,proto3" json:"pair,omitempty"`
	// The maximum number of candlestick data points to return.
	//
	// The server may clamp this limit to a maximum value.
	Limit uint64 `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
	// The height to start the query from.
	//
	// If this is unset (= 0), the server will return the most recent data points.
	StartHeight uint64 `protobuf:"varint,3,opt,name=start_height,json=startHeight,proto3" json:"start_height,omitempty"`
}

func (m *CandlestickDataRequest) Reset()         { *m = CandlestickDataRequest{} }
func (m *CandlestickDataRequest) String() string { return proto.CompactTextString(m) }
func (*CandlestickDataRequest) ProtoMessage()    {}
func (*CandlestickDataRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{65}
}
func (m *CandlestickDataRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CandlestickDataRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CandlestickDataRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CandlestickDataRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CandlestickDataRequest.Merge(m, src)
}
func (m *CandlestickDataRequest) XXX_Size() int {
	return m.Size()
}
func (m *CandlestickDataRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CandlestickDataRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CandlestickDataRequest proto.InternalMessageInfo

func (m *CandlestickDataRequest) GetPair() *DirectedTradingPair {
	if m != nil {
		return m.Pair
	}
	return nil
}

func (m *CandlestickDataRequest) GetLimit() uint64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *CandlestickDataRequest) GetStartHeight() uint64 {
	if m != nil {
		return m.StartHeight
	}
	return 0
}

type CandlestickDataResponse struct {
	// The candlestick data points.
	Data []*CandlestickData `protobuf:"bytes,1,rep,name=data,proto3" json:"data,omitempty"`
}

func (m *CandlestickDataResponse) Reset()         { *m = CandlestickDataResponse{} }
func (m *CandlestickDataResponse) String() string { return proto.CompactTextString(m) }
func (*CandlestickDataResponse) ProtoMessage()    {}
func (*CandlestickDataResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{66}
}
func (m *CandlestickDataResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CandlestickDataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CandlestickDataResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CandlestickDataResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CandlestickDataResponse.Merge(m, src)
}
func (m *CandlestickDataResponse) XXX_Size() int {
	return m.Size()
}
func (m *CandlestickDataResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CandlestickDataResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CandlestickDataResponse proto.InternalMessageInfo

func (m *CandlestickDataResponse) GetData() []*CandlestickData {
	if m != nil {
		return m.Data
	}
	return nil
}

type CandlestickDataStreamRequest struct {
	// The directed trading pair to subscribe to.
	Pair *DirectedTradingPair `protobuf:"bytes,1,opt,name=pair,proto3" json:"pair,omitempty"`
}

func (m *CandlestickDataStreamRequest) Reset()         { *m = CandlestickDataStreamRequest{} }
func (m *CandlestickDataStreamRequest) String() string { return proto.CompactTextString(m) }
func (*CandlestickDataStreamRequest) ProtoMessage()    {}
func (*CandlestickDataStreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{67}
}
func (m *CandlestickDataStreamRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CandlestickDataStreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CandlestickDataStreamRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CandlestickDataStreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CandlestickDataStreamRequest.Merge(m, src)
}
func (m *CandlestickDataStreamRequest) XXX_Size() int {
	return m.Size()
}
func (m *CandlestickDataStreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CandlestickDataStreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CandlestickDataStreamRequest proto.InternalMessageInfo

func (m *CandlestickDataStreamRequest) GetPair() *DirectedTradingPair {
	if m != nil {
		return m.Pair
	}
	return nil
}

type CandlestickDataStreamResponse struct {
	// The candlestick data point.
	Data *CandlestickData `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *CandlestickDataStreamResponse) Reset()         { *m = CandlestickDataStreamResponse{} }
func (m *CandlestickDataStreamResponse) String() string { return proto.CompactTextString(m) }
func (*CandlestickDataStreamResponse) ProtoMessage()    {}
func (*CandlestickDataStreamResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ec17dcdac15b4004, []int{68}
}
func (m *CandlestickDataStreamResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CandlestickDataStreamResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CandlestickDataStreamResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CandlestickDataStreamResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CandlestickDataStreamResponse.Merge(m, src)
}
func (m *CandlestickDataStreamResponse) XXX_Size() int {
	return m.Size()
}
func (m *CandlestickDataStreamResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CandlestickDataStreamResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CandlestickDataStreamResponse proto.InternalMessageInfo

func (m *CandlestickDataStreamResponse) GetData() *CandlestickData {
	if m != nil {
		return m.Data
	}
	return nil
}

func init() {
	// proto.RegisterEnum("penumbra.core.component.dex.v1.PositionState_PositionStateEnum", PositionState_PositionStateEnum_name, PositionState_PositionStateEnum_value)
	proto.RegisterType((*ZKSwapProof)(nil), "penumbra.core.component.dex.v1.ZKSwapProof")
	proto.RegisterType((*ZKSwapClaimProof)(nil), "penumbra.core.component.dex.v1.ZKSwapClaimProof")
	proto.RegisterType((*Swap)(nil), "penumbra.core.component.dex.v1.Swap")
	proto.RegisterType((*SwapClaim)(nil), "penumbra.core.component.dex.v1.SwapClaim")
	proto.RegisterType((*SwapClaimBody)(nil), "penumbra.core.component.dex.v1.SwapClaimBody")
	proto.RegisterType((*SwapBody)(nil), "penumbra.core.component.dex.v1.SwapBody")
	proto.RegisterType((*SwapPayload)(nil), "penumbra.core.component.dex.v1.SwapPayload")
	proto.RegisterType((*SwapPlaintext)(nil), "penumbra.core.component.dex.v1.SwapPlaintext")
	proto.RegisterType((*SwapPlan)(nil), "penumbra.core.component.dex.v1.SwapPlan")
	proto.RegisterType((*SwapClaimPlan)(nil), "penumbra.core.component.dex.v1.SwapClaimPlan")
	proto.RegisterType((*SwapView)(nil), "penumbra.core.component.dex.v1.SwapView")
	proto.RegisterType((*SwapView_Visible)(nil), "penumbra.core.component.dex.v1.SwapView.Visible")
	proto.RegisterType((*SwapView_Opaque)(nil), "penumbra.core.component.dex.v1.SwapView.Opaque")
	proto.RegisterType((*SwapClaimView)(nil), "penumbra.core.component.dex.v1.SwapClaimView")
	proto.RegisterType((*SwapClaimView_Visible)(nil), "penumbra.core.component.dex.v1.SwapClaimView.Visible")
	proto.RegisterType((*SwapClaimView_Opaque)(nil), "penumbra.core.component.dex.v1.SwapClaimView.Opaque")
	proto.RegisterType((*TradingPair)(nil), "penumbra.core.component.dex.v1.TradingPair")
	proto.RegisterType((*DirectedTradingPair)(nil), "penumbra.core.component.dex.v1.DirectedTradingPair")
	proto.RegisterType((*BatchSwapOutputData)(nil), "penumbra.core.component.dex.v1.BatchSwapOutputData")
	proto.RegisterType((*TradingFunction)(nil), "penumbra.core.component.dex.v1.TradingFunction")
	proto.RegisterType((*BareTradingFunction)(nil), "penumbra.core.component.dex.v1.BareTradingFunction")
	proto.RegisterType((*Reserves)(nil), "penumbra.core.component.dex.v1.Reserves")
	proto.RegisterType((*Position)(nil), "penumbra.core.component.dex.v1.Position")
	proto.RegisterType((*PositionId)(nil), "penumbra.core.component.dex.v1.PositionId")
	proto.RegisterType((*PositionState)(nil), "penumbra.core.component.dex.v1.PositionState")
	proto.RegisterType((*LpNft)(nil), "penumbra.core.component.dex.v1.LpNft")
	proto.RegisterType((*PositionOpen)(nil), "penumbra.core.component.dex.v1.PositionOpen")
	proto.RegisterType((*PositionClose)(nil), "penumbra.core.component.dex.v1.PositionClose")
	proto.RegisterType((*PositionWithdraw)(nil), "penumbra.core.component.dex.v1.PositionWithdraw")
	proto.RegisterType((*PositionRewardClaim)(nil), "penumbra.core.component.dex.v1.PositionRewardClaim")
	proto.RegisterType((*SwapExecution)(nil), "penumbra.core.component.dex.v1.SwapExecution")
	proto.RegisterType((*SwapExecution_Trace)(nil), "penumbra.core.component.dex.v1.SwapExecution.Trace")
	proto.RegisterType((*PositionWithdrawPlan)(nil), "penumbra.core.component.dex.v1.PositionWithdrawPlan")
	proto.RegisterType((*PositionRewardClaimPlan)(nil), "penumbra.core.component.dex.v1.PositionRewardClaimPlan")
	proto.RegisterType((*BatchSwapOutputDataRequest)(nil), "penumbra.core.component.dex.v1.BatchSwapOutputDataRequest")
	proto.RegisterType((*BatchSwapOutputDataResponse)(nil), "penumbra.core.component.dex.v1.BatchSwapOutputDataResponse")
	proto.RegisterType((*SwapExecutionRequest)(nil), "penumbra.core.component.dex.v1.SwapExecutionRequest")
	proto.RegisterType((*SwapExecutionResponse)(nil), "penumbra.core.component.dex.v1.SwapExecutionResponse")
	proto.RegisterType((*ArbExecutionRequest)(nil), "penumbra.core.component.dex.v1.ArbExecutionRequest")
	proto.RegisterType((*ArbExecutionResponse)(nil), "penumbra.core.component.dex.v1.ArbExecutionResponse")
	proto.RegisterType((*SwapExecutionsRequest)(nil), "penumbra.core.component.dex.v1.SwapExecutionsRequest")
	proto.RegisterType((*SwapExecutionsResponse)(nil), "penumbra.core.component.dex.v1.SwapExecutionsResponse")
	proto.RegisterType((*ArbExecutionsRequest)(nil), "penumbra.core.component.dex.v1.ArbExecutionsRequest")
	proto.RegisterType((*ArbExecutionsResponse)(nil), "penumbra.core.component.dex.v1.ArbExecutionsResponse")
	proto.RegisterType((*LiquidityPositionsRequest)(nil), "penumbra.core.component.dex.v1.LiquidityPositionsRequest")
	proto.RegisterType((*LiquidityPositionsResponse)(nil), "penumbra.core.component.dex.v1.LiquidityPositionsResponse")
	proto.RegisterType((*LiquidityPositionByIdRequest)(nil), "penumbra.core.component.dex.v1.LiquidityPositionByIdRequest")
	proto.RegisterType((*LiquidityPositionByIdResponse)(nil), "penumbra.core.component.dex.v1.LiquidityPositionByIdResponse")
	proto.RegisterType((*LiquidityPositionsByIdRequest)(nil), "penumbra.core.component.dex.v1.LiquidityPositionsByIdRequest")
	proto.RegisterType((*LiquidityPositionsByIdResponse)(nil), "penumbra.core.component.dex.v1.LiquidityPositionsByIdResponse")
	proto.RegisterType((*LiquidityPositionsByPriceRequest)(nil), "penumbra.core.component.dex.v1.LiquidityPositionsByPriceRequest")
	proto.RegisterType((*LiquidityPositionsByPriceResponse)(nil), "penumbra.core.component.dex.v1.LiquidityPositionsByPriceResponse")
	proto.RegisterType((*SpreadRequest)(nil), "penumbra.core.component.dex.v1.SpreadRequest")
	proto.RegisterType((*SpreadResponse)(nil), "penumbra.core.component.dex.v1.SpreadResponse")
	proto.RegisterType((*SimulateTradeRequest)(nil), "penumbra.core.component.dex.v1.SimulateTradeRequest")
	proto.RegisterType((*SimulateTradeRequest_Routing)(nil), "penumbra.core.component.dex.v1.SimulateTradeRequest.Routing")
	proto.RegisterType((*SimulateTradeRequest_Routing_SingleHop)(nil), "penumbra.core.component.dex.v1.SimulateTradeRequest.Routing.SingleHop")
	proto.RegisterType((*SimulateTradeRequest_Routing_Default)(nil), "penumbra.core.component.dex.v1.SimulateTradeRequest.Routing.Default")
	proto.RegisterType((*SimulateTradeResponse)(nil), "penumbra.core.component.dex.v1.SimulateTradeResponse")
	proto.RegisterType((*EventSwap)(nil), "penumbra.core.component.dex.v1.EventSwap")
	proto.RegisterType((*EventSwapClaim)(nil), "penumbra.core.component.dex.v1.EventSwapClaim")
	proto.RegisterType((*EventPositionOpen)(nil), "penumbra.core.component.dex.v1.EventPositionOpen")
	proto.RegisterType((*EventPositionClose)(nil), "penumbra.core.component.dex.v1.EventPositionClose")
	proto.RegisterType((*EventQueuePositionClose)(nil), "penumbra.core.component.dex.v1.EventQueuePositionClose")
	proto.RegisterType((*EventPositionWithdraw)(nil), "penumbra.core.component.dex.v1.EventPositionWithdraw")
	proto.RegisterType((*EventPositionExecution)(nil), "penumbra.core.component.dex.v1.EventPositionExecution")
	proto.RegisterType((*EventBatchSwap)(nil), "penumbra.core.component.dex.v1.EventBatchSwap")
	proto.RegisterType((*EventArbExecution)(nil), "penumbra.core.component.dex.v1.EventArbExecution")
	proto.RegisterType((*EventValueCircuitBreakerCredit)(nil), "penumbra.core.component.dex.v1.EventValueCircuitBreakerCredit")
	proto.RegisterType((*EventValueCircuitBreakerDebit)(nil), "penumbra.core.component.dex.v1.EventValueCircuitBreakerDebit")
	proto.RegisterType((*DexParameters)(nil), "penumbra.core.component.dex.v1.DexParameters")
	proto.RegisterType((*GenesisContent)(nil), "penumbra.core.component.dex.v1.GenesisContent")
	proto.RegisterType((*CandlestickData)(nil), "penumbra.core.component.dex.v1.CandlestickData")
	proto.RegisterType((*CandlestickDataRequest)(nil), "penumbra.core.component.dex.v1.CandlestickDataRequest")
	proto.RegisterType((*CandlestickDataResponse)(nil), "penumbra.core.component.dex.v1.CandlestickDataResponse")
	proto.RegisterType((*CandlestickDataStreamRequest)(nil), "penumbra.core.component.dex.v1.CandlestickDataStreamRequest")
	proto.RegisterType((*CandlestickDataStreamResponse)(nil), "penumbra.core.component.dex.v1.CandlestickDataStreamResponse")
}

func init() {
	proto.RegisterFile("penumbra/core/component/dex/v1/dex.proto", fileDescriptor_ec17dcdac15b4004)
}

var fileDescriptor_ec17dcdac15b4004 = []byte{
	// 3740 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5c, 0x5d, 0x6c, 0x23, 0x59,
	0x56, 0xee, 0x2a, 0x3b, 0xb1, 0x7d, 0x12, 0xa7, 0xd3, 0x37, 0xe9, 0x9e, 0xac, 0x77, 0x92, 0xee,
	0xae, 0xde, 0x85, 0xde, 0x81, 0x75, 0xda, 0xd5, 0xd3, 0x33, 0xbb, 0x99, 0x5e, 0x66, 0x13, 0x3b,
	0x7f, 0x3b, 0xdd, 0x89, 0xa7, 0x92, 0xc9, 0x8c, 0x46, 0xcd, 0x14, 0x65, 0xd7, 0x75, 0x5c, 0x1a,
	0xbb, 0xaa, 0xba, 0xaa, 0xec, 0x38, 0x12, 0x3f, 0x1a, 0x04, 0x0b, 0x02, 0x81, 0x16, 0x84, 0x40,
	0x83, 0xc4, 0x03, 0x2b, 0xf1, 0xc2, 0x1b, 0x48, 0xbc, 0x81, 0x66, 0x5f, 0x40, 0x68, 0x91, 0xd0,
	0x8a, 0x87, 0x5d, 0x24, 0x24, 0x84, 0x66, 0x90, 0x90, 0x78, 0xe2, 0x8d, 0x97, 0x7d, 0x40, 0xf7,
	0xa7, 0xca, 0x55, 0x4e, 0x39, 0x2e, 0x3b, 0x6e, 0x16, 0x8d, 0x78, 0x99, 0xf6, 0xbd, 0x75, 0xce,
	0x77, 0xcf, 0x39, 0xf7, 0xdc, 0x73, 0xcf, 0x3d, 0xf7, 0x4e, 0xe0, 0xbe, 0x8d, 0xcd, 0x4e, 0xbb,
	0xe6, 0x68, 0xeb, 0x75, 0xcb, 0xc1, 0xeb, 0x75, 0xab, 0x6d, 0x5b, 0x26, 0x36, 0xbd, 0x75, 0x1d,
	0xf7, 0xd6, 0xbb, 0x25, 0xf2, 0x4f, 0xd1, 0x76, 0x2c, 0xcf, 0x42, 0x6b, 0x3e, 0x65, 0x91, 0x50,
	0x16, 0x03, 0xca, 0x22, 0x21, 0xe9, 0x96, 0x0a, 0x52, 0x14, 0x49, 0x73, 0x5d, 0xec, 0x11, 0x04,
	0xfa, 0x83, 0x61, 0x14, 0x86, 0x8e, 0xd6, 0xc0, 0x98, 0xd0, 0x36, 0x30, 0x1e, 0x45, 0xe9, 0xd6,
	0x29, 0xaa, 0x5b, 0xf7, 0x31, 0x1f, 0x0f, 0xa5, 0x6c, 0x1a, 0xb8, 0xa5, 0x63, 0x5d, 0xb5, 0x2d,
	0xab, 0x45, 0x79, 0xc2, 0x1d, 0x9c, 0xfb, 0x4e, 0x94, 0xfb, 0x43, 0x7c, 0xee, 0x12, 0x52, 0xf2,
	0x2f, 0xa7, 0x58, 0x8b, 0x52, 0x98, 0x9d, 0x36, 0x21, 0x30, 0x3b, 0x6d, 0xfe, 0xfd, 0x4b, 0xd1,
	0xef, 0x5e, 0xaf, 0xa9, 0xb9, 0x4d, 0x42, 0xc2, 0x7e, 0x5d, 0x1c, 0xc7, 0x39, 0xb7, 0x3d, 0x6b,
	0xdd, 0x63, 0x7a, 0x78, 0xbe, 0x1e, 0xd2, 0x3d, 0x98, 0x7b, 0xff, 0xad, 0xa3, 0x33, 0xcd, 0xae,
	0x3a, 0x96, 0xd5, 0x40, 0xcb, 0x30, 0x63, 0x98, 0x26, 0x76, 0x56, 0x84, 0x3b, 0xc2, 0xfd, 0x79,
	0x85, 0x35, 0xa4, 0xfb, 0xb0, 0xc8, 0x88, 0xca, 0x2d, 0xcd, 0x68, 0x5f, 0x46, 0xf9, 0x1b, 0x02,
	0xa4, 0x09, 0x21, 0xda, 0x84, 0x19, 0x9b, 0xd0, 0xd1, 0xcf, 0x73, 0xf2, 0xcf, 0x14, 0x2f, 0x9f,
	0xc7, 0x62, 0x48, 0x08, 0x85, 0x71, 0xa2, 0xc7, 0x90, 0xae, 0x59, 0xfa, 0xf9, 0x4a, 0x9a, 0x22,
	0xdc, 0x1f, 0x85, 0x40, 0xf8, 0xb7, 0x2c, 0xfd, 0x5c, 0xa1, 0x5c, 0xd2, 0xdf, 0x08, 0x90, 0x0b,
	0x44, 0x46, 0x3b, 0x51, 0x71, 0x1e, 0x24, 0x13, 0xa7, 0xaf, 0xae, 0x2f, 0xd3, 0x26, 0x97, 0x49,
	0xa4, 0x30, 0x5f, 0x4d, 0x22, 0x13, 0x05, 0xe9, 0x0b, 0x86, 0xbe, 0x0c, 0x0b, 0xd8, 0xb6, 0xea,
	0x4d, 0x55, 0xef, 0x38, 0x9a, 0x67, 0x58, 0xe6, 0x4a, 0xe6, 0x8e, 0x70, 0x3f, 0xad, 0xe4, 0x69,
	0x6f, 0x85, 0x77, 0x4a, 0x7f, 0x94, 0x82, 0x7c, 0x84, 0x1d, 0xed, 0x42, 0xce, 0xec, 0xb4, 0x5a,
	0x46, 0xc3, 0xe0, 0x56, 0x9f, 0x93, 0xbf, 0x32, 0x54, 0x00, 0xe2, 0xa9, 0xdd, 0x52, 0xf1, 0xc0,
	0x67, 0x50, 0xfa, 0xbc, 0xe8, 0x11, 0xa4, 0x1a, 0x18, 0x73, 0x1d, 0xee, 0x0d, 0x85, 0x20, 0xcb,
	0xa2, 0x5b, 0x2a, 0xee, 0x60, 0xac, 0x10, 0x7a, 0xf4, 0x2e, 0x2c, 0x59, 0x1d, 0xcf, 0xee, 0x78,
	0x6a, 0x49, 0xad, 0x5b, 0xed, 0xb6, 0xe1, 0xb5, 0xb1, 0xe9, 0xad, 0xa4, 0x28, 0xcc, 0x4f, 0x87,
	0x60, 0xa8, 0xab, 0x15, 0x3d, 0x26, 0xc1, 0x91, 0xa7, 0x79, 0xb8, 0x1c, 0x90, 0x2b, 0x37, 0x18,
	0x46, 0xa9, 0xdf, 0x15, 0x02, 0x96, 0xc3, 0xc0, 0xe9, 0x89, 0x80, 0xe5, 0x10, 0xf0, 0x31, 0xcc,
	0x71, 0x60, 0x5d, 0xf3, 0xb4, 0x95, 0x59, 0x0a, 0xf8, 0x70, 0xd4, 0xa4, 0x6d, 0x69, 0x5e, 0xbd,
	0x49, 0x4c, 0x7f, 0x48, 0x79, 0x2b, 0x9a, 0xa7, 0x29, 0x60, 0x05, 0xbf, 0xa5, 0xff, 0x10, 0x21,
	0xeb, 0x3b, 0x1b, 0x3a, 0x80, 0x79, 0xcf, 0xd1, 0x74, 0xc3, 0x3c, 0x55, 0x6d, 0xcd, 0x70, 0x92,
	0xba, 0xfb, 0x31, 0xe3, 0xa9, 0x6a, 0x86, 0xa3, 0xcc, 0x79, 0xfd, 0x06, 0xfa, 0x1a, 0xe4, 0x74,
	0xdc, 0xf2, 0x34, 0xb5, 0xa4, 0x1a, 0x7c, 0x86, 0x5e, 0x1e, 0x00, 0x23, 0x41, 0xa0, 0x5b, 0x2a,
	0x6e, 0xb6, 0xad, 0x8e, 0xe9, 0x29, 0x19, 0x4a, 0x5e, 0xda, 0xef, 0x73, 0xca, 0xaa, 0xc1, 0x27,
	0x25, 0x09, 0xa7, 0xbc, 0x8f, 0xaa, 0xb0, 0xd0, 0xc0, 0xf8, 0xa2, 0xe9, 0x07, 0xbd, 0x8b, 0xc5,
	0x54, 0x6a, 0xa1, 0x96, 0x66, 0xd6, 0xc3, 0xc6, 0xcf, 0x37, 0x70, 0xa8, 0x89, 0xb6, 0x21, 0x63,
	0x6b, 0xe7, 0x2d, 0x4b, 0xd3, 0x57, 0x66, 0x92, 0x19, 0x84, 0xae, 0x7e, 0xc6, 0xa2, 0xf8, 0xbc,
	0xd2, 0x2f, 0xc1, 0x5c, 0xa8, 0x1f, 0xed, 0x02, 0x84, 0x64, 0x14, 0xc6, 0x73, 0x8f, 0x10, 0x2b,
	0x5d, 0x82, 0x26, 0x25, 0xc7, 0xba, 0xea, 0x9e, 0x69, 0x36, 0xb5, 0xf4, 0xbc, 0x92, 0x0f, 0x7a,
	0xc9, 0xb0, 0xd2, 0x7f, 0x89, 0x6c, 0x09, 0x56, 0x5b, 0x9a, 0x61, 0x7a, 0xb8, 0xe7, 0x7d, 0x2e,
	0x66, 0xfb, 0x9b, 0x90, 0xab, 0x93, 0x98, 0xa2, 0x92, 0x18, 0x90, 0x4e, 0x1e, 0x03, 0xb2, 0x94,
	0x6b, 0x07, 0x63, 0x54, 0x86, 0x3c, 0x43, 0xd0, 0x74, 0xdd, 0xc1, 0xae, 0xcb, 0xe7, 0x78, 0x6d,
	0x00, 0x85, 0xee, 0x66, 0x44, 0x00, 0x46, 0xa5, 0xcc, 0x53, 0x26, 0xde, 0x22, 0xfb, 0x87, 0xe3,
	0x62, 0xac, 0xd3, 0x55, 0x39, 0xaf, 0xb0, 0x86, 0xf4, 0x23, 0x81, 0xad, 0xad, 0x6a, 0x4b, 0x33,
	0xd1, 0x31, 0x2c, 0x90, 0xc9, 0x51, 0x6d, 0xdf, 0xfe, 0xdc, 0xde, 0x89, 0xc2, 0x6e, 0x30, 0x69,
	0x4a, 0xde, 0x8d, 0xcc, 0xe1, 0x5d, 0x98, 0x27, 0xde, 0x5e, 0x6b, 0x19, 0x26, 0x99, 0x07, 0x3e,
	0xf5, 0x73, 0x0d, 0x8c, 0xb7, 0x78, 0x17, 0xba, 0x0f, 0x8b, 0x34, 0xdc, 0x07, 0x44, 0xaa, 0x43,
	0x6d, 0x3c, 0xaf, 0x2c, 0xd0, 0x7e, 0x9f, 0x50, 0x89, 0xa1, 0x74, 0xa9, 0x4d, 0x07, 0x29, 0x8f,
	0xa4, 0x7f, 0x12, 0x43, 0xf1, 0xfc, 0x05, 0xaa, 0x57, 0x80, 0xac, 0x6d, 0xb9, 0x06, 0xdd, 0x58,
	0x44, 0xba, 0xb1, 0x04, 0xed, 0xc1, 0x78, 0x98, 0x9a, 0x4a, 0x3c, 0x8c, 0xd9, 0xd0, 0xd2, 0x31,
	0x1b, 0x5a, 0xac, 0x51, 0x67, 0x12, 0x1b, 0x75, 0x36, 0xd6, 0xa8, 0xbf, 0x09, 0xcc, 0x5d, 0x4e,
	0x0c, 0x7c, 0x86, 0x9e, 0x40, 0xa6, 0x6b, 0xb8, 0x46, 0xad, 0x85, 0x93, 0xee, 0xf2, 0x3e, 0x6b,
	0xf1, 0x84, 0xf1, 0xed, 0x5d, 0x53, 0x7c, 0x08, 0xb4, 0x0f, 0xb3, 0x96, 0xad, 0x3d, 0xef, 0xf8,
	0xfb, 0xe4, 0x7a, 0x62, 0xb0, 0x43, 0xca, 0xb6, 0x77, 0x4d, 0xe1, 0x00, 0x85, 0x1f, 0xa7, 0x21,
	0xc3, 0x47, 0x40, 0x5f, 0x83, 0x34, 0x0d, 0x38, 0x4c, 0xc2, 0x2f, 0x25, 0x01, 0x55, 0x28, 0x47,
	0x8c, 0xbb, 0xa4, 0xa6, 0xe0, 0x2e, 0x9b, 0xc0, 0xd6, 0xb5, 0xea, 0xf5, 0x78, 0x30, 0xf8, 0xa9,
	0x01, 0x3c, 0x9e, 0x50, 0xb2, 0x30, 0x66, 0xba, 0x5a, 0x9d, 0xcc, 0xe6, 0xbe, 0xae, 0x64, 0x28,
	0xdf, 0x71, 0x0f, 0x35, 0xe1, 0x56, 0x8d, 0xb8, 0x08, 0x8d, 0xa4, 0x6a, 0xd8, 0xc1, 0x96, 0x27,
	0x77, 0xb0, 0xa5, 0xda, 0xc5, 0x4e, 0xf4, 0x14, 0xb2, 0x7e, 0x06, 0xb2, 0xb2, 0x46, 0xb1, 0xe5,
	0xe1, 0x09, 0x50, 0x24, 0xed, 0x26, 0xa9, 0x90, 0xe5, 0x61, 0x32, 0x3f, 0x4a, 0x86, 0x67, 0x20,
	0x21, 0x38, 0x79, 0xe5, 0xf6, 0x55, 0xe1, 0x64, 0xf4, 0x2d, 0x58, 0xa4, 0x3b, 0xa4, 0x5a, 0x52,
	0xdb, 0xd8, 0xd3, 0xa8, 0x05, 0xee, 0x53, 0xd8, 0x3b, 0xc3, 0x36, 0xd2, 0xa7, 0x9c, 0x4e, 0x59,
	0xa0, 0x5d, 0x25, 0xbf, 0xdd, 0xc7, 0x92, 0xfb, 0x58, 0x5f, 0x19, 0x0b, 0x4b, 0xf6, 0xdb, 0x85,
	0x1f, 0xa6, 0x60, 0x96, 0xf9, 0xe4, 0x15, 0xbc, 0xef, 0x7f, 0x6f, 0x92, 0x77, 0x61, 0x21, 0x48,
	0x33, 0xbb, 0x5a, 0xab, 0x83, 0xf9, 0x54, 0xdf, 0x1d, 0xa6, 0xf8, 0x09, 0x21, 0xa2, 0x53, 0x31,
	0xcf, 0x67, 0x96, 0xf6, 0x84, 0x80, 0x64, 0x0e, 0x74, 0x7b, 0x4c, 0x20, 0x99, 0x01, 0xfd, 0x1f,
	0x9d, 0xd8, 0xad, 0x39, 0xc8, 0xd1, 0xd9, 0xe8, 0x1a, 0xf8, 0x4c, 0xfa, 0xc7, 0x74, 0x68, 0x7f,
	0xa1, 0xf1, 0xf0, 0xed, 0xc1, 0x78, 0xf8, 0x28, 0xf1, 0x71, 0x65, 0x58, 0x50, 0x3c, 0x18, 0x08,
	0x8a, 0xaf, 0x8e, 0x87, 0x78, 0x21, 0x32, 0xfe, 0xa5, 0xd8, 0x8f, 0x8c, 0x7b, 0x00, 0x54, 0x1b,
	0x1a, 0x56, 0x46, 0x9e, 0x6f, 0x06, 0xf1, 0x15, 0x6a, 0x0a, 0x76, 0xd8, 0x0b, 0x87, 0x09, 0x71,
	0xba, 0x61, 0x22, 0x75, 0xf5, 0x30, 0xf1, 0x26, 0x64, 0xa8, 0x9e, 0x63, 0x07, 0xdc, 0x59, 0xc2,
	0x76, 0xdc, 0x2b, 0x28, 0xc1, 0x72, 0x9e, 0x9a, 0xc9, 0xb6, 0x6e, 0xc0, 0xf5, 0x3e, 0x12, 0x73,
	0xa8, 0x8f, 0x04, 0x98, 0x3b, 0x8e, 0xe4, 0xaa, 0x19, 0xbe, 0x0a, 0xf8, 0x48, 0xb7, 0x87, 0x39,
	0xec, 0x26, 0xf9, 0x41, 0x04, 0x66, 0xbe, 0xdf, 0xe7, 0x94, 0xf9, 0x74, 0x24, 0xe4, 0x94, 0xa5,
	0x5f, 0x81, 0xa5, 0x8a, 0xe1, 0xe0, 0xba, 0x87, 0xf5, 0xb0, 0x28, 0x8f, 0x60, 0xc6, 0xf5, 0x34,
	0xc7, 0x4b, 0x2a, 0x08, 0xa3, 0x46, 0x25, 0x48, 0x61, 0x53, 0x4f, 0x2a, 0x03, 0xa1, 0x95, 0x3e,
	0x49, 0xc3, 0x52, 0x4c, 0xe4, 0x42, 0x8f, 0x20, 0xc3, 0x13, 0x77, 0x2e, 0xc3, 0xe5, 0xc9, 0xf7,
	0x2c, 0x4b, 0xdb, 0xfb, 0x6c, 0x72, 0xa2, 0x6c, 0x9f, 0xb1, 0xc9, 0xe8, 0x75, 0xc8, 0xb6, 0xb4,
	0x76, 0x4d, 0x27, 0xc3, 0x25, 0xca, 0xf5, 0x19, 0x75, 0x29, 0xc4, 0x28, 0x73, 0x67, 0x4b, 0xc4,
	0x28, 0xa3, 0x37, 0x00, 0x3a, 0x66, 0xc3, 0x68, 0xb5, 0xb0, 0xae, 0x96, 0x78, 0x7e, 0x7f, 0x39,
	0x6b, 0xce, 0xa7, 0x2f, 0x45, 0x98, 0x65, 0x7e, 0xea, 0x4e, 0xc8, 0x2c, 0xa3, 0x5b, 0x30, 0xdb,
	0xc4, 0xc6, 0x69, 0xd3, 0xe3, 0x65, 0x11, 0xde, 0xba, 0x70, 0xf4, 0xca, 0x5e, 0xf1, 0xe8, 0xf5,
	0x1a, 0xdc, 0x64, 0x59, 0x2b, 0xf5, 0x0d, 0x02, 0xcb, 0x87, 0xcd, 0x91, 0x61, 0xb7, 0xc4, 0x15,
	0x41, 0x59, 0xa2, 0x04, 0x47, 0xfc, 0xfb, 0x1e, 0x93, 0xa3, 0x08, 0x4b, 0x6e, 0xdd, 0x53, 0xfd,
	0x9c, 0x5a, 0xb5, 0x1d, 0xdc, 0x30, 0x7a, 0x2b, 0x40, 0x85, 0xbd, 0xe1, 0xd6, 0xbd, 0x2a, 0xff,
	0x52, 0xa5, 0x1f, 0xa4, 0x3f, 0x13, 0xe0, 0x3a, 0x17, 0x62, 0xa7, 0x63, 0xd2, 0xb5, 0x8c, 0xde,
	0x86, 0x5c, 0x20, 0x28, 0xf7, 0x9f, 0x04, 0xfb, 0xa7, 0x83, 0x07, 0x70, 0x94, 0x3e, 0x0a, 0x7a,
	0x13, 0xd2, 0xd4, 0x2c, 0xe2, 0xf8, 0x66, 0xa1, 0x8c, 0x64, 0xa9, 0xc5, 0x0c, 0x81, 0x16, 0x59,
	0xad, 0x88, 0x08, 0x99, 0x67, 0x65, 0xa0, 0x57, 0x40, 0xb0, 0x13, 0x79, 0xaf, 0x60, 0x13, 0xda,
	0xe7, 0x89, 0x3c, 0x56, 0x78, 0x2e, 0x35, 0x20, 0xab, 0x60, 0x17, 0x3b, 0x5d, 0xec, 0xa2, 0x9f,
	0x05, 0xd1, 0x49, 0xb6, 0xb2, 0x44, 0xa7, 0x44, 0xa9, 0x93, 0x2d, 0x28, 0xd1, 0x91, 0xa5, 0xdf,
	0x17, 0x21, 0xeb, 0xcf, 0x11, 0xda, 0x84, 0x94, 0xdd, 0x34, 0xf8, 0x48, 0xeb, 0x09, 0xad, 0x16,
	0xd8, 0x9f, 0xf0, 0x92, 0x83, 0xac, 0x69, 0x99, 0x75, 0xcc, 0x0f, 0x92, 0xac, 0x81, 0xca, 0x34,
	0x44, 0x79, 0x38, 0x69, 0x92, 0xee, 0x4b, 0x44, 0xcb, 0x16, 0x0a, 0xe3, 0x45, 0x15, 0xc8, 0x3a,
	0xdc, 0x24, 0x49, 0xab, 0xa0, 0xbe, 0x09, 0x95, 0x80, 0x13, 0x49, 0xe4, 0xb8, 0x6e, 0xb9, 0x58,
	0xb5, 0x4c, 0x95, 0xac, 0x32, 0xba, 0x9c, 0xb3, 0xca, 0x1c, 0xed, 0x3c, 0x34, 0x77, 0x8c, 0x56,
	0x4b, 0x2a, 0x03, 0xf8, 0x12, 0xec, 0xeb, 0xf1, 0xb5, 0x5d, 0x74, 0x1b, 0xe6, 0xb4, 0x96, 0xa7,
	0xd6, 0x70, 0xbd, 0xf9, 0x50, 0x6e, 0x53, 0x75, 0x73, 0x0a, 0x68, 0x2d, 0x6f, 0x8b, 0xf5, 0x48,
	0x7f, 0x2b, 0x42, 0x3e, 0xa2, 0x07, 0x7a, 0xc7, 0xb7, 0x02, 0x01, 0x5a, 0x90, 0xdf, 0x1c, 0xcb,
	0x0a, 0xd1, 0xd6, 0xb6, 0xd9, 0x69, 0xfb, 0x76, 0x29, 0x40, 0xd6, 0xc5, 0xcf, 0x3b, 0xd8, 0xb7,
	0x7a, 0x5a, 0x09, 0xda, 0xd2, 0xf7, 0x04, 0xb8, 0x71, 0x81, 0x11, 0xdd, 0x83, 0xdb, 0xd5, 0xc3,
	0xa3, 0xfd, 0xe3, 0xfd, 0xc3, 0x03, 0xf5, 0xe8, 0x78, 0xf3, 0x78, 0x5b, 0xdd, 0x3e, 0x78, 0xe7,
	0xa9, 0xfa, 0xce, 0xc1, 0x51, 0x75, 0xbb, 0xbc, 0xbf, 0xb3, 0xbf, 0x5d, 0x59, 0xbc, 0x86, 0xd6,
	0xa0, 0x10, 0x47, 0x74, 0x58, 0xdd, 0x3e, 0xd8, 0xae, 0x2c, 0x0a, 0xc3, 0xbe, 0x97, 0x9f, 0x1c,
	0x1e, 0x6d, 0x57, 0x16, 0x45, 0x74, 0x17, 0x56, 0xe3, 0xbe, 0xbf, 0xbb, 0x7f, 0xbc, 0x57, 0x51,
	0x36, 0xdf, 0x3d, 0x58, 0x4c, 0xa1, 0x7b, 0xf0, 0xc5, 0x78, 0x88, 0xcd, 0xfd, 0xa7, 0xdb, 0x95,
	0xc5, 0x74, 0x41, 0xcc, 0x0a, 0xd2, 0xc7, 0x02, 0xcc, 0x3c, 0xb1, 0x0f, 0x1a, 0x1e, 0x7a, 0x0b,
	0xe6, 0x82, 0x40, 0x63, 0xe8, 0xdc, 0x4d, 0x5f, 0x49, 0x6a, 0xc5, 0x7d, 0x5d, 0x01, 0xbb, 0x3f,
	0xab, 0x81, 0x4b, 0x8a, 0x93, 0xbb, 0xa4, 0x74, 0x0c, 0xf3, 0x7e, 0xff, 0xa1, 0x8d, 0x4d, 0xe2,
	0xa2, 0x41, 0xb9, 0x41, 0x48, 0xe6, 0xa2, 0x3e, 0x7f, 0xbf, 0x30, 0x21, 0x3d, 0xeb, 0x3b, 0x4e,
	0x99, 0x78, 0xe5, 0x54, 0x15, 0x97, 0x7e, 0x24, 0xc0, 0xa2, 0xff, 0xe9, 0x5d, 0xc3, 0x6b, 0xea,
	0x8e, 0x76, 0x36, 0x5d, 0xd3, 0xbe, 0x0f, 0x4b, 0xfe, 0x72, 0x0b, 0x97, 0x51, 0xc5, 0x71, 0xcb,
	0xa8, 0xc8, 0x47, 0x09, 0xd5, 0x52, 0xc3, 0xce, 0x9e, 0x1a, 0x70, 0xf6, 0xbf, 0x16, 0x60, 0x29,
	0x30, 0x27, 0x3e, 0xd3, 0x1c, 0x9d, 0x65, 0xc0, 0x53, 0x55, 0xee, 0x3d, 0x40, 0x0e, 0xc5, 0xbe,
	0x9a, 0x6e, 0x37, 0x38, 0x48, 0xbf, 0x4b, 0xfa, 0x36, 0xaf, 0x89, 0x6d, 0xf7, 0x70, 0xbd, 0x43,
	0xe3, 0xf1, 0x5b, 0x30, 0xeb, 0x39, 0x5a, 0x1d, 0xbb, 0x2b, 0xc2, 0x9d, 0x54, 0x92, 0x6d, 0x31,
	0xc2, 0x4e, 0x02, 0x74, 0x1d, 0x2b, 0x1c, 0x02, 0x3d, 0x24, 0x61, 0xcc, 0xee, 0xf8, 0xb2, 0xae,
	0x5e, 0x7a, 0xee, 0x53, 0x18, 0x2d, 0x7a, 0x04, 0xb3, 0x2c, 0x53, 0xe7, 0x91, 0x7b, 0x04, 0x17,
	0x27, 0x2e, 0x3c, 0x86, 0x19, 0x3a, 0x38, 0x19, 0x94, 0x1d, 0x36, 0x99, 0x02, 0xa3, 0x06, 0xa5,
	0xb4, 0xd2, 0x27, 0x22, 0x2c, 0x0f, 0x7a, 0x28, 0xad, 0x11, 0x86, 0x77, 0x00, 0x61, 0xe2, 0x1d,
	0x60, 0xc0, 0x1d, 0xc4, 0x2b, 0xb9, 0x83, 0x9f, 0x69, 0xa4, 0x26, 0xcc, 0x34, 0x22, 0x0e, 0x9d,
	0x8e, 0x3a, 0x34, 0x7a, 0x1d, 0x32, 0xdc, 0x4d, 0x56, 0x66, 0x92, 0xd8, 0xcf, 0xa7, 0x96, 0x54,
	0x78, 0x29, 0x66, 0x21, 0x4c, 0xcf, 0x86, 0xd2, 0xaf, 0x09, 0x50, 0x88, 0xab, 0x61, 0x10, 0xc9,
	0x5d, 0x2f, 0x94, 0xb6, 0x8a, 0x97, 0xa6, 0xad, 0xa9, 0xab, 0xa5, 0xad, 0x52, 0x03, 0xbe, 0x18,
	0x2b, 0x85, 0x6b, 0x5b, 0xa6, 0x8b, 0xd1, 0x2e, 0xa4, 0x69, 0x49, 0x41, 0x98, 0xbc, 0x28, 0x43,
	0x01, 0xa4, 0x6f, 0x0b, 0xb0, 0x1c, 0x59, 0x5b, 0xa3, 0x14, 0x3d, 0x89, 0x55, 0x74, 0xa4, 0x04,
	0x31, 0xc7, 0xbb, 0xa8, 0xc2, 0x6d, 0xb8, 0x39, 0x20, 0x07, 0x57, 0xd5, 0xaf, 0x87, 0x62, 0xff,
	0xcb, 0x38, 0xe5, 0xf3, 0x3e, 0x1c, 0xad, 0x87, 0x06, 0x4d, 0xe9, 0xab, 0xb0, 0xb4, 0xe9, 0xd4,
	0x92, 0x6a, 0x4d, 0xbc, 0x62, 0x39, 0x4a, 0xff, 0x22, 0xa5, 0x1b, 0x2a, 0xc6, 0x5f, 0x08, 0x03,
	0x56, 0x72, 0x7d, 0xc1, 0xef, 0xc2, 0x3c, 0x3d, 0xe0, 0xa8, 0x11, 0xbe, 0x39, 0xda, 0xc7, 0x4f,
	0x34, 0xab, 0x00, 0xd8, 0xd4, 0x7d, 0x02, 0xb6, 0xc5, 0xe4, 0xb0, 0xa9, 0xef, 0xc5, 0x4f, 0x6c,
	0x7a, 0x4a, 0x13, 0xfb, 0xaf, 0x02, 0xdc, 0x1a, 0x94, 0xf9, 0x27, 0x61, 0xbc, 0x17, 0xe6, 0xb9,
	0xef, 0x45, 0x5d, 0x63, 0x7a, 0x53, 0x22, 0xfd, 0xba, 0x00, 0x37, 0x07, 0xa0, 0x7f, 0x22, 0x6e,
	0xb7, 0x05, 0x5f, 0x78, 0x62, 0x3c, 0xef, 0x18, 0xba, 0xe1, 0x9d, 0xfb, 0xd1, 0x37, 0x50, 0xf3,
	0xcb, 0xb0, 0x60, 0x98, 0xf5, 0x56, 0x47, 0xc7, 0x2a, 0x3d, 0x69, 0xe8, 0xd4, 0x73, 0xb2, 0x4a,
	0x9e, 0xf7, 0xd2, 0x44, 0x4f, 0x97, 0xde, 0x87, 0x42, 0x1c, 0x06, 0xd7, 0xe7, 0x71, 0x24, 0x9e,
	0x25, 0x4f, 0x2d, 0x59, 0x10, 0xfb, 0x10, 0x5e, 0xbe, 0x80, 0xbd, 0x75, 0xbe, 0xaf, 0xfb, 0x22,
	0x4e, 0x73, 0x5f, 0x94, 0x7e, 0x1e, 0x56, 0x87, 0x0c, 0x36, 0x15, 0x5d, 0x5a, 0x31, 0xf0, 0xee,
	0xa5, 0xca, 0xa4, 0xae, 0xa0, 0xcc, 0x07, 0xb0, 0x36, 0x6c, 0xb4, 0xa9, 0x68, 0xf3, 0x1d, 0x01,
	0xee, 0xc4, 0x0d, 0x50, 0x75, 0x8c, 0x3a, 0xf6, 0x35, 0x1a, 0x5c, 0x98, 0xe2, 0x74, 0x16, 0x26,
	0x39, 0xde, 0xb6, 0x8c, 0xb6, 0xe1, 0xd1, 0x83, 0x70, 0x5a, 0x61, 0x0d, 0xe9, 0x4f, 0x04, 0xb8,
	0x7b, 0x89, 0x48, 0xd3, 0x50, 0x1b, 0x6d, 0x80, 0x38, 0x91, 0x9f, 0x89, 0x86, 0x2e, 0xa9, 0x90,
	0x3f, 0xb2, 0x1d, 0xac, 0x05, 0x13, 0x7e, 0x10, 0x6b, 0x9e, 0xc9, 0x53, 0x8b, 0xbf, 0x13, 0x61,
	0xc1, 0x1f, 0x81, 0x6b, 0xfb, 0x1e, 0x2c, 0xd7, 0xb0, 0xeb, 0xa9, 0x25, 0xd5, 0xb3, 0x54, 0x59,
	0x9d, 0xf8, 0xa4, 0xb7, 0x48, 0x50, 0x4a, 0xc7, 0x96, 0x1c, 0x14, 0x5e, 0x7c, 0x64, 0x99, 0x20,
	0x97, 0xd4, 0xc8, 0x95, 0xf5, 0xd8, 0xc8, 0xf2, 0xb1, 0x55, 0x0a, 0x90, 0xdf, 0x84, 0x55, 0xcd,
	0xb6, 0x1d, 0xab, 0xa7, 0xe2, 0x46, 0x03, 0xd7, 0x3d, 0xa3, 0x8b, 0x55, 0x9b, 0xcc, 0x21, 0xd7,
	0x82, 0x86, 0x53, 0x41, 0x59, 0x61, 0x44, 0xdb, 0x3e, 0x0d, 0x9d, 0x66, 0x22, 0xe2, 0x25, 0x00,
	0x4c, 0x58, 0x1a, 0xc7, 0x86, 0x00, 0x10, 0x49, 0xa4, 0x1f, 0xa6, 0x60, 0xf9, 0xc8, 0x68, 0x77,
	0x5a, 0x9a, 0x47, 0xeb, 0x69, 0x81, 0x43, 0x07, 0x07, 0x12, 0x61, 0x8c, 0x03, 0xc9, 0xeb, 0xc1,
	0x81, 0x24, 0x69, 0xf1, 0x9c, 0x91, 0xa3, 0x13, 0xc8, 0x38, 0x56, 0xc7, 0x33, 0xcc, 0x53, 0xbe,
	0xa5, 0x3d, 0x1e, 0xb9, 0x09, 0xc4, 0x08, 0x5d, 0x54, 0x18, 0x86, 0xe2, 0x83, 0x15, 0xfe, 0x5b,
	0x80, 0x0c, 0xef, 0x44, 0xbf, 0x00, 0x19, 0x1d, 0x37, 0xb4, 0x4e, 0xcb, 0xd7, 0xa9, 0x72, 0x95,
	0x31, 0x8a, 0x15, 0x86, 0xb5, 0x77, 0x4d, 0xf1, 0x61, 0xd1, 0x29, 0x80, 0x6b, 0x98, 0xa7, 0x2d,
	0xac, 0x36, 0x2d, 0xbf, 0xee, 0xb8, 0x73, 0xa5, 0x41, 0x8e, 0x28, 0xdc, 0x9e, 0x65, 0xef, 0x5d,
	0x53, 0x72, 0xae, 0xdf, 0x28, 0xcc, 0x41, 0x2e, 0xf8, 0x52, 0xc8, 0x41, 0x86, 0xcb, 0xb2, 0x95,
	0x83, 0x8c, 0x8b, 0x3d, 0xc2, 0x29, 0x7d, 0x4c, 0xd2, 0xac, 0x28, 0x34, 0x5f, 0x28, 0xdb, 0xc1,
	0x24, 0x4d, 0xb4, 0xdf, 0xfa, 0x53, 0xf6, 0x75, 0xc8, 0xfa, 0x95, 0xf0, 0x64, 0x87, 0xd6, 0x80,
	0x5c, 0xfa, 0x53, 0x11, 0x72, 0xdb, 0x5d, 0x6c, 0x7a, 0xf4, 0xf9, 0xe5, 0xe7, 0xe3, 0x59, 0x1a,
	0xbf, 0x93, 0x9a, 0xf8, 0x49, 0x20, 0xcd, 0x85, 0x42, 0xf5, 0x86, 0x7f, 0x11, 0x61, 0x21, 0xb0,
	0x11, 0xab, 0x94, 0x4c, 0xdb, 0x50, 0x43, 0x1e, 0x49, 0x8a, 0x2f, 0xea, 0x91, 0x64, 0xea, 0xca,
	0x8f, 0x24, 0x23, 0xcf, 0x4a, 0xd3, 0x93, 0x3f, 0x2b, 0x95, 0xfe, 0x41, 0x84, 0x1b, 0xd4, 0xba,
	0x91, 0x02, 0xe1, 0x54, 0x4b, 0x51, 0x53, 0xde, 0xf2, 0xd0, 0x1b, 0x00, 0x41, 0xdd, 0x2e, 0xd9,
	0xd5, 0x5a, 0xce, 0xa7, 0x2f, 0x45, 0x98, 0x93, 0x5d, 0xaf, 0x05, 0xcc, 0x32, 0xba, 0x0d, 0xbe,
	0x20, 0xf4, 0x1d, 0xde, 0x0c, 0xbd, 0x5f, 0x01, 0xde, 0xb5, 0x83, 0xb1, 0xa4, 0x01, 0x8a, 0x18,
	0xf3, 0x05, 0xd4, 0x45, 0x1b, 0xf0, 0x12, 0x1d, 0xe2, 0xed, 0x0e, 0xee, 0xe0, 0x17, 0x38, 0xce,
	0xf7, 0x45, 0xb8, 0x19, 0xd1, 0xe5, 0xc5, 0x14, 0x61, 0x3f, 0x3f, 0xce, 0x11, 0xae, 0x90, 0xcd,
	0x0c, 0x94, 0x7c, 0x7f, 0x2b, 0x0d, 0xb7, 0x22, 0xc6, 0x0c, 0x17, 0x4f, 0xff, 0xdf, 0x9a, 0x31,
	0xd6, 0xac, 0xc0, 0x75, 0xdb, 0xc1, 0x5d, 0x35, 0x34, 0x7c, 0x92, 0x0b, 0xed, 0x3c, 0x61, 0x52,
	0x02, 0x11, 0x2e, 0xa0, 0x24, 0xbb, 0xd9, 0x8e, 0xa0, 0xc8, 0xe8, 0x29, 0x64, 0xea, 0x16, 0x7b,
	0xbd, 0x97, 0x99, 0xfc, 0x34, 0xe3, 0x63, 0x48, 0xdf, 0xf3, 0x37, 0xb4, 0xa0, 0x90, 0x77, 0xc9,
	0x43, 0x2d, 0x61, 0xca, 0x0f, 0xb5, 0x34, 0xb8, 0x15, 0xad, 0x35, 0xa8, 0x25, 0xb5, 0x61, 0x39,
	0xc1, 0xdb, 0x86, 0x31, 0x73, 0x20, 0x14, 0xa9, 0x39, 0x94, 0x76, 0x2c, 0x47, 0x8e, 0x19, 0x42,
	0xa6, 0x43, 0x94, 0xc6, 0x79, 0xfb, 0x38, 0x6c, 0x08, 0x79, 0xc7, 0x72, 0x4a, 0xd2, 0x47, 0x02,
	0xdf, 0xb5, 0xc2, 0x05, 0x95, 0x50, 0xc5, 0x43, 0x88, 0xd4, 0x8a, 0x2e, 0xd6, 0x57, 0xc4, 0x29,
	0x14, 0x1d, 0xff, 0x5d, 0x80, 0x35, 0x2a, 0x03, 0x4d, 0xea, 0xca, 0x86, 0x53, 0xef, 0x18, 0xde,
	0x96, 0x83, 0xb5, 0x0f, 0xb1, 0x53, 0x76, 0xb0, 0x6e, 0x78, 0x68, 0x03, 0xb2, 0xec, 0x0d, 0x4d,
	0xb0, 0xb0, 0x47, 0x9e, 0x03, 0xd8, 0xa3, 0x9b, 0x7d, 0x1d, 0xed, 0xc2, 0x22, 0xf1, 0x42, 0xc3,
	0xea, 0xb8, 0x6a, 0x8d, 0xdd, 0xcb, 0x24, 0xca, 0xe1, 0xae, 0xfb, 0x5c, 0xfc, 0x32, 0x07, 0x7d,
	0x03, 0xe6, 0x4c, 0x7c, 0x16, 0x60, 0x24, 0x59, 0xc4, 0x60, 0xe2, 0x33, 0xce, 0x2e, 0x7d, 0x26,
	0xc0, 0xea, 0x30, 0x35, 0x2b, 0xb8, 0xf6, 0x39, 0xd1, 0xf2, 0xc7, 0x02, 0xe4, 0x2b, 0xb8, 0x57,
	0xd5, 0x1c, 0xad, 0x8d, 0x3d, 0xec, 0xb8, 0x68, 0x15, 0xc0, 0x70, 0x55, 0x6c, 0x6a, 0x35, 0x92,
	0xd7, 0x0b, 0xb4, 0x0a, 0x96, 0x33, 0xdc, 0x6d, 0xd6, 0x81, 0xbe, 0x05, 0x8b, 0x0d, 0xa3, 0x87,
	0x75, 0xb5, 0xae, 0x99, 0xba, 0xa1, 0x6b, 0x1e, 0x76, 0x79, 0xf5, 0x66, 0xa4, 0xf2, 0xd7, 0x29,
	0x63, 0x39, 0xe0, 0x43, 0x5f, 0x80, 0x6c, 0x5b, 0xeb, 0x91, 0xa3, 0x92, 0x4b, 0x05, 0xcf, 0x2b,
	0x99, 0xb6, 0xd6, 0xdb, 0xb3, 0x6c, 0x17, 0x3d, 0x84, 0x5b, 0xe4, 0x93, 0x1f, 0xe2, 0x5d, 0xd5,
	0xc6, 0x4e, 0xbf, 0xa2, 0x9b, 0x57, 0x96, 0xda, 0x5a, 0x2f, 0x28, 0x7b, 0x54, 0xb1, 0x43, 0xa3,
	0xf6, 0x03, 0x58, 0x26, 0x4c, 0xfd, 0xf5, 0x57, 0xeb, 0xe8, 0xa7, 0xd8, 0xe3, 0xf9, 0x0a, 0x6a,
	0x6b, 0xbd, 0xc0, 0x8b, 0xb7, 0xe8, 0x17, 0xe9, 0x03, 0x58, 0xd8, 0xc5, 0x26, 0x76, 0x0d, 0xb7,
	0x4c, 0x82, 0x94, 0xe9, 0xa1, 0x27, 0x00, 0x3a, 0xee, 0xa9, 0x36, 0x31, 0x88, 0x9b, 0xf4, 0x7c,
	0x14, 0xb1, 0xa0, 0x92, 0xd3, 0x79, 0xd3, 0x95, 0x3e, 0x11, 0xe0, 0x3a, 0x51, 0xb8, 0x85, 0x5d,
	0xcf, 0xa8, 0x7f, 0x48, 0x23, 0xd1, 0xb0, 0xd5, 0x8a, 0x20, 0x6d, 0xd9, 0x98, 0xad, 0x51, 0x41,
	0xa1, 0xbf, 0xd1, 0x32, 0xcc, 0xd0, 0x72, 0x24, 0x2f, 0x03, 0xb0, 0x06, 0xa1, 0x6c, 0x1a, 0xa7,
	0x4d, 0x7e, 0xb4, 0xa7, 0xbf, 0xd1, 0x22, 0xa4, 0x5a, 0xd6, 0x19, 0x55, 0x55, 0x50, 0xc8, 0x4f,
	0x74, 0x0f, 0xf2, 0x3a, 0x0d, 0xc7, 0x6a, 0xd7, 0x6a, 0x75, 0xda, 0x98, 0xee, 0x00, 0x82, 0x32,
	0xcf, 0x3a, 0x4f, 0x68, 0x1f, 0xc9, 0xec, 0xd8, 0xab, 0x4c, 0x46, 0x92, 0xa1, 0x24, 0xf4, 0x9d,
	0x1e, 0x23, 0x90, 0xfe, 0x58, 0x80, 0x5b, 0x03, 0x1a, 0xf8, 0x05, 0x82, 0x5d, 0x7e, 0xb7, 0x26,
	0x4c, 0xbe, 0x37, 0xb0, 0x3b, 0xb6, 0xa0, 0xc4, 0x25, 0x86, 0x4a, 0x5c, 0x17, 0x2a, 0xcf, 0xa9,
	0x0b, 0x95, 0x67, 0xe9, 0x03, 0x78, 0xe9, 0x82, 0x6c, 0xfc, 0x8c, 0x5b, 0x0e, 0x4a, 0x5f, 0xa9,
	0x24, 0x8f, 0x65, 0x06, 0x61, 0x58, 0xe1, 0xef, 0x14, 0x5e, 0x1e, 0xf8, 0x70, 0xe4, 0x39, 0x58,
	0x6b, 0x4f, 0xdb, 0x02, 0x92, 0x0e, 0xab, 0x43, 0x06, 0xba, 0xa0, 0x8e, 0x30, 0xb1, 0x3a, 0xf2,
	0x6f, 0xe7, 0x61, 0xfe, 0xed, 0x0e, 0x76, 0xce, 0x8f, 0xb0, 0xd3, 0x35, 0xea, 0x18, 0xfd, 0xae,
	0x10, 0xff, 0x60, 0x70, 0x63, 0x92, 0x6d, 0x97, 0xd9, 0xa4, 0xf0, 0xc6, 0x44, 0xbc, 0x5c, 0xcd,
	0x5f, 0x1c, 0xbc, 0x62, 0x7f, 0x75, 0xbc, 0xad, 0x8a, 0xcb, 0xf0, 0x68, 0x4c, 0x2e, 0x3e, 0xfa,
	0x39, 0xcc, 0x47, 0xf6, 0xd5, 0x91, 0x13, 0x1a, 0x73, 0xf9, 0x56, 0x78, 0x75, 0x3c, 0x26, 0x3e,
	0xf4, 0x47, 0x02, 0x2c, 0x44, 0xef, 0x97, 0xd0, 0x78, 0x4a, 0xf8, 0x37, 0x19, 0x85, 0xd7, 0xc6,
	0x65, 0x63, 0x12, 0x3c, 0x10, 0xd0, 0x2f, 0x43, 0x3e, 0x72, 0x4f, 0x83, 0xc6, 0x52, 0xc5, 0x4d,
	0x6c, 0xfc, 0xd8, 0xcb, 0xa0, 0x07, 0x02, 0xfa, 0x1d, 0x01, 0xd0, 0xc5, 0x9a, 0x36, 0xfa, 0xfa,
	0x28, 0xbc, 0xa1, 0xb7, 0x3a, 0x85, 0x8d, 0x49, 0x58, 0x03, 0x79, 0xfe, 0x40, 0x80, 0x9b, 0xb1,
	0x97, 0x24, 0xe8, 0xf1, 0xd8, 0xb8, 0xa1, 0xbb, 0x8f, 0xc2, 0x37, 0x26, 0xe4, 0xe6, 0xae, 0xf2,
	0xb1, 0x00, 0xb7, 0xe2, 0xaf, 0x3b, 0xd0, 0xf8, 0xc8, 0xe1, 0x4b, 0x99, 0xc2, 0xcf, 0x4d, 0xca,
	0x1e, 0x98, 0xec, 0xbb, 0x42, 0xdc, 0x25, 0x1b, 0xbf, 0x96, 0x40, 0xdf, 0x9c, 0x04, 0x3f, 0x7c,
	0xc9, 0x52, 0xd8, 0xbc, 0x02, 0x42, 0x20, 0xe4, 0x29, 0xcc, 0xb2, 0x9b, 0x03, 0x34, 0x3a, 0x11,
	0x0e, 0xdf, 0x61, 0x14, 0x8a, 0x49, 0xc9, 0xf9, 0x4c, 0xfd, 0x6a, 0xcc, 0xee, 0xff, 0xda, 0xb8,
	0xa1, 0x9b, 0x8f, 0xfd, 0xfa, 0xd8, 0x7c, 0x5c, 0x88, 0x3f, 0x14, 0xe0, 0x66, 0xec, 0xde, 0x32,
	0xda, 0x8b, 0x2f, 0xdb, 0xfb, 0x46, 0x7b, 0xf1, 0xa5, 0x1b, 0xda, 0x03, 0x41, 0xfe, 0x3d, 0x01,
	0x6e, 0xf0, 0xfa, 0xb4, 0x61, 0x99, 0xfe, 0x96, 0x44, 0x76, 0x80, 0x70, 0xd1, 0x3a, 0xc1, 0x0e,
	0x10, 0x53, 0x3e, 0x4f, 0xb0, 0x03, 0xc4, 0x55, 0xc6, 0xb7, 0xfe, 0x4a, 0xfc, 0xfb, 0x4f, 0xd7,
	0x84, 0x1f, 0x7c, 0xba, 0x26, 0xfc, 0xdb, 0xa7, 0x6b, 0xc2, 0x77, 0x3e, 0x5b, 0xbb, 0xf6, 0x83,
	0xcf, 0xd6, 0xae, 0xfd, 0xf3, 0x67, 0x6b, 0xd7, 0x40, 0xaa, 0x5b, 0xed, 0x11, 0xa0, 0x5b, 0x59,
	0x92, 0x08, 0x3a, 0x96, 0x67, 0x55, 0x85, 0xf7, 0xab, 0xa7, 0x86, 0xd7, 0xec, 0xd4, 0x08, 0xd1,
	0x7a, 0xdd, 0x72, 0xdb, 0x96, 0xbb, 0xee, 0xe0, 0x96, 0x76, 0x8e, 0x9d, 0xf5, 0xae, 0x1c, 0xfc,
	0xac, 0x37, 0x35, 0xc3, 0x74, 0xd7, 0x2f, 0xff, 0x0b, 0x13, 0x6f, 0xe8, 0xb8, 0xd7, 0x2d, 0x7d,
	0x57, 0x4c, 0x57, 0xcb, 0xe5, 0xca, 0x9f, 0x8b, 0x6b, 0x55, 0x5f, 0x8a, 0x32, 0x91, 0xa2, 0x1c,
	0x48, 0x51, 0xc1, 0xbd, 0xe2, 0x49, 0xe9, 0xfb, 0x7d, 0x82, 0x67, 0x84, 0xe0, 0x59, 0x40, 0xf0,
	0xac, 0x82, 0x7b, 0xcf, 0x4e, 0x4a, 0x9f, 0x8a, 0xaf, 0x5c, 0x4e, 0xf0, 0x6c, 0xb7, 0xba, 0xe5,
	0xff, 0x7f, 0x3b, 0xff, 0x29, 0x4a, 0x3e, 0xf1, 0xc6, 0x06, 0xa1, 0x26, 0xff, 0xe5, 0xe4, 0x1b,
	0x1b, 0x15, 0xdc, 0xdb, 0xd8, 0x38, 0x29, 0xd5, 0x66, 0xe9, 0xdf, 0x67, 0x78, 0xf8, 0x3f, 0x01,
	0x00, 0x00, 0xff, 0xff, 0xa5, 0xa6, 0x63, 0x50, 0x2b, 0x43, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QueryServiceClient is the client API for QueryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryServiceClient interface {
	// Get the batch clearing prices for a specific block height and trading pair.
	BatchSwapOutputData(ctx context.Context, in *BatchSwapOutputDataRequest, opts ...grpc.CallOption) (*BatchSwapOutputDataResponse, error)
	// Get the precise swap execution used for a specific batch swap.
	SwapExecution(ctx context.Context, in *SwapExecutionRequest, opts ...grpc.CallOption) (*SwapExecutionResponse, error)
	// Get the precise execution used to perform on-chain arbitrage.
	ArbExecution(ctx context.Context, in *ArbExecutionRequest, opts ...grpc.CallOption) (*ArbExecutionResponse, error)
	// Stream all swap executions over a range of heights, optionally subscribing to future executions.
	SwapExecutions(ctx context.Context, in *SwapExecutionsRequest, opts ...grpc.CallOption) (QueryService_SwapExecutionsClient, error)
	// Stream all arbitrage executions over a range of heights, optionally subscribing to future executions.
	ArbExecutions(ctx context.Context, in *ArbExecutionsRequest, opts ...grpc.CallOption) (QueryService_ArbExecutionsClient, error)
	// Query all liquidity positions on the DEX.
	LiquidityPositions(ctx context.Context, in *LiquidityPositionsRequest, opts ...grpc.CallOption) (QueryService_LiquidityPositionsClient, error)
	// Query liquidity positions by ID.
	//
	// To get multiple positions, use `LiquidityPositionsById`.
	LiquidityPositionById(ctx context.Context, in *LiquidityPositionByIdRequest, opts ...grpc.CallOption) (*LiquidityPositionByIdResponse, error)
	// Query multiple liquidity positions by ID.
	LiquidityPositionsById(ctx context.Context, in *LiquidityPositionsByIdRequest, opts ...grpc.CallOption) (QueryService_LiquidityPositionsByIdClient, error)
	// Query liquidity positions on a specific pair, sorted by effective price.
	LiquidityPositionsByPrice(ctx context.Context, in *LiquidityPositionsByPriceRequest, opts ...grpc.CallOption) (QueryService_LiquidityPositionsByPriceClient, error)
	// Get the current (direct) spread on a trading pair.
	//
	// This method doesn't do simulation, so actually executing might result in a
	// better price (if the chain takes a different route to the target asset).
	Spread(ctx context.Context, in *SpreadRequest, opts ...grpc.CallOption) (*SpreadResponse, error)
	// Get historical candlestick data for a given trading pair.
	//
	// Note that this RPC is directional, to get data for both directions, make a second request.
	CandlestickData(ctx context.Context, in *CandlestickDataRequest, opts ...grpc.CallOption) (*CandlestickDataResponse, error)
	// Subscribe to candlestick data updates.
	CandlestickDataStream(ctx context.Context, in *CandlestickDataStreamRequest, opts ...grpc.CallOption) (QueryService_CandlestickDataStreamClient, error)
}

type queryServiceClient struct {
	cc grpc1.ClientConn
}

func NewQueryServiceClient(cc grpc1.ClientConn) QueryServiceClient {
	return &queryServiceClient{cc}
}

func (c *queryServiceClient) BatchSwapOutputData(ctx context.Context, in *BatchSwapOutputDataRequest, opts ...grpc.CallOption) (*BatchSwapOutputDataResponse, error) {
	out := new(BatchSwapOutputDataResponse)
	err := c.cc.Invoke(ctx, "/penumbra.core.component.dex.v1.QueryService/BatchSwapOutputData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryServiceClient) SwapExecution(ctx context.Context, in *SwapExecutionRequest, opts ...grpc.CallOption) (*SwapExecutionResponse, error) {
	out := new(SwapExecutionResponse)
	err := c.cc.Invoke(ctx, "/penumbra.core.component.dex.v1.QueryService/SwapExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryServiceClient) ArbExecution(ctx context.Context, in *ArbExecutionRequest, opts ...grpc.CallOption) (*ArbExecutionResponse, error) {
	out := new(ArbExecutionResponse)
	err := c.cc.Invoke(ctx, "/penumbra.core.component.dex.v1.QueryService/ArbExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryServiceClient) SwapExecutions(ctx context.Context, in *SwapExecutionsRequest, opts ...grpc.CallOption) (QueryService_SwapExecutionsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_QueryService_serviceDesc.Streams[0], "/penumbra.core.component.dex.v1.QueryService/SwapExecutions", opts...)
	if err != nil {
		return nil, err
	}
	x := &queryServiceSwapExecutionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type QueryService_SwapExecutionsClient interface {
	Recv() (*SwapExecutionsResponse, error)
	grpc.ClientStream
}

type queryServiceSwapExecutionsClient struct {
	grpc.ClientStream
}

func (x *queryServiceSwapExecutionsClient) Recv() (*SwapExecutionsResponse, error) {
	m := new(SwapExecutionsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queryServiceClient) ArbExecutions(ctx context.Context, in *ArbExecutionsRequest, opts ...grpc.CallOption) (QueryService_ArbExecutionsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_QueryService_serviceDesc.Streams[1], "/penumbra.core.component.dex.v1.QueryService/ArbExecutions", opts...)
	if err != nil {
		return nil, err
	}
	x := &queryServiceArbExecutionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type QueryService_ArbExecutionsClient interface {
	Recv() (*ArbExecutionsResponse, error)
	grpc.ClientStream
}

type queryServiceArbExecutionsClient struct {
	grpc.ClientStream
}

func (x *queryServiceArbExecutionsClient) Recv() (*ArbExecutionsResponse, error) {
	m := new(ArbExecutionsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queryServiceClient) LiquidityPositions(ctx context.Context, in *LiquidityPositionsRequest, opts ...grpc.CallOption) (QueryService_LiquidityPositionsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_QueryService_serviceDesc.Streams[2], "/penumbra.core.component.dex.v1.QueryService/LiquidityPositions", opts...)
	if err != nil {
		return nil, err
	}
	x := &queryServiceLiquidityPositionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type QueryService_LiquidityPositionsClient interface {
	Recv() (*LiquidityPositionsResponse, error)
	grpc.ClientStream
}

type queryServiceLiquidityPositionsClient struct {
	grpc.ClientStream
}

func (x *queryServiceLiquidityPositionsClient) Recv() (*LiquidityPositionsResponse, error) {
	m := new(LiquidityPositionsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queryServiceClient) LiquidityPositionById(ctx context.Context, in *LiquidityPositionByIdRequest, opts ...grpc.CallOption) (*LiquidityPositionByIdResponse, error) {
	out := new(LiquidityPositionByIdResponse)
	err := c.cc.Invoke(ctx, "/penumbra.core.component.dex.v1.QueryService/LiquidityPositionById", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryServiceClient) LiquidityPositionsById(ctx context.Context, in *LiquidityPositionsByIdRequest, opts ...grpc.CallOption) (QueryService_LiquidityPositionsByIdClient, error) {
	stream, err := c.cc.NewStream(ctx, &_QueryService_serviceDesc.Streams[3], "/penumbra.core.component.dex.v1.QueryService/LiquidityPositionsById", opts...)
	if err != nil {
		return nil, err
	}
	x := &queryServiceLiquidityPositionsByIdClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type QueryService_LiquidityPositionsByIdClient interface {
	Recv() (*LiquidityPositionsByIdResponse, error)
	grpc.ClientStream
}

type queryServiceLiquidityPositionsByIdClient struct {
	grpc.ClientStream
}

func (x *queryServiceLiquidityPositionsByIdClient) Recv() (*LiquidityPositionsByIdResponse, error) {
	m := new(LiquidityPositionsByIdResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queryServiceClient) LiquidityPositionsByPrice(ctx context.Context, in *LiquidityPositionsByPriceRequest, opts ...grpc.CallOption) (QueryService_LiquidityPositionsByPriceClient, error) {
	stream, err := c.cc.NewStream(ctx, &_QueryService_serviceDesc.Streams[4], "/penumbra.core.component.dex.v1.QueryService/LiquidityPositionsByPrice", opts...)
	if err != nil {
		return nil, err
	}
	x := &queryServiceLiquidityPositionsByPriceClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type QueryService_LiquidityPositionsByPriceClient interface {
	Recv() (*LiquidityPositionsByPriceResponse, error)
	grpc.ClientStream
}

type queryServiceLiquidityPositionsByPriceClient struct {
	grpc.ClientStream
}

func (x *queryServiceLiquidityPositionsByPriceClient) Recv() (*LiquidityPositionsByPriceResponse, error) {
	m := new(LiquidityPositionsByPriceResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queryServiceClient) Spread(ctx context.Context, in *SpreadRequest, opts ...grpc.CallOption) (*SpreadResponse, error) {
	out := new(SpreadResponse)
	err := c.cc.Invoke(ctx, "/penumbra.core.component.dex.v1.QueryService/Spread", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryServiceClient) CandlestickData(ctx context.Context, in *CandlestickDataRequest, opts ...grpc.CallOption) (*CandlestickDataResponse, error) {
	out := new(CandlestickDataResponse)
	err := c.cc.Invoke(ctx, "/penumbra.core.component.dex.v1.QueryService/CandlestickData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryServiceClient) CandlestickDataStream(ctx context.Context, in *CandlestickDataStreamRequest, opts ...grpc.CallOption) (QueryService_CandlestickDataStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_QueryService_serviceDesc.Streams[5], "/penumbra.core.component.dex.v1.QueryService/CandlestickDataStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &queryServiceCandlestickDataStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type QueryService_CandlestickDataStreamClient interface {
	Recv() (*CandlestickDataStreamResponse, error)
	grpc.ClientStream
}

type queryServiceCandlestickDataStreamClient struct {
	grpc.ClientStream
}

func (x *queryServiceCandlestickDataStreamClient) Recv() (*CandlestickDataStreamResponse, error) {
	m := new(CandlestickDataStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// QueryServiceServer is the server API for QueryService service.
type QueryServiceServer interface {
	// Get the batch clearing prices for a specific block height and trading pair.
	BatchSwapOutputData(context.Context, *BatchSwapOutputDataRequest) (*BatchSwapOutputDataResponse, error)
	// Get the precise swap execution used for a specific batch swap.
	SwapExecution(context.Context, *SwapExecutionRequest) (*SwapExecutionResponse, error)
	// Get the precise execution used to perform on-chain arbitrage.
	ArbExecution(context.Context, *ArbExecutionRequest) (*ArbExecutionResponse, error)
	// Stream all swap executions over a range of heights, optionally subscribing to future executions.
	SwapExecutions(*SwapExecutionsRequest, QueryService_SwapExecutionsServer) error
	// Stream all arbitrage executions over a range of heights, optionally subscribing to future executions.
	ArbExecutions(*ArbExecutionsRequest, QueryService_ArbExecutionsServer) error
	// Query all liquidity positions on the DEX.
	LiquidityPositions(*LiquidityPositionsRequest, QueryService_LiquidityPositionsServer) error
	// Query liquidity positions by ID.
	//
	// To get multiple positions, use `LiquidityPositionsById`.
	LiquidityPositionById(context.Context, *LiquidityPositionByIdRequest) (*LiquidityPositionByIdResponse, error)
	// Query multiple liquidity positions by ID.
	LiquidityPositionsById(*LiquidityPositionsByIdRequest, QueryService_LiquidityPositionsByIdServer) error
	// Query liquidity positions on a specific pair, sorted by effective price.
	LiquidityPositionsByPrice(*LiquidityPositionsByPriceRequest, QueryService_LiquidityPositionsByPriceServer) error
	// Get the current (direct) spread on a trading pair.
	//
	// This method doesn't do simulation, so actually executing might result in a
	// better price (if the chain takes a different route to the target asset).
	Spread(context.Context, *SpreadRequest) (*SpreadResponse, error)
	// Get historical candlestick data for a given trading pair.
	//
	// Note that this RPC is directional, to get data for both directions, make a second request.
	CandlestickData(context.Context, *CandlestickDataRequest) (*CandlestickDataResponse, error)
	// Subscribe to candlestick data updates.
	CandlestickDataStream(*CandlestickDataStreamRequest, QueryService_CandlestickDataStreamServer) error
}

// UnimplementedQueryServiceServer can be embedded to have forward compatible implementations.
type UnimplementedQueryServiceServer struct {
}

func (*UnimplementedQueryServiceServer) BatchSwapOutputData(ctx context.Context, req *BatchSwapOutputDataRequest) (*BatchSwapOutputDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchSwapOutputData not implemented")
}
func (*UnimplementedQueryServiceServer) SwapExecution(ctx context.Context, req *SwapExecutionRequest) (*SwapExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SwapExecution not implemented")
}
func (*UnimplementedQueryServiceServer) ArbExecution(ctx context.Context, req *ArbExecutionRequest) (*ArbExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ArbExecution not implemented")
}
func (*UnimplementedQueryServiceServer) SwapExecutions(req *SwapExecutionsRequest, srv QueryService_SwapExecutionsServer) error {
	return status.Errorf(codes.Unimplemented, "method SwapExecutions not implemented")
}
func (*UnimplementedQueryServiceServer) ArbExecutions(req *ArbExecutionsRequest, srv QueryService_ArbExecutionsServer) error {
	return status.Errorf(codes.Unimplemented, "method ArbExecutions not implemented")
}
func (*UnimplementedQueryServiceServer) LiquidityPositions(req *LiquidityPositionsRequest, srv QueryService_LiquidityPositionsServer) error {
	return status.Errorf(codes.Unimplemented, "method LiquidityPositions not implemented")
}
func (*UnimplementedQueryServiceServer) LiquidityPositionById(ctx context.Context, req *LiquidityPositionByIdRequest) (*LiquidityPositionByIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LiquidityPositionById not implemented")
}
func (*UnimplementedQueryServiceServer) LiquidityPositionsById(req *LiquidityPositionsByIdRequest, srv QueryService_LiquidityPositionsByIdServer) error {
	return status.Errorf(codes.Unimplemented, "method LiquidityPositionsById not implemented")
}
func (*UnimplementedQueryServiceServer) LiquidityPositionsByPrice(req *LiquidityPositionsByPriceRequest, srv QueryService_LiquidityPositionsByPriceServer) error {
	return status.Errorf(codes.Unimplemented, "method LiquidityPositionsByPrice not implemented")
}
func (*UnimplementedQueryServiceServer) Spread(ctx context.Context, req *SpreadRequest) (*SpreadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Spread not implemented")
}
func (*UnimplementedQueryServiceServer) CandlestickData(ctx context.Context, req *CandlestickDataRequest) (*CandlestickDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CandlestickData not implemented")
}
func (*UnimplementedQueryServiceServer) CandlestickDataStream(req *CandlestickDataStreamRequest, srv QueryService_CandlestickDataStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method CandlestickDataStream not implemented")
}

func RegisterQueryServiceServer(s grpc1.Server, srv QueryServiceServer) {
	s.RegisterService(&_QueryService_serviceDesc, srv)
}

func _QueryService_BatchSwapOutputData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchSwapOutputDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServiceServer).BatchSwapOutputData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/penumbra.core.component.dex.v1.QueryService/BatchSwapOutputData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServiceServer).BatchSwapOutputData(ctx, req.(*BatchSwapOutputDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueryService_SwapExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SwapExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServiceServer).SwapExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/penumbra.core.component.dex.v1.QueryService/SwapExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServiceServer).SwapExecution(ctx, req.(*SwapExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueryService_ArbExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArbExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServiceServer).ArbExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/penumbra.core.component.dex.v1.QueryService/ArbExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServiceServer).ArbExecution(ctx, req.(*ArbExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueryService_SwapExecutions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SwapExecutionsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryServiceServer).SwapExecutions(m, &queryServiceSwapExecutionsServer{stream})
}

type QueryService_SwapExecutionsServer interface {
	Send(*SwapExecutionsResponse) error
	grpc.ServerStream
}

type queryServiceSwapExecutionsServer struct {
	grpc.ServerStream
}

func (x *queryServiceSwapExecutionsServer) Send(m *SwapExecutionsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _QueryService_ArbExecutions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ArbExecutionsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryServiceServer).ArbExecutions(m, &queryServiceArbExecutionsServer{stream})
}

type QueryService_ArbExecutionsServer interface {
	Send(*ArbExecutionsResponse) error
	grpc.ServerStream
}

type queryServiceArbExecutionsServer struct {
	grpc.ServerStream
}

func (x *queryServiceArbExecutionsServer) Send(m *ArbExecutionsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _QueryService_LiquidityPositions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(LiquidityPositionsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryServiceServer).LiquidityPositions(m, &queryServiceLiquidityPositionsServer{stream})
}

type QueryService_LiquidityPositionsServer interface {
	Send(*LiquidityPositionsResponse) error
	grpc.ServerStream
}

type queryServiceLiquidityPositionsServer struct {
	grpc.ServerStream
}

func (x *queryServiceLiquidityPositionsServer) Send(m *LiquidityPositionsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _QueryService_LiquidityPositionById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LiquidityPositionByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServiceServer).LiquidityPositionById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/penumbra.core.component.dex.v1.QueryService/LiquidityPositionById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServiceServer).LiquidityPositionById(ctx, req.(*LiquidityPositionByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueryService_LiquidityPositionsById_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(LiquidityPositionsByIdRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryServiceServer).LiquidityPositionsById(m, &queryServiceLiquidityPositionsByIdServer{stream})
}

type QueryService_LiquidityPositionsByIdServer interface {
	Send(*LiquidityPositionsByIdResponse) error
	grpc.ServerStream
}

type queryServiceLiquidityPositionsByIdServer struct {
	grpc.ServerStream
}

func (x *queryServiceLiquidityPositionsByIdServer) Send(m *LiquidityPositionsByIdResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _QueryService_LiquidityPositionsByPrice_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(LiquidityPositionsByPriceRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryServiceServer).LiquidityPositionsByPrice(m, &queryServiceLiquidityPositionsByPriceServer{stream})
}

type QueryService_LiquidityPositionsByPriceServer interface {
	Send(*LiquidityPositionsByPriceResponse) error
	grpc.ServerStream
}

type queryServiceLiquidityPositionsByPriceServer struct {
	grpc.ServerStream
}

func (x *queryServiceLiquidityPositionsByPriceServer) Send(m *LiquidityPositionsByPriceResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _QueryService_Spread_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SpreadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServiceServer).Spread(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/penumbra.core.component.dex.v1.QueryService/Spread",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServiceServer).Spread(ctx, req.(*SpreadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueryService_CandlestickData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CandlestickDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServiceServer).CandlestickData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/penumbra.core.component.dex.v1.QueryService/CandlestickData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServiceServer).CandlestickData(ctx, req.(*CandlestickDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueryService_CandlestickDataStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CandlestickDataStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryServiceServer).CandlestickDataStream(m, &queryServiceCandlestickDataStreamServer{stream})
}

type QueryService_CandlestickDataStreamServer interface {
	Send(*CandlestickDataStreamResponse) error
	grpc.ServerStream
}

type queryServiceCandlestickDataStreamServer struct {
	grpc.ServerStream
}

func (x *queryServiceCandlestickDataStreamServer) Send(m *CandlestickDataStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _QueryService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "penumbra.core.component.dex.v1.QueryService",
	HandlerType: (*QueryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "BatchSwapOutputData",
			Handler:    _QueryService_BatchSwapOutputData_Handler,
		},
		{
			MethodName: "SwapExecution",
			Handler:    _QueryService_SwapExecution_Handler,
		},
		{
			MethodName: "ArbExecution",
			Handler:    _QueryService_ArbExecution_Handler,
		},
		{
			MethodName: "LiquidityPositionById",
			Handler:    _QueryService_LiquidityPositionById_Handler,
		},
		{
			MethodName: "Spread",
			Handler:    _QueryService_Spread_Handler,
		},
		{
			MethodName: "CandlestickData",
			Handler:    _QueryService_CandlestickData_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SwapExecutions",
			Handler:       _QueryService_SwapExecutions_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ArbExecutions",
			Handler:       _QueryService_ArbExecutions_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "LiquidityPositions",
			Handler:       _QueryService_LiquidityPositions_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "LiquidityPositionsById",
			Handler:       _QueryService_LiquidityPositionsById_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "LiquidityPositionsByPrice",
			Handler:       _QueryService_LiquidityPositionsByPrice_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "CandlestickDataStream",
			Handler:       _QueryService_CandlestickDataStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "penumbra/core/component/dex/v1/dex.proto",
}

// SimulationServiceClient is the client API for SimulationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SimulationServiceClient interface {
	// Simulate routing and trade execution.
	SimulateTrade(ctx context.Context, in *SimulateTradeRequest, opts ...grpc.CallOption) (*SimulateTradeResponse, error)
}

type simulationServiceClient struct {
	cc grpc1.ClientConn
}

func NewSimulationServiceClient(cc grpc1.ClientConn) SimulationServiceClient {
	return &simulationServiceClient{cc}
}

func (c *simulationServiceClient) SimulateTrade(ctx context.Context, in *SimulateTradeRequest, opts ...grpc.CallOption) (*SimulateTradeResponse, error) {
	out := new(SimulateTradeResponse)
	err := c.cc.Invoke(ctx, "/penumbra.core.component.dex.v1.SimulationService/SimulateTrade", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SimulationServiceServer is the server API for SimulationService service.
type SimulationServiceServer interface {
	// Simulate routing and trade execution.
	SimulateTrade(context.Context, *SimulateTradeRequest) (*SimulateTradeResponse, error)
}

// UnimplementedSimulationServiceServer can be embedded to have forward compatible implementations.
type UnimplementedSimulationServiceServer struct {
}

func (*UnimplementedSimulationServiceServer) SimulateTrade(ctx context.Context, req *SimulateTradeRequest) (*SimulateTradeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SimulateTrade not implemented")
}

func RegisterSimulationServiceServer(s grpc1.Server, srv SimulationServiceServer) {
	s.RegisterService(&_SimulationService_serviceDesc, srv)
}

func _SimulationService_SimulateTrade_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SimulateTradeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SimulationServiceServer).SimulateTrade(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/penumbra.core.component.dex.v1.SimulationService/SimulateTrade",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SimulationServiceServer).SimulateTrade(ctx, req.(*SimulateTradeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _SimulationService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "penumbra.core.component.dex.v1.SimulationService",
	HandlerType: (*SimulationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SimulateTrade",
			Handler:    _SimulationService_SimulateTrade_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "penumbra/core/component/dex/v1/dex.proto",
}

func (m *ZKSwapProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZKSwapProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZKSwapProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Inner) > 0 {
		i -= len(m.Inner)
		copy(dAtA[i:], m.Inner)
		i = encodeVarintDex(dAtA, i, uint64(len(m.Inner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ZKSwapClaimProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZKSwapClaimProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZKSwapClaimProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Inner) > 0 {
		i -= len(m.Inner)
		copy(dAtA[i:], m.Inner)
		i = encodeVarintDex(dAtA, i, uint64(len(m.Inner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Swap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Swap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Swap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Body != nil {
		{
			size, err := m.Body.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Proof != nil {
		{
			size, err := m.Proof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwapClaim) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EpochDuration != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.EpochDuration))
		i--
		dAtA[i] = 0x38
	}
	if m.Body != nil {
		{
			size, err := m.Body.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Proof != nil {
		{
			size, err := m.Proof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwapClaimBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapClaimBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapClaimBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OutputData != nil {
		{
			size, err := m.OutputData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Output_2Commitment != nil {
		{
			size, err := m.Output_2Commitment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Output_1Commitment != nil {
		{
			size, err := m.Output_1Commitment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Fee != nil {
		{
			size, err := m.Fee.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Nullifier != nil {
		{
			size, err := m.Nullifier.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwapBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.FeeCommitment != nil {
		{
			size, err := m.FeeCommitment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Delta_2I != nil {
		{
			size, err := m.Delta_2I.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Delta_1I != nil {
		{
			size, err := m.Delta_1I.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TradingPair != nil {
		{
			size, err := m.TradingPair.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwapPayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapPayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapPayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EncryptedSwap) > 0 {
		i -= len(m.EncryptedSwap)
		copy(dAtA[i:], m.EncryptedSwap)
		i = encodeVarintDex(dAtA, i, uint64(len(m.EncryptedSwap)))
		i--
		dAtA[i] = 0x12
	}
	if m.Commitment != nil {
		{
			size, err := m.Commitment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwapPlaintext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapPlaintext) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapPlaintext) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Rseed) > 0 {
		i -= len(m.Rseed)
		copy(dAtA[i:], m.Rseed)
		i = encodeVarintDex(dAtA, i, uint64(len(m.Rseed)))
		i--
		dAtA[i] = 0x32
	}
	if m.ClaimAddress != nil {
		{
			size, err := m.ClaimAddress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.ClaimFee != nil {
		{
			size, err := m.ClaimFee.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Delta_2I != nil {
		{
			size, err := m.Delta_2I.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Delta_1I != nil {
		{
			size, err := m.Delta_1I.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TradingPair != nil {
		{
			size, err := m.TradingPair.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwapPlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapPlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapPlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProofBlindingS) > 0 {
		i -= len(m.ProofBlindingS)
		copy(dAtA[i:], m.ProofBlindingS)
		i = encodeVarintDex(dAtA, i, uint64(len(m.ProofBlindingS)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ProofBlindingR) > 0 {
		i -= len(m.ProofBlindingR)
		copy(dAtA[i:], m.ProofBlindingR)
		i = encodeVarintDex(dAtA, i, uint64(len(m.ProofBlindingR)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.FeeBlinding) > 0 {
		i -= len(m.FeeBlinding)
		copy(dAtA[i:], m.FeeBlinding)
		i = encodeVarintDex(dAtA, i, uint64(len(m.FeeBlinding)))
		i--
		dAtA[i] = 0x12
	}
	if m.SwapPlaintext != nil {
		{
			size, err := m.SwapPlaintext.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwapClaimPlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapClaimPlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapClaimPlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProofBlindingS) > 0 {
		i -= len(m.ProofBlindingS)
		copy(dAtA[i:], m.ProofBlindingS)
		i = encodeVarintDex(dAtA, i, uint64(len(m.ProofBlindingS)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ProofBlindingR) > 0 {
		i -= len(m.ProofBlindingR)
		copy(dAtA[i:], m.ProofBlindingR)
		i = encodeVarintDex(dAtA, i, uint64(len(m.ProofBlindingR)))
		i--
		dAtA[i] = 0x2a
	}
	if m.EpochDuration != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.EpochDuration))
		i--
		dAtA[i] = 0x20
	}
	if m.OutputData != nil {
		{
			size, err := m.OutputData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Position != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.Position))
		i--
		dAtA[i] = 0x10
	}
	if m.SwapPlaintext != nil {
		{
			size, err := m.SwapPlaintext.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwapView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapView) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SwapView != nil {
		{
			size := m.SwapView.Size()
			i -= size
			if _, err := m.SwapView.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *SwapView_Visible_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapView_Visible_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Visible != nil {
		{
			size, err := m.Visible.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *SwapView_Opaque_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapView_Opaque_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Opaque != nil {
		{
			size, err := m.Opaque.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *SwapView_Visible) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapView_Visible) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapView_Visible) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Asset_2Metadata != nil {
		{
			size, err := m.Asset_2Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	if m.Asset_1Metadata != nil {
		{
			size, err := m.Asset_1Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	if m.Output_2 != nil {
		{
			size, err := m.Output_2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if m.Output_1 != nil {
		{
			size, err := m.Output_1.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if m.BatchSwapOutputData != nil {
		{
			size, err := m.BatchSwapOutputData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.ClaimTx != nil {
		{
			size, err := m.ClaimTx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.SwapPlaintext != nil {
		{
			size, err := m.SwapPlaintext.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Swap != nil {
		{
			size, err := m.Swap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwapView_Opaque) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapView_Opaque) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapView_Opaque) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Asset_2Metadata != nil {
		{
			size, err := m.Asset_2Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	if m.Asset_1Metadata != nil {
		{
			size, err := m.Asset_1Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	if m.Output_2Value != nil {
		{
			size, err := m.Output_2Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if m.Output_1Value != nil {
		{
			size, err := m.Output_1Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if m.BatchSwapOutputData != nil {
		{
			size, err := m.BatchSwapOutputData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.Swap != nil {
		{
			size, err := m.Swap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwapClaimView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapClaimView) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapClaimView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SwapClaimView != nil {
		{
			size := m.SwapClaimView.Size()
			i -= size
			if _, err := m.SwapClaimView.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *SwapClaimView_Visible_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapClaimView_Visible_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Visible != nil {
		{
			size, err := m.Visible.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *SwapClaimView_Opaque_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapClaimView_Opaque_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Opaque != nil {
		{
			size, err := m.Opaque.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *SwapClaimView_Visible) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapClaimView_Visible) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapClaimView_Visible) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SwapTx != nil {
		{
			size, err := m.SwapTx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Output_2 != nil {
		{
			size, err := m.Output_2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Output_1 != nil {
		{
			size, err := m.Output_1.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SwapClaim != nil {
		{
			size, err := m.SwapClaim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwapClaimView_Opaque) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapClaimView_Opaque) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapClaimView_Opaque) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SwapClaim != nil {
		{
			size, err := m.SwapClaim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TradingPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TradingPair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TradingPair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Asset_2 != nil {
		{
			size, err := m.Asset_2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Asset_1 != nil {
		{
			size, err := m.Asset_1.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DirectedTradingPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DirectedTradingPair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DirectedTradingPair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.End != nil {
		{
			size, err := m.End.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Start != nil {
		{
			size, err := m.Start.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BatchSwapOutputData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchSwapOutputData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchSwapOutputData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SctPositionPrefix != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.SctPositionPrefix))
		i--
		dAtA[i] = 0x50
	}
	if m.EpochStartingHeight != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.EpochStartingHeight))
		i--
		dAtA[i] = 0x48
	}
	if m.TradingPair != nil {
		{
			size, err := m.TradingPair.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Height != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x38
	}
	if m.Unfilled_2 != nil {
		{
			size, err := m.Unfilled_2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Unfilled_1 != nil {
		{
			size, err := m.Unfilled_1.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Lambda_2 != nil {
		{
			size, err := m.Lambda_2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Lambda_1 != nil {
		{
			size, err := m.Lambda_1.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Delta_2 != nil {
		{
			size, err := m.Delta_2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Delta_1 != nil {
		{
			size, err := m.Delta_1.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TradingFunction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TradingFunction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TradingFunction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pair != nil {
		{
			size, err := m.Pair.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Component != nil {
		{
			size, err := m.Component.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BareTradingFunction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BareTradingFunction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BareTradingFunction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Q != nil {
		{
			size, err := m.Q.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.P != nil {
		{
			size, err := m.P.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Fee != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.Fee))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Reserves) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Reserves) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Reserves) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.R2 != nil {
		{
			size, err := m.R2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.R1 != nil {
		{
			size, err := m.R1.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Position) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Position) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Position) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CloseOnFill {
		i--
		if m.CloseOnFill {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Reserves != nil {
		{
			size, err := m.Reserves.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.State != nil {
		{
			size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintDex(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0x12
	}
	if m.Phi != nil {
		{
			size, err := m.Phi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PositionId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PositionId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PositionId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AltBech32M) > 0 {
		i -= len(m.AltBech32M)
		copy(dAtA[i:], m.AltBech32M)
		i = encodeVarintDex(dAtA, i, uint64(len(m.AltBech32M)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Inner) > 0 {
		i -= len(m.Inner)
		copy(dAtA[i:], m.Inner)
		i = encodeVarintDex(dAtA, i, uint64(len(m.Inner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PositionState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PositionState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PositionState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sequence != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.Sequence))
		i--
		dAtA[i] = 0x10
	}
	if m.State != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LpNft) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LpNft) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LpNft) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != nil {
		{
			size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.PositionId != nil {
		{
			size, err := m.PositionId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PositionOpen) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PositionOpen) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PositionOpen) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Position != nil {
		{
			size, err := m.Position.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PositionClose) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PositionClose) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PositionClose) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PositionId != nil {
		{
			size, err := m.PositionId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PositionWithdraw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PositionWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PositionWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sequence != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.Sequence))
		i--
		dAtA[i] = 0x18
	}
	if m.ReservesCommitment != nil {
		{
			size, err := m.ReservesCommitment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.PositionId != nil {
		{
			size, err := m.PositionId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PositionRewardClaim) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PositionRewardClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PositionRewardClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RewardsCommitment != nil {
		{
			size, err := m.RewardsCommitment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.PositionId != nil {
		{
			size, err := m.PositionId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwapExecution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapExecution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapExecution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Output != nil {
		{
			size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Input != nil {
		{
			size, err := m.Input.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Traces) > 0 {
		for iNdEx := len(m.Traces) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Traces[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDex(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SwapExecution_Trace) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapExecution_Trace) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapExecution_Trace) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		for iNdEx := len(m.Value) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Value[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDex(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PositionWithdrawPlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PositionWithdrawPlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PositionWithdrawPlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Rewards) > 0 {
		for iNdEx := len(m.Rewards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rewards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDex(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Sequence != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.Sequence))
		i--
		dAtA[i] = 0x20
	}
	if m.Pair != nil {
		{
			size, err := m.Pair.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PositionId != nil {
		{
			size, err := m.PositionId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Reserves != nil {
		{
			size, err := m.Reserves.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PositionRewardClaimPlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PositionRewardClaimPlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PositionRewardClaimPlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Reserves != nil {
		{
			size, err := m.Reserves.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BatchSwapOutputDataRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchSwapOutputDataRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchSwapOutputDataRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TradingPair != nil {
		{
			size, err := m.TradingPair.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Height != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *BatchSwapOutputDataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchSwapOutputDataResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchSwapOutputDataResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwapExecutionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapExecutionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapExecutionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TradingPair != nil {
		{
			size, err := m.TradingPair.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Height != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *SwapExecutionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapExecutionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapExecutionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SwapExecution != nil {
		{
			size, err := m.SwapExecution.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ArbExecutionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArbExecutionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArbExecutionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Height != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *ArbExecutionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArbExecutionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArbExecutionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Height != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if m.SwapExecution != nil {
		{
			size, err := m.SwapExecution.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwapExecutionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapExecutionsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapExecutionsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TradingPair != nil {
		{
			size, err := m.TradingPair.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.EndHeight != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.EndHeight))
		i--
		dAtA[i] = 0x18
	}
	if m.StartHeight != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.StartHeight))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *SwapExecutionsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapExecutionsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapExecutionsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TradingPair != nil {
		{
			size, err := m.TradingPair.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Height != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if m.SwapExecution != nil {
		{
			size, err := m.SwapExecution.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ArbExecutionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArbExecutionsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArbExecutionsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EndHeight != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.EndHeight))
		i--
		dAtA[i] = 0x18
	}
	if m.StartHeight != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.StartHeight))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *ArbExecutionsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArbExecutionsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArbExecutionsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Height != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if m.SwapExecution != nil {
		{
			size, err := m.SwapExecution.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LiquidityPositionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LiquidityPositionsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LiquidityPositionsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IncludeClosed {
		i--
		if m.IncludeClosed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	return len(dAtA) - i, nil
}

func (m *LiquidityPositionsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LiquidityPositionsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LiquidityPositionsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LiquidityPositionByIdRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LiquidityPositionByIdRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LiquidityPositionByIdRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PositionId != nil {
		{
			size, err := m.PositionId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *LiquidityPositionByIdResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LiquidityPositionByIdResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LiquidityPositionByIdResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LiquidityPositionsByIdRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LiquidityPositionsByIdRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LiquidityPositionsByIdRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PositionId) > 0 {
		for iNdEx := len(m.PositionId) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PositionId[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDex(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *LiquidityPositionsByIdResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LiquidityPositionsByIdResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LiquidityPositionsByIdResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LiquidityPositionsByPriceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LiquidityPositionsByPriceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LiquidityPositionsByPriceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Limit != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x28
	}
	if m.TradingPair != nil {
		{
			size, err := m.TradingPair.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *LiquidityPositionsByPriceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LiquidityPositionsByPriceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LiquidityPositionsByPriceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Id != nil {
		{
			size, err := m.Id.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpreadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpreadRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpreadRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TradingPair != nil {
		{
			size, err := m.TradingPair.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *SpreadResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpreadResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpreadResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ApproxEffectivePrice_2To_1 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ApproxEffectivePrice_2To_1))))
		i--
		dAtA[i] = 0x21
	}
	if m.ApproxEffectivePrice_1To_2 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ApproxEffectivePrice_1To_2))))
		i--
		dAtA[i] = 0x19
	}
	if m.Best_2To_1Position != nil {
		{
			size, err := m.Best_2To_1Position.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Best_1To_2Position != nil {
		{
			size, err := m.Best_1To_2Position.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SimulateTradeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimulateTradeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimulateTradeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Routing != nil {
		{
			size, err := m.Routing.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Output != nil {
		{
			size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Input != nil {
		{
			size, err := m.Input.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SimulateTradeRequest_Routing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimulateTradeRequest_Routing) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimulateTradeRequest_Routing) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Setting != nil {
		{
			size := m.Setting.Size()
			i -= size
			if _, err := m.Setting.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *SimulateTradeRequest_Routing_Default_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimulateTradeRequest_Routing_Default_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Default != nil {
		{
			size, err := m.Default.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *SimulateTradeRequest_Routing_SingleHop_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimulateTradeRequest_Routing_SingleHop_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SingleHop != nil {
		{
			size, err := m.SingleHop.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *SimulateTradeRequest_Routing_SingleHop) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimulateTradeRequest_Routing_SingleHop) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimulateTradeRequest_Routing_SingleHop) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *SimulateTradeRequest_Routing_Default) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimulateTradeRequest_Routing_Default) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimulateTradeRequest_Routing_Default) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *SimulateTradeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimulateTradeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimulateTradeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Unfilled != nil {
		{
			size, err := m.Unfilled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Output != nil {
		{
			size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSwap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSwap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSwap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SwapCommitment != nil {
		{
			size, err := m.SwapCommitment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Delta_2I != nil {
		{
			size, err := m.Delta_2I.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Delta_1I != nil {
		{
			size, err := m.Delta_1I.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TradingPair != nil {
		{
			size, err := m.TradingPair.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSwapClaim) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSwapClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSwapClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Nullifier != nil {
		{
			size, err := m.Nullifier.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Output_2Commitment != nil {
		{
			size, err := m.Output_2Commitment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Output_1Commitment != nil {
		{
			size, err := m.Output_1Commitment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TradingPair != nil {
		{
			size, err := m.TradingPair.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventPositionOpen) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventPositionOpen) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventPositionOpen) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TradingFee != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.TradingFee))
		i--
		dAtA[i] = 0x28
	}
	if m.Reserves_2 != nil {
		{
			size, err := m.Reserves_2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Reserves_1 != nil {
		{
			size, err := m.Reserves_1.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.TradingPair != nil {
		{
			size, err := m.TradingPair.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.PositionId != nil {
		{
			size, err := m.PositionId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventPositionClose) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventPositionClose) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventPositionClose) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PositionId != nil {
		{
			size, err := m.PositionId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventQueuePositionClose) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventQueuePositionClose) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventQueuePositionClose) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PositionId != nil {
		{
			size, err := m.PositionId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventPositionWithdraw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventPositionWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventPositionWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sequence != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.Sequence))
		i--
		dAtA[i] = 0x28
	}
	if m.Reserves_2 != nil {
		{
			size, err := m.Reserves_2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Reserves_1 != nil {
		{
			size, err := m.Reserves_1.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.TradingPair != nil {
		{
			size, err := m.TradingPair.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.PositionId != nil {
		{
			size, err := m.PositionId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventPositionExecution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventPositionExecution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventPositionExecution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		{
			size, err := m.Context.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.PrevReserves_2 != nil {
		{
			size, err := m.PrevReserves_2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.PrevReserves_1 != nil {
		{
			size, err := m.PrevReserves_1.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Reserves_2 != nil {
		{
			size, err := m.Reserves_2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Reserves_1 != nil {
		{
			size, err := m.Reserves_1.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.TradingPair != nil {
		{
			size, err := m.TradingPair.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.PositionId != nil {
		{
			size, err := m.PositionId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventBatchSwap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventBatchSwap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventBatchSwap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SwapExecution_2For_1 != nil {
		{
			size, err := m.SwapExecution_2For_1.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.SwapExecution_1For_2 != nil {
		{
			size, err := m.SwapExecution_1For_2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.BatchSwapOutputData != nil {
		{
			size, err := m.BatchSwapOutputData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventArbExecution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventArbExecution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventArbExecution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SwapExecution != nil {
		{
			size, err := m.SwapExecution.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Height != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventValueCircuitBreakerCredit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventValueCircuitBreakerCredit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventValueCircuitBreakerCredit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NewBalance != nil {
		{
			size, err := m.NewBalance.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PreviousBalance != nil {
		{
			size, err := m.PreviousBalance.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.AssetId != nil {
		{
			size, err := m.AssetId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventValueCircuitBreakerDebit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventValueCircuitBreakerDebit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventValueCircuitBreakerDebit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NewBalance != nil {
		{
			size, err := m.NewBalance.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PreviousBalance != nil {
		{
			size, err := m.PreviousBalance.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.AssetId != nil {
		{
			size, err := m.AssetId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DexParameters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DexParameters) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DexParameters) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxExecutionBudget != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.MaxExecutionBudget))
		i--
		dAtA[i] = 0x28
	}
	if m.MaxPositionsPerPair != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.MaxPositionsPerPair))
		i--
		dAtA[i] = 0x20
	}
	if m.MaxHops != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.MaxHops))
		i--
		dAtA[i] = 0x18
	}
	if len(m.FixedCandidates) > 0 {
		for iNdEx := len(m.FixedCandidates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FixedCandidates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDex(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.IsEnabled {
		i--
		if m.IsEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GenesisContent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenesisContent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenesisContent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DexParams != nil {
		{
			size, err := m.DexParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CandlestickData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CandlestickData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CandlestickData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SwapVolume != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.SwapVolume))))
		i--
		dAtA[i] = 0x39
	}
	if m.DirectVolume != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.DirectVolume))))
		i--
		dAtA[i] = 0x31
	}
	if m.Low != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Low))))
		i--
		dAtA[i] = 0x29
	}
	if m.High != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.High))))
		i--
		dAtA[i] = 0x21
	}
	if m.Close != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Close))))
		i--
		dAtA[i] = 0x19
	}
	if m.Open != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Open))))
		i--
		dAtA[i] = 0x11
	}
	if m.Height != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CandlestickDataRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CandlestickDataRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CandlestickDataRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StartHeight != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.StartHeight))
		i--
		dAtA[i] = 0x18
	}
	if m.Limit != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x10
	}
	if m.Pair != nil {
		{
			size, err := m.Pair.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CandlestickDataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CandlestickDataResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CandlestickDataResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDex(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CandlestickDataStreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CandlestickDataStreamRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CandlestickDataStreamRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pair != nil {
		{
			size, err := m.Pair.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CandlestickDataStreamResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CandlestickDataStreamResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CandlestickDataStreamResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintDex(dAtA []byte, offset int, v uint64) int {
	offset -= sovDex(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ZKSwapProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Inner)
	if l > 0 {
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *ZKSwapClaimProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Inner)
	if l > 0 {
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *Swap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Proof != nil {
		l = m.Proof.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Body != nil {
		l = m.Body.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SwapClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Proof != nil {
		l = m.Proof.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Body != nil {
		l = m.Body.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.EpochDuration != 0 {
		n += 1 + sovDex(uint64(m.EpochDuration))
	}
	return n
}

func (m *SwapClaimBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nullifier != nil {
		l = m.Nullifier.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Fee != nil {
		l = m.Fee.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Output_1Commitment != nil {
		l = m.Output_1Commitment.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Output_2Commitment != nil {
		l = m.Output_2Commitment.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.OutputData != nil {
		l = m.OutputData.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SwapBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TradingPair != nil {
		l = m.TradingPair.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Delta_1I != nil {
		l = m.Delta_1I.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Delta_2I != nil {
		l = m.Delta_2I.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.FeeCommitment != nil {
		l = m.FeeCommitment.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SwapPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commitment != nil {
		l = m.Commitment.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	l = len(m.EncryptedSwap)
	if l > 0 {
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SwapPlaintext) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TradingPair != nil {
		l = m.TradingPair.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Delta_1I != nil {
		l = m.Delta_1I.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Delta_2I != nil {
		l = m.Delta_2I.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.ClaimFee != nil {
		l = m.ClaimFee.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.ClaimAddress != nil {
		l = m.ClaimAddress.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	l = len(m.Rseed)
	if l > 0 {
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SwapPlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SwapPlaintext != nil {
		l = m.SwapPlaintext.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	l = len(m.FeeBlinding)
	if l > 0 {
		n += 1 + l + sovDex(uint64(l))
	}
	l = len(m.ProofBlindingR)
	if l > 0 {
		n += 1 + l + sovDex(uint64(l))
	}
	l = len(m.ProofBlindingS)
	if l > 0 {
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SwapClaimPlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SwapPlaintext != nil {
		l = m.SwapPlaintext.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Position != 0 {
		n += 1 + sovDex(uint64(m.Position))
	}
	if m.OutputData != nil {
		l = m.OutputData.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.EpochDuration != 0 {
		n += 1 + sovDex(uint64(m.EpochDuration))
	}
	l = len(m.ProofBlindingR)
	if l > 0 {
		n += 1 + l + sovDex(uint64(l))
	}
	l = len(m.ProofBlindingS)
	if l > 0 {
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SwapView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SwapView != nil {
		n += m.SwapView.Size()
	}
	return n
}

func (m *SwapView_Visible_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Visible != nil {
		l = m.Visible.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}
func (m *SwapView_Opaque_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Opaque != nil {
		l = m.Opaque.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}
func (m *SwapView_Visible) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Swap != nil {
		l = m.Swap.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.SwapPlaintext != nil {
		l = m.SwapPlaintext.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.ClaimTx != nil {
		l = m.ClaimTx.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.BatchSwapOutputData != nil {
		l = m.BatchSwapOutputData.Size()
		n += 2 + l + sovDex(uint64(l))
	}
	if m.Output_1 != nil {
		l = m.Output_1.Size()
		n += 2 + l + sovDex(uint64(l))
	}
	if m.Output_2 != nil {
		l = m.Output_2.Size()
		n += 2 + l + sovDex(uint64(l))
	}
	if m.Asset_1Metadata != nil {
		l = m.Asset_1Metadata.Size()
		n += 2 + l + sovDex(uint64(l))
	}
	if m.Asset_2Metadata != nil {
		l = m.Asset_2Metadata.Size()
		n += 2 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SwapView_Opaque) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Swap != nil {
		l = m.Swap.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.BatchSwapOutputData != nil {
		l = m.BatchSwapOutputData.Size()
		n += 2 + l + sovDex(uint64(l))
	}
	if m.Output_1Value != nil {
		l = m.Output_1Value.Size()
		n += 2 + l + sovDex(uint64(l))
	}
	if m.Output_2Value != nil {
		l = m.Output_2Value.Size()
		n += 2 + l + sovDex(uint64(l))
	}
	if m.Asset_1Metadata != nil {
		l = m.Asset_1Metadata.Size()
		n += 2 + l + sovDex(uint64(l))
	}
	if m.Asset_2Metadata != nil {
		l = m.Asset_2Metadata.Size()
		n += 2 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SwapClaimView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SwapClaimView != nil {
		n += m.SwapClaimView.Size()
	}
	return n
}

func (m *SwapClaimView_Visible_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Visible != nil {
		l = m.Visible.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}
func (m *SwapClaimView_Opaque_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Opaque != nil {
		l = m.Opaque.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}
func (m *SwapClaimView_Visible) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SwapClaim != nil {
		l = m.SwapClaim.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Output_1 != nil {
		l = m.Output_1.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Output_2 != nil {
		l = m.Output_2.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.SwapTx != nil {
		l = m.SwapTx.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SwapClaimView_Opaque) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SwapClaim != nil {
		l = m.SwapClaim.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *TradingPair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Asset_1 != nil {
		l = m.Asset_1.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Asset_2 != nil {
		l = m.Asset_2.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *DirectedTradingPair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != nil {
		l = m.Start.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.End != nil {
		l = m.End.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *BatchSwapOutputData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Delta_1 != nil {
		l = m.Delta_1.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Delta_2 != nil {
		l = m.Delta_2.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Lambda_1 != nil {
		l = m.Lambda_1.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Lambda_2 != nil {
		l = m.Lambda_2.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Unfilled_1 != nil {
		l = m.Unfilled_1.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Unfilled_2 != nil {
		l = m.Unfilled_2.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovDex(uint64(m.Height))
	}
	if m.TradingPair != nil {
		l = m.TradingPair.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.EpochStartingHeight != 0 {
		n += 1 + sovDex(uint64(m.EpochStartingHeight))
	}
	if m.SctPositionPrefix != 0 {
		n += 1 + sovDex(uint64(m.SctPositionPrefix))
	}
	return n
}

func (m *TradingFunction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Component != nil {
		l = m.Component.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Pair != nil {
		l = m.Pair.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *BareTradingFunction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Fee != 0 {
		n += 1 + sovDex(uint64(m.Fee))
	}
	if m.P != nil {
		l = m.P.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Q != nil {
		l = m.Q.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *Reserves) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.R1 != nil {
		l = m.R1.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.R2 != nil {
		l = m.R2.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *Position) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Phi != nil {
		l = m.Phi.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovDex(uint64(l))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Reserves != nil {
		l = m.Reserves.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.CloseOnFill {
		n += 2
	}
	return n
}

func (m *PositionId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Inner)
	if l > 0 {
		n += 1 + l + sovDex(uint64(l))
	}
	l = len(m.AltBech32M)
	if l > 0 {
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *PositionState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovDex(uint64(m.State))
	}
	if m.Sequence != 0 {
		n += 1 + sovDex(uint64(m.Sequence))
	}
	return n
}

func (m *LpNft) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionId != nil {
		l = m.PositionId.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *PositionOpen) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Position != nil {
		l = m.Position.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *PositionClose) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionId != nil {
		l = m.PositionId.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *PositionWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionId != nil {
		l = m.PositionId.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.ReservesCommitment != nil {
		l = m.ReservesCommitment.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Sequence != 0 {
		n += 1 + sovDex(uint64(m.Sequence))
	}
	return n
}

func (m *PositionRewardClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionId != nil {
		l = m.PositionId.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.RewardsCommitment != nil {
		l = m.RewardsCommitment.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SwapExecution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Traces) > 0 {
		for _, e := range m.Traces {
			l = e.Size()
			n += 1 + l + sovDex(uint64(l))
		}
	}
	if m.Input != nil {
		l = m.Input.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Output != nil {
		l = m.Output.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SwapExecution_Trace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Value) > 0 {
		for _, e := range m.Value {
			l = e.Size()
			n += 1 + l + sovDex(uint64(l))
		}
	}
	return n
}

func (m *PositionWithdrawPlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Reserves != nil {
		l = m.Reserves.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.PositionId != nil {
		l = m.PositionId.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Pair != nil {
		l = m.Pair.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Sequence != 0 {
		n += 1 + sovDex(uint64(m.Sequence))
	}
	if len(m.Rewards) > 0 {
		for _, e := range m.Rewards {
			l = e.Size()
			n += 1 + l + sovDex(uint64(l))
		}
	}
	return n
}

func (m *PositionRewardClaimPlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Reserves != nil {
		l = m.Reserves.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *BatchSwapOutputDataRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovDex(uint64(m.Height))
	}
	if m.TradingPair != nil {
		l = m.TradingPair.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *BatchSwapOutputDataResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SwapExecutionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovDex(uint64(m.Height))
	}
	if m.TradingPair != nil {
		l = m.TradingPair.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SwapExecutionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SwapExecution != nil {
		l = m.SwapExecution.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *ArbExecutionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovDex(uint64(m.Height))
	}
	return n
}

func (m *ArbExecutionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SwapExecution != nil {
		l = m.SwapExecution.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovDex(uint64(m.Height))
	}
	return n
}

func (m *SwapExecutionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartHeight != 0 {
		n += 1 + sovDex(uint64(m.StartHeight))
	}
	if m.EndHeight != 0 {
		n += 1 + sovDex(uint64(m.EndHeight))
	}
	if m.TradingPair != nil {
		l = m.TradingPair.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SwapExecutionsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SwapExecution != nil {
		l = m.SwapExecution.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovDex(uint64(m.Height))
	}
	if m.TradingPair != nil {
		l = m.TradingPair.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *ArbExecutionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartHeight != 0 {
		n += 1 + sovDex(uint64(m.StartHeight))
	}
	if m.EndHeight != 0 {
		n += 1 + sovDex(uint64(m.EndHeight))
	}
	return n
}

func (m *ArbExecutionsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SwapExecution != nil {
		l = m.SwapExecution.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovDex(uint64(m.Height))
	}
	return n
}

func (m *LiquidityPositionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IncludeClosed {
		n += 2
	}
	return n
}

func (m *LiquidityPositionsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *LiquidityPositionByIdRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionId != nil {
		l = m.PositionId.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *LiquidityPositionByIdResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *LiquidityPositionsByIdRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PositionId) > 0 {
		for _, e := range m.PositionId {
			l = e.Size()
			n += 1 + l + sovDex(uint64(l))
		}
	}
	return n
}

func (m *LiquidityPositionsByIdResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *LiquidityPositionsByPriceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TradingPair != nil {
		l = m.TradingPair.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovDex(uint64(m.Limit))
	}
	return n
}

func (m *LiquidityPositionsByPriceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SpreadRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TradingPair != nil {
		l = m.TradingPair.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SpreadResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Best_1To_2Position != nil {
		l = m.Best_1To_2Position.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Best_2To_1Position != nil {
		l = m.Best_2To_1Position.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.ApproxEffectivePrice_1To_2 != 0 {
		n += 9
	}
	if m.ApproxEffectivePrice_2To_1 != 0 {
		n += 9
	}
	return n
}

func (m *SimulateTradeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Input != nil {
		l = m.Input.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Output != nil {
		l = m.Output.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Routing != nil {
		l = m.Routing.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SimulateTradeRequest_Routing) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Setting != nil {
		n += m.Setting.Size()
	}
	return n
}

func (m *SimulateTradeRequest_Routing_Default_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Default != nil {
		l = m.Default.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}
func (m *SimulateTradeRequest_Routing_SingleHop_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SingleHop != nil {
		l = m.SingleHop.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}
func (m *SimulateTradeRequest_Routing_SingleHop) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SimulateTradeRequest_Routing_Default) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SimulateTradeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Output != nil {
		l = m.Output.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Unfilled != nil {
		l = m.Unfilled.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *EventSwap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TradingPair != nil {
		l = m.TradingPair.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Delta_1I != nil {
		l = m.Delta_1I.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Delta_2I != nil {
		l = m.Delta_2I.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.SwapCommitment != nil {
		l = m.SwapCommitment.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *EventSwapClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TradingPair != nil {
		l = m.TradingPair.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Output_1Commitment != nil {
		l = m.Output_1Commitment.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Output_2Commitment != nil {
		l = m.Output_2Commitment.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Nullifier != nil {
		l = m.Nullifier.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *EventPositionOpen) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionId != nil {
		l = m.PositionId.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.TradingPair != nil {
		l = m.TradingPair.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Reserves_1 != nil {
		l = m.Reserves_1.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Reserves_2 != nil {
		l = m.Reserves_2.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.TradingFee != 0 {
		n += 1 + sovDex(uint64(m.TradingFee))
	}
	return n
}

func (m *EventPositionClose) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionId != nil {
		l = m.PositionId.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *EventQueuePositionClose) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionId != nil {
		l = m.PositionId.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *EventPositionWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionId != nil {
		l = m.PositionId.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.TradingPair != nil {
		l = m.TradingPair.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Reserves_1 != nil {
		l = m.Reserves_1.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Reserves_2 != nil {
		l = m.Reserves_2.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Sequence != 0 {
		n += 1 + sovDex(uint64(m.Sequence))
	}
	return n
}

func (m *EventPositionExecution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionId != nil {
		l = m.PositionId.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.TradingPair != nil {
		l = m.TradingPair.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Reserves_1 != nil {
		l = m.Reserves_1.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Reserves_2 != nil {
		l = m.Reserves_2.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.PrevReserves_1 != nil {
		l = m.PrevReserves_1.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.PrevReserves_2 != nil {
		l = m.PrevReserves_2.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *EventBatchSwap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchSwapOutputData != nil {
		l = m.BatchSwapOutputData.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.SwapExecution_1For_2 != nil {
		l = m.SwapExecution_1For_2.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.SwapExecution_2For_1 != nil {
		l = m.SwapExecution_2For_1.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *EventArbExecution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovDex(uint64(m.Height))
	}
	if m.SwapExecution != nil {
		l = m.SwapExecution.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *EventValueCircuitBreakerCredit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AssetId != nil {
		l = m.AssetId.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.PreviousBalance != nil {
		l = m.PreviousBalance.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.NewBalance != nil {
		l = m.NewBalance.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *EventValueCircuitBreakerDebit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AssetId != nil {
		l = m.AssetId.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.PreviousBalance != nil {
		l = m.PreviousBalance.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.NewBalance != nil {
		l = m.NewBalance.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *DexParameters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsEnabled {
		n += 2
	}
	if len(m.FixedCandidates) > 0 {
		for _, e := range m.FixedCandidates {
			l = e.Size()
			n += 1 + l + sovDex(uint64(l))
		}
	}
	if m.MaxHops != 0 {
		n += 1 + sovDex(uint64(m.MaxHops))
	}
	if m.MaxPositionsPerPair != 0 {
		n += 1 + sovDex(uint64(m.MaxPositionsPerPair))
	}
	if m.MaxExecutionBudget != 0 {
		n += 1 + sovDex(uint64(m.MaxExecutionBudget))
	}
	return n
}

func (m *GenesisContent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DexParams != nil {
		l = m.DexParams.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *CandlestickData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovDex(uint64(m.Height))
	}
	if m.Open != 0 {
		n += 9
	}
	if m.Close != 0 {
		n += 9
	}
	if m.High != 0 {
		n += 9
	}
	if m.Low != 0 {
		n += 9
	}
	if m.DirectVolume != 0 {
		n += 9
	}
	if m.SwapVolume != 0 {
		n += 9
	}
	return n
}

func (m *CandlestickDataRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pair != nil {
		l = m.Pair.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovDex(uint64(m.Limit))
	}
	if m.StartHeight != 0 {
		n += 1 + sovDex(uint64(m.StartHeight))
	}
	return n
}

func (m *CandlestickDataResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovDex(uint64(l))
		}
	}
	return n
}

func (m *CandlestickDataStreamRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pair != nil {
		l = m.Pair.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *CandlestickDataStreamResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func sovDex(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDex(x uint64) (n int) {
	return sovDex(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ZKSwapProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZKSwapProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZKSwapProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inner = append(m.Inner[:0], dAtA[iNdEx:postIndex]...)
			if m.Inner == nil {
				m.Inner = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZKSwapClaimProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZKSwapClaimProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZKSwapClaimProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inner = append(m.Inner[:0], dAtA[iNdEx:postIndex]...)
			if m.Inner == nil {
				m.Inner = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Swap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Swap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Swap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proof == nil {
				m.Proof = &ZKSwapProof{}
			}
			if err := m.Proof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Body == nil {
				m.Body = &SwapBody{}
			}
			if err := m.Body.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapClaim) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapClaim: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapClaim: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proof == nil {
				m.Proof = &ZKSwapClaimProof{}
			}
			if err := m.Proof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Body == nil {
				m.Body = &SwapClaimBody{}
			}
			if err := m.Body.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochDuration", wireType)
			}
			m.EpochDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochDuration |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapClaimBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapClaimBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapClaimBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nullifier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Nullifier == nil {
				m.Nullifier = &v1.Nullifier{}
			}
			if err := m.Nullifier.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fee == nil {
				m.Fee = &v11.Fee{}
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output_1Commitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output_1Commitment == nil {
				m.Output_1Commitment = &v12.StateCommitment{}
			}
			if err := m.Output_1Commitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output_2Commitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output_2Commitment == nil {
				m.Output_2Commitment = &v12.StateCommitment{}
			}
			if err := m.Output_2Commitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutputData == nil {
				m.OutputData = &BatchSwapOutputData{}
			}
			if err := m.OutputData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradingPair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TradingPair == nil {
				m.TradingPair = &TradingPair{}
			}
			if err := m.TradingPair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delta_1I", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Delta_1I == nil {
				m.Delta_1I = &v13.Amount{}
			}
			if err := m.Delta_1I.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delta_2I", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Delta_2I == nil {
				m.Delta_2I = &v13.Amount{}
			}
			if err := m.Delta_2I.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeCommitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FeeCommitment == nil {
				m.FeeCommitment = &v14.BalanceCommitment{}
			}
			if err := m.FeeCommitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &SwapPayload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapPayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commitment == nil {
				m.Commitment = &v12.StateCommitment{}
			}
			if err := m.Commitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedSwap", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedSwap = append(m.EncryptedSwap[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedSwap == nil {
				m.EncryptedSwap = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapPlaintext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapPlaintext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapPlaintext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradingPair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TradingPair == nil {
				m.TradingPair = &TradingPair{}
			}
			if err := m.TradingPair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delta_1I", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Delta_1I == nil {
				m.Delta_1I = &v13.Amount{}
			}
			if err := m.Delta_1I.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delta_2I", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Delta_2I == nil {
				m.Delta_2I = &v13.Amount{}
			}
			if err := m.Delta_2I.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimFee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClaimFee == nil {
				m.ClaimFee = &v11.Fee{}
			}
			if err := m.ClaimFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClaimAddress == nil {
				m.ClaimAddress = &v15.Address{}
			}
			if err := m.ClaimAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rseed", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rseed = append(m.Rseed[:0], dAtA[iNdEx:postIndex]...)
			if m.Rseed == nil {
				m.Rseed = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapPlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapPlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapPlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapPlaintext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SwapPlaintext == nil {
				m.SwapPlaintext = &SwapPlaintext{}
			}
			if err := m.SwapPlaintext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeBlinding", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeBlinding = append(m.FeeBlinding[:0], dAtA[iNdEx:postIndex]...)
			if m.FeeBlinding == nil {
				m.FeeBlinding = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofBlindingR", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofBlindingR = append(m.ProofBlindingR[:0], dAtA[iNdEx:postIndex]...)
			if m.ProofBlindingR == nil {
				m.ProofBlindingR = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofBlindingS", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofBlindingS = append(m.ProofBlindingS[:0], dAtA[iNdEx:postIndex]...)
			if m.ProofBlindingS == nil {
				m.ProofBlindingS = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapClaimPlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapClaimPlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapClaimPlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapPlaintext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SwapPlaintext == nil {
				m.SwapPlaintext = &SwapPlaintext{}
			}
			if err := m.SwapPlaintext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			m.Position = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Position |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutputData == nil {
				m.OutputData = &BatchSwapOutputData{}
			}
			if err := m.OutputData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochDuration", wireType)
			}
			m.EpochDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochDuration |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofBlindingR", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofBlindingR = append(m.ProofBlindingR[:0], dAtA[iNdEx:postIndex]...)
			if m.ProofBlindingR == nil {
				m.ProofBlindingR = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofBlindingS", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofBlindingS = append(m.ProofBlindingS[:0], dAtA[iNdEx:postIndex]...)
			if m.ProofBlindingS == nil {
				m.ProofBlindingS = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visible", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SwapView_Visible{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SwapView = &SwapView_Visible_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opaque", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SwapView_Opaque{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SwapView = &SwapView_Opaque_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapView_Visible) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Visible: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Visible: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Swap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Swap == nil {
				m.Swap = &Swap{}
			}
			if err := m.Swap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapPlaintext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SwapPlaintext == nil {
				m.SwapPlaintext = &SwapPlaintext{}
			}
			if err := m.SwapPlaintext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClaimTx == nil {
				m.ClaimTx = &v16.TransactionId{}
			}
			if err := m.ClaimTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchSwapOutputData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchSwapOutputData == nil {
				m.BatchSwapOutputData = &BatchSwapOutputData{}
			}
			if err := m.BatchSwapOutputData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output_1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output_1 == nil {
				m.Output_1 = &v17.NoteView{}
			}
			if err := m.Output_1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output_2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output_2 == nil {
				m.Output_2 = &v17.NoteView{}
			}
			if err := m.Output_2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset_1Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Asset_1Metadata == nil {
				m.Asset_1Metadata = &v14.Metadata{}
			}
			if err := m.Asset_1Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset_2Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Asset_2Metadata == nil {
				m.Asset_2Metadata = &v14.Metadata{}
			}
			if err := m.Asset_2Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapView_Opaque) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Opaque: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Opaque: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Swap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Swap == nil {
				m.Swap = &Swap{}
			}
			if err := m.Swap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchSwapOutputData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchSwapOutputData == nil {
				m.BatchSwapOutputData = &BatchSwapOutputData{}
			}
			if err := m.BatchSwapOutputData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output_1Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output_1Value == nil {
				m.Output_1Value = &v14.ValueView{}
			}
			if err := m.Output_1Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output_2Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output_2Value == nil {
				m.Output_2Value = &v14.ValueView{}
			}
			if err := m.Output_2Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset_1Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Asset_1Metadata == nil {
				m.Asset_1Metadata = &v14.Metadata{}
			}
			if err := m.Asset_1Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset_2Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Asset_2Metadata == nil {
				m.Asset_2Metadata = &v14.Metadata{}
			}
			if err := m.Asset_2Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapClaimView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapClaimView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapClaimView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visible", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SwapClaimView_Visible{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SwapClaimView = &SwapClaimView_Visible_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opaque", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SwapClaimView_Opaque{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SwapClaimView = &SwapClaimView_Opaque_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapClaimView_Visible) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Visible: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Visible: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SwapClaim == nil {
				m.SwapClaim = &SwapClaim{}
			}
			if err := m.SwapClaim.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output_1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output_1 == nil {
				m.Output_1 = &v17.NoteView{}
			}
			if err := m.Output_1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output_2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output_2 == nil {
				m.Output_2 = &v17.NoteView{}
			}
			if err := m.Output_2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SwapTx == nil {
				m.SwapTx = &v16.TransactionId{}
			}
			if err := m.SwapTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapClaimView_Opaque) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Opaque: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Opaque: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SwapClaim == nil {
				m.SwapClaim = &SwapClaim{}
			}
			if err := m.SwapClaim.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TradingPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TradingPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TradingPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset_1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Asset_1 == nil {
				m.Asset_1 = &v14.AssetId{}
			}
			if err := m.Asset_1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset_2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Asset_2 == nil {
				m.Asset_2 = &v14.AssetId{}
			}
			if err := m.Asset_2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DirectedTradingPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DirectedTradingPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DirectedTradingPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Start == nil {
				m.Start = &v14.AssetId{}
			}
			if err := m.Start.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.End == nil {
				m.End = &v14.AssetId{}
			}
			if err := m.End.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchSwapOutputData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchSwapOutputData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchSwapOutputData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delta_1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Delta_1 == nil {
				m.Delta_1 = &v13.Amount{}
			}
			if err := m.Delta_1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delta_2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Delta_2 == nil {
				m.Delta_2 = &v13.Amount{}
			}
			if err := m.Delta_2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lambda_1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lambda_1 == nil {
				m.Lambda_1 = &v13.Amount{}
			}
			if err := m.Lambda_1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lambda_2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lambda_2 == nil {
				m.Lambda_2 = &v13.Amount{}
			}
			if err := m.Lambda_2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unfilled_1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Unfilled_1 == nil {
				m.Unfilled_1 = &v13.Amount{}
			}
			if err := m.Unfilled_1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unfilled_2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Unfilled_2 == nil {
				m.Unfilled_2 = &v13.Amount{}
			}
			if err := m.Unfilled_2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradingPair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TradingPair == nil {
				m.TradingPair = &TradingPair{}
			}
			if err := m.TradingPair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochStartingHeight", wireType)
			}
			m.EpochStartingHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochStartingHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SctPositionPrefix", wireType)
			}
			m.SctPositionPrefix = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SctPositionPrefix |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TradingFunction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TradingFunction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TradingFunction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Component", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Component == nil {
				m.Component = &BareTradingFunction{}
			}
			if err := m.Component.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pair == nil {
				m.Pair = &TradingPair{}
			}
			if err := m.Pair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BareTradingFunction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BareTradingFunction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BareTradingFunction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			m.Fee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fee |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field P", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.P == nil {
				m.P = &v13.Amount{}
			}
			if err := m.P.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Q", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Q == nil {
				m.Q = &v13.Amount{}
			}
			if err := m.Q.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Reserves) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reserves: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reserves: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field R1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.R1 == nil {
				m.R1 = &v13.Amount{}
			}
			if err := m.R1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field R2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.R2 == nil {
				m.R2 = &v13.Amount{}
			}
			if err := m.R2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Position) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Position: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Position: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Phi == nil {
				m.Phi = &TradingFunction{}
			}
			if err := m.Phi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = append(m.Nonce[:0], dAtA[iNdEx:postIndex]...)
			if m.Nonce == nil {
				m.Nonce = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &PositionState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserves", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Reserves == nil {
				m.Reserves = &Reserves{}
			}
			if err := m.Reserves.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseOnFill", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CloseOnFill = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PositionId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PositionId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PositionId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inner = append(m.Inner[:0], dAtA[iNdEx:postIndex]...)
			if m.Inner == nil {
				m.Inner = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AltBech32M", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AltBech32M = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PositionState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PositionState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PositionState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= PositionState_PositionStateEnum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LpNft) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LpNft: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LpNft: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PositionId == nil {
				m.PositionId = &PositionId{}
			}
			if err := m.PositionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &PositionState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PositionOpen) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PositionOpen: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PositionOpen: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Position == nil {
				m.Position = &Position{}
			}
			if err := m.Position.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PositionClose) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PositionClose: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PositionClose: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PositionId == nil {
				m.PositionId = &PositionId{}
			}
			if err := m.PositionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PositionWithdraw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PositionWithdraw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PositionWithdraw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PositionId == nil {
				m.PositionId = &PositionId{}
			}
			if err := m.PositionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReservesCommitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReservesCommitment == nil {
				m.ReservesCommitment = &v14.BalanceCommitment{}
			}
			if err := m.ReservesCommitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PositionRewardClaim) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PositionRewardClaim: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PositionRewardClaim: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PositionId == nil {
				m.PositionId = &PositionId{}
			}
			if err := m.PositionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardsCommitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RewardsCommitment == nil {
				m.RewardsCommitment = &v14.BalanceCommitment{}
			}
			if err := m.RewardsCommitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapExecution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapExecution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapExecution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Traces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Traces = append(m.Traces, &SwapExecution_Trace{})
			if err := m.Traces[len(m.Traces)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Input == nil {
				m.Input = &v14.Value{}
			}
			if err := m.Input.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output == nil {
				m.Output = &v14.Value{}
			}
			if err := m.Output.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapExecution_Trace) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Trace: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Trace: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value, &v14.Value{})
			if err := m.Value[len(m.Value)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PositionWithdrawPlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PositionWithdrawPlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PositionWithdrawPlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserves", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Reserves == nil {
				m.Reserves = &Reserves{}
			}
			if err := m.Reserves.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PositionId == nil {
				m.PositionId = &PositionId{}
			}
			if err := m.PositionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pair == nil {
				m.Pair = &TradingPair{}
			}
			if err := m.Pair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rewards = append(m.Rewards, &v14.Value{})
			if err := m.Rewards[len(m.Rewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PositionRewardClaimPlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PositionRewardClaimPlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PositionRewardClaimPlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserves", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Reserves == nil {
				m.Reserves = &Reserves{}
			}
			if err := m.Reserves.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchSwapOutputDataRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchSwapOutputDataRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchSwapOutputDataRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradingPair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TradingPair == nil {
				m.TradingPair = &TradingPair{}
			}
			if err := m.TradingPair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchSwapOutputDataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchSwapOutputDataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchSwapOutputDataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &BatchSwapOutputData{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapExecutionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapExecutionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapExecutionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradingPair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TradingPair == nil {
				m.TradingPair = &DirectedTradingPair{}
			}
			if err := m.TradingPair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapExecutionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapExecutionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapExecutionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapExecution", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SwapExecution == nil {
				m.SwapExecution = &SwapExecution{}
			}
			if err := m.SwapExecution.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArbExecutionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArbExecutionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArbExecutionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArbExecutionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArbExecutionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArbExecutionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapExecution", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SwapExecution == nil {
				m.SwapExecution = &SwapExecution{}
			}
			if err := m.SwapExecution.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapExecutionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapExecutionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapExecutionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartHeight", wireType)
			}
			m.StartHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndHeight", wireType)
			}
			m.EndHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradingPair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TradingPair == nil {
				m.TradingPair = &DirectedTradingPair{}
			}
			if err := m.TradingPair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapExecutionsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapExecutionsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapExecutionsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapExecution", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SwapExecution == nil {
				m.SwapExecution = &SwapExecution{}
			}
			if err := m.SwapExecution.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradingPair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TradingPair == nil {
				m.TradingPair = &DirectedTradingPair{}
			}
			if err := m.TradingPair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArbExecutionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArbExecutionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArbExecutionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartHeight", wireType)
			}
			m.StartHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndHeight", wireType)
			}
			m.EndHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArbExecutionsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArbExecutionsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArbExecutionsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapExecution", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SwapExecution == nil {
				m.SwapExecution = &SwapExecution{}
			}
			if err := m.SwapExecution.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LiquidityPositionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LiquidityPositionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LiquidityPositionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeClosed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeClosed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LiquidityPositionsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LiquidityPositionsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LiquidityPositionsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &Position{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LiquidityPositionByIdRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LiquidityPositionByIdRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LiquidityPositionByIdRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PositionId == nil {
				m.PositionId = &PositionId{}
			}
			if err := m.PositionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LiquidityPositionByIdResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LiquidityPositionByIdResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LiquidityPositionByIdResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &Position{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LiquidityPositionsByIdRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LiquidityPositionsByIdRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LiquidityPositionsByIdRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PositionId = append(m.PositionId, &PositionId{})
			if err := m.PositionId[len(m.PositionId)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LiquidityPositionsByIdResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LiquidityPositionsByIdResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LiquidityPositionsByIdResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &Position{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LiquidityPositionsByPriceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LiquidityPositionsByPriceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LiquidityPositionsByPriceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradingPair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TradingPair == nil {
				m.TradingPair = &DirectedTradingPair{}
			}
			if err := m.TradingPair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LiquidityPositionsByPriceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LiquidityPositionsByPriceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LiquidityPositionsByPriceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &Position{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &PositionId{}
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpreadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpreadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpreadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradingPair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TradingPair == nil {
				m.TradingPair = &TradingPair{}
			}
			if err := m.TradingPair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpreadResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpreadResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpreadResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Best_1To_2Position", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Best_1To_2Position == nil {
				m.Best_1To_2Position = &Position{}
			}
			if err := m.Best_1To_2Position.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Best_2To_1Position", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Best_2To_1Position == nil {
				m.Best_2To_1Position = &Position{}
			}
			if err := m.Best_2To_1Position.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApproxEffectivePrice_1To_2", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ApproxEffectivePrice_1To_2 = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApproxEffectivePrice_2To_1", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ApproxEffectivePrice_2To_1 = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimulateTradeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimulateTradeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimulateTradeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Input == nil {
				m.Input = &v14.Value{}
			}
			if err := m.Input.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output == nil {
				m.Output = &v14.AssetId{}
			}
			if err := m.Output.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Routing == nil {
				m.Routing = &SimulateTradeRequest_Routing{}
			}
			if err := m.Routing.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimulateTradeRequest_Routing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Routing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Routing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Default", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SimulateTradeRequest_Routing_Default{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Setting = &SimulateTradeRequest_Routing_Default_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SingleHop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SimulateTradeRequest_Routing_SingleHop{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Setting = &SimulateTradeRequest_Routing_SingleHop_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimulateTradeRequest_Routing_SingleHop) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SingleHop: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SingleHop: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimulateTradeRequest_Routing_Default) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Default: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Default: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimulateTradeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimulateTradeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimulateTradeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output == nil {
				m.Output = &SwapExecution{}
			}
			if err := m.Output.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unfilled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Unfilled == nil {
				m.Unfilled = &v14.Value{}
			}
			if err := m.Unfilled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSwap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSwap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSwap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradingPair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TradingPair == nil {
				m.TradingPair = &TradingPair{}
			}
			if err := m.TradingPair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delta_1I", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Delta_1I == nil {
				m.Delta_1I = &v13.Amount{}
			}
			if err := m.Delta_1I.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delta_2I", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Delta_2I == nil {
				m.Delta_2I = &v13.Amount{}
			}
			if err := m.Delta_2I.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapCommitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SwapCommitment == nil {
				m.SwapCommitment = &v12.StateCommitment{}
			}
			if err := m.SwapCommitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSwapClaim) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSwapClaim: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSwapClaim: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradingPair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TradingPair == nil {
				m.TradingPair = &TradingPair{}
			}
			if err := m.TradingPair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output_1Commitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output_1Commitment == nil {
				m.Output_1Commitment = &v12.StateCommitment{}
			}
			if err := m.Output_1Commitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output_2Commitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output_2Commitment == nil {
				m.Output_2Commitment = &v12.StateCommitment{}
			}
			if err := m.Output_2Commitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nullifier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Nullifier == nil {
				m.Nullifier = &v1.Nullifier{}
			}
			if err := m.Nullifier.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventPositionOpen) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventPositionOpen: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventPositionOpen: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PositionId == nil {
				m.PositionId = &PositionId{}
			}
			if err := m.PositionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradingPair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TradingPair == nil {
				m.TradingPair = &TradingPair{}
			}
			if err := m.TradingPair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserves_1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Reserves_1 == nil {
				m.Reserves_1 = &v13.Amount{}
			}
			if err := m.Reserves_1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserves_2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Reserves_2 == nil {
				m.Reserves_2 = &v13.Amount{}
			}
			if err := m.Reserves_2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradingFee", wireType)
			}
			m.TradingFee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TradingFee |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventPositionClose) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventPositionClose: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventPositionClose: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PositionId == nil {
				m.PositionId = &PositionId{}
			}
			if err := m.PositionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventQueuePositionClose) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventQueuePositionClose: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventQueuePositionClose: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PositionId == nil {
				m.PositionId = &PositionId{}
			}
			if err := m.PositionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventPositionWithdraw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventPositionWithdraw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventPositionWithdraw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PositionId == nil {
				m.PositionId = &PositionId{}
			}
			if err := m.PositionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradingPair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TradingPair == nil {
				m.TradingPair = &TradingPair{}
			}
			if err := m.TradingPair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserves_1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Reserves_1 == nil {
				m.Reserves_1 = &v13.Amount{}
			}
			if err := m.Reserves_1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserves_2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Reserves_2 == nil {
				m.Reserves_2 = &v13.Amount{}
			}
			if err := m.Reserves_2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventPositionExecution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventPositionExecution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventPositionExecution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PositionId == nil {
				m.PositionId = &PositionId{}
			}
			if err := m.PositionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradingPair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TradingPair == nil {
				m.TradingPair = &TradingPair{}
			}
			if err := m.TradingPair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserves_1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Reserves_1 == nil {
				m.Reserves_1 = &v13.Amount{}
			}
			if err := m.Reserves_1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserves_2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Reserves_2 == nil {
				m.Reserves_2 = &v13.Amount{}
			}
			if err := m.Reserves_2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevReserves_1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrevReserves_1 == nil {
				m.PrevReserves_1 = &v13.Amount{}
			}
			if err := m.PrevReserves_1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevReserves_2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrevReserves_2 == nil {
				m.PrevReserves_2 = &v13.Amount{}
			}
			if err := m.PrevReserves_2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &DirectedTradingPair{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventBatchSwap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventBatchSwap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventBatchSwap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchSwapOutputData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchSwapOutputData == nil {
				m.BatchSwapOutputData = &BatchSwapOutputData{}
			}
			if err := m.BatchSwapOutputData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapExecution_1For_2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SwapExecution_1For_2 == nil {
				m.SwapExecution_1For_2 = &SwapExecution{}
			}
			if err := m.SwapExecution_1For_2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapExecution_2For_1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SwapExecution_2For_1 == nil {
				m.SwapExecution_2For_1 = &SwapExecution{}
			}
			if err := m.SwapExecution_2For_1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventArbExecution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventArbExecution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventArbExecution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapExecution", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SwapExecution == nil {
				m.SwapExecution = &SwapExecution{}
			}
			if err := m.SwapExecution.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventValueCircuitBreakerCredit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventValueCircuitBreakerCredit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventValueCircuitBreakerCredit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AssetId == nil {
				m.AssetId = &v14.AssetId{}
			}
			if err := m.AssetId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousBalance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PreviousBalance == nil {
				m.PreviousBalance = &v13.Amount{}
			}
			if err := m.PreviousBalance.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewBalance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewBalance == nil {
				m.NewBalance = &v13.Amount{}
			}
			if err := m.NewBalance.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventValueCircuitBreakerDebit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventValueCircuitBreakerDebit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventValueCircuitBreakerDebit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AssetId == nil {
				m.AssetId = &v14.AssetId{}
			}
			if err := m.AssetId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousBalance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PreviousBalance == nil {
				m.PreviousBalance = &v13.Amount{}
			}
			if err := m.PreviousBalance.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewBalance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewBalance == nil {
				m.NewBalance = &v13.Amount{}
			}
			if err := m.NewBalance.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DexParameters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DexParameters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DexParameters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsEnabled = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FixedCandidates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FixedCandidates = append(m.FixedCandidates, &v14.AssetId{})
			if err := m.FixedCandidates[len(m.FixedCandidates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxHops", wireType)
			}
			m.MaxHops = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxHops |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPositionsPerPair", wireType)
			}
			m.MaxPositionsPerPair = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxPositionsPerPair |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxExecutionBudget", wireType)
			}
			m.MaxExecutionBudget = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxExecutionBudget |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenesisContent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenesisContent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenesisContent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DexParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DexParams == nil {
				m.DexParams = &DexParameters{}
			}
			if err := m.DexParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CandlestickData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CandlestickData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CandlestickData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Open", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Open = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Close", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Close = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field High", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.High = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Low", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Low = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectVolume", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.DirectVolume = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapVolume", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.SwapVolume = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CandlestickDataRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CandlestickDataRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CandlestickDataRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pair == nil {
				m.Pair = &DirectedTradingPair{}
			}
			if err := m.Pair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartHeight", wireType)
			}
			m.StartHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CandlestickDataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CandlestickDataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CandlestickDataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &CandlestickData{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CandlestickDataStreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CandlestickDataStreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CandlestickDataStreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pair == nil {
				m.Pair = &DirectedTradingPair{}
			}
			if err := m.Pair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CandlestickDataStreamResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CandlestickDataStreamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CandlestickDataStreamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &CandlestickData{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDex(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDex
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDex
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDex
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDex
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDex
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDex
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDex        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDex          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDex = fmt.Errorf("proto: unexpected end of group")
)
