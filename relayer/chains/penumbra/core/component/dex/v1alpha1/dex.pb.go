// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: penumbra/core/component/dex/v1alpha1/dex.proto

package dexv1alpha1

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	v1alpha14 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/asset/v1alpha1"
	v1alpha11 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/component/fee/v1alpha1"
	v1alpha1 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/component/sct/v1alpha1"
	v1alpha16 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/component/shielded_pool/v1alpha1"
	v1alpha15 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/keys/v1alpha1"
	v1alpha13 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/num/v1alpha1"
	v1alpha12 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/crypto/tct/v1alpha1"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type PositionState_PositionStateEnum int32

const (
	PositionState_POSITION_STATE_ENUM_UNSPECIFIED PositionState_PositionStateEnum = 0
	// The position has been opened, is active, has reserves and accumulated
	// fees, and can be traded against.
	PositionState_POSITION_STATE_ENUM_OPENED PositionState_PositionStateEnum = 1
	// The position has been closed, is inactive and can no longer be traded
	// against, but still has reserves and accumulated fees.
	PositionState_POSITION_STATE_ENUM_CLOSED PositionState_PositionStateEnum = 2
	// The final reserves and accumulated fees have been withdrawn, leaving an
	// empty, inactive position awaiting (possible) retroactive rewards.
	PositionState_POSITION_STATE_ENUM_WITHDRAWN PositionState_PositionStateEnum = 3
	// Any retroactive rewards have been claimed. The position is now an inert,
	// historical artefact.
	PositionState_POSITION_STATE_ENUM_CLAIMED PositionState_PositionStateEnum = 4
)

var PositionState_PositionStateEnum_name = map[int32]string{
	0: "POSITION_STATE_ENUM_UNSPECIFIED",
	1: "POSITION_STATE_ENUM_OPENED",
	2: "POSITION_STATE_ENUM_CLOSED",
	3: "POSITION_STATE_ENUM_WITHDRAWN",
	4: "POSITION_STATE_ENUM_CLAIMED",
}

var PositionState_PositionStateEnum_value = map[string]int32{
	"POSITION_STATE_ENUM_UNSPECIFIED": 0,
	"POSITION_STATE_ENUM_OPENED":      1,
	"POSITION_STATE_ENUM_CLOSED":      2,
	"POSITION_STATE_ENUM_WITHDRAWN":   3,
	"POSITION_STATE_ENUM_CLAIMED":     4,
}

func (x PositionState_PositionStateEnum) String() string {
	return proto.EnumName(PositionState_PositionStateEnum_name, int32(x))
}

func (PositionState_PositionStateEnum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{20, 0}
}

// A Penumbra ZK swap proof.
type ZKSwapProof struct {
	Inner []byte `protobuf:"bytes,1,opt,name=inner,proto3" json:"inner,omitempty"`
}

func (m *ZKSwapProof) Reset()         { *m = ZKSwapProof{} }
func (m *ZKSwapProof) String() string { return proto.CompactTextString(m) }
func (*ZKSwapProof) ProtoMessage()    {}
func (*ZKSwapProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{0}
}
func (m *ZKSwapProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZKSwapProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZKSwapProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZKSwapProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZKSwapProof.Merge(m, src)
}
func (m *ZKSwapProof) XXX_Size() int {
	return m.Size()
}
func (m *ZKSwapProof) XXX_DiscardUnknown() {
	xxx_messageInfo_ZKSwapProof.DiscardUnknown(m)
}

var xxx_messageInfo_ZKSwapProof proto.InternalMessageInfo

func (m *ZKSwapProof) GetInner() []byte {
	if m != nil {
		return m.Inner
	}
	return nil
}

// A Penumbra ZK swap claim proof.
type ZKSwapClaimProof struct {
	Inner []byte `protobuf:"bytes,1,opt,name=inner,proto3" json:"inner,omitempty"`
}

func (m *ZKSwapClaimProof) Reset()         { *m = ZKSwapClaimProof{} }
func (m *ZKSwapClaimProof) String() string { return proto.CompactTextString(m) }
func (*ZKSwapClaimProof) ProtoMessage()    {}
func (*ZKSwapClaimProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{1}
}
func (m *ZKSwapClaimProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZKSwapClaimProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZKSwapClaimProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZKSwapClaimProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZKSwapClaimProof.Merge(m, src)
}
func (m *ZKSwapClaimProof) XXX_Size() int {
	return m.Size()
}
func (m *ZKSwapClaimProof) XXX_DiscardUnknown() {
	xxx_messageInfo_ZKSwapClaimProof.DiscardUnknown(m)
}

var xxx_messageInfo_ZKSwapClaimProof proto.InternalMessageInfo

func (m *ZKSwapClaimProof) GetInner() []byte {
	if m != nil {
		return m.Inner
	}
	return nil
}

// A transaction action that submits a swap to the dex.
type Swap struct {
	// Contains the Swap proof.
	Proof *ZKSwapProof `protobuf:"bytes,1,opt,name=proof,proto3" json:"proof,omitempty"`
	// Encapsulates the authorized fields of the Swap action, used in signing.
	Body *SwapBody `protobuf:"bytes,4,opt,name=body,proto3" json:"body,omitempty"`
}

func (m *Swap) Reset()         { *m = Swap{} }
func (m *Swap) String() string { return proto.CompactTextString(m) }
func (*Swap) ProtoMessage()    {}
func (*Swap) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{2}
}
func (m *Swap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Swap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Swap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Swap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Swap.Merge(m, src)
}
func (m *Swap) XXX_Size() int {
	return m.Size()
}
func (m *Swap) XXX_DiscardUnknown() {
	xxx_messageInfo_Swap.DiscardUnknown(m)
}

var xxx_messageInfo_Swap proto.InternalMessageInfo

func (m *Swap) GetProof() *ZKSwapProof {
	if m != nil {
		return m.Proof
	}
	return nil
}

func (m *Swap) GetBody() *SwapBody {
	if m != nil {
		return m.Body
	}
	return nil
}

// A transaction action that obtains assets previously confirmed
// via a Swap transaction. Does not include a spend authorization
// signature, as it is only capable of consuming the NFT from a
// Swap transaction.
type SwapClaim struct {
	// Contains the SwapClaim proof.
	Proof *ZKSwapClaimProof `protobuf:"bytes,1,opt,name=proof,proto3" json:"proof,omitempty"`
	// Encapsulates the authorized fields of the SwapClaim action, used in signing.
	Body *SwapClaimBody `protobuf:"bytes,2,opt,name=body,proto3" json:"body,omitempty"`
	// The epoch duration of the chain when the swap claim took place.
	EpochDuration uint64 `protobuf:"varint,7,opt,name=epoch_duration,json=epochDuration,proto3" json:"epoch_duration,omitempty"`
}

func (m *SwapClaim) Reset()         { *m = SwapClaim{} }
func (m *SwapClaim) String() string { return proto.CompactTextString(m) }
func (*SwapClaim) ProtoMessage()    {}
func (*SwapClaim) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{3}
}
func (m *SwapClaim) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapClaim) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapClaim.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapClaim) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapClaim.Merge(m, src)
}
func (m *SwapClaim) XXX_Size() int {
	return m.Size()
}
func (m *SwapClaim) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapClaim.DiscardUnknown(m)
}

var xxx_messageInfo_SwapClaim proto.InternalMessageInfo

func (m *SwapClaim) GetProof() *ZKSwapClaimProof {
	if m != nil {
		return m.Proof
	}
	return nil
}

func (m *SwapClaim) GetBody() *SwapClaimBody {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *SwapClaim) GetEpochDuration() uint64 {
	if m != nil {
		return m.EpochDuration
	}
	return 0
}

// Encapsulates the authorized fields of the SwapClaim action, used in signing.
type SwapClaimBody struct {
	// The nullifier for the Swap commitment to be consumed.
	Nullifier *v1alpha1.Nullifier `protobuf:"bytes,1,opt,name=nullifier,proto3" json:"nullifier,omitempty"`
	// The fee allows `SwapClaim` without an additional `Spend`.
	Fee *v1alpha11.Fee `protobuf:"bytes,2,opt,name=fee,proto3" json:"fee,omitempty"`
	// Note output for asset 1.
	Output_1Commitment *v1alpha12.StateCommitment `protobuf:"bytes,3,opt,name=output_1_commitment,json=output1Commitment,proto3" json:"output_1_commitment,omitempty"`
	// Note output for asset 2.
	Output_2Commitment *v1alpha12.StateCommitment `protobuf:"bytes,4,opt,name=output_2_commitment,json=output2Commitment,proto3" json:"output_2_commitment,omitempty"`
	// Input and output amounts, and asset IDs for the assets in the swap.
	OutputData *BatchSwapOutputData `protobuf:"bytes,6,opt,name=output_data,json=outputData,proto3" json:"output_data,omitempty"`
}

func (m *SwapClaimBody) Reset()         { *m = SwapClaimBody{} }
func (m *SwapClaimBody) String() string { return proto.CompactTextString(m) }
func (*SwapClaimBody) ProtoMessage()    {}
func (*SwapClaimBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{4}
}
func (m *SwapClaimBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapClaimBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapClaimBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapClaimBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapClaimBody.Merge(m, src)
}
func (m *SwapClaimBody) XXX_Size() int {
	return m.Size()
}
func (m *SwapClaimBody) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapClaimBody.DiscardUnknown(m)
}

var xxx_messageInfo_SwapClaimBody proto.InternalMessageInfo

func (m *SwapClaimBody) GetNullifier() *v1alpha1.Nullifier {
	if m != nil {
		return m.Nullifier
	}
	return nil
}

func (m *SwapClaimBody) GetFee() *v1alpha11.Fee {
	if m != nil {
		return m.Fee
	}
	return nil
}

func (m *SwapClaimBody) GetOutput_1Commitment() *v1alpha12.StateCommitment {
	if m != nil {
		return m.Output_1Commitment
	}
	return nil
}

func (m *SwapClaimBody) GetOutput_2Commitment() *v1alpha12.StateCommitment {
	if m != nil {
		return m.Output_2Commitment
	}
	return nil
}

func (m *SwapClaimBody) GetOutputData() *BatchSwapOutputData {
	if m != nil {
		return m.OutputData
	}
	return nil
}

// The authorized data of a Swap transaction.
type SwapBody struct {
	// The trading pair to swap.
	TradingPair *TradingPair `protobuf:"bytes,1,opt,name=trading_pair,json=tradingPair,proto3" json:"trading_pair,omitempty"`
	// The amount for asset 1.
	Delta_1I *v1alpha13.Amount `protobuf:"bytes,2,opt,name=delta_1_i,json=delta1I,proto3" json:"delta_1_i,omitempty"`
	// The amount for asset 2.
	Delta_2I *v1alpha13.Amount `protobuf:"bytes,3,opt,name=delta_2_i,json=delta2I,proto3" json:"delta_2_i,omitempty"`
	// A commitment to a prepaid fee for the future SwapClaim.
	// This is recorded separately from delta_j_i because it's shielded;
	// in the future we'll want separate commitments to each delta_j_i
	// anyways in order to prove consistency with flow encryption.
	FeeCommitment *v1alpha14.BalanceCommitment `protobuf:"bytes,4,opt,name=fee_commitment,json=feeCommitment,proto3" json:"fee_commitment,omitempty"`
	// The swap commitment and encryption of the swap data.
	Payload *SwapPayload `protobuf:"bytes,5,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *SwapBody) Reset()         { *m = SwapBody{} }
func (m *SwapBody) String() string { return proto.CompactTextString(m) }
func (*SwapBody) ProtoMessage()    {}
func (*SwapBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{5}
}
func (m *SwapBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapBody.Merge(m, src)
}
func (m *SwapBody) XXX_Size() int {
	return m.Size()
}
func (m *SwapBody) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapBody.DiscardUnknown(m)
}

var xxx_messageInfo_SwapBody proto.InternalMessageInfo

func (m *SwapBody) GetTradingPair() *TradingPair {
	if m != nil {
		return m.TradingPair
	}
	return nil
}

func (m *SwapBody) GetDelta_1I() *v1alpha13.Amount {
	if m != nil {
		return m.Delta_1I
	}
	return nil
}

func (m *SwapBody) GetDelta_2I() *v1alpha13.Amount {
	if m != nil {
		return m.Delta_2I
	}
	return nil
}

func (m *SwapBody) GetFeeCommitment() *v1alpha14.BalanceCommitment {
	if m != nil {
		return m.FeeCommitment
	}
	return nil
}

func (m *SwapBody) GetPayload() *SwapPayload {
	if m != nil {
		return m.Payload
	}
	return nil
}

type SwapPayload struct {
	Commitment    *v1alpha12.StateCommitment `protobuf:"bytes,1,opt,name=commitment,proto3" json:"commitment,omitempty"`
	EncryptedSwap []byte                     `protobuf:"bytes,2,opt,name=encrypted_swap,json=encryptedSwap,proto3" json:"encrypted_swap,omitempty"`
}

func (m *SwapPayload) Reset()         { *m = SwapPayload{} }
func (m *SwapPayload) String() string { return proto.CompactTextString(m) }
func (*SwapPayload) ProtoMessage()    {}
func (*SwapPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{6}
}
func (m *SwapPayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapPayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapPayload.Merge(m, src)
}
func (m *SwapPayload) XXX_Size() int {
	return m.Size()
}
func (m *SwapPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapPayload.DiscardUnknown(m)
}

var xxx_messageInfo_SwapPayload proto.InternalMessageInfo

func (m *SwapPayload) GetCommitment() *v1alpha12.StateCommitment {
	if m != nil {
		return m.Commitment
	}
	return nil
}

func (m *SwapPayload) GetEncryptedSwap() []byte {
	if m != nil {
		return m.EncryptedSwap
	}
	return nil
}

type SwapPlaintext struct {
	// The trading pair to swap.
	TradingPair *TradingPair `protobuf:"bytes,1,opt,name=trading_pair,json=tradingPair,proto3" json:"trading_pair,omitempty"`
	// Input amount of asset 1
	Delta_1I *v1alpha13.Amount `protobuf:"bytes,2,opt,name=delta_1_i,json=delta1I,proto3" json:"delta_1_i,omitempty"`
	// Input amount of asset 2
	Delta_2I *v1alpha13.Amount `protobuf:"bytes,3,opt,name=delta_2_i,json=delta2I,proto3" json:"delta_2_i,omitempty"`
	// Pre-paid fee to claim the swap
	ClaimFee *v1alpha11.Fee `protobuf:"bytes,4,opt,name=claim_fee,json=claimFee,proto3" json:"claim_fee,omitempty"`
	// Address that will claim the swap outputs via SwapClaim.
	ClaimAddress *v1alpha15.Address `protobuf:"bytes,5,opt,name=claim_address,json=claimAddress,proto3" json:"claim_address,omitempty"`
	// Swap rseed (blinding factors are derived from this)
	Rseed []byte `protobuf:"bytes,6,opt,name=rseed,proto3" json:"rseed,omitempty"`
}

func (m *SwapPlaintext) Reset()         { *m = SwapPlaintext{} }
func (m *SwapPlaintext) String() string { return proto.CompactTextString(m) }
func (*SwapPlaintext) ProtoMessage()    {}
func (*SwapPlaintext) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{7}
}
func (m *SwapPlaintext) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapPlaintext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapPlaintext.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapPlaintext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapPlaintext.Merge(m, src)
}
func (m *SwapPlaintext) XXX_Size() int {
	return m.Size()
}
func (m *SwapPlaintext) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapPlaintext.DiscardUnknown(m)
}

var xxx_messageInfo_SwapPlaintext proto.InternalMessageInfo

func (m *SwapPlaintext) GetTradingPair() *TradingPair {
	if m != nil {
		return m.TradingPair
	}
	return nil
}

func (m *SwapPlaintext) GetDelta_1I() *v1alpha13.Amount {
	if m != nil {
		return m.Delta_1I
	}
	return nil
}

func (m *SwapPlaintext) GetDelta_2I() *v1alpha13.Amount {
	if m != nil {
		return m.Delta_2I
	}
	return nil
}

func (m *SwapPlaintext) GetClaimFee() *v1alpha11.Fee {
	if m != nil {
		return m.ClaimFee
	}
	return nil
}

func (m *SwapPlaintext) GetClaimAddress() *v1alpha15.Address {
	if m != nil {
		return m.ClaimAddress
	}
	return nil
}

func (m *SwapPlaintext) GetRseed() []byte {
	if m != nil {
		return m.Rseed
	}
	return nil
}

type SwapPlan struct {
	// The plaintext version of the swap to be performed.
	SwapPlaintext *SwapPlaintext `protobuf:"bytes,1,opt,name=swap_plaintext,json=swapPlaintext,proto3" json:"swap_plaintext,omitempty"`
	// The blinding factor for the fee commitment. The fee in the SwapPlan is private to prevent linkability with the SwapClaim.
	FeeBlinding []byte `protobuf:"bytes,2,opt,name=fee_blinding,json=feeBlinding,proto3" json:"fee_blinding,omitempty"`
	// The first blinding factor to use for the ZK swap proof.
	ProofBlindingR []byte `protobuf:"bytes,3,opt,name=proof_blinding_r,json=proofBlindingR,proto3" json:"proof_blinding_r,omitempty"`
	// The second blinding factor to use for the ZK swap proof.
	ProofBlindingS []byte `protobuf:"bytes,4,opt,name=proof_blinding_s,json=proofBlindingS,proto3" json:"proof_blinding_s,omitempty"`
}

func (m *SwapPlan) Reset()         { *m = SwapPlan{} }
func (m *SwapPlan) String() string { return proto.CompactTextString(m) }
func (*SwapPlan) ProtoMessage()    {}
func (*SwapPlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{8}
}
func (m *SwapPlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapPlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapPlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapPlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapPlan.Merge(m, src)
}
func (m *SwapPlan) XXX_Size() int {
	return m.Size()
}
func (m *SwapPlan) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapPlan.DiscardUnknown(m)
}

var xxx_messageInfo_SwapPlan proto.InternalMessageInfo

func (m *SwapPlan) GetSwapPlaintext() *SwapPlaintext {
	if m != nil {
		return m.SwapPlaintext
	}
	return nil
}

func (m *SwapPlan) GetFeeBlinding() []byte {
	if m != nil {
		return m.FeeBlinding
	}
	return nil
}

func (m *SwapPlan) GetProofBlindingR() []byte {
	if m != nil {
		return m.ProofBlindingR
	}
	return nil
}

func (m *SwapPlan) GetProofBlindingS() []byte {
	if m != nil {
		return m.ProofBlindingS
	}
	return nil
}

type SwapClaimPlan struct {
	// The plaintext version of the swap to be performed.
	SwapPlaintext *SwapPlaintext `protobuf:"bytes,1,opt,name=swap_plaintext,json=swapPlaintext,proto3" json:"swap_plaintext,omitempty"`
	// The position of the swap commitment.
	Position uint64 `protobuf:"varint,2,opt,name=position,proto3" json:"position,omitempty"`
	// Input and output amounts for the Swap.
	OutputData *BatchSwapOutputData `protobuf:"bytes,3,opt,name=output_data,json=outputData,proto3" json:"output_data,omitempty"`
	// The epoch duration, used in proving.
	EpochDuration uint64 `protobuf:"varint,4,opt,name=epoch_duration,json=epochDuration,proto3" json:"epoch_duration,omitempty"`
	// The first blinding factor to use for the ZK swap claim proof.
	ProofBlindingR []byte `protobuf:"bytes,5,opt,name=proof_blinding_r,json=proofBlindingR,proto3" json:"proof_blinding_r,omitempty"`
	// The second blinding factor to use for the ZK swap claim proof.
	ProofBlindingS []byte `protobuf:"bytes,6,opt,name=proof_blinding_s,json=proofBlindingS,proto3" json:"proof_blinding_s,omitempty"`
}

func (m *SwapClaimPlan) Reset()         { *m = SwapClaimPlan{} }
func (m *SwapClaimPlan) String() string { return proto.CompactTextString(m) }
func (*SwapClaimPlan) ProtoMessage()    {}
func (*SwapClaimPlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{9}
}
func (m *SwapClaimPlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapClaimPlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapClaimPlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapClaimPlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapClaimPlan.Merge(m, src)
}
func (m *SwapClaimPlan) XXX_Size() int {
	return m.Size()
}
func (m *SwapClaimPlan) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapClaimPlan.DiscardUnknown(m)
}

var xxx_messageInfo_SwapClaimPlan proto.InternalMessageInfo

func (m *SwapClaimPlan) GetSwapPlaintext() *SwapPlaintext {
	if m != nil {
		return m.SwapPlaintext
	}
	return nil
}

func (m *SwapClaimPlan) GetPosition() uint64 {
	if m != nil {
		return m.Position
	}
	return 0
}

func (m *SwapClaimPlan) GetOutputData() *BatchSwapOutputData {
	if m != nil {
		return m.OutputData
	}
	return nil
}

func (m *SwapClaimPlan) GetEpochDuration() uint64 {
	if m != nil {
		return m.EpochDuration
	}
	return 0
}

func (m *SwapClaimPlan) GetProofBlindingR() []byte {
	if m != nil {
		return m.ProofBlindingR
	}
	return nil
}

func (m *SwapClaimPlan) GetProofBlindingS() []byte {
	if m != nil {
		return m.ProofBlindingS
	}
	return nil
}

type SwapView struct {
	// Types that are valid to be assigned to SwapView:
	//
	//	*SwapView_Visible_
	//	*SwapView_Opaque_
	SwapView isSwapView_SwapView `protobuf_oneof:"swap_view"`
}

func (m *SwapView) Reset()         { *m = SwapView{} }
func (m *SwapView) String() string { return proto.CompactTextString(m) }
func (*SwapView) ProtoMessage()    {}
func (*SwapView) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{10}
}
func (m *SwapView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapView.Merge(m, src)
}
func (m *SwapView) XXX_Size() int {
	return m.Size()
}
func (m *SwapView) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapView.DiscardUnknown(m)
}

var xxx_messageInfo_SwapView proto.InternalMessageInfo

type isSwapView_SwapView interface {
	isSwapView_SwapView()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SwapView_Visible_ struct {
	Visible *SwapView_Visible `protobuf:"bytes,1,opt,name=visible,proto3,oneof" json:"visible,omitempty"`
}
type SwapView_Opaque_ struct {
	Opaque *SwapView_Opaque `protobuf:"bytes,2,opt,name=opaque,proto3,oneof" json:"opaque,omitempty"`
}

func (*SwapView_Visible_) isSwapView_SwapView() {}
func (*SwapView_Opaque_) isSwapView_SwapView()  {}

func (m *SwapView) GetSwapView() isSwapView_SwapView {
	if m != nil {
		return m.SwapView
	}
	return nil
}

func (m *SwapView) GetVisible() *SwapView_Visible {
	if x, ok := m.GetSwapView().(*SwapView_Visible_); ok {
		return x.Visible
	}
	return nil
}

func (m *SwapView) GetOpaque() *SwapView_Opaque {
	if x, ok := m.GetSwapView().(*SwapView_Opaque_); ok {
		return x.Opaque
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SwapView) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SwapView_Visible_)(nil),
		(*SwapView_Opaque_)(nil),
	}
}

type SwapView_Visible struct {
	Swap          *Swap          `protobuf:"bytes,1,opt,name=swap,proto3" json:"swap,omitempty"`
	SwapPlaintext *SwapPlaintext `protobuf:"bytes,3,opt,name=swap_plaintext,json=swapPlaintext,proto3" json:"swap_plaintext,omitempty"`
}

func (m *SwapView_Visible) Reset()         { *m = SwapView_Visible{} }
func (m *SwapView_Visible) String() string { return proto.CompactTextString(m) }
func (*SwapView_Visible) ProtoMessage()    {}
func (*SwapView_Visible) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{10, 0}
}
func (m *SwapView_Visible) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapView_Visible) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapView_Visible.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapView_Visible) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapView_Visible.Merge(m, src)
}
func (m *SwapView_Visible) XXX_Size() int {
	return m.Size()
}
func (m *SwapView_Visible) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapView_Visible.DiscardUnknown(m)
}

var xxx_messageInfo_SwapView_Visible proto.InternalMessageInfo

func (m *SwapView_Visible) GetSwap() *Swap {
	if m != nil {
		return m.Swap
	}
	return nil
}

func (m *SwapView_Visible) GetSwapPlaintext() *SwapPlaintext {
	if m != nil {
		return m.SwapPlaintext
	}
	return nil
}

type SwapView_Opaque struct {
	Swap *Swap `protobuf:"bytes,1,opt,name=swap,proto3" json:"swap,omitempty"`
}

func (m *SwapView_Opaque) Reset()         { *m = SwapView_Opaque{} }
func (m *SwapView_Opaque) String() string { return proto.CompactTextString(m) }
func (*SwapView_Opaque) ProtoMessage()    {}
func (*SwapView_Opaque) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{10, 1}
}
func (m *SwapView_Opaque) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapView_Opaque) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapView_Opaque.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapView_Opaque) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapView_Opaque.Merge(m, src)
}
func (m *SwapView_Opaque) XXX_Size() int {
	return m.Size()
}
func (m *SwapView_Opaque) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapView_Opaque.DiscardUnknown(m)
}

var xxx_messageInfo_SwapView_Opaque proto.InternalMessageInfo

func (m *SwapView_Opaque) GetSwap() *Swap {
	if m != nil {
		return m.Swap
	}
	return nil
}

type SwapClaimView struct {
	// Types that are valid to be assigned to SwapClaimView:
	//
	//	*SwapClaimView_Visible_
	//	*SwapClaimView_Opaque_
	SwapClaimView isSwapClaimView_SwapClaimView `protobuf_oneof:"swap_claim_view"`
}

func (m *SwapClaimView) Reset()         { *m = SwapClaimView{} }
func (m *SwapClaimView) String() string { return proto.CompactTextString(m) }
func (*SwapClaimView) ProtoMessage()    {}
func (*SwapClaimView) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{11}
}
func (m *SwapClaimView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapClaimView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapClaimView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapClaimView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapClaimView.Merge(m, src)
}
func (m *SwapClaimView) XXX_Size() int {
	return m.Size()
}
func (m *SwapClaimView) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapClaimView.DiscardUnknown(m)
}

var xxx_messageInfo_SwapClaimView proto.InternalMessageInfo

type isSwapClaimView_SwapClaimView interface {
	isSwapClaimView_SwapClaimView()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SwapClaimView_Visible_ struct {
	Visible *SwapClaimView_Visible `protobuf:"bytes,1,opt,name=visible,proto3,oneof" json:"visible,omitempty"`
}
type SwapClaimView_Opaque_ struct {
	Opaque *SwapClaimView_Opaque `protobuf:"bytes,2,opt,name=opaque,proto3,oneof" json:"opaque,omitempty"`
}

func (*SwapClaimView_Visible_) isSwapClaimView_SwapClaimView() {}
func (*SwapClaimView_Opaque_) isSwapClaimView_SwapClaimView()  {}

func (m *SwapClaimView) GetSwapClaimView() isSwapClaimView_SwapClaimView {
	if m != nil {
		return m.SwapClaimView
	}
	return nil
}

func (m *SwapClaimView) GetVisible() *SwapClaimView_Visible {
	if x, ok := m.GetSwapClaimView().(*SwapClaimView_Visible_); ok {
		return x.Visible
	}
	return nil
}

func (m *SwapClaimView) GetOpaque() *SwapClaimView_Opaque {
	if x, ok := m.GetSwapClaimView().(*SwapClaimView_Opaque_); ok {
		return x.Opaque
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SwapClaimView) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SwapClaimView_Visible_)(nil),
		(*SwapClaimView_Opaque_)(nil),
	}
}

type SwapClaimView_Visible struct {
	SwapClaim *SwapClaim          `protobuf:"bytes,1,opt,name=swap_claim,json=swapClaim,proto3" json:"swap_claim,omitempty"`
	Output_1  *v1alpha16.NoteView `protobuf:"bytes,2,opt,name=output_1,json=output1,proto3" json:"output_1,omitempty"`
	Output_2  *v1alpha16.NoteView `protobuf:"bytes,3,opt,name=output_2,json=output2,proto3" json:"output_2,omitempty"`
}

func (m *SwapClaimView_Visible) Reset()         { *m = SwapClaimView_Visible{} }
func (m *SwapClaimView_Visible) String() string { return proto.CompactTextString(m) }
func (*SwapClaimView_Visible) ProtoMessage()    {}
func (*SwapClaimView_Visible) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{11, 0}
}
func (m *SwapClaimView_Visible) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapClaimView_Visible) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapClaimView_Visible.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapClaimView_Visible) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapClaimView_Visible.Merge(m, src)
}
func (m *SwapClaimView_Visible) XXX_Size() int {
	return m.Size()
}
func (m *SwapClaimView_Visible) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapClaimView_Visible.DiscardUnknown(m)
}

var xxx_messageInfo_SwapClaimView_Visible proto.InternalMessageInfo

func (m *SwapClaimView_Visible) GetSwapClaim() *SwapClaim {
	if m != nil {
		return m.SwapClaim
	}
	return nil
}

func (m *SwapClaimView_Visible) GetOutput_1() *v1alpha16.NoteView {
	if m != nil {
		return m.Output_1
	}
	return nil
}

func (m *SwapClaimView_Visible) GetOutput_2() *v1alpha16.NoteView {
	if m != nil {
		return m.Output_2
	}
	return nil
}

type SwapClaimView_Opaque struct {
	SwapClaim *SwapClaim `protobuf:"bytes,1,opt,name=swap_claim,json=swapClaim,proto3" json:"swap_claim,omitempty"`
}

func (m *SwapClaimView_Opaque) Reset()         { *m = SwapClaimView_Opaque{} }
func (m *SwapClaimView_Opaque) String() string { return proto.CompactTextString(m) }
func (*SwapClaimView_Opaque) ProtoMessage()    {}
func (*SwapClaimView_Opaque) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{11, 1}
}
func (m *SwapClaimView_Opaque) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapClaimView_Opaque) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapClaimView_Opaque.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapClaimView_Opaque) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapClaimView_Opaque.Merge(m, src)
}
func (m *SwapClaimView_Opaque) XXX_Size() int {
	return m.Size()
}
func (m *SwapClaimView_Opaque) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapClaimView_Opaque.DiscardUnknown(m)
}

var xxx_messageInfo_SwapClaimView_Opaque proto.InternalMessageInfo

func (m *SwapClaimView_Opaque) GetSwapClaim() *SwapClaim {
	if m != nil {
		return m.SwapClaim
	}
	return nil
}

// Holds two asset IDs. Ordering doesn't reflect trading direction. Instead, we
// require `asset_1 < asset_2` as field elements, to ensure a canonical
// representation of an unordered pair.
type TradingPair struct {
	// The first asset of the pair.
	Asset_1 *v1alpha14.AssetId `protobuf:"bytes,1,opt,name=asset_1,json=asset1,proto3" json:"asset_1,omitempty"`
	// The second asset of the pair.
	Asset_2 *v1alpha14.AssetId `protobuf:"bytes,2,opt,name=asset_2,json=asset2,proto3" json:"asset_2,omitempty"`
}

func (m *TradingPair) Reset()         { *m = TradingPair{} }
func (m *TradingPair) String() string { return proto.CompactTextString(m) }
func (*TradingPair) ProtoMessage()    {}
func (*TradingPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{12}
}
func (m *TradingPair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TradingPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TradingPair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TradingPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TradingPair.Merge(m, src)
}
func (m *TradingPair) XXX_Size() int {
	return m.Size()
}
func (m *TradingPair) XXX_DiscardUnknown() {
	xxx_messageInfo_TradingPair.DiscardUnknown(m)
}

var xxx_messageInfo_TradingPair proto.InternalMessageInfo

func (m *TradingPair) GetAsset_1() *v1alpha14.AssetId {
	if m != nil {
		return m.Asset_1
	}
	return nil
}

func (m *TradingPair) GetAsset_2() *v1alpha14.AssetId {
	if m != nil {
		return m.Asset_2
	}
	return nil
}

// Encodes a trading pair starting from asset `start`
// and ending on asset `end`.
type DirectedTradingPair struct {
	// The start asset of the pair.
	Start *v1alpha14.AssetId `protobuf:"bytes,1,opt,name=start,proto3" json:"start,omitempty"`
	// The end asset of the pair.
	End *v1alpha14.AssetId `protobuf:"bytes,2,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *DirectedTradingPair) Reset()         { *m = DirectedTradingPair{} }
func (m *DirectedTradingPair) String() string { return proto.CompactTextString(m) }
func (*DirectedTradingPair) ProtoMessage()    {}
func (*DirectedTradingPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{13}
}
func (m *DirectedTradingPair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DirectedTradingPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DirectedTradingPair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DirectedTradingPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DirectedTradingPair.Merge(m, src)
}
func (m *DirectedTradingPair) XXX_Size() int {
	return m.Size()
}
func (m *DirectedTradingPair) XXX_DiscardUnknown() {
	xxx_messageInfo_DirectedTradingPair.DiscardUnknown(m)
}

var xxx_messageInfo_DirectedTradingPair proto.InternalMessageInfo

func (m *DirectedTradingPair) GetStart() *v1alpha14.AssetId {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *DirectedTradingPair) GetEnd() *v1alpha14.AssetId {
	if m != nil {
		return m.End
	}
	return nil
}

// Records the result of a batch swap on-chain.
//
// Used as a public input to a swap claim proof, as it implies the effective
// clearing price for the batch.
type BatchSwapOutputData struct {
	// The total amount of asset 1 that was input to the batch swap.
	Delta_1 *v1alpha13.Amount `protobuf:"bytes,1,opt,name=delta_1,json=delta1,proto3" json:"delta_1,omitempty"`
	// The total amount of asset 2 that was input to the batch swap.
	Delta_2 *v1alpha13.Amount `protobuf:"bytes,2,opt,name=delta_2,json=delta2,proto3" json:"delta_2,omitempty"`
	// The total amount of asset 1 that was output from the batch swap for 2=>1 trades.
	Lambda_1 *v1alpha13.Amount `protobuf:"bytes,3,opt,name=lambda_1,json=lambda1,proto3" json:"lambda_1,omitempty"`
	// The total amount of asset 2 that was output from the batch swap for 1=>2 trades.
	Lambda_2 *v1alpha13.Amount `protobuf:"bytes,4,opt,name=lambda_2,json=lambda2,proto3" json:"lambda_2,omitempty"`
	// The total amount of asset 1 that was returned unfilled from the batch swap for 1=>2 trades.
	Unfilled_1 *v1alpha13.Amount `protobuf:"bytes,5,opt,name=unfilled_1,json=unfilled1,proto3" json:"unfilled_1,omitempty"`
	// The total amount of asset 2 that was returned unfilled from the batch swap for 2=>1 trades.
	Unfilled_2 *v1alpha13.Amount `protobuf:"bytes,6,opt,name=unfilled_2,json=unfilled2,proto3" json:"unfilled_2,omitempty"`
	// The height for which the batch swap data is valid.
	Height uint64 `protobuf:"varint,7,opt,name=height,proto3" json:"height,omitempty"`
	// The trading pair associated with the batch swap.
	TradingPair *TradingPair `protobuf:"bytes,8,opt,name=trading_pair,json=tradingPair,proto3" json:"trading_pair,omitempty"`
	// The starting block height of the epoch for which the batch swap data is valid.
	EpochStartingHeight uint64 `protobuf:"varint,9,opt,name=epoch_starting_height,json=epochStartingHeight,proto3" json:"epoch_starting_height,omitempty"`
}

func (m *BatchSwapOutputData) Reset()         { *m = BatchSwapOutputData{} }
func (m *BatchSwapOutputData) String() string { return proto.CompactTextString(m) }
func (*BatchSwapOutputData) ProtoMessage()    {}
func (*BatchSwapOutputData) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{14}
}
func (m *BatchSwapOutputData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchSwapOutputData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchSwapOutputData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchSwapOutputData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchSwapOutputData.Merge(m, src)
}
func (m *BatchSwapOutputData) XXX_Size() int {
	return m.Size()
}
func (m *BatchSwapOutputData) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchSwapOutputData.DiscardUnknown(m)
}

var xxx_messageInfo_BatchSwapOutputData proto.InternalMessageInfo

func (m *BatchSwapOutputData) GetDelta_1() *v1alpha13.Amount {
	if m != nil {
		return m.Delta_1
	}
	return nil
}

func (m *BatchSwapOutputData) GetDelta_2() *v1alpha13.Amount {
	if m != nil {
		return m.Delta_2
	}
	return nil
}

func (m *BatchSwapOutputData) GetLambda_1() *v1alpha13.Amount {
	if m != nil {
		return m.Lambda_1
	}
	return nil
}

func (m *BatchSwapOutputData) GetLambda_2() *v1alpha13.Amount {
	if m != nil {
		return m.Lambda_2
	}
	return nil
}

func (m *BatchSwapOutputData) GetUnfilled_1() *v1alpha13.Amount {
	if m != nil {
		return m.Unfilled_1
	}
	return nil
}

func (m *BatchSwapOutputData) GetUnfilled_2() *v1alpha13.Amount {
	if m != nil {
		return m.Unfilled_2
	}
	return nil
}

func (m *BatchSwapOutputData) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *BatchSwapOutputData) GetTradingPair() *TradingPair {
	if m != nil {
		return m.TradingPair
	}
	return nil
}

func (m *BatchSwapOutputData) GetEpochStartingHeight() uint64 {
	if m != nil {
		return m.EpochStartingHeight
	}
	return 0
}

// The trading function for a specific pair.
// For a pair (asset_1, asset_2), a trading function is defined by:
// `phi(R) = p*R_1 + q*R_2` and `gamma = 1 - fee`.
// The trading function is frequently referred to as "phi".
type TradingFunction struct {
	Component *BareTradingFunction `protobuf:"bytes,1,opt,name=component,proto3" json:"component,omitempty"`
	Pair      *TradingPair         `protobuf:"bytes,2,opt,name=pair,proto3" json:"pair,omitempty"`
}

func (m *TradingFunction) Reset()         { *m = TradingFunction{} }
func (m *TradingFunction) String() string { return proto.CompactTextString(m) }
func (*TradingFunction) ProtoMessage()    {}
func (*TradingFunction) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{15}
}
func (m *TradingFunction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TradingFunction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TradingFunction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TradingFunction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TradingFunction.Merge(m, src)
}
func (m *TradingFunction) XXX_Size() int {
	return m.Size()
}
func (m *TradingFunction) XXX_DiscardUnknown() {
	xxx_messageInfo_TradingFunction.DiscardUnknown(m)
}

var xxx_messageInfo_TradingFunction proto.InternalMessageInfo

func (m *TradingFunction) GetComponent() *BareTradingFunction {
	if m != nil {
		return m.Component
	}
	return nil
}

func (m *TradingFunction) GetPair() *TradingPair {
	if m != nil {
		return m.Pair
	}
	return nil
}

// The minimum amount of data describing a trading function.
//
// This implicitly treats the trading function as being between assets 1 and 2,
// without specifying what those assets are, to avoid duplicating data (each
// asset ID alone is twice the size of the trading function).
type BareTradingFunction struct {
	Fee uint32 `protobuf:"varint,1,opt,name=fee,proto3" json:"fee,omitempty"`
	// This is not actually an amount, it's an integer the same width as an amount
	P *v1alpha13.Amount `protobuf:"bytes,2,opt,name=p,proto3" json:"p,omitempty"`
	// This is not actually an amount, it's an integer the same width as an amount
	Q *v1alpha13.Amount `protobuf:"bytes,3,opt,name=q,proto3" json:"q,omitempty"`
}

func (m *BareTradingFunction) Reset()         { *m = BareTradingFunction{} }
func (m *BareTradingFunction) String() string { return proto.CompactTextString(m) }
func (*BareTradingFunction) ProtoMessage()    {}
func (*BareTradingFunction) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{16}
}
func (m *BareTradingFunction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BareTradingFunction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BareTradingFunction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BareTradingFunction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BareTradingFunction.Merge(m, src)
}
func (m *BareTradingFunction) XXX_Size() int {
	return m.Size()
}
func (m *BareTradingFunction) XXX_DiscardUnknown() {
	xxx_messageInfo_BareTradingFunction.DiscardUnknown(m)
}

var xxx_messageInfo_BareTradingFunction proto.InternalMessageInfo

func (m *BareTradingFunction) GetFee() uint32 {
	if m != nil {
		return m.Fee
	}
	return 0
}

func (m *BareTradingFunction) GetP() *v1alpha13.Amount {
	if m != nil {
		return m.P
	}
	return nil
}

func (m *BareTradingFunction) GetQ() *v1alpha13.Amount {
	if m != nil {
		return m.Q
	}
	return nil
}

// The reserves of a position.
//
// Like a position, this implicitly treats the trading function as being
// between assets 1 and 2, without specifying what those assets are, to avoid
// duplicating data (each asset ID alone is four times the size of the
// reserves).
type Reserves struct {
	R1 *v1alpha13.Amount `protobuf:"bytes,1,opt,name=r1,proto3" json:"r1,omitempty"`
	R2 *v1alpha13.Amount `protobuf:"bytes,2,opt,name=r2,proto3" json:"r2,omitempty"`
}

func (m *Reserves) Reset()         { *m = Reserves{} }
func (m *Reserves) String() string { return proto.CompactTextString(m) }
func (*Reserves) ProtoMessage()    {}
func (*Reserves) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{17}
}
func (m *Reserves) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Reserves) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Reserves.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Reserves) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Reserves.Merge(m, src)
}
func (m *Reserves) XXX_Size() int {
	return m.Size()
}
func (m *Reserves) XXX_DiscardUnknown() {
	xxx_messageInfo_Reserves.DiscardUnknown(m)
}

var xxx_messageInfo_Reserves proto.InternalMessageInfo

func (m *Reserves) GetR1() *v1alpha13.Amount {
	if m != nil {
		return m.R1
	}
	return nil
}

func (m *Reserves) GetR2() *v1alpha13.Amount {
	if m != nil {
		return m.R2
	}
	return nil
}

// Data identifying a position.
type Position struct {
	Phi *TradingFunction `protobuf:"bytes,1,opt,name=phi,proto3" json:"phi,omitempty"`
	// A random value used to disambiguate different positions with the exact same
	// trading function.  The chain should reject newly created positions with the
	// same nonce as an existing position.  This ensures that `PositionId`s will
	// be unique, and allows us to track position ownership with a
	// sequence of stateful NFTs based on the `PositionId`.
	Nonce    []byte         `protobuf:"bytes,2,opt,name=nonce,proto3" json:"nonce,omitempty"`
	State    *PositionState `protobuf:"bytes,3,opt,name=state,proto3" json:"state,omitempty"`
	Reserves *Reserves      `protobuf:"bytes,4,opt,name=reserves,proto3" json:"reserves,omitempty"`
	// / If set to true, the position is a limit-order and will be closed
	// / immediately after being filled.
	CloseOnFill bool `protobuf:"varint,5,opt,name=close_on_fill,json=closeOnFill,proto3" json:"close_on_fill,omitempty"`
}

func (m *Position) Reset()         { *m = Position{} }
func (m *Position) String() string { return proto.CompactTextString(m) }
func (*Position) ProtoMessage()    {}
func (*Position) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{18}
}
func (m *Position) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Position) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Position.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Position) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Position.Merge(m, src)
}
func (m *Position) XXX_Size() int {
	return m.Size()
}
func (m *Position) XXX_DiscardUnknown() {
	xxx_messageInfo_Position.DiscardUnknown(m)
}

var xxx_messageInfo_Position proto.InternalMessageInfo

func (m *Position) GetPhi() *TradingFunction {
	if m != nil {
		return m.Phi
	}
	return nil
}

func (m *Position) GetNonce() []byte {
	if m != nil {
		return m.Nonce
	}
	return nil
}

func (m *Position) GetState() *PositionState {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *Position) GetReserves() *Reserves {
	if m != nil {
		return m.Reserves
	}
	return nil
}

func (m *Position) GetCloseOnFill() bool {
	if m != nil {
		return m.CloseOnFill
	}
	return false
}

// A hash of a `Position`.
type PositionId struct {
	// The bytes of the position ID.
	Inner []byte `protobuf:"bytes,1,opt,name=inner,proto3" json:"inner,omitempty"`
	// Alternatively, a Bech32m-encoded string representation of the `inner`
	// bytes.
	//
	// NOTE: implementations are not required to support parsing this field.
	// Implementations should prefer to encode the bytes in all messages they
	// produce. Implementations must not accept messages with both `inner` and
	// `alt_bech32m` set.
	AltBech32M string `protobuf:"bytes,2,opt,name=alt_bech32m,json=altBech32m,proto3" json:"alt_bech32m,omitempty"`
}

func (m *PositionId) Reset()         { *m = PositionId{} }
func (m *PositionId) String() string { return proto.CompactTextString(m) }
func (*PositionId) ProtoMessage()    {}
func (*PositionId) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{19}
}
func (m *PositionId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PositionId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PositionId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PositionId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PositionId.Merge(m, src)
}
func (m *PositionId) XXX_Size() int {
	return m.Size()
}
func (m *PositionId) XXX_DiscardUnknown() {
	xxx_messageInfo_PositionId.DiscardUnknown(m)
}

var xxx_messageInfo_PositionId proto.InternalMessageInfo

func (m *PositionId) GetInner() []byte {
	if m != nil {
		return m.Inner
	}
	return nil
}

func (m *PositionId) GetAltBech32M() string {
	if m != nil {
		return m.AltBech32M
	}
	return ""
}

// The state of a position.
type PositionState struct {
	State PositionState_PositionStateEnum `protobuf:"varint,1,opt,name=state,proto3,enum=penumbra.core.component.dex.v1alpha1.PositionState_PositionStateEnum" json:"state,omitempty"`
}

func (m *PositionState) Reset()         { *m = PositionState{} }
func (m *PositionState) String() string { return proto.CompactTextString(m) }
func (*PositionState) ProtoMessage()    {}
func (*PositionState) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{20}
}
func (m *PositionState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PositionState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PositionState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PositionState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PositionState.Merge(m, src)
}
func (m *PositionState) XXX_Size() int {
	return m.Size()
}
func (m *PositionState) XXX_DiscardUnknown() {
	xxx_messageInfo_PositionState.DiscardUnknown(m)
}

var xxx_messageInfo_PositionState proto.InternalMessageInfo

func (m *PositionState) GetState() PositionState_PositionStateEnum {
	if m != nil {
		return m.State
	}
	return PositionState_POSITION_STATE_ENUM_UNSPECIFIED
}

// An LPNFT tracking both ownership and state of a position.
//
// Tracking the state as part of the LPNFT means that all LP-related actions can
// be authorized by spending funds: a state transition (e.g., closing a
// position) is modeled as spending an "open position LPNFT" and minting a
// "closed position LPNFT" for the same (globally unique) position ID.
//
// This means that the LP mechanics can be agnostic to the mechanism used to
// record custody and spend authorization.  For instance, they can be recorded
// in the shielded pool, where custody is based on off-chain keys, or they could
// be recorded in a programmatic on-chain account (in the future, e.g., to
// support interchain accounts).  This also means that LP-related actions don't
// require any cryptographic implementation (proofs, signatures, etc), other
// than hooking into the value commitment mechanism used for transaction
// balances.
type LpNft struct {
	PositionId *PositionId    `protobuf:"bytes,1,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
	State      *PositionState `protobuf:"bytes,2,opt,name=state,proto3" json:"state,omitempty"`
}

func (m *LpNft) Reset()         { *m = LpNft{} }
func (m *LpNft) String() string { return proto.CompactTextString(m) }
func (*LpNft) ProtoMessage()    {}
func (*LpNft) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{21}
}
func (m *LpNft) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LpNft) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LpNft.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LpNft) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LpNft.Merge(m, src)
}
func (m *LpNft) XXX_Size() int {
	return m.Size()
}
func (m *LpNft) XXX_DiscardUnknown() {
	xxx_messageInfo_LpNft.DiscardUnknown(m)
}

var xxx_messageInfo_LpNft proto.InternalMessageInfo

func (m *LpNft) GetPositionId() *PositionId {
	if m != nil {
		return m.PositionId
	}
	return nil
}

func (m *LpNft) GetState() *PositionState {
	if m != nil {
		return m.State
	}
	return nil
}

// A transaction action that opens a new position.
//
// This action's contribution to the transaction's value balance is to consume
// the initial reserves and contribute an opened position NFT.
type PositionOpen struct {
	// Contains the data defining the position, sufficient to compute its `PositionId`.
	//
	// Positions are immutable, so the `PositionData` (and hence the `PositionId`)
	// are unchanged over the entire lifetime of the position.
	Position *Position `protobuf:"bytes,1,opt,name=position,proto3" json:"position,omitempty"`
}

func (m *PositionOpen) Reset()         { *m = PositionOpen{} }
func (m *PositionOpen) String() string { return proto.CompactTextString(m) }
func (*PositionOpen) ProtoMessage()    {}
func (*PositionOpen) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{22}
}
func (m *PositionOpen) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PositionOpen) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PositionOpen.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PositionOpen) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PositionOpen.Merge(m, src)
}
func (m *PositionOpen) XXX_Size() int {
	return m.Size()
}
func (m *PositionOpen) XXX_DiscardUnknown() {
	xxx_messageInfo_PositionOpen.DiscardUnknown(m)
}

var xxx_messageInfo_PositionOpen proto.InternalMessageInfo

func (m *PositionOpen) GetPosition() *Position {
	if m != nil {
		return m.Position
	}
	return nil
}

// A transaction action that closes a position.
//
// This action's contribution to the transaction's value balance is to consume
// an opened position NFT and contribute a closed position NFT.
//
// Closing a position does not immediately withdraw funds, because Penumbra
// transactions (like any ZK transaction model) are early-binding: the prover
// must know the state transition they prove knowledge of, and they cannot know
// the final reserves with certainty until after the position has been deactivated.
type PositionClose struct {
	PositionId *PositionId `protobuf:"bytes,1,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
}

func (m *PositionClose) Reset()         { *m = PositionClose{} }
func (m *PositionClose) String() string { return proto.CompactTextString(m) }
func (*PositionClose) ProtoMessage()    {}
func (*PositionClose) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{23}
}
func (m *PositionClose) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PositionClose) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PositionClose.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PositionClose) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PositionClose.Merge(m, src)
}
func (m *PositionClose) XXX_Size() int {
	return m.Size()
}
func (m *PositionClose) XXX_DiscardUnknown() {
	xxx_messageInfo_PositionClose.DiscardUnknown(m)
}

var xxx_messageInfo_PositionClose proto.InternalMessageInfo

func (m *PositionClose) GetPositionId() *PositionId {
	if m != nil {
		return m.PositionId
	}
	return nil
}

// A transaction action that withdraws funds from a closed position.
//
// This action's contribution to the transaction's value balance is to consume a
// closed position NFT and contribute a withdrawn position NFT, as well as all
// of the funds that were in the position at the time of closing.
type PositionWithdraw struct {
	PositionId *PositionId `protobuf:"bytes,1,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
	// A transparent (zero blinding factor) commitment to the position's final reserves and fees.
	//
	// The chain will check this commitment by recomputing it with the on-chain state.
	ReservesCommitment *v1alpha14.BalanceCommitment `protobuf:"bytes,2,opt,name=reserves_commitment,json=reservesCommitment,proto3" json:"reserves_commitment,omitempty"`
}

func (m *PositionWithdraw) Reset()         { *m = PositionWithdraw{} }
func (m *PositionWithdraw) String() string { return proto.CompactTextString(m) }
func (*PositionWithdraw) ProtoMessage()    {}
func (*PositionWithdraw) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{24}
}
func (m *PositionWithdraw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PositionWithdraw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PositionWithdraw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PositionWithdraw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PositionWithdraw.Merge(m, src)
}
func (m *PositionWithdraw) XXX_Size() int {
	return m.Size()
}
func (m *PositionWithdraw) XXX_DiscardUnknown() {
	xxx_messageInfo_PositionWithdraw.DiscardUnknown(m)
}

var xxx_messageInfo_PositionWithdraw proto.InternalMessageInfo

func (m *PositionWithdraw) GetPositionId() *PositionId {
	if m != nil {
		return m.PositionId
	}
	return nil
}

func (m *PositionWithdraw) GetReservesCommitment() *v1alpha14.BalanceCommitment {
	if m != nil {
		return m.ReservesCommitment
	}
	return nil
}

// A transaction action that claims retroactive rewards for a historical
// position.
//
// This action's contribution to the transaction's value balance is to consume a
// withdrawn position NFT and contribute its reward balance.
type PositionRewardClaim struct {
	PositionId *PositionId `protobuf:"bytes,1,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
	// A transparent (zero blinding factor) commitment to the position's accumulated rewards.
	//
	// The chain will check this commitment by recomputing it with the on-chain state.
	RewardsCommitment *v1alpha14.BalanceCommitment `protobuf:"bytes,2,opt,name=rewards_commitment,json=rewardsCommitment,proto3" json:"rewards_commitment,omitempty"`
}

func (m *PositionRewardClaim) Reset()         { *m = PositionRewardClaim{} }
func (m *PositionRewardClaim) String() string { return proto.CompactTextString(m) }
func (*PositionRewardClaim) ProtoMessage()    {}
func (*PositionRewardClaim) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{25}
}
func (m *PositionRewardClaim) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PositionRewardClaim) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PositionRewardClaim.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PositionRewardClaim) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PositionRewardClaim.Merge(m, src)
}
func (m *PositionRewardClaim) XXX_Size() int {
	return m.Size()
}
func (m *PositionRewardClaim) XXX_DiscardUnknown() {
	xxx_messageInfo_PositionRewardClaim.DiscardUnknown(m)
}

var xxx_messageInfo_PositionRewardClaim proto.InternalMessageInfo

func (m *PositionRewardClaim) GetPositionId() *PositionId {
	if m != nil {
		return m.PositionId
	}
	return nil
}

func (m *PositionRewardClaim) GetRewardsCommitment() *v1alpha14.BalanceCommitment {
	if m != nil {
		return m.RewardsCommitment
	}
	return nil
}

// Contains the entire execution of a particular swap.
type SwapExecution struct {
	Traces []*SwapExecution_Trace `protobuf:"bytes,1,rep,name=traces,proto3" json:"traces,omitempty"`
	// The total input amount for this execution.
	Input *v1alpha14.Value `protobuf:"bytes,2,opt,name=input,proto3" json:"input,omitempty"`
	// The total output amount for this execution.
	Output *v1alpha14.Value `protobuf:"bytes,3,opt,name=output,proto3" json:"output,omitempty"`
}

func (m *SwapExecution) Reset()         { *m = SwapExecution{} }
func (m *SwapExecution) String() string { return proto.CompactTextString(m) }
func (*SwapExecution) ProtoMessage()    {}
func (*SwapExecution) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{26}
}
func (m *SwapExecution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapExecution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapExecution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapExecution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapExecution.Merge(m, src)
}
func (m *SwapExecution) XXX_Size() int {
	return m.Size()
}
func (m *SwapExecution) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapExecution.DiscardUnknown(m)
}

var xxx_messageInfo_SwapExecution proto.InternalMessageInfo

func (m *SwapExecution) GetTraces() []*SwapExecution_Trace {
	if m != nil {
		return m.Traces
	}
	return nil
}

func (m *SwapExecution) GetInput() *v1alpha14.Value {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *SwapExecution) GetOutput() *v1alpha14.Value {
	if m != nil {
		return m.Output
	}
	return nil
}

// Contains all individual steps consisting of a trade trace.
type SwapExecution_Trace struct {
	// Each step in the trade trace.
	Value []*v1alpha14.Value `protobuf:"bytes,1,rep,name=value,proto3" json:"value,omitempty"`
}

func (m *SwapExecution_Trace) Reset()         { *m = SwapExecution_Trace{} }
func (m *SwapExecution_Trace) String() string { return proto.CompactTextString(m) }
func (*SwapExecution_Trace) ProtoMessage()    {}
func (*SwapExecution_Trace) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{26, 0}
}
func (m *SwapExecution_Trace) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapExecution_Trace) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapExecution_Trace.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapExecution_Trace) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapExecution_Trace.Merge(m, src)
}
func (m *SwapExecution_Trace) XXX_Size() int {
	return m.Size()
}
func (m *SwapExecution_Trace) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapExecution_Trace.DiscardUnknown(m)
}

var xxx_messageInfo_SwapExecution_Trace proto.InternalMessageInfo

func (m *SwapExecution_Trace) GetValue() []*v1alpha14.Value {
	if m != nil {
		return m.Value
	}
	return nil
}

// Contains private and public data for withdrawing funds from a closed position.
type PositionWithdrawPlan struct {
	Reserves   *Reserves    `protobuf:"bytes,1,opt,name=reserves,proto3" json:"reserves,omitempty"`
	PositionId *PositionId  `protobuf:"bytes,2,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
	Pair       *TradingPair `protobuf:"bytes,3,opt,name=pair,proto3" json:"pair,omitempty"`
}

func (m *PositionWithdrawPlan) Reset()         { *m = PositionWithdrawPlan{} }
func (m *PositionWithdrawPlan) String() string { return proto.CompactTextString(m) }
func (*PositionWithdrawPlan) ProtoMessage()    {}
func (*PositionWithdrawPlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{27}
}
func (m *PositionWithdrawPlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PositionWithdrawPlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PositionWithdrawPlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PositionWithdrawPlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PositionWithdrawPlan.Merge(m, src)
}
func (m *PositionWithdrawPlan) XXX_Size() int {
	return m.Size()
}
func (m *PositionWithdrawPlan) XXX_DiscardUnknown() {
	xxx_messageInfo_PositionWithdrawPlan.DiscardUnknown(m)
}

var xxx_messageInfo_PositionWithdrawPlan proto.InternalMessageInfo

func (m *PositionWithdrawPlan) GetReserves() *Reserves {
	if m != nil {
		return m.Reserves
	}
	return nil
}

func (m *PositionWithdrawPlan) GetPositionId() *PositionId {
	if m != nil {
		return m.PositionId
	}
	return nil
}

func (m *PositionWithdrawPlan) GetPair() *TradingPair {
	if m != nil {
		return m.Pair
	}
	return nil
}

// Contains private and public data for claiming rewards from a position.
type PositionRewardClaimPlan struct {
	Reserves *Reserves `protobuf:"bytes,1,opt,name=reserves,proto3" json:"reserves,omitempty"`
}

func (m *PositionRewardClaimPlan) Reset()         { *m = PositionRewardClaimPlan{} }
func (m *PositionRewardClaimPlan) String() string { return proto.CompactTextString(m) }
func (*PositionRewardClaimPlan) ProtoMessage()    {}
func (*PositionRewardClaimPlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{28}
}
func (m *PositionRewardClaimPlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PositionRewardClaimPlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PositionRewardClaimPlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PositionRewardClaimPlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PositionRewardClaimPlan.Merge(m, src)
}
func (m *PositionRewardClaimPlan) XXX_Size() int {
	return m.Size()
}
func (m *PositionRewardClaimPlan) XXX_DiscardUnknown() {
	xxx_messageInfo_PositionRewardClaimPlan.DiscardUnknown(m)
}

var xxx_messageInfo_PositionRewardClaimPlan proto.InternalMessageInfo

func (m *PositionRewardClaimPlan) GetReserves() *Reserves {
	if m != nil {
		return m.Reserves
	}
	return nil
}

// Requests batch swap data associated with a given height and trading pair from the view service.
type BatchSwapOutputDataRequest struct {
	// The expected chain id (empty string if no expectation).
	ChainId     string       `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	Height      uint64       `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
	TradingPair *TradingPair `protobuf:"bytes,3,opt,name=trading_pair,json=tradingPair,proto3" json:"trading_pair,omitempty"`
}

func (m *BatchSwapOutputDataRequest) Reset()         { *m = BatchSwapOutputDataRequest{} }
func (m *BatchSwapOutputDataRequest) String() string { return proto.CompactTextString(m) }
func (*BatchSwapOutputDataRequest) ProtoMessage()    {}
func (*BatchSwapOutputDataRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{29}
}
func (m *BatchSwapOutputDataRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchSwapOutputDataRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchSwapOutputDataRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchSwapOutputDataRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchSwapOutputDataRequest.Merge(m, src)
}
func (m *BatchSwapOutputDataRequest) XXX_Size() int {
	return m.Size()
}
func (m *BatchSwapOutputDataRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchSwapOutputDataRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BatchSwapOutputDataRequest proto.InternalMessageInfo

func (m *BatchSwapOutputDataRequest) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *BatchSwapOutputDataRequest) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *BatchSwapOutputDataRequest) GetTradingPair() *TradingPair {
	if m != nil {
		return m.TradingPair
	}
	return nil
}

type BatchSwapOutputDataResponse struct {
	Data *BatchSwapOutputData `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *BatchSwapOutputDataResponse) Reset()         { *m = BatchSwapOutputDataResponse{} }
func (m *BatchSwapOutputDataResponse) String() string { return proto.CompactTextString(m) }
func (*BatchSwapOutputDataResponse) ProtoMessage()    {}
func (*BatchSwapOutputDataResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{30}
}
func (m *BatchSwapOutputDataResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchSwapOutputDataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchSwapOutputDataResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchSwapOutputDataResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchSwapOutputDataResponse.Merge(m, src)
}
func (m *BatchSwapOutputDataResponse) XXX_Size() int {
	return m.Size()
}
func (m *BatchSwapOutputDataResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchSwapOutputDataResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BatchSwapOutputDataResponse proto.InternalMessageInfo

func (m *BatchSwapOutputDataResponse) GetData() *BatchSwapOutputData {
	if m != nil {
		return m.Data
	}
	return nil
}

type SwapExecutionRequest struct {
	// The expected chain id (empty string if no expectation).
	ChainId     string               `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	Height      uint64               `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
	TradingPair *DirectedTradingPair `protobuf:"bytes,3,opt,name=trading_pair,json=tradingPair,proto3" json:"trading_pair,omitempty"`
}

func (m *SwapExecutionRequest) Reset()         { *m = SwapExecutionRequest{} }
func (m *SwapExecutionRequest) String() string { return proto.CompactTextString(m) }
func (*SwapExecutionRequest) ProtoMessage()    {}
func (*SwapExecutionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{31}
}
func (m *SwapExecutionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapExecutionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapExecutionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapExecutionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapExecutionRequest.Merge(m, src)
}
func (m *SwapExecutionRequest) XXX_Size() int {
	return m.Size()
}
func (m *SwapExecutionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapExecutionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SwapExecutionRequest proto.InternalMessageInfo

func (m *SwapExecutionRequest) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *SwapExecutionRequest) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *SwapExecutionRequest) GetTradingPair() *DirectedTradingPair {
	if m != nil {
		return m.TradingPair
	}
	return nil
}

type SwapExecutionResponse struct {
	SwapExecution *SwapExecution `protobuf:"bytes,1,opt,name=swap_execution,json=swapExecution,proto3" json:"swap_execution,omitempty"`
}

func (m *SwapExecutionResponse) Reset()         { *m = SwapExecutionResponse{} }
func (m *SwapExecutionResponse) String() string { return proto.CompactTextString(m) }
func (*SwapExecutionResponse) ProtoMessage()    {}
func (*SwapExecutionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{32}
}
func (m *SwapExecutionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapExecutionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapExecutionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapExecutionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapExecutionResponse.Merge(m, src)
}
func (m *SwapExecutionResponse) XXX_Size() int {
	return m.Size()
}
func (m *SwapExecutionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapExecutionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SwapExecutionResponse proto.InternalMessageInfo

func (m *SwapExecutionResponse) GetSwapExecution() *SwapExecution {
	if m != nil {
		return m.SwapExecution
	}
	return nil
}

type ArbExecutionRequest struct {
	// The expected chain id (empty string if no expectation).
	ChainId string `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	Height  uint64 `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
}

func (m *ArbExecutionRequest) Reset()         { *m = ArbExecutionRequest{} }
func (m *ArbExecutionRequest) String() string { return proto.CompactTextString(m) }
func (*ArbExecutionRequest) ProtoMessage()    {}
func (*ArbExecutionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{33}
}
func (m *ArbExecutionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArbExecutionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArbExecutionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArbExecutionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArbExecutionRequest.Merge(m, src)
}
func (m *ArbExecutionRequest) XXX_Size() int {
	return m.Size()
}
func (m *ArbExecutionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ArbExecutionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ArbExecutionRequest proto.InternalMessageInfo

func (m *ArbExecutionRequest) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *ArbExecutionRequest) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

type ArbExecutionResponse struct {
	SwapExecution *SwapExecution `protobuf:"bytes,1,opt,name=swap_execution,json=swapExecution,proto3" json:"swap_execution,omitempty"`
	Height        uint64         `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
}

func (m *ArbExecutionResponse) Reset()         { *m = ArbExecutionResponse{} }
func (m *ArbExecutionResponse) String() string { return proto.CompactTextString(m) }
func (*ArbExecutionResponse) ProtoMessage()    {}
func (*ArbExecutionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{34}
}
func (m *ArbExecutionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArbExecutionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArbExecutionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArbExecutionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArbExecutionResponse.Merge(m, src)
}
func (m *ArbExecutionResponse) XXX_Size() int {
	return m.Size()
}
func (m *ArbExecutionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ArbExecutionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ArbExecutionResponse proto.InternalMessageInfo

func (m *ArbExecutionResponse) GetSwapExecution() *SwapExecution {
	if m != nil {
		return m.SwapExecution
	}
	return nil
}

func (m *ArbExecutionResponse) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

type SwapExecutionsRequest struct {
	// The expected chain id (empty string if no expectation).
	ChainId string `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// If present, only return swap executions occurring after the given height.
	StartHeight uint64 `protobuf:"varint,2,opt,name=start_height,json=startHeight,proto3" json:"start_height,omitempty"`
	// If present, only return swap executions occurring before the given height.
	EndHeight uint64 `protobuf:"varint,3,opt,name=end_height,json=endHeight,proto3" json:"end_height,omitempty"`
	// If present, filter swap executions by the given trading pair.
	TradingPair *DirectedTradingPair `protobuf:"bytes,4,opt,name=trading_pair,json=tradingPair,proto3" json:"trading_pair,omitempty"`
}

func (m *SwapExecutionsRequest) Reset()         { *m = SwapExecutionsRequest{} }
func (m *SwapExecutionsRequest) String() string { return proto.CompactTextString(m) }
func (*SwapExecutionsRequest) ProtoMessage()    {}
func (*SwapExecutionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{35}
}
func (m *SwapExecutionsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapExecutionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapExecutionsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapExecutionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapExecutionsRequest.Merge(m, src)
}
func (m *SwapExecutionsRequest) XXX_Size() int {
	return m.Size()
}
func (m *SwapExecutionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapExecutionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SwapExecutionsRequest proto.InternalMessageInfo

func (m *SwapExecutionsRequest) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *SwapExecutionsRequest) GetStartHeight() uint64 {
	if m != nil {
		return m.StartHeight
	}
	return 0
}

func (m *SwapExecutionsRequest) GetEndHeight() uint64 {
	if m != nil {
		return m.EndHeight
	}
	return 0
}

func (m *SwapExecutionsRequest) GetTradingPair() *DirectedTradingPair {
	if m != nil {
		return m.TradingPair
	}
	return nil
}

type SwapExecutionsResponse struct {
	SwapExecution *SwapExecution       `protobuf:"bytes,1,opt,name=swap_execution,json=swapExecution,proto3" json:"swap_execution,omitempty"`
	Height        uint64               `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
	TradingPair   *DirectedTradingPair `protobuf:"bytes,3,opt,name=trading_pair,json=tradingPair,proto3" json:"trading_pair,omitempty"`
}

func (m *SwapExecutionsResponse) Reset()         { *m = SwapExecutionsResponse{} }
func (m *SwapExecutionsResponse) String() string { return proto.CompactTextString(m) }
func (*SwapExecutionsResponse) ProtoMessage()    {}
func (*SwapExecutionsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{36}
}
func (m *SwapExecutionsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapExecutionsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapExecutionsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapExecutionsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapExecutionsResponse.Merge(m, src)
}
func (m *SwapExecutionsResponse) XXX_Size() int {
	return m.Size()
}
func (m *SwapExecutionsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapExecutionsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SwapExecutionsResponse proto.InternalMessageInfo

func (m *SwapExecutionsResponse) GetSwapExecution() *SwapExecution {
	if m != nil {
		return m.SwapExecution
	}
	return nil
}

func (m *SwapExecutionsResponse) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *SwapExecutionsResponse) GetTradingPair() *DirectedTradingPair {
	if m != nil {
		return m.TradingPair
	}
	return nil
}

type ArbExecutionsRequest struct {
	// The expected chain id (empty string if no expectation).
	ChainId string `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// If present, only return arb executions occurring after the given height.
	StartHeight uint64 `protobuf:"varint,2,opt,name=start_height,json=startHeight,proto3" json:"start_height,omitempty"`
	// If present, only return arb executions occurring before the given height.
	EndHeight uint64 `protobuf:"varint,3,opt,name=end_height,json=endHeight,proto3" json:"end_height,omitempty"`
}

func (m *ArbExecutionsRequest) Reset()         { *m = ArbExecutionsRequest{} }
func (m *ArbExecutionsRequest) String() string { return proto.CompactTextString(m) }
func (*ArbExecutionsRequest) ProtoMessage()    {}
func (*ArbExecutionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{37}
}
func (m *ArbExecutionsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArbExecutionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArbExecutionsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArbExecutionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArbExecutionsRequest.Merge(m, src)
}
func (m *ArbExecutionsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ArbExecutionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ArbExecutionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ArbExecutionsRequest proto.InternalMessageInfo

func (m *ArbExecutionsRequest) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *ArbExecutionsRequest) GetStartHeight() uint64 {
	if m != nil {
		return m.StartHeight
	}
	return 0
}

func (m *ArbExecutionsRequest) GetEndHeight() uint64 {
	if m != nil {
		return m.EndHeight
	}
	return 0
}

type ArbExecutionsResponse struct {
	SwapExecution *SwapExecution `protobuf:"bytes,1,opt,name=swap_execution,json=swapExecution,proto3" json:"swap_execution,omitempty"`
	Height        uint64         `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
}

func (m *ArbExecutionsResponse) Reset()         { *m = ArbExecutionsResponse{} }
func (m *ArbExecutionsResponse) String() string { return proto.CompactTextString(m) }
func (*ArbExecutionsResponse) ProtoMessage()    {}
func (*ArbExecutionsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{38}
}
func (m *ArbExecutionsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArbExecutionsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArbExecutionsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArbExecutionsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArbExecutionsResponse.Merge(m, src)
}
func (m *ArbExecutionsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ArbExecutionsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ArbExecutionsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ArbExecutionsResponse proto.InternalMessageInfo

func (m *ArbExecutionsResponse) GetSwapExecution() *SwapExecution {
	if m != nil {
		return m.SwapExecution
	}
	return nil
}

func (m *ArbExecutionsResponse) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

type LiquidityPositionsRequest struct {
	// The expected chain id (empty string if no expectation).
	ChainId string `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// If true, include closed and withdrawn positions.
	IncludeClosed bool `protobuf:"varint,4,opt,name=include_closed,json=includeClosed,proto3" json:"include_closed,omitempty"`
}

func (m *LiquidityPositionsRequest) Reset()         { *m = LiquidityPositionsRequest{} }
func (m *LiquidityPositionsRequest) String() string { return proto.CompactTextString(m) }
func (*LiquidityPositionsRequest) ProtoMessage()    {}
func (*LiquidityPositionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{39}
}
func (m *LiquidityPositionsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LiquidityPositionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LiquidityPositionsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LiquidityPositionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiquidityPositionsRequest.Merge(m, src)
}
func (m *LiquidityPositionsRequest) XXX_Size() int {
	return m.Size()
}
func (m *LiquidityPositionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LiquidityPositionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LiquidityPositionsRequest proto.InternalMessageInfo

func (m *LiquidityPositionsRequest) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *LiquidityPositionsRequest) GetIncludeClosed() bool {
	if m != nil {
		return m.IncludeClosed
	}
	return false
}

type LiquidityPositionsResponse struct {
	Data *Position `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *LiquidityPositionsResponse) Reset()         { *m = LiquidityPositionsResponse{} }
func (m *LiquidityPositionsResponse) String() string { return proto.CompactTextString(m) }
func (*LiquidityPositionsResponse) ProtoMessage()    {}
func (*LiquidityPositionsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{40}
}
func (m *LiquidityPositionsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LiquidityPositionsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LiquidityPositionsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LiquidityPositionsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiquidityPositionsResponse.Merge(m, src)
}
func (m *LiquidityPositionsResponse) XXX_Size() int {
	return m.Size()
}
func (m *LiquidityPositionsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LiquidityPositionsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LiquidityPositionsResponse proto.InternalMessageInfo

func (m *LiquidityPositionsResponse) GetData() *Position {
	if m != nil {
		return m.Data
	}
	return nil
}

type LiquidityPositionByIdRequest struct {
	// The expected chain id (empty string if no expectation).
	ChainId    string      `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	PositionId *PositionId `protobuf:"bytes,2,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
}

func (m *LiquidityPositionByIdRequest) Reset()         { *m = LiquidityPositionByIdRequest{} }
func (m *LiquidityPositionByIdRequest) String() string { return proto.CompactTextString(m) }
func (*LiquidityPositionByIdRequest) ProtoMessage()    {}
func (*LiquidityPositionByIdRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{41}
}
func (m *LiquidityPositionByIdRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LiquidityPositionByIdRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LiquidityPositionByIdRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LiquidityPositionByIdRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiquidityPositionByIdRequest.Merge(m, src)
}
func (m *LiquidityPositionByIdRequest) XXX_Size() int {
	return m.Size()
}
func (m *LiquidityPositionByIdRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LiquidityPositionByIdRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LiquidityPositionByIdRequest proto.InternalMessageInfo

func (m *LiquidityPositionByIdRequest) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *LiquidityPositionByIdRequest) GetPositionId() *PositionId {
	if m != nil {
		return m.PositionId
	}
	return nil
}

type LiquidityPositionByIdResponse struct {
	Data *Position `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *LiquidityPositionByIdResponse) Reset()         { *m = LiquidityPositionByIdResponse{} }
func (m *LiquidityPositionByIdResponse) String() string { return proto.CompactTextString(m) }
func (*LiquidityPositionByIdResponse) ProtoMessage()    {}
func (*LiquidityPositionByIdResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{42}
}
func (m *LiquidityPositionByIdResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LiquidityPositionByIdResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LiquidityPositionByIdResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LiquidityPositionByIdResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiquidityPositionByIdResponse.Merge(m, src)
}
func (m *LiquidityPositionByIdResponse) XXX_Size() int {
	return m.Size()
}
func (m *LiquidityPositionByIdResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LiquidityPositionByIdResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LiquidityPositionByIdResponse proto.InternalMessageInfo

func (m *LiquidityPositionByIdResponse) GetData() *Position {
	if m != nil {
		return m.Data
	}
	return nil
}

type LiquidityPositionsByIdRequest struct {
	// The expected chain id (empty string if no expectation).
	ChainId    string        `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	PositionId []*PositionId `protobuf:"bytes,2,rep,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
}

func (m *LiquidityPositionsByIdRequest) Reset()         { *m = LiquidityPositionsByIdRequest{} }
func (m *LiquidityPositionsByIdRequest) String() string { return proto.CompactTextString(m) }
func (*LiquidityPositionsByIdRequest) ProtoMessage()    {}
func (*LiquidityPositionsByIdRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{43}
}
func (m *LiquidityPositionsByIdRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LiquidityPositionsByIdRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LiquidityPositionsByIdRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LiquidityPositionsByIdRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiquidityPositionsByIdRequest.Merge(m, src)
}
func (m *LiquidityPositionsByIdRequest) XXX_Size() int {
	return m.Size()
}
func (m *LiquidityPositionsByIdRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LiquidityPositionsByIdRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LiquidityPositionsByIdRequest proto.InternalMessageInfo

func (m *LiquidityPositionsByIdRequest) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *LiquidityPositionsByIdRequest) GetPositionId() []*PositionId {
	if m != nil {
		return m.PositionId
	}
	return nil
}

type LiquidityPositionsByIdResponse struct {
	Data *Position `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *LiquidityPositionsByIdResponse) Reset()         { *m = LiquidityPositionsByIdResponse{} }
func (m *LiquidityPositionsByIdResponse) String() string { return proto.CompactTextString(m) }
func (*LiquidityPositionsByIdResponse) ProtoMessage()    {}
func (*LiquidityPositionsByIdResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{44}
}
func (m *LiquidityPositionsByIdResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LiquidityPositionsByIdResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LiquidityPositionsByIdResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LiquidityPositionsByIdResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiquidityPositionsByIdResponse.Merge(m, src)
}
func (m *LiquidityPositionsByIdResponse) XXX_Size() int {
	return m.Size()
}
func (m *LiquidityPositionsByIdResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LiquidityPositionsByIdResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LiquidityPositionsByIdResponse proto.InternalMessageInfo

func (m *LiquidityPositionsByIdResponse) GetData() *Position {
	if m != nil {
		return m.Data
	}
	return nil
}

type LiquidityPositionsByPriceRequest struct {
	// The expected chain id (empty string if no expectation).
	ChainId string `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// The directed trading pair to request positions for
	TradingPair *DirectedTradingPair `protobuf:"bytes,2,opt,name=trading_pair,json=tradingPair,proto3" json:"trading_pair,omitempty"`
	// The maximum number of positions to return.
	Limit uint64 `protobuf:"varint,5,opt,name=limit,proto3" json:"limit,omitempty"`
}

func (m *LiquidityPositionsByPriceRequest) Reset()         { *m = LiquidityPositionsByPriceRequest{} }
func (m *LiquidityPositionsByPriceRequest) String() string { return proto.CompactTextString(m) }
func (*LiquidityPositionsByPriceRequest) ProtoMessage()    {}
func (*LiquidityPositionsByPriceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{45}
}
func (m *LiquidityPositionsByPriceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LiquidityPositionsByPriceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LiquidityPositionsByPriceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LiquidityPositionsByPriceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiquidityPositionsByPriceRequest.Merge(m, src)
}
func (m *LiquidityPositionsByPriceRequest) XXX_Size() int {
	return m.Size()
}
func (m *LiquidityPositionsByPriceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LiquidityPositionsByPriceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LiquidityPositionsByPriceRequest proto.InternalMessageInfo

func (m *LiquidityPositionsByPriceRequest) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *LiquidityPositionsByPriceRequest) GetTradingPair() *DirectedTradingPair {
	if m != nil {
		return m.TradingPair
	}
	return nil
}

func (m *LiquidityPositionsByPriceRequest) GetLimit() uint64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type LiquidityPositionsByPriceResponse struct {
	Data *Position `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *LiquidityPositionsByPriceResponse) Reset()         { *m = LiquidityPositionsByPriceResponse{} }
func (m *LiquidityPositionsByPriceResponse) String() string { return proto.CompactTextString(m) }
func (*LiquidityPositionsByPriceResponse) ProtoMessage()    {}
func (*LiquidityPositionsByPriceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{46}
}
func (m *LiquidityPositionsByPriceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LiquidityPositionsByPriceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LiquidityPositionsByPriceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LiquidityPositionsByPriceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiquidityPositionsByPriceResponse.Merge(m, src)
}
func (m *LiquidityPositionsByPriceResponse) XXX_Size() int {
	return m.Size()
}
func (m *LiquidityPositionsByPriceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LiquidityPositionsByPriceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LiquidityPositionsByPriceResponse proto.InternalMessageInfo

func (m *LiquidityPositionsByPriceResponse) GetData() *Position {
	if m != nil {
		return m.Data
	}
	return nil
}

type SpreadRequest struct {
	// The expected chain id (empty string if no expectation).
	ChainId     string       `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	TradingPair *TradingPair `protobuf:"bytes,2,opt,name=trading_pair,json=tradingPair,proto3" json:"trading_pair,omitempty"`
}

func (m *SpreadRequest) Reset()         { *m = SpreadRequest{} }
func (m *SpreadRequest) String() string { return proto.CompactTextString(m) }
func (*SpreadRequest) ProtoMessage()    {}
func (*SpreadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{47}
}
func (m *SpreadRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpreadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpreadRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpreadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpreadRequest.Merge(m, src)
}
func (m *SpreadRequest) XXX_Size() int {
	return m.Size()
}
func (m *SpreadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SpreadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SpreadRequest proto.InternalMessageInfo

func (m *SpreadRequest) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *SpreadRequest) GetTradingPair() *TradingPair {
	if m != nil {
		return m.TradingPair
	}
	return nil
}

type SpreadResponse struct {
	// The best position when trading 1 => 2.
	Best_1To_2Position *Position `protobuf:"bytes,1,opt,name=best_1_to_2_position,json=best1To2Position,proto3" json:"best_1_to_2_position,omitempty"`
	// The best position when trading 2 => 1.
	Best_2To_1Position *Position `protobuf:"bytes,2,opt,name=best_2_to_1_position,json=best2To1Position,proto3" json:"best_2_to_1_position,omitempty"`
	// An approximation of the effective price when trading 1 => 2.
	ApproxEffectivePrice_1To_2 float64 `protobuf:"fixed64,3,opt,name=approx_effective_price_1_to_2,json=approxEffectivePrice1To2,proto3" json:"approx_effective_price_1_to_2,omitempty"`
	// An approximation of the effective price when trading 2 => 1.
	ApproxEffectivePrice_2To_1 float64 `protobuf:"fixed64,4,opt,name=approx_effective_price_2_to_1,json=approxEffectivePrice2To1,proto3" json:"approx_effective_price_2_to_1,omitempty"`
}

func (m *SpreadResponse) Reset()         { *m = SpreadResponse{} }
func (m *SpreadResponse) String() string { return proto.CompactTextString(m) }
func (*SpreadResponse) ProtoMessage()    {}
func (*SpreadResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{48}
}
func (m *SpreadResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpreadResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpreadResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpreadResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpreadResponse.Merge(m, src)
}
func (m *SpreadResponse) XXX_Size() int {
	return m.Size()
}
func (m *SpreadResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SpreadResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SpreadResponse proto.InternalMessageInfo

func (m *SpreadResponse) GetBest_1To_2Position() *Position {
	if m != nil {
		return m.Best_1To_2Position
	}
	return nil
}

func (m *SpreadResponse) GetBest_2To_1Position() *Position {
	if m != nil {
		return m.Best_2To_1Position
	}
	return nil
}

func (m *SpreadResponse) GetApproxEffectivePrice_1To_2() float64 {
	if m != nil {
		return m.ApproxEffectivePrice_1To_2
	}
	return 0
}

func (m *SpreadResponse) GetApproxEffectivePrice_2To_1() float64 {
	if m != nil {
		return m.ApproxEffectivePrice_2To_1
	}
	return 0
}

type SimulateTradeRequest struct {
	Input   *v1alpha14.Value              `protobuf:"bytes,1,opt,name=input,proto3" json:"input,omitempty"`
	Output  *v1alpha14.AssetId            `protobuf:"bytes,2,opt,name=output,proto3" json:"output,omitempty"`
	Routing *SimulateTradeRequest_Routing `protobuf:"bytes,3,opt,name=routing,proto3" json:"routing,omitempty"`
}

func (m *SimulateTradeRequest) Reset()         { *m = SimulateTradeRequest{} }
func (m *SimulateTradeRequest) String() string { return proto.CompactTextString(m) }
func (*SimulateTradeRequest) ProtoMessage()    {}
func (*SimulateTradeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{49}
}
func (m *SimulateTradeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SimulateTradeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SimulateTradeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SimulateTradeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SimulateTradeRequest.Merge(m, src)
}
func (m *SimulateTradeRequest) XXX_Size() int {
	return m.Size()
}
func (m *SimulateTradeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SimulateTradeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SimulateTradeRequest proto.InternalMessageInfo

func (m *SimulateTradeRequest) GetInput() *v1alpha14.Value {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *SimulateTradeRequest) GetOutput() *v1alpha14.AssetId {
	if m != nil {
		return m.Output
	}
	return nil
}

func (m *SimulateTradeRequest) GetRouting() *SimulateTradeRequest_Routing {
	if m != nil {
		return m.Routing
	}
	return nil
}

type SimulateTradeRequest_Routing struct {
	// Types that are valid to be assigned to Setting:
	//
	//	*SimulateTradeRequest_Routing_Default_
	//	*SimulateTradeRequest_Routing_SingleHop_
	Setting isSimulateTradeRequest_Routing_Setting `protobuf_oneof:"setting"`
}

func (m *SimulateTradeRequest_Routing) Reset()         { *m = SimulateTradeRequest_Routing{} }
func (m *SimulateTradeRequest_Routing) String() string { return proto.CompactTextString(m) }
func (*SimulateTradeRequest_Routing) ProtoMessage()    {}
func (*SimulateTradeRequest_Routing) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{49, 0}
}
func (m *SimulateTradeRequest_Routing) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SimulateTradeRequest_Routing) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SimulateTradeRequest_Routing.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SimulateTradeRequest_Routing) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SimulateTradeRequest_Routing.Merge(m, src)
}
func (m *SimulateTradeRequest_Routing) XXX_Size() int {
	return m.Size()
}
func (m *SimulateTradeRequest_Routing) XXX_DiscardUnknown() {
	xxx_messageInfo_SimulateTradeRequest_Routing.DiscardUnknown(m)
}

var xxx_messageInfo_SimulateTradeRequest_Routing proto.InternalMessageInfo

type isSimulateTradeRequest_Routing_Setting interface {
	isSimulateTradeRequest_Routing_Setting()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SimulateTradeRequest_Routing_Default_ struct {
	Default *SimulateTradeRequest_Routing_Default `protobuf:"bytes,1,opt,name=default,proto3,oneof" json:"default,omitempty"`
}
type SimulateTradeRequest_Routing_SingleHop_ struct {
	SingleHop *SimulateTradeRequest_Routing_SingleHop `protobuf:"bytes,2,opt,name=single_hop,json=singleHop,proto3,oneof" json:"single_hop,omitempty"`
}

func (*SimulateTradeRequest_Routing_Default_) isSimulateTradeRequest_Routing_Setting()   {}
func (*SimulateTradeRequest_Routing_SingleHop_) isSimulateTradeRequest_Routing_Setting() {}

func (m *SimulateTradeRequest_Routing) GetSetting() isSimulateTradeRequest_Routing_Setting {
	if m != nil {
		return m.Setting
	}
	return nil
}

func (m *SimulateTradeRequest_Routing) GetDefault() *SimulateTradeRequest_Routing_Default {
	if x, ok := m.GetSetting().(*SimulateTradeRequest_Routing_Default_); ok {
		return x.Default
	}
	return nil
}

func (m *SimulateTradeRequest_Routing) GetSingleHop() *SimulateTradeRequest_Routing_SingleHop {
	if x, ok := m.GetSetting().(*SimulateTradeRequest_Routing_SingleHop_); ok {
		return x.SingleHop
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SimulateTradeRequest_Routing) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SimulateTradeRequest_Routing_Default_)(nil),
		(*SimulateTradeRequest_Routing_SingleHop_)(nil),
	}
}

type SimulateTradeRequest_Routing_SingleHop struct {
}

func (m *SimulateTradeRequest_Routing_SingleHop) Reset() {
	*m = SimulateTradeRequest_Routing_SingleHop{}
}
func (m *SimulateTradeRequest_Routing_SingleHop) String() string { return proto.CompactTextString(m) }
func (*SimulateTradeRequest_Routing_SingleHop) ProtoMessage()    {}
func (*SimulateTradeRequest_Routing_SingleHop) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{49, 0, 0}
}
func (m *SimulateTradeRequest_Routing_SingleHop) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SimulateTradeRequest_Routing_SingleHop) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SimulateTradeRequest_Routing_SingleHop.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SimulateTradeRequest_Routing_SingleHop) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SimulateTradeRequest_Routing_SingleHop.Merge(m, src)
}
func (m *SimulateTradeRequest_Routing_SingleHop) XXX_Size() int {
	return m.Size()
}
func (m *SimulateTradeRequest_Routing_SingleHop) XXX_DiscardUnknown() {
	xxx_messageInfo_SimulateTradeRequest_Routing_SingleHop.DiscardUnknown(m)
}

var xxx_messageInfo_SimulateTradeRequest_Routing_SingleHop proto.InternalMessageInfo

type SimulateTradeRequest_Routing_Default struct {
}

func (m *SimulateTradeRequest_Routing_Default) Reset()         { *m = SimulateTradeRequest_Routing_Default{} }
func (m *SimulateTradeRequest_Routing_Default) String() string { return proto.CompactTextString(m) }
func (*SimulateTradeRequest_Routing_Default) ProtoMessage()    {}
func (*SimulateTradeRequest_Routing_Default) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{49, 0, 1}
}
func (m *SimulateTradeRequest_Routing_Default) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SimulateTradeRequest_Routing_Default) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SimulateTradeRequest_Routing_Default.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SimulateTradeRequest_Routing_Default) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SimulateTradeRequest_Routing_Default.Merge(m, src)
}
func (m *SimulateTradeRequest_Routing_Default) XXX_Size() int {
	return m.Size()
}
func (m *SimulateTradeRequest_Routing_Default) XXX_DiscardUnknown() {
	xxx_messageInfo_SimulateTradeRequest_Routing_Default.DiscardUnknown(m)
}

var xxx_messageInfo_SimulateTradeRequest_Routing_Default proto.InternalMessageInfo

type SimulateTradeResponse struct {
	Output *SwapExecution `protobuf:"bytes,1,opt,name=output,proto3" json:"output,omitempty"`
}

func (m *SimulateTradeResponse) Reset()         { *m = SimulateTradeResponse{} }
func (m *SimulateTradeResponse) String() string { return proto.CompactTextString(m) }
func (*SimulateTradeResponse) ProtoMessage()    {}
func (*SimulateTradeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_259f31b405eaa9a9, []int{50}
}
func (m *SimulateTradeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SimulateTradeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SimulateTradeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SimulateTradeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SimulateTradeResponse.Merge(m, src)
}
func (m *SimulateTradeResponse) XXX_Size() int {
	return m.Size()
}
func (m *SimulateTradeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SimulateTradeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SimulateTradeResponse proto.InternalMessageInfo

func (m *SimulateTradeResponse) GetOutput() *SwapExecution {
	if m != nil {
		return m.Output
	}
	return nil
}

func init() {
	proto.RegisterEnum("penumbra.core.component.dex.v1alpha1.PositionState_PositionStateEnum", PositionState_PositionStateEnum_name, PositionState_PositionStateEnum_value)
	proto.RegisterType((*ZKSwapProof)(nil), "penumbra.core.component.dex.v1alpha1.ZKSwapProof")
	proto.RegisterType((*ZKSwapClaimProof)(nil), "penumbra.core.component.dex.v1alpha1.ZKSwapClaimProof")
	proto.RegisterType((*Swap)(nil), "penumbra.core.component.dex.v1alpha1.Swap")
	proto.RegisterType((*SwapClaim)(nil), "penumbra.core.component.dex.v1alpha1.SwapClaim")
	proto.RegisterType((*SwapClaimBody)(nil), "penumbra.core.component.dex.v1alpha1.SwapClaimBody")
	proto.RegisterType((*SwapBody)(nil), "penumbra.core.component.dex.v1alpha1.SwapBody")
	proto.RegisterType((*SwapPayload)(nil), "penumbra.core.component.dex.v1alpha1.SwapPayload")
	proto.RegisterType((*SwapPlaintext)(nil), "penumbra.core.component.dex.v1alpha1.SwapPlaintext")
	proto.RegisterType((*SwapPlan)(nil), "penumbra.core.component.dex.v1alpha1.SwapPlan")
	proto.RegisterType((*SwapClaimPlan)(nil), "penumbra.core.component.dex.v1alpha1.SwapClaimPlan")
	proto.RegisterType((*SwapView)(nil), "penumbra.core.component.dex.v1alpha1.SwapView")
	proto.RegisterType((*SwapView_Visible)(nil), "penumbra.core.component.dex.v1alpha1.SwapView.Visible")
	proto.RegisterType((*SwapView_Opaque)(nil), "penumbra.core.component.dex.v1alpha1.SwapView.Opaque")
	proto.RegisterType((*SwapClaimView)(nil), "penumbra.core.component.dex.v1alpha1.SwapClaimView")
	proto.RegisterType((*SwapClaimView_Visible)(nil), "penumbra.core.component.dex.v1alpha1.SwapClaimView.Visible")
	proto.RegisterType((*SwapClaimView_Opaque)(nil), "penumbra.core.component.dex.v1alpha1.SwapClaimView.Opaque")
	proto.RegisterType((*TradingPair)(nil), "penumbra.core.component.dex.v1alpha1.TradingPair")
	proto.RegisterType((*DirectedTradingPair)(nil), "penumbra.core.component.dex.v1alpha1.DirectedTradingPair")
	proto.RegisterType((*BatchSwapOutputData)(nil), "penumbra.core.component.dex.v1alpha1.BatchSwapOutputData")
	proto.RegisterType((*TradingFunction)(nil), "penumbra.core.component.dex.v1alpha1.TradingFunction")
	proto.RegisterType((*BareTradingFunction)(nil), "penumbra.core.component.dex.v1alpha1.BareTradingFunction")
	proto.RegisterType((*Reserves)(nil), "penumbra.core.component.dex.v1alpha1.Reserves")
	proto.RegisterType((*Position)(nil), "penumbra.core.component.dex.v1alpha1.Position")
	proto.RegisterType((*PositionId)(nil), "penumbra.core.component.dex.v1alpha1.PositionId")
	proto.RegisterType((*PositionState)(nil), "penumbra.core.component.dex.v1alpha1.PositionState")
	proto.RegisterType((*LpNft)(nil), "penumbra.core.component.dex.v1alpha1.LpNft")
	proto.RegisterType((*PositionOpen)(nil), "penumbra.core.component.dex.v1alpha1.PositionOpen")
	proto.RegisterType((*PositionClose)(nil), "penumbra.core.component.dex.v1alpha1.PositionClose")
	proto.RegisterType((*PositionWithdraw)(nil), "penumbra.core.component.dex.v1alpha1.PositionWithdraw")
	proto.RegisterType((*PositionRewardClaim)(nil), "penumbra.core.component.dex.v1alpha1.PositionRewardClaim")
	proto.RegisterType((*SwapExecution)(nil), "penumbra.core.component.dex.v1alpha1.SwapExecution")
	proto.RegisterType((*SwapExecution_Trace)(nil), "penumbra.core.component.dex.v1alpha1.SwapExecution.Trace")
	proto.RegisterType((*PositionWithdrawPlan)(nil), "penumbra.core.component.dex.v1alpha1.PositionWithdrawPlan")
	proto.RegisterType((*PositionRewardClaimPlan)(nil), "penumbra.core.component.dex.v1alpha1.PositionRewardClaimPlan")
	proto.RegisterType((*BatchSwapOutputDataRequest)(nil), "penumbra.core.component.dex.v1alpha1.BatchSwapOutputDataRequest")
	proto.RegisterType((*BatchSwapOutputDataResponse)(nil), "penumbra.core.component.dex.v1alpha1.BatchSwapOutputDataResponse")
	proto.RegisterType((*SwapExecutionRequest)(nil), "penumbra.core.component.dex.v1alpha1.SwapExecutionRequest")
	proto.RegisterType((*SwapExecutionResponse)(nil), "penumbra.core.component.dex.v1alpha1.SwapExecutionResponse")
	proto.RegisterType((*ArbExecutionRequest)(nil), "penumbra.core.component.dex.v1alpha1.ArbExecutionRequest")
	proto.RegisterType((*ArbExecutionResponse)(nil), "penumbra.core.component.dex.v1alpha1.ArbExecutionResponse")
	proto.RegisterType((*SwapExecutionsRequest)(nil), "penumbra.core.component.dex.v1alpha1.SwapExecutionsRequest")
	proto.RegisterType((*SwapExecutionsResponse)(nil), "penumbra.core.component.dex.v1alpha1.SwapExecutionsResponse")
	proto.RegisterType((*ArbExecutionsRequest)(nil), "penumbra.core.component.dex.v1alpha1.ArbExecutionsRequest")
	proto.RegisterType((*ArbExecutionsResponse)(nil), "penumbra.core.component.dex.v1alpha1.ArbExecutionsResponse")
	proto.RegisterType((*LiquidityPositionsRequest)(nil), "penumbra.core.component.dex.v1alpha1.LiquidityPositionsRequest")
	proto.RegisterType((*LiquidityPositionsResponse)(nil), "penumbra.core.component.dex.v1alpha1.LiquidityPositionsResponse")
	proto.RegisterType((*LiquidityPositionByIdRequest)(nil), "penumbra.core.component.dex.v1alpha1.LiquidityPositionByIdRequest")
	proto.RegisterType((*LiquidityPositionByIdResponse)(nil), "penumbra.core.component.dex.v1alpha1.LiquidityPositionByIdResponse")
	proto.RegisterType((*LiquidityPositionsByIdRequest)(nil), "penumbra.core.component.dex.v1alpha1.LiquidityPositionsByIdRequest")
	proto.RegisterType((*LiquidityPositionsByIdResponse)(nil), "penumbra.core.component.dex.v1alpha1.LiquidityPositionsByIdResponse")
	proto.RegisterType((*LiquidityPositionsByPriceRequest)(nil), "penumbra.core.component.dex.v1alpha1.LiquidityPositionsByPriceRequest")
	proto.RegisterType((*LiquidityPositionsByPriceResponse)(nil), "penumbra.core.component.dex.v1alpha1.LiquidityPositionsByPriceResponse")
	proto.RegisterType((*SpreadRequest)(nil), "penumbra.core.component.dex.v1alpha1.SpreadRequest")
	proto.RegisterType((*SpreadResponse)(nil), "penumbra.core.component.dex.v1alpha1.SpreadResponse")
	proto.RegisterType((*SimulateTradeRequest)(nil), "penumbra.core.component.dex.v1alpha1.SimulateTradeRequest")
	proto.RegisterType((*SimulateTradeRequest_Routing)(nil), "penumbra.core.component.dex.v1alpha1.SimulateTradeRequest.Routing")
	proto.RegisterType((*SimulateTradeRequest_Routing_SingleHop)(nil), "penumbra.core.component.dex.v1alpha1.SimulateTradeRequest.Routing.SingleHop")
	proto.RegisterType((*SimulateTradeRequest_Routing_Default)(nil), "penumbra.core.component.dex.v1alpha1.SimulateTradeRequest.Routing.Default")
	proto.RegisterType((*SimulateTradeResponse)(nil), "penumbra.core.component.dex.v1alpha1.SimulateTradeResponse")
}

func init() {
	proto.RegisterFile("penumbra/core/component/dex/v1alpha1/dex.proto", fileDescriptor_259f31b405eaa9a9)
}

var fileDescriptor_259f31b405eaa9a9 = []byte{
	// 2769 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x5b, 0x4d, 0x6c, 0x1b, 0xc7,
	0x15, 0xd6, 0x90, 0x94, 0x48, 0x3e, 0x4a, 0x8a, 0x3c, 0x92, 0x53, 0x85, 0xa9, 0x15, 0x7b, 0xe3,
	0x04, 0x6a, 0x81, 0x52, 0xe6, 0xa6, 0x69, 0x1b, 0xa9, 0xf9, 0x11, 0x45, 0xca, 0x62, 0x62, 0x4b,
	0xcc, 0x52, 0xb1, 0x0b, 0x57, 0xc9, 0x66, 0xc5, 0x1d, 0x9a, 0x8b, 0x2e, 0x77, 0xd7, 0xbb, 0x4b,
	0x59, 0xba, 0x15, 0x08, 0x02, 0x14, 0x69, 0x53, 0x14, 0xe8, 0xa9, 0x3d, 0x04, 0x45, 0xd1, 0xa0,
	0x40, 0x0b, 0x04, 0xc8, 0x21, 0xb7, 0xde, 0x9b, 0xf6, 0x14, 0xe4, 0xd4, 0x4b, 0x7f, 0x60, 0x5f,
	0x8a, 0x9c, 0x7b, 0xec, 0xa1, 0x98, 0xd9, 0xd9, 0xe5, 0x92, 0x5e, 0xba, 0xbb, 0x24, 0xdd, 0x00,
	0xbd, 0x18, 0x9a, 0xd9, 0xf7, 0xbe, 0xf9, 0xde, 0xcf, 0xbc, 0x79, 0x33, 0x84, 0xa1, 0x64, 0x11,
	0xa3, 0xd7, 0x3d, 0xb6, 0x95, 0x8d, 0x96, 0x69, 0x93, 0x8d, 0x96, 0xd9, 0xb5, 0x4c, 0x83, 0x18,
	0xee, 0x86, 0x4a, 0x4e, 0x37, 0x4e, 0xca, 0x8a, 0x6e, 0x75, 0x94, 0x32, 0x1d, 0x94, 0x2c, 0xdb,
	0x74, 0x4d, 0x7c, 0xd9, 0x97, 0x2f, 0x51, 0xf9, 0x52, 0x20, 0x5f, 0xa2, 0x22, 0xbe, 0x7c, 0xf1,
	0xd9, 0x3e, 0xaa, 0x7d, 0x66, 0xb9, 0xe6, 0x86, 0xdb, 0x72, 0xfb, 0x68, 0x6e, 0xcb, 0xf5, 0xd0,
	0x8a, 0x97, 0x07, 0x57, 0x37, 0x7a, 0xdd, 0xbe, 0x94, 0xd1, 0xeb, 0x72, 0xa9, 0xf5, 0x41, 0x29,
	0xc5, 0x71, 0x48, 0x08, 0x8d, 0x0d, 0xb9, 0xe4, 0xb3, 0x83, 0x92, 0x3f, 0x20, 0x67, 0x4e, 0x5f,
	0x90, 0x8e, 0xb8, 0xdc, 0x48, 0xab, 0x9d, 0x30, 0x4f, 0x27, 0xe0, 0x39, 0x52, 0xbe, 0x4d, 0x48,
	0x5f, 0xbe, 0x4d, 0x08, 0x97, 0xaf, 0x8c, 0xc4, 0xef, 0x68, 0x44, 0x57, 0x89, 0x2a, 0x5b, 0xa6,
	0xa9, 0x87, 0x56, 0x0a, 0x4f, 0x7b, 0x18, 0xc2, 0xd3, 0x50, 0xb8, 0xf5, 0x5a, 0xf3, 0xae, 0x62,
	0x35, 0x6c, 0xd3, 0x6c, 0xe3, 0x15, 0x98, 0xd5, 0x0c, 0x83, 0xd8, 0xab, 0xe8, 0x22, 0x5a, 0x9f,
	0x97, 0xbc, 0x81, 0xb0, 0x0e, 0x4b, 0x9e, 0xd0, 0x8e, 0xae, 0x68, 0xdd, 0x87, 0x49, 0xfe, 0x1c,
	0x41, 0x86, 0x0a, 0xe2, 0xab, 0x30, 0x6b, 0x51, 0x39, 0xf6, 0xb9, 0x20, 0x96, 0x4b, 0x71, 0x22,
	0x5a, 0x0a, 0x51, 0x91, 0x3c, 0x7d, 0x5c, 0x81, 0xcc, 0xb1, 0xa9, 0x9e, 0xad, 0x66, 0x18, 0x4e,
	0x29, 0x1e, 0x0e, 0x45, 0xa9, 0x98, 0xea, 0x99, 0xc4, 0x74, 0x85, 0x3f, 0x21, 0xc8, 0x07, 0xf4,
	0xf1, 0xb5, 0x41, 0x6a, 0xdf, 0x4a, 0x42, 0xad, 0xef, 0x00, 0x9f, 0xdf, 0x55, 0xce, 0x2f, 0xc5,
	0xc0, 0x9e, 0x8b, 0xcf, 0x8f, 0x41, 0xf5, 0x49, 0xe2, 0x67, 0x60, 0x91, 0x58, 0x66, 0xab, 0x23,
	0xab, 0x3d, 0x5b, 0x71, 0x35, 0xd3, 0x58, 0xcd, 0x5e, 0x44, 0xeb, 0x19, 0x69, 0x81, 0xcd, 0x56,
	0xf9, 0xa4, 0xf0, 0x49, 0x1a, 0x16, 0x06, 0xd4, 0xf1, 0x75, 0xc8, 0x1b, 0x3d, 0x5d, 0xd7, 0xda,
	0x1a, 0x8f, 0x46, 0x41, 0xdc, 0x18, 0x49, 0x83, 0x66, 0x5b, 0x40, 0x63, 0xdf, 0x57, 0x93, 0xfa,
	0x08, 0x78, 0x0b, 0xd2, 0x6d, 0x42, 0xb8, 0x3d, 0x5f, 0x1b, 0x09, 0x44, 0xd3, 0x30, 0x00, 0xda,
	0x25, 0x44, 0xa2, 0x5a, 0xf8, 0x4d, 0x58, 0x36, 0x7b, 0xae, 0xd5, 0x73, 0xe5, 0xb2, 0xdc, 0x32,
	0xbb, 0x5d, 0xcd, 0xed, 0x12, 0xc3, 0x5d, 0x4d, 0x33, 0xb0, 0x6f, 0x84, 0xc0, 0xd8, 0x86, 0x2d,
	0xb9, 0x61, 0x36, 0x4d, 0x57, 0x71, 0xc9, 0x4e, 0xa0, 0x24, 0x9d, 0xf3, 0x90, 0xca, 0xfd, 0xa9,
	0x10, 0xbc, 0x18, 0x86, 0xcf, 0x4c, 0x00, 0x2f, 0x86, 0xe0, 0x6f, 0x41, 0x81, 0xc3, 0xab, 0x8a,
	0xab, 0xac, 0xce, 0x31, 0xd8, 0x17, 0xe2, 0x85, 0xb4, 0xa2, 0xb8, 0xad, 0x0e, 0x0d, 0xcc, 0x01,
	0x43, 0xa8, 0x2a, 0xae, 0x22, 0x81, 0x19, 0xfc, 0x2d, 0xbc, 0x9b, 0x86, 0x9c, 0x9f, 0x96, 0xf8,
	0x10, 0xe6, 0x5d, 0x5b, 0x51, 0x35, 0xe3, 0xb6, 0x6c, 0x29, 0x9a, 0x9d, 0x6c, 0x93, 0x1c, 0x7a,
	0x9a, 0x0d, 0x45, 0xb3, 0xa5, 0x82, 0xdb, 0x1f, 0xe0, 0x97, 0x20, 0xaf, 0x12, 0xdd, 0x55, 0xe4,
	0xb2, 0xac, 0xf1, 0xf8, 0x09, 0x43, 0x90, 0xb4, 0xdc, 0x05, 0x40, 0xdb, 0x5d, 0xb3, 0x67, 0xb8,
	0x52, 0x96, 0x29, 0x95, 0xeb, 0x7d, 0x7d, 0x51, 0xd6, 0x78, 0xc8, 0xe2, 0xeb, 0x8b, 0x75, 0x7c,
	0x03, 0x16, 0xdb, 0x84, 0x3c, 0x18, 0x98, 0xe1, 0x6c, 0xf4, 0x6a, 0x69, 0xc8, 0x73, 0xba, 0x62,
	0xb4, 0xc2, 0xa1, 0x59, 0x68, 0x93, 0xd0, 0x10, 0xbf, 0x06, 0x59, 0x4b, 0x39, 0xd3, 0x4d, 0x45,
	0x5d, 0x9d, 0x4d, 0xe2, 0x28, 0x56, 0x4b, 0x3c, 0x45, 0xc9, 0x47, 0x10, 0xde, 0x41, 0x50, 0x08,
	0x7d, 0xc0, 0xd7, 0x01, 0x42, 0x84, 0xd1, 0x38, 0x99, 0x14, 0x02, 0x60, 0xbb, 0xd8, 0x60, 0x4a,
	0x44, 0x95, 0x9d, 0xbb, 0x8a, 0xc5, 0x02, 0x31, 0x2f, 0x2d, 0x04, 0xb3, 0x74, 0x71, 0xe1, 0xa7,
	0x7c, 0x17, 0x37, 0x74, 0x45, 0x33, 0x5c, 0x72, 0xea, 0xfe, 0x9f, 0xa6, 0xc4, 0x2e, 0xe4, 0x5b,
	0xb4, 0x50, 0xc9, 0xb4, 0xa4, 0x64, 0x92, 0x96, 0x94, 0x1c, 0xd3, 0xdd, 0x25, 0x04, 0xd7, 0x61,
	0xc1, 0xc3, 0x51, 0x54, 0xd5, 0x26, 0x8e, 0xc3, 0x13, 0xe1, 0xf2, 0x10, 0x16, 0x3b, 0x7c, 0xfb,
	0x64, 0x3c, 0x59, 0x69, 0x9e, 0xa9, 0xf2, 0x11, 0x3d, 0xb8, 0x6c, 0x87, 0x10, 0x95, 0x6d, 0xef,
	0x79, 0xc9, 0x1b, 0x08, 0x7f, 0x45, 0xde, 0xf6, 0x6c, 0xe8, 0x8a, 0x81, 0x6f, 0xc1, 0x22, 0x0d,
	0x9d, 0x6c, 0xf9, 0xd1, 0xe1, 0xd1, 0x48, 0x50, 0xdd, 0x83, 0xc0, 0x4a, 0x0b, 0xce, 0x40, 0x9c,
	0x2f, 0xc1, 0x3c, 0xdd, 0x24, 0xc7, 0xba, 0x66, 0xd0, 0x28, 0xf1, 0xf4, 0x28, 0xb4, 0x09, 0xa9,
	0xf0, 0x29, 0xbc, 0x0e, 0x4b, 0xec, 0x6c, 0x09, 0x84, 0x64, 0x9b, 0xf9, 0x7e, 0x5e, 0x5a, 0x64,
	0xf3, 0xbe, 0xa0, 0x14, 0x21, 0xe9, 0x30, 0x2f, 0x0f, 0x4b, 0x36, 0x85, 0xbf, 0xa5, 0x42, 0xc7,
	0xc6, 0x23, 0x37, 0xb2, 0x08, 0x39, 0xcb, 0x74, 0x34, 0x76, 0x8a, 0xa5, 0xd8, 0x29, 0x16, 0x8c,
	0x87, 0x8b, 0x6c, 0x7a, 0x8a, 0x45, 0x36, 0xe2, 0x0c, 0xcd, 0x44, 0x9c, 0xa1, 0x91, 0x0e, 0x9e,
	0x8d, 0xed, 0xe0, 0xb9, 0x48, 0x07, 0x7f, 0xc4, 0xeb, 0xfb, 0x0d, 0x8d, 0xdc, 0xc5, 0x12, 0x64,
	0x4f, 0x34, 0x47, 0x3b, 0xd6, 0x49, 0xb2, 0x26, 0xc3, 0x07, 0x28, 0xdd, 0xf0, 0xb4, 0xf7, 0x66,
	0x24, 0x1f, 0x08, 0x1f, 0xc0, 0x9c, 0x69, 0x29, 0x77, 0x7a, 0xfe, 0xd1, 0xfc, 0x7c, 0x42, 0xc8,
	0x03, 0xa6, 0xbc, 0x37, 0x23, 0x71, 0x98, 0xe2, 0x87, 0x08, 0xb2, 0x7c, 0x1d, 0xfc, 0x12, 0x64,
	0x58, 0xb1, 0xf2, 0xd8, 0x7e, 0x3d, 0x3e, 0xb4, 0xc4, 0xf4, 0x22, 0x92, 0x29, 0x3d, 0xad, 0x64,
	0x2a, 0xee, 0xc1, 0x9c, 0xc7, 0x7d, 0x52, 0x96, 0x95, 0x02, 0xe4, 0x19, 0xcb, 0x13, 0x8d, 0xdc,
	0x15, 0x3e, 0xce, 0x84, 0x76, 0x04, 0x8b, 0xda, 0xcd, 0xe1, 0xa8, 0x6d, 0x25, 0xec, 0xe6, 0x46,
	0x85, 0xee, 0x70, 0x28, 0x74, 0x9b, 0xe3, 0xe0, 0x3e, 0x10, 0xbf, 0x77, 0x52, 0xfd, 0xf8, 0xed,
	0x03, 0x30, 0xcb, 0x58, 0xa5, 0xfb, 0xaf, 0x4d, 0x60, 0xf4, 0x2a, 0x12, 0x73, 0x8e, 0xd7, 0x23,
	0x37, 0x21, 0xe7, 0xf7, 0x71, 0x9c, 0xf3, 0x77, 0x46, 0xb7, 0x94, 0x03, 0xd7, 0x8a, 0x7e, 0x73,
	0x69, 0xba, 0x84, 0x12, 0x97, 0xb2, 0xbc, 0x8f, 0x0b, 0x81, 0x8a, 0x3c, 0x3d, 0x26, 0x06, 0x15,
	0x8b, 0xdf, 0x0b, 0xb2, 0x63, 0xca, 0x3e, 0xa8, 0x9c, 0x83, 0xc7, 0xfa, 0x78, 0x5e, 0xce, 0xbc,
	0x8f, 0xa0, 0x70, 0x38, 0x70, 0xbc, 0x66, 0x59, 0x33, 0x23, 0x97, 0xf9, 0x7a, 0xcf, 0x3c, 0xbc,
	0xd5, 0xd9, 0xa6, 0xc3, 0xba, 0x2a, 0xcd, 0xb1, 0xf9, 0x72, 0x5f, 0x5f, 0xe4, 0x5e, 0x4e, 0xa4,
	0x2f, 0x0a, 0x3f, 0x46, 0xb0, 0x5c, 0xd5, 0x6c, 0xd2, 0x72, 0x89, 0x1a, 0xe6, 0xb5, 0x05, 0xb3,
	0x8e, 0xab, 0xd8, 0x6e, 0x32, 0x56, 0x9e, 0x0e, 0xfe, 0x36, 0xa4, 0x89, 0xa1, 0x26, 0x23, 0x44,
	0x35, 0x84, 0x4f, 0x32, 0xb0, 0x1c, 0x51, 0xa1, 0xf1, 0x16, 0x64, 0x79, 0x13, 0xc2, 0xf9, 0xc4,
	0x69, 0x21, 0xe6, 0xbc, 0x16, 0xa4, 0xaf, 0x2c, 0x26, 0xe8, 0x5f, 0x3c, 0x65, 0x11, 0xbf, 0x08,
	0x39, 0x5d, 0xe9, 0x1e, 0xab, 0x74, 0xe9, 0x04, 0xdd, 0x8b, 0xa7, 0x53, 0x0e, 0xa9, 0x8b, 0xbc,
	0x79, 0x49, 0xa0, 0x2e, 0xe2, 0x6d, 0x80, 0x9e, 0xd1, 0xd6, 0x74, 0x9d, 0xa8, 0x72, 0x99, 0x77,
	0x2c, 0x71, 0x00, 0xf2, 0xbe, 0x56, 0x79, 0x00, 0x42, 0xe4, 0x17, 0x92, 0x44, 0x10, 0x22, 0x7e,
	0x1c, 0xe6, 0x3a, 0x44, 0xbb, 0xdd, 0x71, 0xf9, 0x7d, 0x92, 0x8f, 0x1e, 0x68, 0x38, 0x73, 0x53,
	0x69, 0x38, 0x45, 0x38, 0xef, 0x9d, 0xc0, 0x2c, 0x97, 0x28, 0x38, 0x5f, 0x3c, 0xcf, 0x16, 0x5f,
	0x66, 0x1f, 0x9b, 0xfc, 0xdb, 0x1e, 0xfb, 0x24, 0x7c, 0x8c, 0xe0, 0x31, 0x0e, 0xb8, 0xdb, 0x33,
	0x5a, 0xec, 0x88, 0xbe, 0x09, 0xf9, 0x60, 0x69, 0x9e, 0x35, 0xb1, 0x7b, 0x04, 0x9b, 0x0c, 0xa1,
	0x49, 0x7d, 0x2c, 0x5c, 0x83, 0x0c, 0x33, 0x37, 0x35, 0xae, 0xb9, 0x4c, 0x9d, 0xed, 0xbc, 0x88,
	0x95, 0xf0, 0x92, 0x77, 0x7b, 0xa6, 0x8c, 0x17, 0xbc, 0x2b, 0xf1, 0x15, 0x40, 0x56, 0x82, 0xd4,
	0x45, 0x16, 0xd5, 0xb8, 0x93, 0x20, 0x5d, 0xd1, 0x1d, 0xc1, 0x86, 0x9c, 0x44, 0x1c, 0x62, 0x9f,
	0x10, 0x07, 0x8b, 0x90, 0xb2, 0x93, 0x6c, 0xb4, 0x94, 0x5d, 0x66, 0x3a, 0x49, 0xf6, 0x57, 0xca,
	0x16, 0x85, 0xdf, 0xa4, 0x20, 0xd7, 0xf0, 0x9b, 0xba, 0xab, 0x90, 0xb6, 0x3a, 0x1a, 0x5f, 0xf5,
	0xf9, 0x44, 0x4e, 0x0d, 0x82, 0x44, 0x11, 0x68, 0x77, 0x6e, 0x98, 0x46, 0x8b, 0xf0, 0xbe, 0xd8,
	0x1b, 0xe0, 0x3a, 0xab, 0x67, 0x2e, 0x49, 0xd6, 0x55, 0xf8, 0xec, 0xd8, 0x7d, 0x4d, 0xf2, 0x10,
	0xf0, 0xab, 0x90, 0xb3, 0xb9, 0xab, 0x92, 0xbd, 0x29, 0xf9, 0x0e, 0x96, 0x02, 0x7d, 0x2c, 0xd0,
	0x5b, 0x89, 0xe9, 0x10, 0xd9, 0x34, 0x64, 0xba, 0xdd, 0xd8, 0x1e, 0xcf, 0x49, 0x05, 0x36, 0x79,
	0x60, 0xec, 0x6a, 0xba, 0x2e, 0xec, 0x00, 0xf8, 0x3c, 0xea, 0x6a, 0xf4, 0xab, 0x19, 0x7e, 0x0a,
	0x0a, 0x8a, 0xee, 0xca, 0xc7, 0xa4, 0xd5, 0x79, 0x4e, 0xec, 0x32, 0xd3, 0xf3, 0x12, 0x28, 0xba,
	0x5b, 0xf1, 0x66, 0x84, 0xdf, 0xa7, 0x60, 0x61, 0xc0, 0x1a, 0xfc, 0x7d, 0xdf, 0x23, 0x14, 0x68,
	0x51, 0xac, 0x8d, 0xe1, 0x91, 0xc1, 0x51, 0xcd, 0xe8, 0x75, 0xb9, 0x8f, 0x84, 0x3f, 0x20, 0x38,
	0xf7, 0xc0, 0x47, 0xfc, 0x34, 0x3c, 0xd5, 0x38, 0x68, 0xd6, 0x0f, 0xeb, 0x07, 0xfb, 0x72, 0xf3,
	0x70, 0xfb, 0xb0, 0x26, 0xd7, 0xf6, 0xdf, 0xb8, 0x2e, 0xbf, 0xb1, 0xdf, 0x6c, 0xd4, 0x76, 0xea,
	0xbb, 0xf5, 0x5a, 0x75, 0x69, 0x06, 0xaf, 0x41, 0x31, 0x4a, 0xe8, 0xa0, 0x51, 0xdb, 0xaf, 0x55,
	0x97, 0xd0, 0xa8, 0xef, 0x3b, 0xd7, 0x0e, 0x9a, 0xb5, 0xea, 0x52, 0x0a, 0x5f, 0x82, 0x0b, 0x51,
	0xdf, 0x6f, 0xd6, 0x0f, 0xf7, 0xaa, 0xd2, 0xf6, 0xcd, 0xfd, 0xa5, 0x34, 0x7e, 0x0a, 0x9e, 0x8c,
	0x86, 0xd8, 0xae, 0x5f, 0xaf, 0x55, 0x97, 0x32, 0xc2, 0x87, 0x08, 0x66, 0xaf, 0x59, 0xfb, 0x6d,
	0x17, 0xbf, 0x0e, 0x05, 0xff, 0xde, 0x21, 0x6b, 0x2a, 0x4f, 0xcf, 0x2b, 0xc9, 0x7c, 0x55, 0x57,
	0x25, 0xb0, 0xfa, 0x11, 0x0c, 0x52, 0x31, 0x35, 0x69, 0x2a, 0x0a, 0xb7, 0x60, 0xde, 0x9f, 0x3f,
	0xb0, 0x88, 0x41, 0x53, 0x33, 0xb8, 0x35, 0xa1, 0x24, 0xa9, 0xe9, 0xa3, 0xf4, 0x6f, 0x59, 0xc2,
	0x71, 0x3f, 0x61, 0x76, 0x68, 0x36, 0x3e, 0x02, 0x57, 0x08, 0x7f, 0x44, 0xb0, 0xe4, 0x7f, 0xba,
	0xa9, 0xb9, 0x1d, 0xd5, 0x56, 0xee, 0x3e, 0x0a, 0x97, 0xbf, 0x0d, 0xcb, 0xfe, 0x96, 0x0b, 0x3f,
	0x2e, 0xa5, 0xc6, 0x7b, 0x5c, 0xc2, 0x3e, 0x56, 0x7f, 0x4e, 0xf8, 0x14, 0xc1, 0x72, 0xe0, 0x44,
	0x72, 0x57, 0xb1, 0x55, 0xaf, 0x0d, 0x7e, 0x04, 0xc6, 0xbc, 0x05, 0xd8, 0x66, 0x2b, 0x4c, 0xc3,
	0x96, 0x73, 0x1c, 0x2a, 0x64, 0xca, 0x07, 0xfc, 0xa2, 0x5f, 0x3b, 0x25, 0xad, 0x1e, 0xab, 0xcd,
	0xaf, 0xc3, 0x9c, 0x6b, 0x2b, 0x2d, 0xe2, 0xac, 0xa2, 0x8b, 0xe9, 0xf8, 0xe7, 0xe8, 0x00, 0x08,
	0x2d, 0xd6, 0x2d, 0x22, 0x71, 0x20, 0xfc, 0x02, 0x2d, 0x63, 0x56, 0xcf, 0xe7, 0xfd, 0xf4, 0xc3,
	0x79, 0xdf, 0x50, 0xf4, 0x1e, 0x91, 0x3c, 0x0d, 0xbc, 0x05, 0x73, 0x5e, 0xeb, 0xce, 0x6b, 0x79,
	0x2c, 0x5d, 0xae, 0x52, 0xac, 0xc0, 0x2c, 0x23, 0x42, 0x09, 0x9c, 0xd0, 0x2f, 0xdc, 0xa4, 0x78,
	0x04, 0x98, 0x86, 0xf0, 0x6f, 0x04, 0x2b, 0xc3, 0x59, 0xcb, 0x1e, 0x44, 0xc2, 0x27, 0x03, 0x9a,
	0xf0, 0x64, 0x18, 0x4a, 0x9c, 0xd4, 0x14, 0x12, 0xc7, 0x6f, 0x5c, 0xd2, 0x93, 0x35, 0x2e, 0x04,
	0xbe, 0x12, 0x91, 0xe9, 0xd3, 0x76, 0x00, 0xad, 0xc1, 0xc5, 0xa8, 0xd7, 0x1a, 0x72, 0xa7, 0x47,
	0x1c, 0x17, 0x3f, 0x01, 0xb9, 0x56, 0x47, 0xd1, 0x82, 0x5d, 0x95, 0x97, 0xb2, 0x6c, 0x5c, 0x57,
	0x43, 0xfd, 0x6a, 0xea, 0xa1, 0xfd, 0x6a, 0x7a, 0x1a, 0xfd, 0xaa, 0xa0, 0xc3, 0x93, 0x91, 0x34,
	0x1d, 0xcb, 0x34, 0x1c, 0x82, 0xaf, 0x43, 0x86, 0xbd, 0x52, 0xa1, 0x49, 0x5f, 0xa9, 0x18, 0x8c,
	0xf0, 0x5b, 0x04, 0x2b, 0x03, 0xfb, 0x6a, 0x02, 0x7f, 0x1c, 0x45, 0xfa, 0x23, 0x26, 0xc5, 0x88,
	0x4b, 0xe3, 0xa0, 0x5f, 0x1c, 0x38, 0x3f, 0x44, 0x94, 0x7b, 0xc4, 0x7f, 0xe9, 0x21, 0xfe, 0x97,
	0xe4, 0xcf, 0x86, 0x7d, 0x50, 0xf6, 0xd2, 0x13, 0x0c, 0x85, 0x3d, 0x58, 0xde, 0xb6, 0x8f, 0xa7,
	0xe0, 0x1c, 0xe1, 0x3d, 0x04, 0x2b, 0x83, 0x50, 0x8f, 0x9e, 0xfe, 0x48, 0x32, 0x9f, 0xa3, 0x21,
	0x67, 0x3a, 0x31, 0x2c, 0xbb, 0x04, 0xf3, 0xec, 0x0a, 0x25, 0x0f, 0x40, 0x16, 0xd8, 0x9c, 0x77,
	0x6f, 0xc2, 0x17, 0x00, 0x88, 0xa1, 0xfa, 0x02, 0x69, 0x26, 0x90, 0x27, 0x86, 0xba, 0x17, 0x9d,
	0x20, 0x99, 0xa9, 0x26, 0xc8, 0x17, 0x08, 0x1e, 0x1f, 0x36, 0xea, 0xcb, 0xf3, 0xf1, 0x23, 0xdf,
	0x0d, 0x03, 0xd9, 0xf4, 0x3f, 0x89, 0x1f, 0xbd, 0x62, 0x9e, 0x1f, 0x5a, 0xf5, 0x4b, 0x4c, 0xe2,
	0x37, 0xe1, 0x89, 0x6b, 0xda, 0x9d, 0x9e, 0xa6, 0x6a, 0xee, 0x99, 0x7f, 0x80, 0xc4, 0xf1, 0xc3,
	0x33, 0xb0, 0xa8, 0x19, 0x2d, 0xbd, 0xa7, 0x12, 0x99, 0x5d, 0x8b, 0x54, 0x96, 0x87, 0x39, 0x69,
	0x81, 0xcf, 0xb2, 0xee, 0x54, 0x15, 0xde, 0x86, 0x62, 0x14, 0x3c, 0x37, 0xb8, 0x32, 0x50, 0x86,
	0x93, 0x76, 0xc5, 0x5e, 0xed, 0xfd, 0x09, 0x82, 0xaf, 0x3e, 0xb0, 0x44, 0xe5, 0xac, 0xae, 0xc6,
	0x30, 0x62, 0xfa, 0xc7, 0xb9, 0xd0, 0x82, 0x0b, 0x23, 0xd8, 0x4c, 0xd1, 0xe6, 0xf7, 0x51, 0xc4,
	0x2a, 0xce, 0xb8, 0x46, 0xa7, 0x27, 0x36, 0x5a, 0x85, 0xb5, 0x51, 0x74, 0xa6, 0x68, 0xf5, 0xc7,
	0x08, 0x2e, 0x46, 0x2d, 0xd3, 0xb0, 0xb5, 0x16, 0x89, 0x61, 0xf8, 0x70, 0x2d, 0x49, 0x4d, 0xb3,
	0x96, 0xe0, 0x15, 0x98, 0xd5, 0xb5, 0xae, 0xe6, 0xb2, 0xc7, 0x82, 0x8c, 0xe4, 0x0d, 0x84, 0xdb,
	0x70, 0xe9, 0x21, 0x94, 0xa7, 0xe8, 0x9c, 0x1f, 0x22, 0x58, 0x68, 0x5a, 0x36, 0x51, 0xe2, 0xa4,
	0xc0, 0x61, 0xa4, 0x27, 0x26, 0xed, 0xb9, 0x3e, 0x4f, 0xc1, 0xa2, 0x4f, 0x81, 0x5b, 0xf6, 0x16,
	0xac, 0x1c, 0x13, 0xc7, 0x95, 0xcb, 0xb2, 0x6b, 0xca, 0xa2, 0x3c, 0xe1, 0x35, 0x78, 0x89, 0x62,
	0x95, 0x0f, 0x4d, 0x31, 0x78, 0x9f, 0xf2, 0xf1, 0x45, 0x8a, 0x5f, 0x96, 0x07, 0x7e, 0x9c, 0x1c,
	0x13, 0x5f, 0x3c, 0x34, 0xcb, 0x01, 0xfe, 0xcb, 0x70, 0x41, 0xb1, 0x2c, 0xdb, 0x3c, 0x95, 0x49,
	0xbb, 0x4d, 0x5a, 0xae, 0x76, 0x42, 0x64, 0x8b, 0xc6, 0x8e, 0x5b, 0xc4, 0xaa, 0x3b, 0x92, 0x56,
	0x3d, 0xa1, 0x9a, 0x2f, 0xc3, 0xc2, 0x4b, 0x89, 0x3e, 0x04, 0xc0, 0xa3, 0xcc, 0xaa, 0xe6, 0x08,
	0x00, 0xca, 0x44, 0xf8, 0x57, 0x1a, 0x56, 0x9a, 0x5a, 0xb7, 0xa7, 0x2b, 0x2e, 0x7b, 0x94, 0x0c,
	0x12, 0x3d, 0xb8, 0xab, 0xa1, 0xc4, 0x77, 0xb5, 0x17, 0x83, 0xbb, 0x5a, 0xb2, 0x5f, 0x27, 0x3c,
	0x25, 0x7c, 0x04, 0x59, 0xdb, 0xec, 0xb9, 0x9a, 0x71, 0x9b, 0x1f, 0xc7, 0x95, 0x98, 0xe7, 0x53,
	0x84, 0x19, 0x25, 0xc9, 0x43, 0x92, 0x7c, 0x48, 0xf6, 0xf3, 0x17, 0x9f, 0xc4, 0x6d, 0xc8, 0xaa,
	0xa4, 0xad, 0xf4, 0x74, 0xdf, 0xca, 0x57, 0x27, 0x5f, 0xa9, 0x54, 0xf5, 0x10, 0xf7, 0x66, 0x24,
	0x1f, 0x1c, 0x77, 0x01, 0x1c, 0xcd, 0xb8, 0xad, 0x13, 0xb9, 0x63, 0xfa, 0x8f, 0xba, 0xd7, 0xa6,
	0xb0, 0x54, 0x93, 0x81, 0xee, 0x99, 0xd6, 0xde, 0x8c, 0x94, 0x77, 0xfc, 0x41, 0xb1, 0x00, 0xf9,
	0xe0, 0x4b, 0x31, 0x0f, 0x59, 0xce, 0xa8, 0x92, 0x87, 0xac, 0x43, 0x5c, 0xaa, 0x29, 0xa8, 0x70,
	0x7e, 0x08, 0x99, 0xef, 0xa8, 0xd7, 0x82, 0xd8, 0x4d, 0xd0, 0x1b, 0x70, 0x08, 0xf1, 0x9f, 0x05,
	0x98, 0x7f, 0xbd, 0x47, 0xec, 0xb3, 0x26, 0xb1, 0x4f, 0xb4, 0x16, 0xc1, 0xbf, 0x44, 0xd1, 0x3f,
	0xf5, 0xbc, 0x32, 0xfe, 0x0d, 0xc9, 0x73, 0x49, 0x71, 0x7b, 0x02, 0x04, 0x6e, 0xfa, 0x8f, 0xd0,
	0xf0, 0x13, 0xc8, 0xe6, 0x38, 0xc6, 0x73, 0x42, 0x5b, 0x63, 0xe9, 0x72, 0x2a, 0xef, 0x22, 0x98,
	0x0f, 0xf7, 0x70, 0x38, 0xe6, 0x29, 0x12, 0x71, 0x0d, 0x2a, 0x6e, 0x8e, 0xa3, 0xca, 0x79, 0xbc,
	0x8f, 0x60, 0x71, 0xb0, 0x5b, 0xc7, 0xe3, 0xd8, 0xe5, 0x37, 0x7c, 0xc5, 0xef, 0x8e, 0xa7, 0xec,
	0xb1, 0xb9, 0x82, 0xf0, 0x7b, 0x08, 0x16, 0x06, 0x7a, 0x5b, 0x3c, 0x86, 0x75, 0x4e, 0xc2, 0x10,
	0x45, 0x36, 0xd3, 0x57, 0x10, 0xfe, 0x05, 0x02, 0xfc, 0xe0, 0xe1, 0x8b, 0x5f, 0x8e, 0x87, 0x3a,
	0xb2, 0x2b, 0x2e, 0xbe, 0x32, 0x3e, 0x40, 0xc0, 0xed, 0x57, 0x08, 0xce, 0x47, 0xf6, 0x89, 0xb8,
	0x32, 0x26, 0x7a, 0xa8, 0xfb, 0x2b, 0xee, 0x4c, 0x84, 0xc1, 0x73, 0xeb, 0x43, 0x04, 0x8f, 0x47,
	0x77, 0x75, 0x78, 0x5c, 0xfc, 0x70, 0x8b, 0x5a, 0xac, 0x4e, 0x06, 0x12, 0xb8, 0xf2, 0x23, 0x14,
	0x75, 0x85, 0xe1, 0x3d, 0x16, 0xde, 0x1d, 0x7f, 0x95, 0x70, 0x5f, 0x59, 0xbc, 0x3a, 0x31, 0x4e,
	0x40, 0xd8, 0x81, 0x39, 0xaf, 0x4d, 0xc2, 0x71, 0x8b, 0x77, 0xb8, 0xaf, 0x2b, 0x7e, 0x33, 0x99,
	0x92, 0xb7, 0xac, 0xf8, 0x01, 0x82, 0x73, 0xfc, 0x44, 0xd1, 0x4c, 0xc3, 0xaf, 0xf7, 0xac, 0xa4,
	0x86, 0xcf, 0x99, 0xd8, 0x25, 0x35, 0xe2, 0xd8, 0x8b, 0x5d, 0x52, 0xa3, 0x0e, 0xb6, 0xca, 0xdf,
	0x53, 0x9f, 0xde, 0x5b, 0x43, 0x9f, 0xdd, 0x5b, 0x43, 0xff, 0xb8, 0xb7, 0x86, 0x7e, 0x76, 0x7f,
	0x6d, 0xe6, 0xb3, 0xfb, 0x6b, 0x33, 0x7f, 0xb9, 0xbf, 0x36, 0x03, 0xeb, 0x2d, 0xb3, 0x1b, 0x0b,
	0xba, 0x92, 0xab, 0x92, 0xd3, 0x86, 0x6d, 0xba, 0x66, 0x03, 0xdd, 0x3a, 0xba, 0xad, 0xb9, 0x9d,
	0xde, 0x31, 0x15, 0xdd, 0x68, 0x99, 0x4e, 0xd7, 0x74, 0x36, 0x6c, 0xa2, 0x2b, 0x67, 0xc4, 0xde,
	0x38, 0x11, 0x83, 0x3f, 0x59, 0x4b, 0xec, 0x6c, 0xc4, 0xf9, 0x8f, 0x0c, 0x5b, 0x2a, 0x39, 0xf5,
	0xff, 0xfe, 0x75, 0x2a, 0xd3, 0xd8, 0xd9, 0xa9, 0xfe, 0x2e, 0x75, 0xb9, 0xe1, 0xf3, 0xda, 0xa1,
	0xbc, 0x76, 0x02, 0x5e, 0x55, 0x72, 0x5a, 0xba, 0xc1, 0xa5, 0xff, 0xdc, 0x17, 0x3b, 0xa2, 0x62,
	0x47, 0x81, 0xd8, 0x51, 0x95, 0x9c, 0x1e, 0xf9, 0x62, 0xf7, 0x52, 0x57, 0xe2, 0x88, 0x1d, 0x5d,
	0x6d, 0x54, 0xae, 0x13, 0x57, 0xa1, 0x7d, 0xff, 0x17, 0xa9, 0x75, 0x5f, 0x65, 0x73, 0x93, 0xea,
	0xd0, 0x7f, 0xb9, 0xd2, 0xe6, 0x66, 0x95, 0x9c, 0x6e, 0x6e, 0xfa, 0x6a, 0xc7, 0x73, 0xec, 0xbf,
	0x06, 0x3c, 0xf7, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xf2, 0xf1, 0x71, 0xaf, 0xb6, 0x31, 0x00,
	0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QueryServiceClient is the client API for QueryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryServiceClient interface {
	// Get the batch clearing prices for a specific block height and trading pair.
	BatchSwapOutputData(ctx context.Context, in *BatchSwapOutputDataRequest, opts ...grpc.CallOption) (*BatchSwapOutputDataResponse, error)
	// Get the precise swap execution used for a specific batch swap.
	SwapExecution(ctx context.Context, in *SwapExecutionRequest, opts ...grpc.CallOption) (*SwapExecutionResponse, error)
	// Get the precise execution used to perform on-chain arbitrage.
	ArbExecution(ctx context.Context, in *ArbExecutionRequest, opts ...grpc.CallOption) (*ArbExecutionResponse, error)
	// Stream all swap executions over a range of heights, optionally subscribing to future executions.
	SwapExecutions(ctx context.Context, in *SwapExecutionsRequest, opts ...grpc.CallOption) (QueryService_SwapExecutionsClient, error)
	// Stream all arbitrage executions over a range of heights, optionally subscribing to future executions.
	ArbExecutions(ctx context.Context, in *ArbExecutionsRequest, opts ...grpc.CallOption) (QueryService_ArbExecutionsClient, error)
	// Query all liquidity positions on the DEX.
	LiquidityPositions(ctx context.Context, in *LiquidityPositionsRequest, opts ...grpc.CallOption) (QueryService_LiquidityPositionsClient, error)
	// Query liquidity positions by ID.
	//
	// To get multiple positions, use `LiquidityPositionsById`.
	LiquidityPositionById(ctx context.Context, in *LiquidityPositionByIdRequest, opts ...grpc.CallOption) (*LiquidityPositionByIdResponse, error)
	// Query multiple liquidity positions by ID.
	LiquidityPositionsById(ctx context.Context, in *LiquidityPositionsByIdRequest, opts ...grpc.CallOption) (QueryService_LiquidityPositionsByIdClient, error)
	// Query liquidity positions on a specific pair, sorted by effective price.
	LiquidityPositionsByPrice(ctx context.Context, in *LiquidityPositionsByPriceRequest, opts ...grpc.CallOption) (QueryService_LiquidityPositionsByPriceClient, error)
	// Get the current (direct) spread on a trading pair.
	//
	// This method doesn't do simulation, so actually executing might result in a
	// better price (if the chain takes a different route to the target asset).
	Spread(ctx context.Context, in *SpreadRequest, opts ...grpc.CallOption) (*SpreadResponse, error)
}

type queryServiceClient struct {
	cc grpc1.ClientConn
}

func NewQueryServiceClient(cc grpc1.ClientConn) QueryServiceClient {
	return &queryServiceClient{cc}
}

func (c *queryServiceClient) BatchSwapOutputData(ctx context.Context, in *BatchSwapOutputDataRequest, opts ...grpc.CallOption) (*BatchSwapOutputDataResponse, error) {
	out := new(BatchSwapOutputDataResponse)
	err := c.cc.Invoke(ctx, "/penumbra.core.component.dex.v1alpha1.QueryService/BatchSwapOutputData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryServiceClient) SwapExecution(ctx context.Context, in *SwapExecutionRequest, opts ...grpc.CallOption) (*SwapExecutionResponse, error) {
	out := new(SwapExecutionResponse)
	err := c.cc.Invoke(ctx, "/penumbra.core.component.dex.v1alpha1.QueryService/SwapExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryServiceClient) ArbExecution(ctx context.Context, in *ArbExecutionRequest, opts ...grpc.CallOption) (*ArbExecutionResponse, error) {
	out := new(ArbExecutionResponse)
	err := c.cc.Invoke(ctx, "/penumbra.core.component.dex.v1alpha1.QueryService/ArbExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryServiceClient) SwapExecutions(ctx context.Context, in *SwapExecutionsRequest, opts ...grpc.CallOption) (QueryService_SwapExecutionsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_QueryService_serviceDesc.Streams[0], "/penumbra.core.component.dex.v1alpha1.QueryService/SwapExecutions", opts...)
	if err != nil {
		return nil, err
	}
	x := &queryServiceSwapExecutionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type QueryService_SwapExecutionsClient interface {
	Recv() (*SwapExecutionsResponse, error)
	grpc.ClientStream
}

type queryServiceSwapExecutionsClient struct {
	grpc.ClientStream
}

func (x *queryServiceSwapExecutionsClient) Recv() (*SwapExecutionsResponse, error) {
	m := new(SwapExecutionsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queryServiceClient) ArbExecutions(ctx context.Context, in *ArbExecutionsRequest, opts ...grpc.CallOption) (QueryService_ArbExecutionsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_QueryService_serviceDesc.Streams[1], "/penumbra.core.component.dex.v1alpha1.QueryService/ArbExecutions", opts...)
	if err != nil {
		return nil, err
	}
	x := &queryServiceArbExecutionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type QueryService_ArbExecutionsClient interface {
	Recv() (*ArbExecutionsResponse, error)
	grpc.ClientStream
}

type queryServiceArbExecutionsClient struct {
	grpc.ClientStream
}

func (x *queryServiceArbExecutionsClient) Recv() (*ArbExecutionsResponse, error) {
	m := new(ArbExecutionsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queryServiceClient) LiquidityPositions(ctx context.Context, in *LiquidityPositionsRequest, opts ...grpc.CallOption) (QueryService_LiquidityPositionsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_QueryService_serviceDesc.Streams[2], "/penumbra.core.component.dex.v1alpha1.QueryService/LiquidityPositions", opts...)
	if err != nil {
		return nil, err
	}
	x := &queryServiceLiquidityPositionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type QueryService_LiquidityPositionsClient interface {
	Recv() (*LiquidityPositionsResponse, error)
	grpc.ClientStream
}

type queryServiceLiquidityPositionsClient struct {
	grpc.ClientStream
}

func (x *queryServiceLiquidityPositionsClient) Recv() (*LiquidityPositionsResponse, error) {
	m := new(LiquidityPositionsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queryServiceClient) LiquidityPositionById(ctx context.Context, in *LiquidityPositionByIdRequest, opts ...grpc.CallOption) (*LiquidityPositionByIdResponse, error) {
	out := new(LiquidityPositionByIdResponse)
	err := c.cc.Invoke(ctx, "/penumbra.core.component.dex.v1alpha1.QueryService/LiquidityPositionById", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryServiceClient) LiquidityPositionsById(ctx context.Context, in *LiquidityPositionsByIdRequest, opts ...grpc.CallOption) (QueryService_LiquidityPositionsByIdClient, error) {
	stream, err := c.cc.NewStream(ctx, &_QueryService_serviceDesc.Streams[3], "/penumbra.core.component.dex.v1alpha1.QueryService/LiquidityPositionsById", opts...)
	if err != nil {
		return nil, err
	}
	x := &queryServiceLiquidityPositionsByIdClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type QueryService_LiquidityPositionsByIdClient interface {
	Recv() (*LiquidityPositionsByIdResponse, error)
	grpc.ClientStream
}

type queryServiceLiquidityPositionsByIdClient struct {
	grpc.ClientStream
}

func (x *queryServiceLiquidityPositionsByIdClient) Recv() (*LiquidityPositionsByIdResponse, error) {
	m := new(LiquidityPositionsByIdResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queryServiceClient) LiquidityPositionsByPrice(ctx context.Context, in *LiquidityPositionsByPriceRequest, opts ...grpc.CallOption) (QueryService_LiquidityPositionsByPriceClient, error) {
	stream, err := c.cc.NewStream(ctx, &_QueryService_serviceDesc.Streams[4], "/penumbra.core.component.dex.v1alpha1.QueryService/LiquidityPositionsByPrice", opts...)
	if err != nil {
		return nil, err
	}
	x := &queryServiceLiquidityPositionsByPriceClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type QueryService_LiquidityPositionsByPriceClient interface {
	Recv() (*LiquidityPositionsByPriceResponse, error)
	grpc.ClientStream
}

type queryServiceLiquidityPositionsByPriceClient struct {
	grpc.ClientStream
}

func (x *queryServiceLiquidityPositionsByPriceClient) Recv() (*LiquidityPositionsByPriceResponse, error) {
	m := new(LiquidityPositionsByPriceResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queryServiceClient) Spread(ctx context.Context, in *SpreadRequest, opts ...grpc.CallOption) (*SpreadResponse, error) {
	out := new(SpreadResponse)
	err := c.cc.Invoke(ctx, "/penumbra.core.component.dex.v1alpha1.QueryService/Spread", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueryServiceServer is the server API for QueryService service.
type QueryServiceServer interface {
	// Get the batch clearing prices for a specific block height and trading pair.
	BatchSwapOutputData(context.Context, *BatchSwapOutputDataRequest) (*BatchSwapOutputDataResponse, error)
	// Get the precise swap execution used for a specific batch swap.
	SwapExecution(context.Context, *SwapExecutionRequest) (*SwapExecutionResponse, error)
	// Get the precise execution used to perform on-chain arbitrage.
	ArbExecution(context.Context, *ArbExecutionRequest) (*ArbExecutionResponse, error)
	// Stream all swap executions over a range of heights, optionally subscribing to future executions.
	SwapExecutions(*SwapExecutionsRequest, QueryService_SwapExecutionsServer) error
	// Stream all arbitrage executions over a range of heights, optionally subscribing to future executions.
	ArbExecutions(*ArbExecutionsRequest, QueryService_ArbExecutionsServer) error
	// Query all liquidity positions on the DEX.
	LiquidityPositions(*LiquidityPositionsRequest, QueryService_LiquidityPositionsServer) error
	// Query liquidity positions by ID.
	//
	// To get multiple positions, use `LiquidityPositionsById`.
	LiquidityPositionById(context.Context, *LiquidityPositionByIdRequest) (*LiquidityPositionByIdResponse, error)
	// Query multiple liquidity positions by ID.
	LiquidityPositionsById(*LiquidityPositionsByIdRequest, QueryService_LiquidityPositionsByIdServer) error
	// Query liquidity positions on a specific pair, sorted by effective price.
	LiquidityPositionsByPrice(*LiquidityPositionsByPriceRequest, QueryService_LiquidityPositionsByPriceServer) error
	// Get the current (direct) spread on a trading pair.
	//
	// This method doesn't do simulation, so actually executing might result in a
	// better price (if the chain takes a different route to the target asset).
	Spread(context.Context, *SpreadRequest) (*SpreadResponse, error)
}

// UnimplementedQueryServiceServer can be embedded to have forward compatible implementations.
type UnimplementedQueryServiceServer struct {
}

func (*UnimplementedQueryServiceServer) BatchSwapOutputData(ctx context.Context, req *BatchSwapOutputDataRequest) (*BatchSwapOutputDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchSwapOutputData not implemented")
}
func (*UnimplementedQueryServiceServer) SwapExecution(ctx context.Context, req *SwapExecutionRequest) (*SwapExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SwapExecution not implemented")
}
func (*UnimplementedQueryServiceServer) ArbExecution(ctx context.Context, req *ArbExecutionRequest) (*ArbExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ArbExecution not implemented")
}
func (*UnimplementedQueryServiceServer) SwapExecutions(req *SwapExecutionsRequest, srv QueryService_SwapExecutionsServer) error {
	return status.Errorf(codes.Unimplemented, "method SwapExecutions not implemented")
}
func (*UnimplementedQueryServiceServer) ArbExecutions(req *ArbExecutionsRequest, srv QueryService_ArbExecutionsServer) error {
	return status.Errorf(codes.Unimplemented, "method ArbExecutions not implemented")
}
func (*UnimplementedQueryServiceServer) LiquidityPositions(req *LiquidityPositionsRequest, srv QueryService_LiquidityPositionsServer) error {
	return status.Errorf(codes.Unimplemented, "method LiquidityPositions not implemented")
}
func (*UnimplementedQueryServiceServer) LiquidityPositionById(ctx context.Context, req *LiquidityPositionByIdRequest) (*LiquidityPositionByIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LiquidityPositionById not implemented")
}
func (*UnimplementedQueryServiceServer) LiquidityPositionsById(req *LiquidityPositionsByIdRequest, srv QueryService_LiquidityPositionsByIdServer) error {
	return status.Errorf(codes.Unimplemented, "method LiquidityPositionsById not implemented")
}
func (*UnimplementedQueryServiceServer) LiquidityPositionsByPrice(req *LiquidityPositionsByPriceRequest, srv QueryService_LiquidityPositionsByPriceServer) error {
	return status.Errorf(codes.Unimplemented, "method LiquidityPositionsByPrice not implemented")
}
func (*UnimplementedQueryServiceServer) Spread(ctx context.Context, req *SpreadRequest) (*SpreadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Spread not implemented")
}

func RegisterQueryServiceServer(s grpc1.Server, srv QueryServiceServer) {
	s.RegisterService(&_QueryService_serviceDesc, srv)
}

func _QueryService_BatchSwapOutputData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchSwapOutputDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServiceServer).BatchSwapOutputData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/penumbra.core.component.dex.v1alpha1.QueryService/BatchSwapOutputData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServiceServer).BatchSwapOutputData(ctx, req.(*BatchSwapOutputDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueryService_SwapExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SwapExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServiceServer).SwapExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/penumbra.core.component.dex.v1alpha1.QueryService/SwapExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServiceServer).SwapExecution(ctx, req.(*SwapExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueryService_ArbExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArbExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServiceServer).ArbExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/penumbra.core.component.dex.v1alpha1.QueryService/ArbExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServiceServer).ArbExecution(ctx, req.(*ArbExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueryService_SwapExecutions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SwapExecutionsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryServiceServer).SwapExecutions(m, &queryServiceSwapExecutionsServer{stream})
}

type QueryService_SwapExecutionsServer interface {
	Send(*SwapExecutionsResponse) error
	grpc.ServerStream
}

type queryServiceSwapExecutionsServer struct {
	grpc.ServerStream
}

func (x *queryServiceSwapExecutionsServer) Send(m *SwapExecutionsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _QueryService_ArbExecutions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ArbExecutionsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryServiceServer).ArbExecutions(m, &queryServiceArbExecutionsServer{stream})
}

type QueryService_ArbExecutionsServer interface {
	Send(*ArbExecutionsResponse) error
	grpc.ServerStream
}

type queryServiceArbExecutionsServer struct {
	grpc.ServerStream
}

func (x *queryServiceArbExecutionsServer) Send(m *ArbExecutionsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _QueryService_LiquidityPositions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(LiquidityPositionsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryServiceServer).LiquidityPositions(m, &queryServiceLiquidityPositionsServer{stream})
}

type QueryService_LiquidityPositionsServer interface {
	Send(*LiquidityPositionsResponse) error
	grpc.ServerStream
}

type queryServiceLiquidityPositionsServer struct {
	grpc.ServerStream
}

func (x *queryServiceLiquidityPositionsServer) Send(m *LiquidityPositionsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _QueryService_LiquidityPositionById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LiquidityPositionByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServiceServer).LiquidityPositionById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/penumbra.core.component.dex.v1alpha1.QueryService/LiquidityPositionById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServiceServer).LiquidityPositionById(ctx, req.(*LiquidityPositionByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueryService_LiquidityPositionsById_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(LiquidityPositionsByIdRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryServiceServer).LiquidityPositionsById(m, &queryServiceLiquidityPositionsByIdServer{stream})
}

type QueryService_LiquidityPositionsByIdServer interface {
	Send(*LiquidityPositionsByIdResponse) error
	grpc.ServerStream
}

type queryServiceLiquidityPositionsByIdServer struct {
	grpc.ServerStream
}

func (x *queryServiceLiquidityPositionsByIdServer) Send(m *LiquidityPositionsByIdResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _QueryService_LiquidityPositionsByPrice_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(LiquidityPositionsByPriceRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryServiceServer).LiquidityPositionsByPrice(m, &queryServiceLiquidityPositionsByPriceServer{stream})
}

type QueryService_LiquidityPositionsByPriceServer interface {
	Send(*LiquidityPositionsByPriceResponse) error
	grpc.ServerStream
}

type queryServiceLiquidityPositionsByPriceServer struct {
	grpc.ServerStream
}

func (x *queryServiceLiquidityPositionsByPriceServer) Send(m *LiquidityPositionsByPriceResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _QueryService_Spread_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SpreadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServiceServer).Spread(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/penumbra.core.component.dex.v1alpha1.QueryService/Spread",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServiceServer).Spread(ctx, req.(*SpreadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _QueryService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "penumbra.core.component.dex.v1alpha1.QueryService",
	HandlerType: (*QueryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "BatchSwapOutputData",
			Handler:    _QueryService_BatchSwapOutputData_Handler,
		},
		{
			MethodName: "SwapExecution",
			Handler:    _QueryService_SwapExecution_Handler,
		},
		{
			MethodName: "ArbExecution",
			Handler:    _QueryService_ArbExecution_Handler,
		},
		{
			MethodName: "LiquidityPositionById",
			Handler:    _QueryService_LiquidityPositionById_Handler,
		},
		{
			MethodName: "Spread",
			Handler:    _QueryService_Spread_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SwapExecutions",
			Handler:       _QueryService_SwapExecutions_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ArbExecutions",
			Handler:       _QueryService_ArbExecutions_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "LiquidityPositions",
			Handler:       _QueryService_LiquidityPositions_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "LiquidityPositionsById",
			Handler:       _QueryService_LiquidityPositionsById_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "LiquidityPositionsByPrice",
			Handler:       _QueryService_LiquidityPositionsByPrice_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "penumbra/core/component/dex/v1alpha1/dex.proto",
}

// SimulationServiceClient is the client API for SimulationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SimulationServiceClient interface {
	// Simulate routing and trade execution.
	SimulateTrade(ctx context.Context, in *SimulateTradeRequest, opts ...grpc.CallOption) (*SimulateTradeResponse, error)
}

type simulationServiceClient struct {
	cc grpc1.ClientConn
}

func NewSimulationServiceClient(cc grpc1.ClientConn) SimulationServiceClient {
	return &simulationServiceClient{cc}
}

func (c *simulationServiceClient) SimulateTrade(ctx context.Context, in *SimulateTradeRequest, opts ...grpc.CallOption) (*SimulateTradeResponse, error) {
	out := new(SimulateTradeResponse)
	err := c.cc.Invoke(ctx, "/penumbra.core.component.dex.v1alpha1.SimulationService/SimulateTrade", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SimulationServiceServer is the server API for SimulationService service.
type SimulationServiceServer interface {
	// Simulate routing and trade execution.
	SimulateTrade(context.Context, *SimulateTradeRequest) (*SimulateTradeResponse, error)
}

// UnimplementedSimulationServiceServer can be embedded to have forward compatible implementations.
type UnimplementedSimulationServiceServer struct {
}

func (*UnimplementedSimulationServiceServer) SimulateTrade(ctx context.Context, req *SimulateTradeRequest) (*SimulateTradeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SimulateTrade not implemented")
}

func RegisterSimulationServiceServer(s grpc1.Server, srv SimulationServiceServer) {
	s.RegisterService(&_SimulationService_serviceDesc, srv)
}

func _SimulationService_SimulateTrade_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SimulateTradeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SimulationServiceServer).SimulateTrade(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/penumbra.core.component.dex.v1alpha1.SimulationService/SimulateTrade",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SimulationServiceServer).SimulateTrade(ctx, req.(*SimulateTradeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _SimulationService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "penumbra.core.component.dex.v1alpha1.SimulationService",
	HandlerType: (*SimulationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SimulateTrade",
			Handler:    _SimulationService_SimulateTrade_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "penumbra/core/component/dex/v1alpha1/dex.proto",
}

func (m *ZKSwapProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZKSwapProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZKSwapProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Inner) > 0 {
		i -= len(m.Inner)
		copy(dAtA[i:], m.Inner)
		i = encodeVarintDex(dAtA, i, uint64(len(m.Inner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ZKSwapClaimProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZKSwapClaimProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZKSwapClaimProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Inner) > 0 {
		i -= len(m.Inner)
		copy(dAtA[i:], m.Inner)
		i = encodeVarintDex(dAtA, i, uint64(len(m.Inner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Swap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Swap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Swap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Body != nil {
		{
			size, err := m.Body.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Proof != nil {
		{
			size, err := m.Proof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwapClaim) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EpochDuration != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.EpochDuration))
		i--
		dAtA[i] = 0x38
	}
	if m.Body != nil {
		{
			size, err := m.Body.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Proof != nil {
		{
			size, err := m.Proof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwapClaimBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapClaimBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapClaimBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OutputData != nil {
		{
			size, err := m.OutputData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Output_2Commitment != nil {
		{
			size, err := m.Output_2Commitment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Output_1Commitment != nil {
		{
			size, err := m.Output_1Commitment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Fee != nil {
		{
			size, err := m.Fee.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Nullifier != nil {
		{
			size, err := m.Nullifier.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwapBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.FeeCommitment != nil {
		{
			size, err := m.FeeCommitment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Delta_2I != nil {
		{
			size, err := m.Delta_2I.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Delta_1I != nil {
		{
			size, err := m.Delta_1I.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TradingPair != nil {
		{
			size, err := m.TradingPair.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwapPayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapPayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapPayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EncryptedSwap) > 0 {
		i -= len(m.EncryptedSwap)
		copy(dAtA[i:], m.EncryptedSwap)
		i = encodeVarintDex(dAtA, i, uint64(len(m.EncryptedSwap)))
		i--
		dAtA[i] = 0x12
	}
	if m.Commitment != nil {
		{
			size, err := m.Commitment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwapPlaintext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapPlaintext) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapPlaintext) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Rseed) > 0 {
		i -= len(m.Rseed)
		copy(dAtA[i:], m.Rseed)
		i = encodeVarintDex(dAtA, i, uint64(len(m.Rseed)))
		i--
		dAtA[i] = 0x32
	}
	if m.ClaimAddress != nil {
		{
			size, err := m.ClaimAddress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.ClaimFee != nil {
		{
			size, err := m.ClaimFee.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Delta_2I != nil {
		{
			size, err := m.Delta_2I.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Delta_1I != nil {
		{
			size, err := m.Delta_1I.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TradingPair != nil {
		{
			size, err := m.TradingPair.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwapPlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapPlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapPlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProofBlindingS) > 0 {
		i -= len(m.ProofBlindingS)
		copy(dAtA[i:], m.ProofBlindingS)
		i = encodeVarintDex(dAtA, i, uint64(len(m.ProofBlindingS)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ProofBlindingR) > 0 {
		i -= len(m.ProofBlindingR)
		copy(dAtA[i:], m.ProofBlindingR)
		i = encodeVarintDex(dAtA, i, uint64(len(m.ProofBlindingR)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.FeeBlinding) > 0 {
		i -= len(m.FeeBlinding)
		copy(dAtA[i:], m.FeeBlinding)
		i = encodeVarintDex(dAtA, i, uint64(len(m.FeeBlinding)))
		i--
		dAtA[i] = 0x12
	}
	if m.SwapPlaintext != nil {
		{
			size, err := m.SwapPlaintext.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwapClaimPlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapClaimPlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapClaimPlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProofBlindingS) > 0 {
		i -= len(m.ProofBlindingS)
		copy(dAtA[i:], m.ProofBlindingS)
		i = encodeVarintDex(dAtA, i, uint64(len(m.ProofBlindingS)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ProofBlindingR) > 0 {
		i -= len(m.ProofBlindingR)
		copy(dAtA[i:], m.ProofBlindingR)
		i = encodeVarintDex(dAtA, i, uint64(len(m.ProofBlindingR)))
		i--
		dAtA[i] = 0x2a
	}
	if m.EpochDuration != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.EpochDuration))
		i--
		dAtA[i] = 0x20
	}
	if m.OutputData != nil {
		{
			size, err := m.OutputData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Position != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.Position))
		i--
		dAtA[i] = 0x10
	}
	if m.SwapPlaintext != nil {
		{
			size, err := m.SwapPlaintext.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwapView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapView) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SwapView != nil {
		{
			size := m.SwapView.Size()
			i -= size
			if _, err := m.SwapView.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *SwapView_Visible_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapView_Visible_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Visible != nil {
		{
			size, err := m.Visible.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *SwapView_Opaque_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapView_Opaque_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Opaque != nil {
		{
			size, err := m.Opaque.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *SwapView_Visible) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapView_Visible) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapView_Visible) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SwapPlaintext != nil {
		{
			size, err := m.SwapPlaintext.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Swap != nil {
		{
			size, err := m.Swap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwapView_Opaque) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapView_Opaque) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapView_Opaque) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Swap != nil {
		{
			size, err := m.Swap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwapClaimView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapClaimView) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapClaimView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SwapClaimView != nil {
		{
			size := m.SwapClaimView.Size()
			i -= size
			if _, err := m.SwapClaimView.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *SwapClaimView_Visible_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapClaimView_Visible_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Visible != nil {
		{
			size, err := m.Visible.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *SwapClaimView_Opaque_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapClaimView_Opaque_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Opaque != nil {
		{
			size, err := m.Opaque.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *SwapClaimView_Visible) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapClaimView_Visible) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapClaimView_Visible) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Output_2 != nil {
		{
			size, err := m.Output_2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Output_1 != nil {
		{
			size, err := m.Output_1.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SwapClaim != nil {
		{
			size, err := m.SwapClaim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwapClaimView_Opaque) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapClaimView_Opaque) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapClaimView_Opaque) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SwapClaim != nil {
		{
			size, err := m.SwapClaim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TradingPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TradingPair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TradingPair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Asset_2 != nil {
		{
			size, err := m.Asset_2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Asset_1 != nil {
		{
			size, err := m.Asset_1.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DirectedTradingPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DirectedTradingPair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DirectedTradingPair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.End != nil {
		{
			size, err := m.End.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Start != nil {
		{
			size, err := m.Start.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BatchSwapOutputData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchSwapOutputData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchSwapOutputData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EpochStartingHeight != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.EpochStartingHeight))
		i--
		dAtA[i] = 0x48
	}
	if m.TradingPair != nil {
		{
			size, err := m.TradingPair.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Height != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x38
	}
	if m.Unfilled_2 != nil {
		{
			size, err := m.Unfilled_2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Unfilled_1 != nil {
		{
			size, err := m.Unfilled_1.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Lambda_2 != nil {
		{
			size, err := m.Lambda_2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Lambda_1 != nil {
		{
			size, err := m.Lambda_1.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Delta_2 != nil {
		{
			size, err := m.Delta_2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Delta_1 != nil {
		{
			size, err := m.Delta_1.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TradingFunction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TradingFunction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TradingFunction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pair != nil {
		{
			size, err := m.Pair.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Component != nil {
		{
			size, err := m.Component.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BareTradingFunction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BareTradingFunction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BareTradingFunction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Q != nil {
		{
			size, err := m.Q.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.P != nil {
		{
			size, err := m.P.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Fee != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.Fee))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Reserves) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Reserves) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Reserves) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.R2 != nil {
		{
			size, err := m.R2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.R1 != nil {
		{
			size, err := m.R1.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Position) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Position) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Position) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CloseOnFill {
		i--
		if m.CloseOnFill {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Reserves != nil {
		{
			size, err := m.Reserves.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.State != nil {
		{
			size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintDex(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0x12
	}
	if m.Phi != nil {
		{
			size, err := m.Phi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PositionId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PositionId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PositionId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AltBech32M) > 0 {
		i -= len(m.AltBech32M)
		copy(dAtA[i:], m.AltBech32M)
		i = encodeVarintDex(dAtA, i, uint64(len(m.AltBech32M)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Inner) > 0 {
		i -= len(m.Inner)
		copy(dAtA[i:], m.Inner)
		i = encodeVarintDex(dAtA, i, uint64(len(m.Inner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PositionState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PositionState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PositionState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LpNft) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LpNft) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LpNft) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != nil {
		{
			size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.PositionId != nil {
		{
			size, err := m.PositionId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PositionOpen) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PositionOpen) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PositionOpen) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Position != nil {
		{
			size, err := m.Position.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PositionClose) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PositionClose) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PositionClose) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PositionId != nil {
		{
			size, err := m.PositionId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PositionWithdraw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PositionWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PositionWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReservesCommitment != nil {
		{
			size, err := m.ReservesCommitment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.PositionId != nil {
		{
			size, err := m.PositionId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PositionRewardClaim) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PositionRewardClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PositionRewardClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RewardsCommitment != nil {
		{
			size, err := m.RewardsCommitment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.PositionId != nil {
		{
			size, err := m.PositionId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwapExecution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapExecution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapExecution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Output != nil {
		{
			size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Input != nil {
		{
			size, err := m.Input.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Traces) > 0 {
		for iNdEx := len(m.Traces) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Traces[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDex(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SwapExecution_Trace) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapExecution_Trace) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapExecution_Trace) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		for iNdEx := len(m.Value) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Value[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDex(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PositionWithdrawPlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PositionWithdrawPlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PositionWithdrawPlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pair != nil {
		{
			size, err := m.Pair.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PositionId != nil {
		{
			size, err := m.PositionId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Reserves != nil {
		{
			size, err := m.Reserves.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PositionRewardClaimPlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PositionRewardClaimPlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PositionRewardClaimPlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Reserves != nil {
		{
			size, err := m.Reserves.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BatchSwapOutputDataRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchSwapOutputDataRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchSwapOutputDataRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TradingPair != nil {
		{
			size, err := m.TradingPair.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Height != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintDex(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BatchSwapOutputDataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchSwapOutputDataResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchSwapOutputDataResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwapExecutionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapExecutionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapExecutionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TradingPair != nil {
		{
			size, err := m.TradingPair.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Height != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintDex(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwapExecutionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapExecutionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapExecutionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SwapExecution != nil {
		{
			size, err := m.SwapExecution.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ArbExecutionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArbExecutionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArbExecutionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Height != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintDex(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ArbExecutionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArbExecutionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArbExecutionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Height != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if m.SwapExecution != nil {
		{
			size, err := m.SwapExecution.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwapExecutionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapExecutionsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapExecutionsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TradingPair != nil {
		{
			size, err := m.TradingPair.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.EndHeight != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.EndHeight))
		i--
		dAtA[i] = 0x18
	}
	if m.StartHeight != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.StartHeight))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintDex(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwapExecutionsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapExecutionsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapExecutionsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TradingPair != nil {
		{
			size, err := m.TradingPair.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Height != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if m.SwapExecution != nil {
		{
			size, err := m.SwapExecution.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ArbExecutionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArbExecutionsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArbExecutionsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EndHeight != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.EndHeight))
		i--
		dAtA[i] = 0x18
	}
	if m.StartHeight != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.StartHeight))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintDex(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ArbExecutionsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArbExecutionsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArbExecutionsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Height != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if m.SwapExecution != nil {
		{
			size, err := m.SwapExecution.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LiquidityPositionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LiquidityPositionsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LiquidityPositionsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IncludeClosed {
		i--
		if m.IncludeClosed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintDex(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LiquidityPositionsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LiquidityPositionsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LiquidityPositionsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LiquidityPositionByIdRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LiquidityPositionByIdRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LiquidityPositionByIdRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PositionId != nil {
		{
			size, err := m.PositionId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintDex(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LiquidityPositionByIdResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LiquidityPositionByIdResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LiquidityPositionByIdResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LiquidityPositionsByIdRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LiquidityPositionsByIdRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LiquidityPositionsByIdRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PositionId) > 0 {
		for iNdEx := len(m.PositionId) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PositionId[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDex(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintDex(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LiquidityPositionsByIdResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LiquidityPositionsByIdResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LiquidityPositionsByIdResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LiquidityPositionsByPriceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LiquidityPositionsByPriceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LiquidityPositionsByPriceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Limit != 0 {
		i = encodeVarintDex(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x28
	}
	if m.TradingPair != nil {
		{
			size, err := m.TradingPair.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintDex(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LiquidityPositionsByPriceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LiquidityPositionsByPriceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LiquidityPositionsByPriceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpreadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpreadRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpreadRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TradingPair != nil {
		{
			size, err := m.TradingPair.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintDex(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpreadResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpreadResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpreadResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ApproxEffectivePrice_2To_1 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ApproxEffectivePrice_2To_1))))
		i--
		dAtA[i] = 0x21
	}
	if m.ApproxEffectivePrice_1To_2 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ApproxEffectivePrice_1To_2))))
		i--
		dAtA[i] = 0x19
	}
	if m.Best_2To_1Position != nil {
		{
			size, err := m.Best_2To_1Position.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Best_1To_2Position != nil {
		{
			size, err := m.Best_1To_2Position.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SimulateTradeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimulateTradeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimulateTradeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Routing != nil {
		{
			size, err := m.Routing.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Output != nil {
		{
			size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Input != nil {
		{
			size, err := m.Input.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SimulateTradeRequest_Routing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimulateTradeRequest_Routing) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimulateTradeRequest_Routing) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Setting != nil {
		{
			size := m.Setting.Size()
			i -= size
			if _, err := m.Setting.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *SimulateTradeRequest_Routing_Default_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimulateTradeRequest_Routing_Default_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Default != nil {
		{
			size, err := m.Default.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *SimulateTradeRequest_Routing_SingleHop_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimulateTradeRequest_Routing_SingleHop_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SingleHop != nil {
		{
			size, err := m.SingleHop.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *SimulateTradeRequest_Routing_SingleHop) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimulateTradeRequest_Routing_SingleHop) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimulateTradeRequest_Routing_SingleHop) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *SimulateTradeRequest_Routing_Default) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimulateTradeRequest_Routing_Default) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimulateTradeRequest_Routing_Default) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *SimulateTradeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimulateTradeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimulateTradeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Output != nil {
		{
			size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintDex(dAtA []byte, offset int, v uint64) int {
	offset -= sovDex(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ZKSwapProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Inner)
	if l > 0 {
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *ZKSwapClaimProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Inner)
	if l > 0 {
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *Swap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Proof != nil {
		l = m.Proof.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Body != nil {
		l = m.Body.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SwapClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Proof != nil {
		l = m.Proof.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Body != nil {
		l = m.Body.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.EpochDuration != 0 {
		n += 1 + sovDex(uint64(m.EpochDuration))
	}
	return n
}

func (m *SwapClaimBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nullifier != nil {
		l = m.Nullifier.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Fee != nil {
		l = m.Fee.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Output_1Commitment != nil {
		l = m.Output_1Commitment.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Output_2Commitment != nil {
		l = m.Output_2Commitment.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.OutputData != nil {
		l = m.OutputData.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SwapBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TradingPair != nil {
		l = m.TradingPair.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Delta_1I != nil {
		l = m.Delta_1I.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Delta_2I != nil {
		l = m.Delta_2I.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.FeeCommitment != nil {
		l = m.FeeCommitment.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SwapPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commitment != nil {
		l = m.Commitment.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	l = len(m.EncryptedSwap)
	if l > 0 {
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SwapPlaintext) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TradingPair != nil {
		l = m.TradingPair.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Delta_1I != nil {
		l = m.Delta_1I.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Delta_2I != nil {
		l = m.Delta_2I.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.ClaimFee != nil {
		l = m.ClaimFee.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.ClaimAddress != nil {
		l = m.ClaimAddress.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	l = len(m.Rseed)
	if l > 0 {
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SwapPlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SwapPlaintext != nil {
		l = m.SwapPlaintext.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	l = len(m.FeeBlinding)
	if l > 0 {
		n += 1 + l + sovDex(uint64(l))
	}
	l = len(m.ProofBlindingR)
	if l > 0 {
		n += 1 + l + sovDex(uint64(l))
	}
	l = len(m.ProofBlindingS)
	if l > 0 {
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SwapClaimPlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SwapPlaintext != nil {
		l = m.SwapPlaintext.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Position != 0 {
		n += 1 + sovDex(uint64(m.Position))
	}
	if m.OutputData != nil {
		l = m.OutputData.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.EpochDuration != 0 {
		n += 1 + sovDex(uint64(m.EpochDuration))
	}
	l = len(m.ProofBlindingR)
	if l > 0 {
		n += 1 + l + sovDex(uint64(l))
	}
	l = len(m.ProofBlindingS)
	if l > 0 {
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SwapView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SwapView != nil {
		n += m.SwapView.Size()
	}
	return n
}

func (m *SwapView_Visible_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Visible != nil {
		l = m.Visible.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}
func (m *SwapView_Opaque_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Opaque != nil {
		l = m.Opaque.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}
func (m *SwapView_Visible) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Swap != nil {
		l = m.Swap.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.SwapPlaintext != nil {
		l = m.SwapPlaintext.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SwapView_Opaque) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Swap != nil {
		l = m.Swap.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SwapClaimView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SwapClaimView != nil {
		n += m.SwapClaimView.Size()
	}
	return n
}

func (m *SwapClaimView_Visible_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Visible != nil {
		l = m.Visible.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}
func (m *SwapClaimView_Opaque_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Opaque != nil {
		l = m.Opaque.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}
func (m *SwapClaimView_Visible) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SwapClaim != nil {
		l = m.SwapClaim.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Output_1 != nil {
		l = m.Output_1.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Output_2 != nil {
		l = m.Output_2.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SwapClaimView_Opaque) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SwapClaim != nil {
		l = m.SwapClaim.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *TradingPair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Asset_1 != nil {
		l = m.Asset_1.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Asset_2 != nil {
		l = m.Asset_2.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *DirectedTradingPair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != nil {
		l = m.Start.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.End != nil {
		l = m.End.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *BatchSwapOutputData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Delta_1 != nil {
		l = m.Delta_1.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Delta_2 != nil {
		l = m.Delta_2.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Lambda_1 != nil {
		l = m.Lambda_1.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Lambda_2 != nil {
		l = m.Lambda_2.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Unfilled_1 != nil {
		l = m.Unfilled_1.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Unfilled_2 != nil {
		l = m.Unfilled_2.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovDex(uint64(m.Height))
	}
	if m.TradingPair != nil {
		l = m.TradingPair.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.EpochStartingHeight != 0 {
		n += 1 + sovDex(uint64(m.EpochStartingHeight))
	}
	return n
}

func (m *TradingFunction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Component != nil {
		l = m.Component.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Pair != nil {
		l = m.Pair.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *BareTradingFunction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Fee != 0 {
		n += 1 + sovDex(uint64(m.Fee))
	}
	if m.P != nil {
		l = m.P.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Q != nil {
		l = m.Q.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *Reserves) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.R1 != nil {
		l = m.R1.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.R2 != nil {
		l = m.R2.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *Position) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Phi != nil {
		l = m.Phi.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovDex(uint64(l))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Reserves != nil {
		l = m.Reserves.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.CloseOnFill {
		n += 2
	}
	return n
}

func (m *PositionId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Inner)
	if l > 0 {
		n += 1 + l + sovDex(uint64(l))
	}
	l = len(m.AltBech32M)
	if l > 0 {
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *PositionState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovDex(uint64(m.State))
	}
	return n
}

func (m *LpNft) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionId != nil {
		l = m.PositionId.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *PositionOpen) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Position != nil {
		l = m.Position.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *PositionClose) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionId != nil {
		l = m.PositionId.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *PositionWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionId != nil {
		l = m.PositionId.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.ReservesCommitment != nil {
		l = m.ReservesCommitment.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *PositionRewardClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionId != nil {
		l = m.PositionId.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.RewardsCommitment != nil {
		l = m.RewardsCommitment.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SwapExecution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Traces) > 0 {
		for _, e := range m.Traces {
			l = e.Size()
			n += 1 + l + sovDex(uint64(l))
		}
	}
	if m.Input != nil {
		l = m.Input.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Output != nil {
		l = m.Output.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SwapExecution_Trace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Value) > 0 {
		for _, e := range m.Value {
			l = e.Size()
			n += 1 + l + sovDex(uint64(l))
		}
	}
	return n
}

func (m *PositionWithdrawPlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Reserves != nil {
		l = m.Reserves.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.PositionId != nil {
		l = m.PositionId.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Pair != nil {
		l = m.Pair.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *PositionRewardClaimPlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Reserves != nil {
		l = m.Reserves.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *BatchSwapOutputDataRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovDex(uint64(m.Height))
	}
	if m.TradingPair != nil {
		l = m.TradingPair.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *BatchSwapOutputDataResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SwapExecutionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovDex(uint64(m.Height))
	}
	if m.TradingPair != nil {
		l = m.TradingPair.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SwapExecutionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SwapExecution != nil {
		l = m.SwapExecution.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *ArbExecutionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovDex(uint64(m.Height))
	}
	return n
}

func (m *ArbExecutionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SwapExecution != nil {
		l = m.SwapExecution.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovDex(uint64(m.Height))
	}
	return n
}

func (m *SwapExecutionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovDex(uint64(l))
	}
	if m.StartHeight != 0 {
		n += 1 + sovDex(uint64(m.StartHeight))
	}
	if m.EndHeight != 0 {
		n += 1 + sovDex(uint64(m.EndHeight))
	}
	if m.TradingPair != nil {
		l = m.TradingPair.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SwapExecutionsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SwapExecution != nil {
		l = m.SwapExecution.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovDex(uint64(m.Height))
	}
	if m.TradingPair != nil {
		l = m.TradingPair.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *ArbExecutionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovDex(uint64(l))
	}
	if m.StartHeight != 0 {
		n += 1 + sovDex(uint64(m.StartHeight))
	}
	if m.EndHeight != 0 {
		n += 1 + sovDex(uint64(m.EndHeight))
	}
	return n
}

func (m *ArbExecutionsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SwapExecution != nil {
		l = m.SwapExecution.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovDex(uint64(m.Height))
	}
	return n
}

func (m *LiquidityPositionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovDex(uint64(l))
	}
	if m.IncludeClosed {
		n += 2
	}
	return n
}

func (m *LiquidityPositionsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *LiquidityPositionByIdRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovDex(uint64(l))
	}
	if m.PositionId != nil {
		l = m.PositionId.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *LiquidityPositionByIdResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *LiquidityPositionsByIdRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovDex(uint64(l))
	}
	if len(m.PositionId) > 0 {
		for _, e := range m.PositionId {
			l = e.Size()
			n += 1 + l + sovDex(uint64(l))
		}
	}
	return n
}

func (m *LiquidityPositionsByIdResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *LiquidityPositionsByPriceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovDex(uint64(l))
	}
	if m.TradingPair != nil {
		l = m.TradingPair.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovDex(uint64(m.Limit))
	}
	return n
}

func (m *LiquidityPositionsByPriceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SpreadRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovDex(uint64(l))
	}
	if m.TradingPair != nil {
		l = m.TradingPair.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SpreadResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Best_1To_2Position != nil {
		l = m.Best_1To_2Position.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Best_2To_1Position != nil {
		l = m.Best_2To_1Position.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.ApproxEffectivePrice_1To_2 != 0 {
		n += 9
	}
	if m.ApproxEffectivePrice_2To_1 != 0 {
		n += 9
	}
	return n
}

func (m *SimulateTradeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Input != nil {
		l = m.Input.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Output != nil {
		l = m.Output.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	if m.Routing != nil {
		l = m.Routing.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func (m *SimulateTradeRequest_Routing) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Setting != nil {
		n += m.Setting.Size()
	}
	return n
}

func (m *SimulateTradeRequest_Routing_Default_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Default != nil {
		l = m.Default.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}
func (m *SimulateTradeRequest_Routing_SingleHop_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SingleHop != nil {
		l = m.SingleHop.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}
func (m *SimulateTradeRequest_Routing_SingleHop) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SimulateTradeRequest_Routing_Default) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SimulateTradeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Output != nil {
		l = m.Output.Size()
		n += 1 + l + sovDex(uint64(l))
	}
	return n
}

func sovDex(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDex(x uint64) (n int) {
	return sovDex(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ZKSwapProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZKSwapProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZKSwapProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inner = append(m.Inner[:0], dAtA[iNdEx:postIndex]...)
			if m.Inner == nil {
				m.Inner = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZKSwapClaimProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZKSwapClaimProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZKSwapClaimProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inner = append(m.Inner[:0], dAtA[iNdEx:postIndex]...)
			if m.Inner == nil {
				m.Inner = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Swap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Swap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Swap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proof == nil {
				m.Proof = &ZKSwapProof{}
			}
			if err := m.Proof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Body == nil {
				m.Body = &SwapBody{}
			}
			if err := m.Body.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapClaim) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapClaim: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapClaim: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proof == nil {
				m.Proof = &ZKSwapClaimProof{}
			}
			if err := m.Proof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Body == nil {
				m.Body = &SwapClaimBody{}
			}
			if err := m.Body.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochDuration", wireType)
			}
			m.EpochDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochDuration |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapClaimBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapClaimBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapClaimBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nullifier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Nullifier == nil {
				m.Nullifier = &v1alpha1.Nullifier{}
			}
			if err := m.Nullifier.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fee == nil {
				m.Fee = &v1alpha11.Fee{}
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output_1Commitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output_1Commitment == nil {
				m.Output_1Commitment = &v1alpha12.StateCommitment{}
			}
			if err := m.Output_1Commitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output_2Commitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output_2Commitment == nil {
				m.Output_2Commitment = &v1alpha12.StateCommitment{}
			}
			if err := m.Output_2Commitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutputData == nil {
				m.OutputData = &BatchSwapOutputData{}
			}
			if err := m.OutputData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradingPair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TradingPair == nil {
				m.TradingPair = &TradingPair{}
			}
			if err := m.TradingPair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delta_1I", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Delta_1I == nil {
				m.Delta_1I = &v1alpha13.Amount{}
			}
			if err := m.Delta_1I.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delta_2I", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Delta_2I == nil {
				m.Delta_2I = &v1alpha13.Amount{}
			}
			if err := m.Delta_2I.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeCommitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FeeCommitment == nil {
				m.FeeCommitment = &v1alpha14.BalanceCommitment{}
			}
			if err := m.FeeCommitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &SwapPayload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapPayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commitment == nil {
				m.Commitment = &v1alpha12.StateCommitment{}
			}
			if err := m.Commitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedSwap", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedSwap = append(m.EncryptedSwap[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedSwap == nil {
				m.EncryptedSwap = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapPlaintext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapPlaintext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapPlaintext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradingPair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TradingPair == nil {
				m.TradingPair = &TradingPair{}
			}
			if err := m.TradingPair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delta_1I", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Delta_1I == nil {
				m.Delta_1I = &v1alpha13.Amount{}
			}
			if err := m.Delta_1I.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delta_2I", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Delta_2I == nil {
				m.Delta_2I = &v1alpha13.Amount{}
			}
			if err := m.Delta_2I.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimFee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClaimFee == nil {
				m.ClaimFee = &v1alpha11.Fee{}
			}
			if err := m.ClaimFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClaimAddress == nil {
				m.ClaimAddress = &v1alpha15.Address{}
			}
			if err := m.ClaimAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rseed", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rseed = append(m.Rseed[:0], dAtA[iNdEx:postIndex]...)
			if m.Rseed == nil {
				m.Rseed = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapPlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapPlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapPlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapPlaintext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SwapPlaintext == nil {
				m.SwapPlaintext = &SwapPlaintext{}
			}
			if err := m.SwapPlaintext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeBlinding", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeBlinding = append(m.FeeBlinding[:0], dAtA[iNdEx:postIndex]...)
			if m.FeeBlinding == nil {
				m.FeeBlinding = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofBlindingR", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofBlindingR = append(m.ProofBlindingR[:0], dAtA[iNdEx:postIndex]...)
			if m.ProofBlindingR == nil {
				m.ProofBlindingR = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofBlindingS", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofBlindingS = append(m.ProofBlindingS[:0], dAtA[iNdEx:postIndex]...)
			if m.ProofBlindingS == nil {
				m.ProofBlindingS = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapClaimPlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapClaimPlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapClaimPlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapPlaintext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SwapPlaintext == nil {
				m.SwapPlaintext = &SwapPlaintext{}
			}
			if err := m.SwapPlaintext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			m.Position = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Position |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutputData == nil {
				m.OutputData = &BatchSwapOutputData{}
			}
			if err := m.OutputData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochDuration", wireType)
			}
			m.EpochDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochDuration |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofBlindingR", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofBlindingR = append(m.ProofBlindingR[:0], dAtA[iNdEx:postIndex]...)
			if m.ProofBlindingR == nil {
				m.ProofBlindingR = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofBlindingS", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofBlindingS = append(m.ProofBlindingS[:0], dAtA[iNdEx:postIndex]...)
			if m.ProofBlindingS == nil {
				m.ProofBlindingS = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visible", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SwapView_Visible{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SwapView = &SwapView_Visible_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opaque", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SwapView_Opaque{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SwapView = &SwapView_Opaque_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapView_Visible) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Visible: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Visible: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Swap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Swap == nil {
				m.Swap = &Swap{}
			}
			if err := m.Swap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapPlaintext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SwapPlaintext == nil {
				m.SwapPlaintext = &SwapPlaintext{}
			}
			if err := m.SwapPlaintext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapView_Opaque) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Opaque: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Opaque: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Swap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Swap == nil {
				m.Swap = &Swap{}
			}
			if err := m.Swap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapClaimView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapClaimView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapClaimView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visible", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SwapClaimView_Visible{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SwapClaimView = &SwapClaimView_Visible_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opaque", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SwapClaimView_Opaque{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SwapClaimView = &SwapClaimView_Opaque_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapClaimView_Visible) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Visible: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Visible: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SwapClaim == nil {
				m.SwapClaim = &SwapClaim{}
			}
			if err := m.SwapClaim.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output_1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output_1 == nil {
				m.Output_1 = &v1alpha16.NoteView{}
			}
			if err := m.Output_1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output_2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output_2 == nil {
				m.Output_2 = &v1alpha16.NoteView{}
			}
			if err := m.Output_2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapClaimView_Opaque) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Opaque: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Opaque: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SwapClaim == nil {
				m.SwapClaim = &SwapClaim{}
			}
			if err := m.SwapClaim.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TradingPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TradingPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TradingPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset_1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Asset_1 == nil {
				m.Asset_1 = &v1alpha14.AssetId{}
			}
			if err := m.Asset_1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset_2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Asset_2 == nil {
				m.Asset_2 = &v1alpha14.AssetId{}
			}
			if err := m.Asset_2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DirectedTradingPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DirectedTradingPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DirectedTradingPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Start == nil {
				m.Start = &v1alpha14.AssetId{}
			}
			if err := m.Start.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.End == nil {
				m.End = &v1alpha14.AssetId{}
			}
			if err := m.End.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchSwapOutputData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchSwapOutputData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchSwapOutputData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delta_1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Delta_1 == nil {
				m.Delta_1 = &v1alpha13.Amount{}
			}
			if err := m.Delta_1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delta_2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Delta_2 == nil {
				m.Delta_2 = &v1alpha13.Amount{}
			}
			if err := m.Delta_2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lambda_1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lambda_1 == nil {
				m.Lambda_1 = &v1alpha13.Amount{}
			}
			if err := m.Lambda_1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lambda_2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lambda_2 == nil {
				m.Lambda_2 = &v1alpha13.Amount{}
			}
			if err := m.Lambda_2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unfilled_1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Unfilled_1 == nil {
				m.Unfilled_1 = &v1alpha13.Amount{}
			}
			if err := m.Unfilled_1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unfilled_2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Unfilled_2 == nil {
				m.Unfilled_2 = &v1alpha13.Amount{}
			}
			if err := m.Unfilled_2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradingPair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TradingPair == nil {
				m.TradingPair = &TradingPair{}
			}
			if err := m.TradingPair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochStartingHeight", wireType)
			}
			m.EpochStartingHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochStartingHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TradingFunction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TradingFunction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TradingFunction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Component", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Component == nil {
				m.Component = &BareTradingFunction{}
			}
			if err := m.Component.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pair == nil {
				m.Pair = &TradingPair{}
			}
			if err := m.Pair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BareTradingFunction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BareTradingFunction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BareTradingFunction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			m.Fee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fee |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field P", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.P == nil {
				m.P = &v1alpha13.Amount{}
			}
			if err := m.P.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Q", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Q == nil {
				m.Q = &v1alpha13.Amount{}
			}
			if err := m.Q.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Reserves) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reserves: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reserves: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field R1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.R1 == nil {
				m.R1 = &v1alpha13.Amount{}
			}
			if err := m.R1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field R2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.R2 == nil {
				m.R2 = &v1alpha13.Amount{}
			}
			if err := m.R2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Position) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Position: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Position: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Phi == nil {
				m.Phi = &TradingFunction{}
			}
			if err := m.Phi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = append(m.Nonce[:0], dAtA[iNdEx:postIndex]...)
			if m.Nonce == nil {
				m.Nonce = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &PositionState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserves", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Reserves == nil {
				m.Reserves = &Reserves{}
			}
			if err := m.Reserves.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseOnFill", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CloseOnFill = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PositionId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PositionId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PositionId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inner = append(m.Inner[:0], dAtA[iNdEx:postIndex]...)
			if m.Inner == nil {
				m.Inner = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AltBech32M", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AltBech32M = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PositionState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PositionState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PositionState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= PositionState_PositionStateEnum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LpNft) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LpNft: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LpNft: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PositionId == nil {
				m.PositionId = &PositionId{}
			}
			if err := m.PositionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &PositionState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PositionOpen) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PositionOpen: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PositionOpen: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Position == nil {
				m.Position = &Position{}
			}
			if err := m.Position.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PositionClose) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PositionClose: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PositionClose: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PositionId == nil {
				m.PositionId = &PositionId{}
			}
			if err := m.PositionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PositionWithdraw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PositionWithdraw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PositionWithdraw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PositionId == nil {
				m.PositionId = &PositionId{}
			}
			if err := m.PositionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReservesCommitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReservesCommitment == nil {
				m.ReservesCommitment = &v1alpha14.BalanceCommitment{}
			}
			if err := m.ReservesCommitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PositionRewardClaim) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PositionRewardClaim: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PositionRewardClaim: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PositionId == nil {
				m.PositionId = &PositionId{}
			}
			if err := m.PositionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardsCommitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RewardsCommitment == nil {
				m.RewardsCommitment = &v1alpha14.BalanceCommitment{}
			}
			if err := m.RewardsCommitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapExecution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapExecution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapExecution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Traces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Traces = append(m.Traces, &SwapExecution_Trace{})
			if err := m.Traces[len(m.Traces)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Input == nil {
				m.Input = &v1alpha14.Value{}
			}
			if err := m.Input.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output == nil {
				m.Output = &v1alpha14.Value{}
			}
			if err := m.Output.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapExecution_Trace) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Trace: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Trace: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value, &v1alpha14.Value{})
			if err := m.Value[len(m.Value)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PositionWithdrawPlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PositionWithdrawPlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PositionWithdrawPlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserves", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Reserves == nil {
				m.Reserves = &Reserves{}
			}
			if err := m.Reserves.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PositionId == nil {
				m.PositionId = &PositionId{}
			}
			if err := m.PositionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pair == nil {
				m.Pair = &TradingPair{}
			}
			if err := m.Pair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PositionRewardClaimPlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PositionRewardClaimPlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PositionRewardClaimPlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserves", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Reserves == nil {
				m.Reserves = &Reserves{}
			}
			if err := m.Reserves.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchSwapOutputDataRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchSwapOutputDataRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchSwapOutputDataRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradingPair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TradingPair == nil {
				m.TradingPair = &TradingPair{}
			}
			if err := m.TradingPair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchSwapOutputDataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchSwapOutputDataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchSwapOutputDataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &BatchSwapOutputData{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapExecutionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapExecutionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapExecutionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradingPair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TradingPair == nil {
				m.TradingPair = &DirectedTradingPair{}
			}
			if err := m.TradingPair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapExecutionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapExecutionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapExecutionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapExecution", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SwapExecution == nil {
				m.SwapExecution = &SwapExecution{}
			}
			if err := m.SwapExecution.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArbExecutionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArbExecutionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArbExecutionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArbExecutionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArbExecutionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArbExecutionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapExecution", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SwapExecution == nil {
				m.SwapExecution = &SwapExecution{}
			}
			if err := m.SwapExecution.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapExecutionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapExecutionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapExecutionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartHeight", wireType)
			}
			m.StartHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndHeight", wireType)
			}
			m.EndHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradingPair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TradingPair == nil {
				m.TradingPair = &DirectedTradingPair{}
			}
			if err := m.TradingPair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapExecutionsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapExecutionsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapExecutionsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapExecution", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SwapExecution == nil {
				m.SwapExecution = &SwapExecution{}
			}
			if err := m.SwapExecution.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradingPair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TradingPair == nil {
				m.TradingPair = &DirectedTradingPair{}
			}
			if err := m.TradingPair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArbExecutionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArbExecutionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArbExecutionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartHeight", wireType)
			}
			m.StartHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndHeight", wireType)
			}
			m.EndHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArbExecutionsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArbExecutionsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArbExecutionsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapExecution", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SwapExecution == nil {
				m.SwapExecution = &SwapExecution{}
			}
			if err := m.SwapExecution.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LiquidityPositionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LiquidityPositionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LiquidityPositionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeClosed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeClosed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LiquidityPositionsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LiquidityPositionsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LiquidityPositionsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &Position{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LiquidityPositionByIdRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LiquidityPositionByIdRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LiquidityPositionByIdRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PositionId == nil {
				m.PositionId = &PositionId{}
			}
			if err := m.PositionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LiquidityPositionByIdResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LiquidityPositionByIdResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LiquidityPositionByIdResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &Position{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LiquidityPositionsByIdRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LiquidityPositionsByIdRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LiquidityPositionsByIdRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PositionId = append(m.PositionId, &PositionId{})
			if err := m.PositionId[len(m.PositionId)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LiquidityPositionsByIdResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LiquidityPositionsByIdResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LiquidityPositionsByIdResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &Position{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LiquidityPositionsByPriceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LiquidityPositionsByPriceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LiquidityPositionsByPriceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradingPair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TradingPair == nil {
				m.TradingPair = &DirectedTradingPair{}
			}
			if err := m.TradingPair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LiquidityPositionsByPriceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LiquidityPositionsByPriceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LiquidityPositionsByPriceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &Position{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpreadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpreadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpreadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradingPair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TradingPair == nil {
				m.TradingPair = &TradingPair{}
			}
			if err := m.TradingPair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpreadResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpreadResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpreadResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Best_1To_2Position", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Best_1To_2Position == nil {
				m.Best_1To_2Position = &Position{}
			}
			if err := m.Best_1To_2Position.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Best_2To_1Position", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Best_2To_1Position == nil {
				m.Best_2To_1Position = &Position{}
			}
			if err := m.Best_2To_1Position.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApproxEffectivePrice_1To_2", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ApproxEffectivePrice_1To_2 = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApproxEffectivePrice_2To_1", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ApproxEffectivePrice_2To_1 = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimulateTradeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimulateTradeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimulateTradeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Input == nil {
				m.Input = &v1alpha14.Value{}
			}
			if err := m.Input.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output == nil {
				m.Output = &v1alpha14.AssetId{}
			}
			if err := m.Output.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Routing == nil {
				m.Routing = &SimulateTradeRequest_Routing{}
			}
			if err := m.Routing.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimulateTradeRequest_Routing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Routing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Routing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Default", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SimulateTradeRequest_Routing_Default{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Setting = &SimulateTradeRequest_Routing_Default_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SingleHop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SimulateTradeRequest_Routing_SingleHop{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Setting = &SimulateTradeRequest_Routing_SingleHop_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimulateTradeRequest_Routing_SingleHop) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SingleHop: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SingleHop: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimulateTradeRequest_Routing_Default) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Default: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Default: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimulateTradeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimulateTradeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimulateTradeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output == nil {
				m.Output = &SwapExecution{}
			}
			if err := m.Output.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDex(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDex
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDex
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDex
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDex
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDex
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDex
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDex        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDex          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDex = fmt.Errorf("proto: unexpected end of group")
)
