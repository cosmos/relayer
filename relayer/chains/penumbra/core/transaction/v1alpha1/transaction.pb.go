// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: penumbra/core/transaction/v1alpha1/transaction.proto

package transactionv1alpha1

import (
	fmt "fmt"
	proto "github.com/cosmos/gogoproto/proto"
	v1alpha1 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/crypto/v1alpha1"
	v1alpha11 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/dex/v1alpha1"
	v1alpha14 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/governance/v1alpha1"
	v1alpha13 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/ibc/v1alpha1"
	v1alpha12 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/stake/v1alpha1"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// A Penumbra transaction.
type Transaction struct {
	Body *TransactionBody `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// The binding signature is stored separately from the transaction body that it signs.
	BindingSig []byte `protobuf:"bytes,2,opt,name=binding_sig,json=bindingSig,proto3" json:"binding_sig,omitempty"`
	// The root of some previous state of the state commitment tree, used as an anchor for all
	// ZK state transition proofs.
	Anchor *v1alpha1.MerkleRoot `protobuf:"bytes,3,opt,name=anchor,proto3" json:"anchor,omitempty"`
}

func (m *Transaction) Reset()         { *m = Transaction{} }
func (m *Transaction) String() string { return proto.CompactTextString(m) }
func (*Transaction) ProtoMessage()    {}
func (*Transaction) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{0}
}
func (m *Transaction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Transaction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Transaction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Transaction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Transaction.Merge(m, src)
}
func (m *Transaction) XXX_Size() int {
	return m.Size()
}
func (m *Transaction) XXX_DiscardUnknown() {
	xxx_messageInfo_Transaction.DiscardUnknown(m)
}

var xxx_messageInfo_Transaction proto.InternalMessageInfo

func (m *Transaction) GetBody() *TransactionBody {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *Transaction) GetBindingSig() []byte {
	if m != nil {
		return m.BindingSig
	}
	return nil
}

func (m *Transaction) GetAnchor() *v1alpha1.MerkleRoot {
	if m != nil {
		return m.Anchor
	}
	return nil
}

// A transaction ID, the Sha256 hash of a transaction.
type Id struct {
	Hash []byte `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
}

func (m *Id) Reset()         { *m = Id{} }
func (m *Id) String() string { return proto.CompactTextString(m) }
func (*Id) ProtoMessage()    {}
func (*Id) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{1}
}
func (m *Id) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Id) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Id.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Id) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Id.Merge(m, src)
}
func (m *Id) XXX_Size() int {
	return m.Size()
}
func (m *Id) XXX_DiscardUnknown() {
	xxx_messageInfo_Id.DiscardUnknown(m)
}

var xxx_messageInfo_Id proto.InternalMessageInfo

func (m *Id) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

// The body of a transaction.
type TransactionBody struct {
	// A list of actions (state changes) performed by this transaction.
	Actions []*Action `protobuf:"bytes,1,rep,name=actions,proto3" json:"actions,omitempty"`
	// The maximum height that this transaction can be included in the chain.
	//
	// If zero, there is no maximum.
	ExpiryHeight uint64 `protobuf:"varint,2,opt,name=expiry_height,json=expiryHeight,proto3" json:"expiry_height,omitempty"`
	// The chain this transaction is intended for.  Including this prevents
	// replaying a transaction on one chain onto a different chain.
	ChainId string `protobuf:"bytes,3,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// The transaction fee.
	Fee *v1alpha1.Fee `protobuf:"bytes,4,opt,name=fee,proto3" json:"fee,omitempty"`
	// A list of clues for use with Fuzzy Message Detection.
	FmdClues []*v1alpha1.Clue `protobuf:"bytes,5,rep,name=fmd_clues,json=fmdClues,proto3" json:"fmd_clues,omitempty"`
	// Types that are valid to be assigned to XEncryptedMemo:
	//	*TransactionBody_EncryptedMemo
	XEncryptedMemo isTransactionBody_XEncryptedMemo `protobuf_oneof:"_encrypted_memo"`
}

func (m *TransactionBody) Reset()         { *m = TransactionBody{} }
func (m *TransactionBody) String() string { return proto.CompactTextString(m) }
func (*TransactionBody) ProtoMessage()    {}
func (*TransactionBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{2}
}
func (m *TransactionBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactionBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransactionBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransactionBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionBody.Merge(m, src)
}
func (m *TransactionBody) XXX_Size() int {
	return m.Size()
}
func (m *TransactionBody) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionBody.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionBody proto.InternalMessageInfo

type isTransactionBody_XEncryptedMemo interface {
	isTransactionBody_XEncryptedMemo()
	MarshalTo([]byte) (int, error)
	Size() int
}

type TransactionBody_EncryptedMemo struct {
	EncryptedMemo []byte `protobuf:"bytes,6,opt,name=encrypted_memo,json=encryptedMemo,proto3,oneof" json:"encrypted_memo,omitempty"`
}

func (*TransactionBody_EncryptedMemo) isTransactionBody_XEncryptedMemo() {}

func (m *TransactionBody) GetXEncryptedMemo() isTransactionBody_XEncryptedMemo {
	if m != nil {
		return m.XEncryptedMemo
	}
	return nil
}

func (m *TransactionBody) GetActions() []*Action {
	if m != nil {
		return m.Actions
	}
	return nil
}

func (m *TransactionBody) GetExpiryHeight() uint64 {
	if m != nil {
		return m.ExpiryHeight
	}
	return 0
}

func (m *TransactionBody) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *TransactionBody) GetFee() *v1alpha1.Fee {
	if m != nil {
		return m.Fee
	}
	return nil
}

func (m *TransactionBody) GetFmdClues() []*v1alpha1.Clue {
	if m != nil {
		return m.FmdClues
	}
	return nil
}

func (m *TransactionBody) GetEncryptedMemo() []byte {
	if x, ok := m.GetXEncryptedMemo().(*TransactionBody_EncryptedMemo); ok {
		return x.EncryptedMemo
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TransactionBody) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TransactionBody_EncryptedMemo)(nil),
	}
}

// A state change performed by a transaction.
type Action struct {
	// Types that are valid to be assigned to Action:
	//	*Action_Spend
	//	*Action_Output
	//	*Action_Swap
	//	*Action_SwapClaim
	//	*Action_ValidatorDefinition
	//	*Action_IbcAction
	//	*Action_ProposalSubmit
	//	*Action_ProposalWithdraw
	//	*Action_ValidatorVote
	//	*Action_DelegatorVote
	//	*Action_ProposalDepositClaim
	//	*Action_PositionOpen
	//	*Action_PositionClose
	//	*Action_PositionWithdraw
	//	*Action_PositionRewardClaim
	//	*Action_Delegate
	//	*Action_Undelegate
	//	*Action_UndelegateClaim
	//	*Action_DaoSpend
	//	*Action_DaoOutput
	//	*Action_DaoDeposit
	//	*Action_Ics20Withdrawal
	Action isAction_Action `protobuf_oneof:"action"`
}

func (m *Action) Reset()         { *m = Action{} }
func (m *Action) String() string { return proto.CompactTextString(m) }
func (*Action) ProtoMessage()    {}
func (*Action) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{3}
}
func (m *Action) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Action) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Action.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Action) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Action.Merge(m, src)
}
func (m *Action) XXX_Size() int {
	return m.Size()
}
func (m *Action) XXX_DiscardUnknown() {
	xxx_messageInfo_Action.DiscardUnknown(m)
}

var xxx_messageInfo_Action proto.InternalMessageInfo

type isAction_Action interface {
	isAction_Action()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Action_Spend struct {
	Spend *Spend `protobuf:"bytes,1,opt,name=spend,proto3,oneof" json:"spend,omitempty"`
}
type Action_Output struct {
	Output *Output `protobuf:"bytes,2,opt,name=output,proto3,oneof" json:"output,omitempty"`
}
type Action_Swap struct {
	Swap *v1alpha11.Swap `protobuf:"bytes,3,opt,name=swap,proto3,oneof" json:"swap,omitempty"`
}
type Action_SwapClaim struct {
	SwapClaim *v1alpha11.SwapClaim `protobuf:"bytes,4,opt,name=swap_claim,json=swapClaim,proto3,oneof" json:"swap_claim,omitempty"`
}
type Action_ValidatorDefinition struct {
	ValidatorDefinition *v1alpha12.ValidatorDefinition `protobuf:"bytes,16,opt,name=validator_definition,json=validatorDefinition,proto3,oneof" json:"validator_definition,omitempty"`
}
type Action_IbcAction struct {
	IbcAction *v1alpha13.IbcAction `protobuf:"bytes,17,opt,name=ibc_action,json=ibcAction,proto3,oneof" json:"ibc_action,omitempty"`
}
type Action_ProposalSubmit struct {
	ProposalSubmit *v1alpha14.ProposalSubmit `protobuf:"bytes,18,opt,name=proposal_submit,json=proposalSubmit,proto3,oneof" json:"proposal_submit,omitempty"`
}
type Action_ProposalWithdraw struct {
	ProposalWithdraw *v1alpha14.ProposalWithdraw `protobuf:"bytes,19,opt,name=proposal_withdraw,json=proposalWithdraw,proto3,oneof" json:"proposal_withdraw,omitempty"`
}
type Action_ValidatorVote struct {
	ValidatorVote *v1alpha14.ValidatorVote `protobuf:"bytes,20,opt,name=validator_vote,json=validatorVote,proto3,oneof" json:"validator_vote,omitempty"`
}
type Action_DelegatorVote struct {
	DelegatorVote *v1alpha14.DelegatorVote `protobuf:"bytes,21,opt,name=delegator_vote,json=delegatorVote,proto3,oneof" json:"delegator_vote,omitempty"`
}
type Action_ProposalDepositClaim struct {
	ProposalDepositClaim *v1alpha14.ProposalDepositClaim `protobuf:"bytes,22,opt,name=proposal_deposit_claim,json=proposalDepositClaim,proto3,oneof" json:"proposal_deposit_claim,omitempty"`
}
type Action_PositionOpen struct {
	PositionOpen *v1alpha11.PositionOpen `protobuf:"bytes,30,opt,name=position_open,json=positionOpen,proto3,oneof" json:"position_open,omitempty"`
}
type Action_PositionClose struct {
	PositionClose *v1alpha11.PositionClose `protobuf:"bytes,31,opt,name=position_close,json=positionClose,proto3,oneof" json:"position_close,omitempty"`
}
type Action_PositionWithdraw struct {
	PositionWithdraw *v1alpha11.PositionWithdraw `protobuf:"bytes,32,opt,name=position_withdraw,json=positionWithdraw,proto3,oneof" json:"position_withdraw,omitempty"`
}
type Action_PositionRewardClaim struct {
	PositionRewardClaim *v1alpha11.PositionRewardClaim `protobuf:"bytes,34,opt,name=position_reward_claim,json=positionRewardClaim,proto3,oneof" json:"position_reward_claim,omitempty"`
}
type Action_Delegate struct {
	Delegate *v1alpha12.Delegate `protobuf:"bytes,40,opt,name=delegate,proto3,oneof" json:"delegate,omitempty"`
}
type Action_Undelegate struct {
	Undelegate *v1alpha12.Undelegate `protobuf:"bytes,41,opt,name=undelegate,proto3,oneof" json:"undelegate,omitempty"`
}
type Action_UndelegateClaim struct {
	UndelegateClaim *v1alpha12.UndelegateClaim `protobuf:"bytes,42,opt,name=undelegate_claim,json=undelegateClaim,proto3,oneof" json:"undelegate_claim,omitempty"`
}
type Action_DaoSpend struct {
	DaoSpend *v1alpha14.DaoSpend `protobuf:"bytes,50,opt,name=dao_spend,json=daoSpend,proto3,oneof" json:"dao_spend,omitempty"`
}
type Action_DaoOutput struct {
	DaoOutput *v1alpha14.DaoOutput `protobuf:"bytes,51,opt,name=dao_output,json=daoOutput,proto3,oneof" json:"dao_output,omitempty"`
}
type Action_DaoDeposit struct {
	DaoDeposit *v1alpha14.DaoDeposit `protobuf:"bytes,52,opt,name=dao_deposit,json=daoDeposit,proto3,oneof" json:"dao_deposit,omitempty"`
}
type Action_Ics20Withdrawal struct {
	Ics20Withdrawal *v1alpha13.Ics20Withdrawal `protobuf:"bytes,200,opt,name=ics20_withdrawal,json=ics20Withdrawal,proto3,oneof" json:"ics20_withdrawal,omitempty"`
}

func (*Action_Spend) isAction_Action()                {}
func (*Action_Output) isAction_Action()               {}
func (*Action_Swap) isAction_Action()                 {}
func (*Action_SwapClaim) isAction_Action()            {}
func (*Action_ValidatorDefinition) isAction_Action()  {}
func (*Action_IbcAction) isAction_Action()            {}
func (*Action_ProposalSubmit) isAction_Action()       {}
func (*Action_ProposalWithdraw) isAction_Action()     {}
func (*Action_ValidatorVote) isAction_Action()        {}
func (*Action_DelegatorVote) isAction_Action()        {}
func (*Action_ProposalDepositClaim) isAction_Action() {}
func (*Action_PositionOpen) isAction_Action()         {}
func (*Action_PositionClose) isAction_Action()        {}
func (*Action_PositionWithdraw) isAction_Action()     {}
func (*Action_PositionRewardClaim) isAction_Action()  {}
func (*Action_Delegate) isAction_Action()             {}
func (*Action_Undelegate) isAction_Action()           {}
func (*Action_UndelegateClaim) isAction_Action()      {}
func (*Action_DaoSpend) isAction_Action()             {}
func (*Action_DaoOutput) isAction_Action()            {}
func (*Action_DaoDeposit) isAction_Action()           {}
func (*Action_Ics20Withdrawal) isAction_Action()      {}

func (m *Action) GetAction() isAction_Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *Action) GetSpend() *Spend {
	if x, ok := m.GetAction().(*Action_Spend); ok {
		return x.Spend
	}
	return nil
}

func (m *Action) GetOutput() *Output {
	if x, ok := m.GetAction().(*Action_Output); ok {
		return x.Output
	}
	return nil
}

func (m *Action) GetSwap() *v1alpha11.Swap {
	if x, ok := m.GetAction().(*Action_Swap); ok {
		return x.Swap
	}
	return nil
}

func (m *Action) GetSwapClaim() *v1alpha11.SwapClaim {
	if x, ok := m.GetAction().(*Action_SwapClaim); ok {
		return x.SwapClaim
	}
	return nil
}

func (m *Action) GetValidatorDefinition() *v1alpha12.ValidatorDefinition {
	if x, ok := m.GetAction().(*Action_ValidatorDefinition); ok {
		return x.ValidatorDefinition
	}
	return nil
}

func (m *Action) GetIbcAction() *v1alpha13.IbcAction {
	if x, ok := m.GetAction().(*Action_IbcAction); ok {
		return x.IbcAction
	}
	return nil
}

func (m *Action) GetProposalSubmit() *v1alpha14.ProposalSubmit {
	if x, ok := m.GetAction().(*Action_ProposalSubmit); ok {
		return x.ProposalSubmit
	}
	return nil
}

func (m *Action) GetProposalWithdraw() *v1alpha14.ProposalWithdraw {
	if x, ok := m.GetAction().(*Action_ProposalWithdraw); ok {
		return x.ProposalWithdraw
	}
	return nil
}

func (m *Action) GetValidatorVote() *v1alpha14.ValidatorVote {
	if x, ok := m.GetAction().(*Action_ValidatorVote); ok {
		return x.ValidatorVote
	}
	return nil
}

func (m *Action) GetDelegatorVote() *v1alpha14.DelegatorVote {
	if x, ok := m.GetAction().(*Action_DelegatorVote); ok {
		return x.DelegatorVote
	}
	return nil
}

func (m *Action) GetProposalDepositClaim() *v1alpha14.ProposalDepositClaim {
	if x, ok := m.GetAction().(*Action_ProposalDepositClaim); ok {
		return x.ProposalDepositClaim
	}
	return nil
}

func (m *Action) GetPositionOpen() *v1alpha11.PositionOpen {
	if x, ok := m.GetAction().(*Action_PositionOpen); ok {
		return x.PositionOpen
	}
	return nil
}

func (m *Action) GetPositionClose() *v1alpha11.PositionClose {
	if x, ok := m.GetAction().(*Action_PositionClose); ok {
		return x.PositionClose
	}
	return nil
}

func (m *Action) GetPositionWithdraw() *v1alpha11.PositionWithdraw {
	if x, ok := m.GetAction().(*Action_PositionWithdraw); ok {
		return x.PositionWithdraw
	}
	return nil
}

func (m *Action) GetPositionRewardClaim() *v1alpha11.PositionRewardClaim {
	if x, ok := m.GetAction().(*Action_PositionRewardClaim); ok {
		return x.PositionRewardClaim
	}
	return nil
}

func (m *Action) GetDelegate() *v1alpha12.Delegate {
	if x, ok := m.GetAction().(*Action_Delegate); ok {
		return x.Delegate
	}
	return nil
}

func (m *Action) GetUndelegate() *v1alpha12.Undelegate {
	if x, ok := m.GetAction().(*Action_Undelegate); ok {
		return x.Undelegate
	}
	return nil
}

func (m *Action) GetUndelegateClaim() *v1alpha12.UndelegateClaim {
	if x, ok := m.GetAction().(*Action_UndelegateClaim); ok {
		return x.UndelegateClaim
	}
	return nil
}

func (m *Action) GetDaoSpend() *v1alpha14.DaoSpend {
	if x, ok := m.GetAction().(*Action_DaoSpend); ok {
		return x.DaoSpend
	}
	return nil
}

func (m *Action) GetDaoOutput() *v1alpha14.DaoOutput {
	if x, ok := m.GetAction().(*Action_DaoOutput); ok {
		return x.DaoOutput
	}
	return nil
}

func (m *Action) GetDaoDeposit() *v1alpha14.DaoDeposit {
	if x, ok := m.GetAction().(*Action_DaoDeposit); ok {
		return x.DaoDeposit
	}
	return nil
}

func (m *Action) GetIcs20Withdrawal() *v1alpha13.Ics20Withdrawal {
	if x, ok := m.GetAction().(*Action_Ics20Withdrawal); ok {
		return x.Ics20Withdrawal
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Action) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Action_Spend)(nil),
		(*Action_Output)(nil),
		(*Action_Swap)(nil),
		(*Action_SwapClaim)(nil),
		(*Action_ValidatorDefinition)(nil),
		(*Action_IbcAction)(nil),
		(*Action_ProposalSubmit)(nil),
		(*Action_ProposalWithdraw)(nil),
		(*Action_ValidatorVote)(nil),
		(*Action_DelegatorVote)(nil),
		(*Action_ProposalDepositClaim)(nil),
		(*Action_PositionOpen)(nil),
		(*Action_PositionClose)(nil),
		(*Action_PositionWithdraw)(nil),
		(*Action_PositionRewardClaim)(nil),
		(*Action_Delegate)(nil),
		(*Action_Undelegate)(nil),
		(*Action_UndelegateClaim)(nil),
		(*Action_DaoSpend)(nil),
		(*Action_DaoOutput)(nil),
		(*Action_DaoDeposit)(nil),
		(*Action_Ics20Withdrawal)(nil),
	}
}

// A transaction perspective is a bundle of key material and commitment openings
// that allow generating a view of a transaction from that perspective.
type TransactionPerspective struct {
	PayloadKeys     []*PayloadKeyWithCommitment `protobuf:"bytes,1,rep,name=payload_keys,json=payloadKeys,proto3" json:"payload_keys,omitempty"`
	SpendNullifiers []*NullifierWithNote        `protobuf:"bytes,2,rep,name=spend_nullifiers,json=spendNullifiers,proto3" json:"spend_nullifiers,omitempty"`
	// The openings of note commitments referred to in the transaction
	// but not included in the transaction.
	AdviceNotes []*v1alpha1.Note `protobuf:"bytes,3,rep,name=advice_notes,json=adviceNotes,proto3" json:"advice_notes,omitempty"`
	// Any relevant address views.
	AddressViews []*v1alpha1.AddressView `protobuf:"bytes,4,rep,name=address_views,json=addressViews,proto3" json:"address_views,omitempty"`
}

func (m *TransactionPerspective) Reset()         { *m = TransactionPerspective{} }
func (m *TransactionPerspective) String() string { return proto.CompactTextString(m) }
func (*TransactionPerspective) ProtoMessage()    {}
func (*TransactionPerspective) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{4}
}
func (m *TransactionPerspective) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactionPerspective) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransactionPerspective.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransactionPerspective) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionPerspective.Merge(m, src)
}
func (m *TransactionPerspective) XXX_Size() int {
	return m.Size()
}
func (m *TransactionPerspective) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionPerspective.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionPerspective proto.InternalMessageInfo

func (m *TransactionPerspective) GetPayloadKeys() []*PayloadKeyWithCommitment {
	if m != nil {
		return m.PayloadKeys
	}
	return nil
}

func (m *TransactionPerspective) GetSpendNullifiers() []*NullifierWithNote {
	if m != nil {
		return m.SpendNullifiers
	}
	return nil
}

func (m *TransactionPerspective) GetAdviceNotes() []*v1alpha1.Note {
	if m != nil {
		return m.AdviceNotes
	}
	return nil
}

func (m *TransactionPerspective) GetAddressViews() []*v1alpha1.AddressView {
	if m != nil {
		return m.AddressViews
	}
	return nil
}

type PayloadKeyWithCommitment struct {
	PayloadKey []byte                    `protobuf:"bytes,1,opt,name=payload_key,json=payloadKey,proto3" json:"payload_key,omitempty"`
	Commitment *v1alpha1.StateCommitment `protobuf:"bytes,2,opt,name=commitment,proto3" json:"commitment,omitempty"`
}

func (m *PayloadKeyWithCommitment) Reset()         { *m = PayloadKeyWithCommitment{} }
func (m *PayloadKeyWithCommitment) String() string { return proto.CompactTextString(m) }
func (*PayloadKeyWithCommitment) ProtoMessage()    {}
func (*PayloadKeyWithCommitment) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{5}
}
func (m *PayloadKeyWithCommitment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PayloadKeyWithCommitment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PayloadKeyWithCommitment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PayloadKeyWithCommitment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PayloadKeyWithCommitment.Merge(m, src)
}
func (m *PayloadKeyWithCommitment) XXX_Size() int {
	return m.Size()
}
func (m *PayloadKeyWithCommitment) XXX_DiscardUnknown() {
	xxx_messageInfo_PayloadKeyWithCommitment.DiscardUnknown(m)
}

var xxx_messageInfo_PayloadKeyWithCommitment proto.InternalMessageInfo

func (m *PayloadKeyWithCommitment) GetPayloadKey() []byte {
	if m != nil {
		return m.PayloadKey
	}
	return nil
}

func (m *PayloadKeyWithCommitment) GetCommitment() *v1alpha1.StateCommitment {
	if m != nil {
		return m.Commitment
	}
	return nil
}

type NullifierWithNote struct {
	Nullifier *v1alpha1.Nullifier `protobuf:"bytes,1,opt,name=nullifier,proto3" json:"nullifier,omitempty"`
	Note      *v1alpha1.Note      `protobuf:"bytes,2,opt,name=note,proto3" json:"note,omitempty"`
}

func (m *NullifierWithNote) Reset()         { *m = NullifierWithNote{} }
func (m *NullifierWithNote) String() string { return proto.CompactTextString(m) }
func (*NullifierWithNote) ProtoMessage()    {}
func (*NullifierWithNote) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{6}
}
func (m *NullifierWithNote) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NullifierWithNote) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NullifierWithNote.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NullifierWithNote) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NullifierWithNote.Merge(m, src)
}
func (m *NullifierWithNote) XXX_Size() int {
	return m.Size()
}
func (m *NullifierWithNote) XXX_DiscardUnknown() {
	xxx_messageInfo_NullifierWithNote.DiscardUnknown(m)
}

var xxx_messageInfo_NullifierWithNote proto.InternalMessageInfo

func (m *NullifierWithNote) GetNullifier() *v1alpha1.Nullifier {
	if m != nil {
		return m.Nullifier
	}
	return nil
}

func (m *NullifierWithNote) GetNote() *v1alpha1.Note {
	if m != nil {
		return m.Note
	}
	return nil
}

type TransactionView struct {
	// A list views into of actions (state changes) performed by this transaction.
	ActionViews []*ActionView `protobuf:"bytes,1,rep,name=action_views,json=actionViews,proto3" json:"action_views,omitempty"`
	// The maximum height that this transaction can be included in the chain.
	//
	// If zero, there is no maximum.
	ExpiryHeight uint64 `protobuf:"varint,2,opt,name=expiry_height,json=expiryHeight,proto3" json:"expiry_height,omitempty"`
	// The chain this transaction is intended for.  Including this prevents
	// replaying a transaction on one chain onto a different chain.
	ChainId string `protobuf:"bytes,3,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// The transaction fee.
	Fee *v1alpha1.Fee `protobuf:"bytes,4,opt,name=fee,proto3" json:"fee,omitempty"`
	// A list of clues for use with Fuzzy Message Detection.
	FmdClues []*v1alpha1.Clue `protobuf:"bytes,5,rep,name=fmd_clues,json=fmdClues,proto3" json:"fmd_clues,omitempty"`
	// Types that are valid to be assigned to XMemo:
	//
	//	*TransactionView_Memo
	XMemo isTransactionView_XMemo `protobuf_oneof:"_memo"`
	// Any relevant address views.
	AddressViews []*v1alpha1.AddressView `protobuf:"bytes,400,rep,name=address_views,json=addressViews,proto3" json:"address_views,omitempty"`
}

func (m *TransactionView) Reset()         { *m = TransactionView{} }
func (m *TransactionView) String() string { return proto.CompactTextString(m) }
func (*TransactionView) ProtoMessage()    {}
func (*TransactionView) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{7}
}
func (m *TransactionView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactionView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransactionView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransactionView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionView.Merge(m, src)
}
func (m *TransactionView) XXX_Size() int {
	return m.Size()
}
func (m *TransactionView) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionView.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionView proto.InternalMessageInfo

type isTransactionView_XMemo interface {
	isTransactionView_XMemo()
	MarshalTo([]byte) (int, error)
	Size() int
}

type TransactionView_Memo struct {
	Memo []byte `protobuf:"bytes,6,opt,name=memo,proto3,oneof" json:"memo,omitempty"`
}

func (*TransactionView_Memo) isTransactionView_XMemo() {}

func (m *TransactionView) GetXMemo() isTransactionView_XMemo {
	if m != nil {
		return m.XMemo
	}
	return nil
}

func (m *TransactionView) GetActionViews() []*ActionView {
	if m != nil {
		return m.ActionViews
	}
	return nil
}

func (m *TransactionView) GetExpiryHeight() uint64 {
	if m != nil {
		return m.ExpiryHeight
	}
	return 0
}

func (m *TransactionView) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *TransactionView) GetFee() *v1alpha1.Fee {
	if m != nil {
		return m.Fee
	}
	return nil
}

func (m *TransactionView) GetFmdClues() []*v1alpha1.Clue {
	if m != nil {
		return m.FmdClues
	}
	return nil
}

func (m *TransactionView) GetMemo() []byte {
	if x, ok := m.GetXMemo().(*TransactionView_Memo); ok {
		return x.Memo
	}
	return nil
}

func (m *TransactionView) GetAddressViews() []*v1alpha1.AddressView {
	if m != nil {
		return m.AddressViews
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TransactionView) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TransactionView_Memo)(nil),
	}
}

// A view of a specific state change action performed by a transaction.
type ActionView struct {
	// Types that are valid to be assigned to ActionView:
	//
	//	*ActionView_Spend
	//	*ActionView_Output
	//	*ActionView_Swap
	//	*ActionView_SwapClaim
	//	*ActionView_ValidatorDefinition
	//	*ActionView_IbcAction
	//	*ActionView_ProposalSubmit
	//	*ActionView_ProposalWithdraw
	//	*ActionView_ValidatorVote
	//	*ActionView_DelegatorVote
	//	*ActionView_ProposalDepositClaim
	//	*ActionView_PositionOpen
	//	*ActionView_PositionClose
	//	*ActionView_PositionWithdraw
	//	*ActionView_PositionRewardClaim
	//	*ActionView_Delegate
	//	*ActionView_Undelegate
	//	*ActionView_DaoSpend
	//	*ActionView_DaoOutput
	//	*ActionView_DaoDeposit
	//	*ActionView_UndelegateClaim
	//	*ActionView_Ics20Withdrawal
	ActionView isActionView_ActionView `protobuf_oneof:"action_view"`
}

func (m *ActionView) Reset()         { *m = ActionView{} }
func (m *ActionView) String() string { return proto.CompactTextString(m) }
func (*ActionView) ProtoMessage()    {}
func (*ActionView) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{8}
}
func (m *ActionView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionView.Merge(m, src)
}
func (m *ActionView) XXX_Size() int {
	return m.Size()
}
func (m *ActionView) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionView.DiscardUnknown(m)
}

var xxx_messageInfo_ActionView proto.InternalMessageInfo

type isActionView_ActionView interface {
	isActionView_ActionView()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ActionView_Spend struct {
	Spend *SpendView `protobuf:"bytes,1,opt,name=spend,proto3,oneof" json:"spend,omitempty"`
}
type ActionView_Output struct {
	Output *OutputView `protobuf:"bytes,2,opt,name=output,proto3,oneof" json:"output,omitempty"`
}
type ActionView_Swap struct {
	Swap *v1alpha11.SwapView `protobuf:"bytes,3,opt,name=swap,proto3,oneof" json:"swap,omitempty"`
}
type ActionView_SwapClaim struct {
	SwapClaim *v1alpha11.SwapClaimView `protobuf:"bytes,4,opt,name=swap_claim,json=swapClaim,proto3,oneof" json:"swap_claim,omitempty"`
}
type ActionView_ValidatorDefinition struct {
	ValidatorDefinition *v1alpha12.ValidatorDefinition `protobuf:"bytes,16,opt,name=validator_definition,json=validatorDefinition,proto3,oneof" json:"validator_definition,omitempty"`
}
type ActionView_IbcAction struct {
	IbcAction *v1alpha13.IbcAction `protobuf:"bytes,17,opt,name=ibc_action,json=ibcAction,proto3,oneof" json:"ibc_action,omitempty"`
}
type ActionView_ProposalSubmit struct {
	ProposalSubmit *v1alpha14.ProposalSubmit `protobuf:"bytes,18,opt,name=proposal_submit,json=proposalSubmit,proto3,oneof" json:"proposal_submit,omitempty"`
}
type ActionView_ProposalWithdraw struct {
	ProposalWithdraw *v1alpha14.ProposalWithdraw `protobuf:"bytes,19,opt,name=proposal_withdraw,json=proposalWithdraw,proto3,oneof" json:"proposal_withdraw,omitempty"`
}
type ActionView_ValidatorVote struct {
	ValidatorVote *v1alpha14.ValidatorVote `protobuf:"bytes,20,opt,name=validator_vote,json=validatorVote,proto3,oneof" json:"validator_vote,omitempty"`
}
type ActionView_DelegatorVote struct {
	DelegatorVote *DelegatorVoteView `protobuf:"bytes,21,opt,name=delegator_vote,json=delegatorVote,proto3,oneof" json:"delegator_vote,omitempty"`
}
type ActionView_ProposalDepositClaim struct {
	ProposalDepositClaim *v1alpha14.ProposalDepositClaim `protobuf:"bytes,22,opt,name=proposal_deposit_claim,json=proposalDepositClaim,proto3,oneof" json:"proposal_deposit_claim,omitempty"`
}
type ActionView_PositionOpen struct {
	PositionOpen *v1alpha11.PositionOpen `protobuf:"bytes,30,opt,name=position_open,json=positionOpen,proto3,oneof" json:"position_open,omitempty"`
}
type ActionView_PositionClose struct {
	PositionClose *v1alpha11.PositionClose `protobuf:"bytes,31,opt,name=position_close,json=positionClose,proto3,oneof" json:"position_close,omitempty"`
}
type ActionView_PositionWithdraw struct {
	PositionWithdraw *v1alpha11.PositionWithdraw `protobuf:"bytes,32,opt,name=position_withdraw,json=positionWithdraw,proto3,oneof" json:"position_withdraw,omitempty"`
}
type ActionView_PositionRewardClaim struct {
	PositionRewardClaim *v1alpha11.PositionRewardClaim `protobuf:"bytes,34,opt,name=position_reward_claim,json=positionRewardClaim,proto3,oneof" json:"position_reward_claim,omitempty"`
}
type ActionView_Delegate struct {
	Delegate *v1alpha12.Delegate `protobuf:"bytes,41,opt,name=delegate,proto3,oneof" json:"delegate,omitempty"`
}
type ActionView_Undelegate struct {
	Undelegate *v1alpha12.Undelegate `protobuf:"bytes,42,opt,name=undelegate,proto3,oneof" json:"undelegate,omitempty"`
}
type ActionView_DaoSpend struct {
	DaoSpend *v1alpha14.DaoSpend `protobuf:"bytes,50,opt,name=dao_spend,json=daoSpend,proto3,oneof" json:"dao_spend,omitempty"`
}
type ActionView_DaoOutput struct {
	DaoOutput *v1alpha14.DaoOutput `protobuf:"bytes,51,opt,name=dao_output,json=daoOutput,proto3,oneof" json:"dao_output,omitempty"`
}
type ActionView_DaoDeposit struct {
	DaoDeposit *v1alpha14.DaoDeposit `protobuf:"bytes,52,opt,name=dao_deposit,json=daoDeposit,proto3,oneof" json:"dao_deposit,omitempty"`
}
type ActionView_UndelegateClaim struct {
	UndelegateClaim *v1alpha12.UndelegateClaim `protobuf:"bytes,43,opt,name=undelegate_claim,json=undelegateClaim,proto3,oneof" json:"undelegate_claim,omitempty"`
}
type ActionView_Ics20Withdrawal struct {
	Ics20Withdrawal *v1alpha13.Ics20Withdrawal `protobuf:"bytes,200,opt,name=ics20_withdrawal,json=ics20Withdrawal,proto3,oneof" json:"ics20_withdrawal,omitempty"`
}

func (*ActionView_Spend) isActionView_ActionView()                {}
func (*ActionView_Output) isActionView_ActionView()               {}
func (*ActionView_Swap) isActionView_ActionView()                 {}
func (*ActionView_SwapClaim) isActionView_ActionView()            {}
func (*ActionView_ValidatorDefinition) isActionView_ActionView()  {}
func (*ActionView_IbcAction) isActionView_ActionView()            {}
func (*ActionView_ProposalSubmit) isActionView_ActionView()       {}
func (*ActionView_ProposalWithdraw) isActionView_ActionView()     {}
func (*ActionView_ValidatorVote) isActionView_ActionView()        {}
func (*ActionView_DelegatorVote) isActionView_ActionView()        {}
func (*ActionView_ProposalDepositClaim) isActionView_ActionView() {}
func (*ActionView_PositionOpen) isActionView_ActionView()         {}
func (*ActionView_PositionClose) isActionView_ActionView()        {}
func (*ActionView_PositionWithdraw) isActionView_ActionView()     {}
func (*ActionView_PositionRewardClaim) isActionView_ActionView()  {}
func (*ActionView_Delegate) isActionView_ActionView()             {}
func (*ActionView_Undelegate) isActionView_ActionView()           {}
func (*ActionView_DaoSpend) isActionView_ActionView()             {}
func (*ActionView_DaoOutput) isActionView_ActionView()            {}
func (*ActionView_DaoDeposit) isActionView_ActionView()           {}
func (*ActionView_UndelegateClaim) isActionView_ActionView()      {}
func (*ActionView_Ics20Withdrawal) isActionView_ActionView()      {}

func (m *ActionView) GetActionView() isActionView_ActionView {
	if m != nil {
		return m.ActionView
	}
	return nil
}

func (m *ActionView) GetSpend() *SpendView {
	if x, ok := m.GetActionView().(*ActionView_Spend); ok {
		return x.Spend
	}
	return nil
}

func (m *ActionView) GetOutput() *OutputView {
	if x, ok := m.GetActionView().(*ActionView_Output); ok {
		return x.Output
	}
	return nil
}

func (m *ActionView) GetSwap() *v1alpha11.SwapView {
	if x, ok := m.GetActionView().(*ActionView_Swap); ok {
		return x.Swap
	}
	return nil
}

func (m *ActionView) GetSwapClaim() *v1alpha11.SwapClaimView {
	if x, ok := m.GetActionView().(*ActionView_SwapClaim); ok {
		return x.SwapClaim
	}
	return nil
}

func (m *ActionView) GetValidatorDefinition() *v1alpha12.ValidatorDefinition {
	if x, ok := m.GetActionView().(*ActionView_ValidatorDefinition); ok {
		return x.ValidatorDefinition
	}
	return nil
}

func (m *ActionView) GetIbcAction() *v1alpha13.IbcAction {
	if x, ok := m.GetActionView().(*ActionView_IbcAction); ok {
		return x.IbcAction
	}
	return nil
}

func (m *ActionView) GetProposalSubmit() *v1alpha14.ProposalSubmit {
	if x, ok := m.GetActionView().(*ActionView_ProposalSubmit); ok {
		return x.ProposalSubmit
	}
	return nil
}

func (m *ActionView) GetProposalWithdraw() *v1alpha14.ProposalWithdraw {
	if x, ok := m.GetActionView().(*ActionView_ProposalWithdraw); ok {
		return x.ProposalWithdraw
	}
	return nil
}

func (m *ActionView) GetValidatorVote() *v1alpha14.ValidatorVote {
	if x, ok := m.GetActionView().(*ActionView_ValidatorVote); ok {
		return x.ValidatorVote
	}
	return nil
}

func (m *ActionView) GetDelegatorVote() *DelegatorVoteView {
	if x, ok := m.GetActionView().(*ActionView_DelegatorVote); ok {
		return x.DelegatorVote
	}
	return nil
}

func (m *ActionView) GetProposalDepositClaim() *v1alpha14.ProposalDepositClaim {
	if x, ok := m.GetActionView().(*ActionView_ProposalDepositClaim); ok {
		return x.ProposalDepositClaim
	}
	return nil
}

func (m *ActionView) GetPositionOpen() *v1alpha11.PositionOpen {
	if x, ok := m.GetActionView().(*ActionView_PositionOpen); ok {
		return x.PositionOpen
	}
	return nil
}

func (m *ActionView) GetPositionClose() *v1alpha11.PositionClose {
	if x, ok := m.GetActionView().(*ActionView_PositionClose); ok {
		return x.PositionClose
	}
	return nil
}

func (m *ActionView) GetPositionWithdraw() *v1alpha11.PositionWithdraw {
	if x, ok := m.GetActionView().(*ActionView_PositionWithdraw); ok {
		return x.PositionWithdraw
	}
	return nil
}

func (m *ActionView) GetPositionRewardClaim() *v1alpha11.PositionRewardClaim {
	if x, ok := m.GetActionView().(*ActionView_PositionRewardClaim); ok {
		return x.PositionRewardClaim
	}
	return nil
}

func (m *ActionView) GetDelegate() *v1alpha12.Delegate {
	if x, ok := m.GetActionView().(*ActionView_Delegate); ok {
		return x.Delegate
	}
	return nil
}

func (m *ActionView) GetUndelegate() *v1alpha12.Undelegate {
	if x, ok := m.GetActionView().(*ActionView_Undelegate); ok {
		return x.Undelegate
	}
	return nil
}

func (m *ActionView) GetDaoSpend() *v1alpha14.DaoSpend {
	if x, ok := m.GetActionView().(*ActionView_DaoSpend); ok {
		return x.DaoSpend
	}
	return nil
}

func (m *ActionView) GetDaoOutput() *v1alpha14.DaoOutput {
	if x, ok := m.GetActionView().(*ActionView_DaoOutput); ok {
		return x.DaoOutput
	}
	return nil
}

func (m *ActionView) GetDaoDeposit() *v1alpha14.DaoDeposit {
	if x, ok := m.GetActionView().(*ActionView_DaoDeposit); ok {
		return x.DaoDeposit
	}
	return nil
}

func (m *ActionView) GetUndelegateClaim() *v1alpha12.UndelegateClaim {
	if x, ok := m.GetActionView().(*ActionView_UndelegateClaim); ok {
		return x.UndelegateClaim
	}
	return nil
}

func (m *ActionView) GetIcs20Withdrawal() *v1alpha13.Ics20Withdrawal {
	if x, ok := m.GetActionView().(*ActionView_Ics20Withdrawal); ok {
		return x.Ics20Withdrawal
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ActionView) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ActionView_Spend)(nil),
		(*ActionView_Output)(nil),
		(*ActionView_Swap)(nil),
		(*ActionView_SwapClaim)(nil),
		(*ActionView_ValidatorDefinition)(nil),
		(*ActionView_IbcAction)(nil),
		(*ActionView_ProposalSubmit)(nil),
		(*ActionView_ProposalWithdraw)(nil),
		(*ActionView_ValidatorVote)(nil),
		(*ActionView_DelegatorVote)(nil),
		(*ActionView_ProposalDepositClaim)(nil),
		(*ActionView_PositionOpen)(nil),
		(*ActionView_PositionClose)(nil),
		(*ActionView_PositionWithdraw)(nil),
		(*ActionView_PositionRewardClaim)(nil),
		(*ActionView_Delegate)(nil),
		(*ActionView_Undelegate)(nil),
		(*ActionView_DaoSpend)(nil),
		(*ActionView_DaoOutput)(nil),
		(*ActionView_DaoDeposit)(nil),
		(*ActionView_UndelegateClaim)(nil),
		(*ActionView_Ics20Withdrawal)(nil),
	}
}

type SpendView struct {
	// Types that are valid to be assigned to SpendView:
	//
	//	*SpendView_Visible_
	//	*SpendView_Opaque_
	SpendView isSpendView_SpendView `protobuf_oneof:"spend_view"`
}

func (m *SpendView) Reset()         { *m = SpendView{} }
func (m *SpendView) String() string { return proto.CompactTextString(m) }
func (*SpendView) ProtoMessage()    {}
func (*SpendView) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{9}
}
func (m *SpendView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpendView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpendView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpendView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpendView.Merge(m, src)
}
func (m *SpendView) XXX_Size() int {
	return m.Size()
}
func (m *SpendView) XXX_DiscardUnknown() {
	xxx_messageInfo_SpendView.DiscardUnknown(m)
}

var xxx_messageInfo_SpendView proto.InternalMessageInfo

type isSpendView_SpendView interface {
	isSpendView_SpendView()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SpendView_Visible_ struct {
	Visible *SpendView_Visible `protobuf:"bytes,1,opt,name=visible,proto3,oneof" json:"visible,omitempty"`
}
type SpendView_Opaque_ struct {
	Opaque *SpendView_Opaque `protobuf:"bytes,2,opt,name=opaque,proto3,oneof" json:"opaque,omitempty"`
}

func (*SpendView_Visible_) isSpendView_SpendView() {}
func (*SpendView_Opaque_) isSpendView_SpendView()  {}

func (m *SpendView) GetSpendView() isSpendView_SpendView {
	if m != nil {
		return m.SpendView
	}
	return nil
}

func (m *SpendView) GetVisible() *SpendView_Visible {
	if x, ok := m.GetSpendView().(*SpendView_Visible_); ok {
		return x.Visible
	}
	return nil
}

func (m *SpendView) GetOpaque() *SpendView_Opaque {
	if x, ok := m.GetSpendView().(*SpendView_Opaque_); ok {
		return x.Opaque
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SpendView) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SpendView_Visible_)(nil),
		(*SpendView_Opaque_)(nil),
	}
}

type SpendView_Visible struct {
	Spend *Spend         `protobuf:"bytes,1,opt,name=spend,proto3" json:"spend,omitempty"`
	Note  *v1alpha1.Note `protobuf:"bytes,2,opt,name=note,proto3" json:"note,omitempty"`
}

func (m *SpendView_Visible) Reset()         { *m = SpendView_Visible{} }
func (m *SpendView_Visible) String() string { return proto.CompactTextString(m) }
func (*SpendView_Visible) ProtoMessage()    {}
func (*SpendView_Visible) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{9, 0}
}
func (m *SpendView_Visible) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpendView_Visible) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpendView_Visible.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpendView_Visible) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpendView_Visible.Merge(m, src)
}
func (m *SpendView_Visible) XXX_Size() int {
	return m.Size()
}
func (m *SpendView_Visible) XXX_DiscardUnknown() {
	xxx_messageInfo_SpendView_Visible.DiscardUnknown(m)
}

var xxx_messageInfo_SpendView_Visible proto.InternalMessageInfo

func (m *SpendView_Visible) GetSpend() *Spend {
	if m != nil {
		return m.Spend
	}
	return nil
}

func (m *SpendView_Visible) GetNote() *v1alpha1.Note {
	if m != nil {
		return m.Note
	}
	return nil
}

type SpendView_Opaque struct {
	Spend *Spend `protobuf:"bytes,1,opt,name=spend,proto3" json:"spend,omitempty"`
}

func (m *SpendView_Opaque) Reset()         { *m = SpendView_Opaque{} }
func (m *SpendView_Opaque) String() string { return proto.CompactTextString(m) }
func (*SpendView_Opaque) ProtoMessage()    {}
func (*SpendView_Opaque) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{9, 1}
}
func (m *SpendView_Opaque) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpendView_Opaque) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpendView_Opaque.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpendView_Opaque) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpendView_Opaque.Merge(m, src)
}
func (m *SpendView_Opaque) XXX_Size() int {
	return m.Size()
}
func (m *SpendView_Opaque) XXX_DiscardUnknown() {
	xxx_messageInfo_SpendView_Opaque.DiscardUnknown(m)
}

var xxx_messageInfo_SpendView_Opaque proto.InternalMessageInfo

func (m *SpendView_Opaque) GetSpend() *Spend {
	if m != nil {
		return m.Spend
	}
	return nil
}

type DelegatorVoteView struct {
	// Types that are valid to be assigned to DelegatorVote:
	//
	//	*DelegatorVoteView_Visible_
	//	*DelegatorVoteView_Opaque_
	DelegatorVote isDelegatorVoteView_DelegatorVote `protobuf_oneof:"delegator_vote"`
}

func (m *DelegatorVoteView) Reset()         { *m = DelegatorVoteView{} }
func (m *DelegatorVoteView) String() string { return proto.CompactTextString(m) }
func (*DelegatorVoteView) ProtoMessage()    {}
func (*DelegatorVoteView) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{10}
}
func (m *DelegatorVoteView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelegatorVoteView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelegatorVoteView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelegatorVoteView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelegatorVoteView.Merge(m, src)
}
func (m *DelegatorVoteView) XXX_Size() int {
	return m.Size()
}
func (m *DelegatorVoteView) XXX_DiscardUnknown() {
	xxx_messageInfo_DelegatorVoteView.DiscardUnknown(m)
}

var xxx_messageInfo_DelegatorVoteView proto.InternalMessageInfo

type isDelegatorVoteView_DelegatorVote interface {
	isDelegatorVoteView_DelegatorVote()
	MarshalTo([]byte) (int, error)
	Size() int
}

type DelegatorVoteView_Visible_ struct {
	Visible *DelegatorVoteView_Visible `protobuf:"bytes,1,opt,name=visible,proto3,oneof" json:"visible,omitempty"`
}
type DelegatorVoteView_Opaque_ struct {
	Opaque *DelegatorVoteView_Opaque `protobuf:"bytes,2,opt,name=opaque,proto3,oneof" json:"opaque,omitempty"`
}

func (*DelegatorVoteView_Visible_) isDelegatorVoteView_DelegatorVote() {}
func (*DelegatorVoteView_Opaque_) isDelegatorVoteView_DelegatorVote()  {}

func (m *DelegatorVoteView) GetDelegatorVote() isDelegatorVoteView_DelegatorVote {
	if m != nil {
		return m.DelegatorVote
	}
	return nil
}

func (m *DelegatorVoteView) GetVisible() *DelegatorVoteView_Visible {
	if x, ok := m.GetDelegatorVote().(*DelegatorVoteView_Visible_); ok {
		return x.Visible
	}
	return nil
}

func (m *DelegatorVoteView) GetOpaque() *DelegatorVoteView_Opaque {
	if x, ok := m.GetDelegatorVote().(*DelegatorVoteView_Opaque_); ok {
		return x.Opaque
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DelegatorVoteView) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DelegatorVoteView_Visible_)(nil),
		(*DelegatorVoteView_Opaque_)(nil),
	}
}

type DelegatorVoteView_Visible struct {
	DelegatorVote *v1alpha14.DelegatorVote `protobuf:"bytes,1,opt,name=delegator_vote,json=delegatorVote,proto3" json:"delegator_vote,omitempty"`
	Note          *v1alpha1.Note           `protobuf:"bytes,2,opt,name=note,proto3" json:"note,omitempty"`
}

func (m *DelegatorVoteView_Visible) Reset()         { *m = DelegatorVoteView_Visible{} }
func (m *DelegatorVoteView_Visible) String() string { return proto.CompactTextString(m) }
func (*DelegatorVoteView_Visible) ProtoMessage()    {}
func (*DelegatorVoteView_Visible) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{10, 0}
}
func (m *DelegatorVoteView_Visible) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelegatorVoteView_Visible) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelegatorVoteView_Visible.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelegatorVoteView_Visible) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelegatorVoteView_Visible.Merge(m, src)
}
func (m *DelegatorVoteView_Visible) XXX_Size() int {
	return m.Size()
}
func (m *DelegatorVoteView_Visible) XXX_DiscardUnknown() {
	xxx_messageInfo_DelegatorVoteView_Visible.DiscardUnknown(m)
}

var xxx_messageInfo_DelegatorVoteView_Visible proto.InternalMessageInfo

func (m *DelegatorVoteView_Visible) GetDelegatorVote() *v1alpha14.DelegatorVote {
	if m != nil {
		return m.DelegatorVote
	}
	return nil
}

func (m *DelegatorVoteView_Visible) GetNote() *v1alpha1.Note {
	if m != nil {
		return m.Note
	}
	return nil
}

type DelegatorVoteView_Opaque struct {
	DelegatorVote *v1alpha14.DelegatorVote `protobuf:"bytes,1,opt,name=delegator_vote,json=delegatorVote,proto3" json:"delegator_vote,omitempty"`
}

func (m *DelegatorVoteView_Opaque) Reset()         { *m = DelegatorVoteView_Opaque{} }
func (m *DelegatorVoteView_Opaque) String() string { return proto.CompactTextString(m) }
func (*DelegatorVoteView_Opaque) ProtoMessage()    {}
func (*DelegatorVoteView_Opaque) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{10, 1}
}
func (m *DelegatorVoteView_Opaque) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelegatorVoteView_Opaque) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelegatorVoteView_Opaque.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelegatorVoteView_Opaque) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelegatorVoteView_Opaque.Merge(m, src)
}
func (m *DelegatorVoteView_Opaque) XXX_Size() int {
	return m.Size()
}
func (m *DelegatorVoteView_Opaque) XXX_DiscardUnknown() {
	xxx_messageInfo_DelegatorVoteView_Opaque.DiscardUnknown(m)
}

var xxx_messageInfo_DelegatorVoteView_Opaque proto.InternalMessageInfo

func (m *DelegatorVoteView_Opaque) GetDelegatorVote() *v1alpha14.DelegatorVote {
	if m != nil {
		return m.DelegatorVote
	}
	return nil
}

type OutputView struct {
	// Types that are valid to be assigned to OutputView:
	//
	//	*OutputView_Visible_
	//	*OutputView_Opaque_
	OutputView isOutputView_OutputView `protobuf_oneof:"output_view"`
}

func (m *OutputView) Reset()         { *m = OutputView{} }
func (m *OutputView) String() string { return proto.CompactTextString(m) }
func (*OutputView) ProtoMessage()    {}
func (*OutputView) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{11}
}
func (m *OutputView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OutputView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OutputView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OutputView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutputView.Merge(m, src)
}
func (m *OutputView) XXX_Size() int {
	return m.Size()
}
func (m *OutputView) XXX_DiscardUnknown() {
	xxx_messageInfo_OutputView.DiscardUnknown(m)
}

var xxx_messageInfo_OutputView proto.InternalMessageInfo

type isOutputView_OutputView interface {
	isOutputView_OutputView()
	MarshalTo([]byte) (int, error)
	Size() int
}

type OutputView_Visible_ struct {
	Visible *OutputView_Visible `protobuf:"bytes,1,opt,name=visible,proto3,oneof" json:"visible,omitempty"`
}
type OutputView_Opaque_ struct {
	Opaque *OutputView_Opaque `protobuf:"bytes,2,opt,name=opaque,proto3,oneof" json:"opaque,omitempty"`
}

func (*OutputView_Visible_) isOutputView_OutputView() {}
func (*OutputView_Opaque_) isOutputView_OutputView()  {}

func (m *OutputView) GetOutputView() isOutputView_OutputView {
	if m != nil {
		return m.OutputView
	}
	return nil
}

func (m *OutputView) GetVisible() *OutputView_Visible {
	if x, ok := m.GetOutputView().(*OutputView_Visible_); ok {
		return x.Visible
	}
	return nil
}

func (m *OutputView) GetOpaque() *OutputView_Opaque {
	if x, ok := m.GetOutputView().(*OutputView_Opaque_); ok {
		return x.Opaque
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*OutputView) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*OutputView_Visible_)(nil),
		(*OutputView_Opaque_)(nil),
	}
}

type OutputView_Visible struct {
	Output     *Output        `protobuf:"bytes,1,opt,name=output,proto3" json:"output,omitempty"`
	Note       *v1alpha1.Note `protobuf:"bytes,2,opt,name=note,proto3" json:"note,omitempty"`
	PayloadKey []byte         `protobuf:"bytes,3,opt,name=payload_key,json=payloadKey,proto3" json:"payload_key,omitempty"`
}

func (m *OutputView_Visible) Reset()         { *m = OutputView_Visible{} }
func (m *OutputView_Visible) String() string { return proto.CompactTextString(m) }
func (*OutputView_Visible) ProtoMessage()    {}
func (*OutputView_Visible) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{11, 0}
}
func (m *OutputView_Visible) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OutputView_Visible) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OutputView_Visible.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OutputView_Visible) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutputView_Visible.Merge(m, src)
}
func (m *OutputView_Visible) XXX_Size() int {
	return m.Size()
}
func (m *OutputView_Visible) XXX_DiscardUnknown() {
	xxx_messageInfo_OutputView_Visible.DiscardUnknown(m)
}

var xxx_messageInfo_OutputView_Visible proto.InternalMessageInfo

func (m *OutputView_Visible) GetOutput() *Output {
	if m != nil {
		return m.Output
	}
	return nil
}

func (m *OutputView_Visible) GetNote() *v1alpha1.Note {
	if m != nil {
		return m.Note
	}
	return nil
}

func (m *OutputView_Visible) GetPayloadKey() []byte {
	if m != nil {
		return m.PayloadKey
	}
	return nil
}

type OutputView_Opaque struct {
	Output *Output `protobuf:"bytes,1,opt,name=output,proto3" json:"output,omitempty"`
}

func (m *OutputView_Opaque) Reset()         { *m = OutputView_Opaque{} }
func (m *OutputView_Opaque) String() string { return proto.CompactTextString(m) }
func (*OutputView_Opaque) ProtoMessage()    {}
func (*OutputView_Opaque) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{11, 1}
}
func (m *OutputView_Opaque) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OutputView_Opaque) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OutputView_Opaque.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OutputView_Opaque) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutputView_Opaque.Merge(m, src)
}
func (m *OutputView_Opaque) XXX_Size() int {
	return m.Size()
}
func (m *OutputView_Opaque) XXX_DiscardUnknown() {
	xxx_messageInfo_OutputView_Opaque.DiscardUnknown(m)
}

var xxx_messageInfo_OutputView_Opaque proto.InternalMessageInfo

func (m *OutputView_Opaque) GetOutput() *Output {
	if m != nil {
		return m.Output
	}
	return nil
}

// Spends a shielded note.
type Spend struct {
	// The effecting data of the spend.
	Body *SpendBody `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// The authorizing signature for the spend.
	AuthSig *v1alpha1.SpendAuthSignature `protobuf:"bytes,2,opt,name=auth_sig,json=authSig,proto3" json:"auth_sig,omitempty"`
	// The proof that the spend is well-formed is authorizing data.
	Proof *v1alpha1.ZKSpendProof `protobuf:"bytes,3,opt,name=proof,proto3" json:"proof,omitempty"`
}

func (m *Spend) Reset()         { *m = Spend{} }
func (m *Spend) String() string { return proto.CompactTextString(m) }
func (*Spend) ProtoMessage()    {}
func (*Spend) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{12}
}
func (m *Spend) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Spend) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Spend.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Spend) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Spend.Merge(m, src)
}
func (m *Spend) XXX_Size() int {
	return m.Size()
}
func (m *Spend) XXX_DiscardUnknown() {
	xxx_messageInfo_Spend.DiscardUnknown(m)
}

var xxx_messageInfo_Spend proto.InternalMessageInfo

func (m *Spend) GetBody() *SpendBody {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *Spend) GetAuthSig() *v1alpha1.SpendAuthSignature {
	if m != nil {
		return m.AuthSig
	}
	return nil
}

func (m *Spend) GetProof() *v1alpha1.ZKSpendProof {
	if m != nil {
		return m.Proof
	}
	return nil
}

// The body of a spend description, containing only the effecting data
// describing changes to the ledger, and not the authorizing data that allows
// those changes to be performed.
type SpendBody struct {
	// A commitment to the value of the input note.
	BalanceCommitment *v1alpha1.BalanceCommitment `protobuf:"bytes,1,opt,name=balance_commitment,json=balanceCommitment,proto3" json:"balance_commitment,omitempty"`
	// The nullifier of the input note.
	Nullifier []byte `protobuf:"bytes,3,opt,name=nullifier,proto3" json:"nullifier,omitempty"`
	// The randomized validating key for the spend authorization signature.
	Rk []byte `protobuf:"bytes,4,opt,name=rk,proto3" json:"rk,omitempty"`
}

func (m *SpendBody) Reset()         { *m = SpendBody{} }
func (m *SpendBody) String() string { return proto.CompactTextString(m) }
func (*SpendBody) ProtoMessage()    {}
func (*SpendBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{13}
}
func (m *SpendBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpendBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpendBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpendBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpendBody.Merge(m, src)
}
func (m *SpendBody) XXX_Size() int {
	return m.Size()
}
func (m *SpendBody) XXX_DiscardUnknown() {
	xxx_messageInfo_SpendBody.DiscardUnknown(m)
}

var xxx_messageInfo_SpendBody proto.InternalMessageInfo

func (m *SpendBody) GetBalanceCommitment() *v1alpha1.BalanceCommitment {
	if m != nil {
		return m.BalanceCommitment
	}
	return nil
}

func (m *SpendBody) GetNullifier() []byte {
	if m != nil {
		return m.Nullifier
	}
	return nil
}

func (m *SpendBody) GetRk() []byte {
	if m != nil {
		return m.Rk
	}
	return nil
}

// Creates a new shielded note.
type Output struct {
	// The effecting data for the output.
	Body *OutputBody `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// The output proof is authorizing data.
	Proof *v1alpha1.ZKOutputProof `protobuf:"bytes,2,opt,name=proof,proto3" json:"proof,omitempty"`
}

func (m *Output) Reset()         { *m = Output{} }
func (m *Output) String() string { return proto.CompactTextString(m) }
func (*Output) ProtoMessage()    {}
func (*Output) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{14}
}
func (m *Output) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Output) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Output.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Output) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Output.Merge(m, src)
}
func (m *Output) XXX_Size() int {
	return m.Size()
}
func (m *Output) XXX_DiscardUnknown() {
	xxx_messageInfo_Output.DiscardUnknown(m)
}

var xxx_messageInfo_Output proto.InternalMessageInfo

func (m *Output) GetBody() *OutputBody {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *Output) GetProof() *v1alpha1.ZKOutputProof {
	if m != nil {
		return m.Proof
	}
	return nil
}

// The body of an output description, containing only the effecting data
// describing changes to the ledger, and not the authorizing data that allows
// those changes to be performed.
type OutputBody struct {
	// The minimal data required to scan and process the new output note.
	NotePayload *v1alpha1.NotePayload `protobuf:"bytes,1,opt,name=note_payload,json=notePayload,proto3" json:"note_payload,omitempty"`
	// A commitment to the value of the output note. 32 bytes.
	BalanceCommitment *v1alpha1.BalanceCommitment `protobuf:"bytes,2,opt,name=balance_commitment,json=balanceCommitment,proto3" json:"balance_commitment,omitempty"`
	// An encrypted key for decrypting the memo.
	WrappedMemoKey []byte `protobuf:"bytes,3,opt,name=wrapped_memo_key,json=wrappedMemoKey,proto3" json:"wrapped_memo_key,omitempty"`
	// The key material used for note encryption, wrapped in encryption to the
	// sender's outgoing viewing key. 80 bytes.
	OvkWrappedKey []byte `protobuf:"bytes,4,opt,name=ovk_wrapped_key,json=ovkWrappedKey,proto3" json:"ovk_wrapped_key,omitempty"`
}

func (m *OutputBody) Reset()         { *m = OutputBody{} }
func (m *OutputBody) String() string { return proto.CompactTextString(m) }
func (*OutputBody) ProtoMessage()    {}
func (*OutputBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{15}
}
func (m *OutputBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OutputBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OutputBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OutputBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutputBody.Merge(m, src)
}
func (m *OutputBody) XXX_Size() int {
	return m.Size()
}
func (m *OutputBody) XXX_DiscardUnknown() {
	xxx_messageInfo_OutputBody.DiscardUnknown(m)
}

var xxx_messageInfo_OutputBody proto.InternalMessageInfo

func (m *OutputBody) GetNotePayload() *v1alpha1.NotePayload {
	if m != nil {
		return m.NotePayload
	}
	return nil
}

func (m *OutputBody) GetBalanceCommitment() *v1alpha1.BalanceCommitment {
	if m != nil {
		return m.BalanceCommitment
	}
	return nil
}

func (m *OutputBody) GetWrappedMemoKey() []byte {
	if m != nil {
		return m.WrappedMemoKey
	}
	return nil
}

func (m *OutputBody) GetOvkWrappedKey() []byte {
	if m != nil {
		return m.OvkWrappedKey
	}
	return nil
}

// The data required to authorize a transaction plan.
type AuthorizationData struct {
	// The computed auth hash for the approved transaction plan.
	EffectHash *v1alpha1.EffectHash `protobuf:"bytes,1,opt,name=effect_hash,json=effectHash,proto3" json:"effect_hash,omitempty"`
	// The required spend authorizations, returned in the same order as the
	// Spend actions in the original request.
	SpendAuths []*v1alpha1.SpendAuthSignature `protobuf:"bytes,2,rep,name=spend_auths,json=spendAuths,proto3" json:"spend_auths,omitempty"`
	// The required delegator vote authorizations, returned in the same order as the
	// DelegatorVote actions in the original request.
	DelegatorVoteAuths []*v1alpha1.SpendAuthSignature `protobuf:"bytes,3,rep,name=delegator_vote_auths,json=delegatorVoteAuths,proto3" json:"delegator_vote_auths,omitempty"`
}

func (m *AuthorizationData) Reset()         { *m = AuthorizationData{} }
func (m *AuthorizationData) String() string { return proto.CompactTextString(m) }
func (*AuthorizationData) ProtoMessage()    {}
func (*AuthorizationData) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{16}
}
func (m *AuthorizationData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthorizationData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthorizationData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthorizationData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthorizationData.Merge(m, src)
}
func (m *AuthorizationData) XXX_Size() int {
	return m.Size()
}
func (m *AuthorizationData) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthorizationData.DiscardUnknown(m)
}

var xxx_messageInfo_AuthorizationData proto.InternalMessageInfo

func (m *AuthorizationData) GetEffectHash() *v1alpha1.EffectHash {
	if m != nil {
		return m.EffectHash
	}
	return nil
}

func (m *AuthorizationData) GetSpendAuths() []*v1alpha1.SpendAuthSignature {
	if m != nil {
		return m.SpendAuths
	}
	return nil
}

func (m *AuthorizationData) GetDelegatorVoteAuths() []*v1alpha1.SpendAuthSignature {
	if m != nil {
		return m.DelegatorVoteAuths
	}
	return nil
}

// The data required for proving when building a transaction from a plan.
type WitnessData struct {
	// The anchor for the state transition proofs.
	Anchor *v1alpha1.MerkleRoot `protobuf:"bytes,1,opt,name=anchor,proto3" json:"anchor,omitempty"`
	// The auth paths for the notes the transaction spends, in the
	// same order as the spends in the transaction plan.
	StateCommitmentProofs []*v1alpha1.StateCommitmentProof `protobuf:"bytes,2,rep,name=state_commitment_proofs,json=stateCommitmentProofs,proto3" json:"state_commitment_proofs,omitempty"`
}

func (m *WitnessData) Reset()         { *m = WitnessData{} }
func (m *WitnessData) String() string { return proto.CompactTextString(m) }
func (*WitnessData) ProtoMessage()    {}
func (*WitnessData) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{17}
}
func (m *WitnessData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WitnessData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WitnessData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WitnessData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WitnessData.Merge(m, src)
}
func (m *WitnessData) XXX_Size() int {
	return m.Size()
}
func (m *WitnessData) XXX_DiscardUnknown() {
	xxx_messageInfo_WitnessData.DiscardUnknown(m)
}

var xxx_messageInfo_WitnessData proto.InternalMessageInfo

func (m *WitnessData) GetAnchor() *v1alpha1.MerkleRoot {
	if m != nil {
		return m.Anchor
	}
	return nil
}

func (m *WitnessData) GetStateCommitmentProofs() []*v1alpha1.StateCommitmentProof {
	if m != nil {
		return m.StateCommitmentProofs
	}
	return nil
}

// Describes a planned transaction.
type TransactionPlan struct {
	Actions      []*ActionPlan `protobuf:"bytes,1,rep,name=actions,proto3" json:"actions,omitempty"`
	ExpiryHeight uint64        `protobuf:"varint,2,opt,name=expiry_height,json=expiryHeight,proto3" json:"expiry_height,omitempty"`
	ChainId      string        `protobuf:"bytes,3,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	Fee          *v1alpha1.Fee `protobuf:"bytes,4,opt,name=fee,proto3" json:"fee,omitempty"`
	CluePlans    []*CluePlan   `protobuf:"bytes,5,rep,name=clue_plans,json=cluePlans,proto3" json:"clue_plans,omitempty"`
	MemoPlan     *MemoPlan     `protobuf:"bytes,6,opt,name=memo_plan,json=memoPlan,proto3" json:"memo_plan,omitempty"`
}

func (m *TransactionPlan) Reset()         { *m = TransactionPlan{} }
func (m *TransactionPlan) String() string { return proto.CompactTextString(m) }
func (*TransactionPlan) ProtoMessage()    {}
func (*TransactionPlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{18}
}
func (m *TransactionPlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactionPlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransactionPlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransactionPlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionPlan.Merge(m, src)
}
func (m *TransactionPlan) XXX_Size() int {
	return m.Size()
}
func (m *TransactionPlan) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionPlan.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionPlan proto.InternalMessageInfo

func (m *TransactionPlan) GetActions() []*ActionPlan {
	if m != nil {
		return m.Actions
	}
	return nil
}

func (m *TransactionPlan) GetExpiryHeight() uint64 {
	if m != nil {
		return m.ExpiryHeight
	}
	return 0
}

func (m *TransactionPlan) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *TransactionPlan) GetFee() *v1alpha1.Fee {
	if m != nil {
		return m.Fee
	}
	return nil
}

func (m *TransactionPlan) GetCluePlans() []*CluePlan {
	if m != nil {
		return m.CluePlans
	}
	return nil
}

func (m *TransactionPlan) GetMemoPlan() *MemoPlan {
	if m != nil {
		return m.MemoPlan
	}
	return nil
}

// Describes a planned transaction action.
//
// Some transaction Actions don't have any private data and are treated as being plans
// themselves.
type ActionPlan struct {
	// Types that are valid to be assigned to Action:
	//
	//	*ActionPlan_Spend
	//	*ActionPlan_Output
	//	*ActionPlan_Swap
	//	*ActionPlan_SwapClaim
	//	*ActionPlan_ValidatorDefinition
	//	*ActionPlan_IbcAction
	//	*ActionPlan_ProposalSubmit
	//	*ActionPlan_ProposalWithdraw
	//	*ActionPlan_ValidatorVote
	//	*ActionPlan_DelegatorVote
	//	*ActionPlan_ProposalDepositClaim
	//	*ActionPlan_PositionOpen
	//	*ActionPlan_PositionClose
	//	*ActionPlan_PositionWithdraw
	//	*ActionPlan_PositionRewardClaim
	//	*ActionPlan_Delegate
	//	*ActionPlan_Undelegate
	//	*ActionPlan_UndelegateClaim
	//	*ActionPlan_DaoSpend
	//	*ActionPlan_DaoOutput
	//	*ActionPlan_DaoDeposit
	Action isActionPlan_Action `protobuf_oneof:"action"`
}

func (m *ActionPlan) Reset()         { *m = ActionPlan{} }
func (m *ActionPlan) String() string { return proto.CompactTextString(m) }
func (*ActionPlan) ProtoMessage()    {}
func (*ActionPlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{19}
}
func (m *ActionPlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionPlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionPlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionPlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionPlan.Merge(m, src)
}
func (m *ActionPlan) XXX_Size() int {
	return m.Size()
}
func (m *ActionPlan) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionPlan.DiscardUnknown(m)
}

var xxx_messageInfo_ActionPlan proto.InternalMessageInfo

type isActionPlan_Action interface {
	isActionPlan_Action()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ActionPlan_Spend struct {
	Spend *SpendPlan `protobuf:"bytes,1,opt,name=spend,proto3,oneof" json:"spend,omitempty"`
}
type ActionPlan_Output struct {
	Output *OutputPlan `protobuf:"bytes,2,opt,name=output,proto3,oneof" json:"output,omitempty"`
}
type ActionPlan_Swap struct {
	Swap *v1alpha11.SwapPlan `protobuf:"bytes,3,opt,name=swap,proto3,oneof" json:"swap,omitempty"`
}
type ActionPlan_SwapClaim struct {
	SwapClaim *v1alpha11.SwapClaimPlan `protobuf:"bytes,4,opt,name=swap_claim,json=swapClaim,proto3,oneof" json:"swap_claim,omitempty"`
}
type ActionPlan_ValidatorDefinition struct {
	ValidatorDefinition *v1alpha12.ValidatorDefinition `protobuf:"bytes,16,opt,name=validator_definition,json=validatorDefinition,proto3,oneof" json:"validator_definition,omitempty"`
}
type ActionPlan_IbcAction struct {
	IbcAction *v1alpha13.IbcAction `protobuf:"bytes,17,opt,name=ibc_action,json=ibcAction,proto3,oneof" json:"ibc_action,omitempty"`
}
type ActionPlan_ProposalSubmit struct {
	ProposalSubmit *v1alpha14.ProposalSubmit `protobuf:"bytes,18,opt,name=proposal_submit,json=proposalSubmit,proto3,oneof" json:"proposal_submit,omitempty"`
}
type ActionPlan_ProposalWithdraw struct {
	ProposalWithdraw *v1alpha14.ProposalWithdraw `protobuf:"bytes,19,opt,name=proposal_withdraw,json=proposalWithdraw,proto3,oneof" json:"proposal_withdraw,omitempty"`
}
type ActionPlan_ValidatorVote struct {
	ValidatorVote *v1alpha14.ValidatorVote `protobuf:"bytes,20,opt,name=validator_vote,json=validatorVote,proto3,oneof" json:"validator_vote,omitempty"`
}
type ActionPlan_DelegatorVote struct {
	DelegatorVote *v1alpha14.DelegatorVotePlan `protobuf:"bytes,21,opt,name=delegator_vote,json=delegatorVote,proto3,oneof" json:"delegator_vote,omitempty"`
}
type ActionPlan_ProposalDepositClaim struct {
	ProposalDepositClaim *v1alpha14.ProposalDepositClaim `protobuf:"bytes,22,opt,name=proposal_deposit_claim,json=proposalDepositClaim,proto3,oneof" json:"proposal_deposit_claim,omitempty"`
}
type ActionPlan_PositionOpen struct {
	PositionOpen *v1alpha11.PositionOpen `protobuf:"bytes,30,opt,name=position_open,json=positionOpen,proto3,oneof" json:"position_open,omitempty"`
}
type ActionPlan_PositionClose struct {
	PositionClose *v1alpha11.PositionClose `protobuf:"bytes,31,opt,name=position_close,json=positionClose,proto3,oneof" json:"position_close,omitempty"`
}
type ActionPlan_PositionWithdraw struct {
	PositionWithdraw *v1alpha11.PositionWithdrawPlan `protobuf:"bytes,32,opt,name=position_withdraw,json=positionWithdraw,proto3,oneof" json:"position_withdraw,omitempty"`
}
type ActionPlan_PositionRewardClaim struct {
	PositionRewardClaim *v1alpha11.PositionRewardClaimPlan `protobuf:"bytes,34,opt,name=position_reward_claim,json=positionRewardClaim,proto3,oneof" json:"position_reward_claim,omitempty"`
}
type ActionPlan_Delegate struct {
	Delegate *v1alpha12.Delegate `protobuf:"bytes,40,opt,name=delegate,proto3,oneof" json:"delegate,omitempty"`
}
type ActionPlan_Undelegate struct {
	Undelegate *v1alpha12.Undelegate `protobuf:"bytes,41,opt,name=undelegate,proto3,oneof" json:"undelegate,omitempty"`
}
type ActionPlan_UndelegateClaim struct {
	UndelegateClaim *v1alpha12.UndelegateClaimPlan `protobuf:"bytes,42,opt,name=undelegate_claim,json=undelegateClaim,proto3,oneof" json:"undelegate_claim,omitempty"`
}
type ActionPlan_DaoSpend struct {
	DaoSpend *v1alpha14.DaoSpend `protobuf:"bytes,50,opt,name=dao_spend,json=daoSpend,proto3,oneof" json:"dao_spend,omitempty"`
}
type ActionPlan_DaoOutput struct {
	DaoOutput *v1alpha14.DaoOutput `protobuf:"bytes,51,opt,name=dao_output,json=daoOutput,proto3,oneof" json:"dao_output,omitempty"`
}
type ActionPlan_DaoDeposit struct {
	DaoDeposit *v1alpha14.DaoDeposit `protobuf:"bytes,52,opt,name=dao_deposit,json=daoDeposit,proto3,oneof" json:"dao_deposit,omitempty"`
}

func (*ActionPlan_Spend) isActionPlan_Action()                {}
func (*ActionPlan_Output) isActionPlan_Action()               {}
func (*ActionPlan_Swap) isActionPlan_Action()                 {}
func (*ActionPlan_SwapClaim) isActionPlan_Action()            {}
func (*ActionPlan_ValidatorDefinition) isActionPlan_Action()  {}
func (*ActionPlan_IbcAction) isActionPlan_Action()            {}
func (*ActionPlan_ProposalSubmit) isActionPlan_Action()       {}
func (*ActionPlan_ProposalWithdraw) isActionPlan_Action()     {}
func (*ActionPlan_ValidatorVote) isActionPlan_Action()        {}
func (*ActionPlan_DelegatorVote) isActionPlan_Action()        {}
func (*ActionPlan_ProposalDepositClaim) isActionPlan_Action() {}
func (*ActionPlan_PositionOpen) isActionPlan_Action()         {}
func (*ActionPlan_PositionClose) isActionPlan_Action()        {}
func (*ActionPlan_PositionWithdraw) isActionPlan_Action()     {}
func (*ActionPlan_PositionRewardClaim) isActionPlan_Action()  {}
func (*ActionPlan_Delegate) isActionPlan_Action()             {}
func (*ActionPlan_Undelegate) isActionPlan_Action()           {}
func (*ActionPlan_UndelegateClaim) isActionPlan_Action()      {}
func (*ActionPlan_DaoSpend) isActionPlan_Action()             {}
func (*ActionPlan_DaoOutput) isActionPlan_Action()            {}
func (*ActionPlan_DaoDeposit) isActionPlan_Action()           {}

func (m *ActionPlan) GetAction() isActionPlan_Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *ActionPlan) GetSpend() *SpendPlan {
	if x, ok := m.GetAction().(*ActionPlan_Spend); ok {
		return x.Spend
	}
	return nil
}

func (m *ActionPlan) GetOutput() *OutputPlan {
	if x, ok := m.GetAction().(*ActionPlan_Output); ok {
		return x.Output
	}
	return nil
}

func (m *ActionPlan) GetSwap() *v1alpha11.SwapPlan {
	if x, ok := m.GetAction().(*ActionPlan_Swap); ok {
		return x.Swap
	}
	return nil
}

func (m *ActionPlan) GetSwapClaim() *v1alpha11.SwapClaimPlan {
	if x, ok := m.GetAction().(*ActionPlan_SwapClaim); ok {
		return x.SwapClaim
	}
	return nil
}

func (m *ActionPlan) GetValidatorDefinition() *v1alpha12.ValidatorDefinition {
	if x, ok := m.GetAction().(*ActionPlan_ValidatorDefinition); ok {
		return x.ValidatorDefinition
	}
	return nil
}

func (m *ActionPlan) GetIbcAction() *v1alpha13.IbcAction {
	if x, ok := m.GetAction().(*ActionPlan_IbcAction); ok {
		return x.IbcAction
	}
	return nil
}

func (m *ActionPlan) GetProposalSubmit() *v1alpha14.ProposalSubmit {
	if x, ok := m.GetAction().(*ActionPlan_ProposalSubmit); ok {
		return x.ProposalSubmit
	}
	return nil
}

func (m *ActionPlan) GetProposalWithdraw() *v1alpha14.ProposalWithdraw {
	if x, ok := m.GetAction().(*ActionPlan_ProposalWithdraw); ok {
		return x.ProposalWithdraw
	}
	return nil
}

func (m *ActionPlan) GetValidatorVote() *v1alpha14.ValidatorVote {
	if x, ok := m.GetAction().(*ActionPlan_ValidatorVote); ok {
		return x.ValidatorVote
	}
	return nil
}

func (m *ActionPlan) GetDelegatorVote() *v1alpha14.DelegatorVotePlan {
	if x, ok := m.GetAction().(*ActionPlan_DelegatorVote); ok {
		return x.DelegatorVote
	}
	return nil
}

func (m *ActionPlan) GetProposalDepositClaim() *v1alpha14.ProposalDepositClaim {
	if x, ok := m.GetAction().(*ActionPlan_ProposalDepositClaim); ok {
		return x.ProposalDepositClaim
	}
	return nil
}

func (m *ActionPlan) GetPositionOpen() *v1alpha11.PositionOpen {
	if x, ok := m.GetAction().(*ActionPlan_PositionOpen); ok {
		return x.PositionOpen
	}
	return nil
}

func (m *ActionPlan) GetPositionClose() *v1alpha11.PositionClose {
	if x, ok := m.GetAction().(*ActionPlan_PositionClose); ok {
		return x.PositionClose
	}
	return nil
}

func (m *ActionPlan) GetPositionWithdraw() *v1alpha11.PositionWithdrawPlan {
	if x, ok := m.GetAction().(*ActionPlan_PositionWithdraw); ok {
		return x.PositionWithdraw
	}
	return nil
}

func (m *ActionPlan) GetPositionRewardClaim() *v1alpha11.PositionRewardClaimPlan {
	if x, ok := m.GetAction().(*ActionPlan_PositionRewardClaim); ok {
		return x.PositionRewardClaim
	}
	return nil
}

func (m *ActionPlan) GetDelegate() *v1alpha12.Delegate {
	if x, ok := m.GetAction().(*ActionPlan_Delegate); ok {
		return x.Delegate
	}
	return nil
}

func (m *ActionPlan) GetUndelegate() *v1alpha12.Undelegate {
	if x, ok := m.GetAction().(*ActionPlan_Undelegate); ok {
		return x.Undelegate
	}
	return nil
}

func (m *ActionPlan) GetUndelegateClaim() *v1alpha12.UndelegateClaimPlan {
	if x, ok := m.GetAction().(*ActionPlan_UndelegateClaim); ok {
		return x.UndelegateClaim
	}
	return nil
}

func (m *ActionPlan) GetDaoSpend() *v1alpha14.DaoSpend {
	if x, ok := m.GetAction().(*ActionPlan_DaoSpend); ok {
		return x.DaoSpend
	}
	return nil
}

func (m *ActionPlan) GetDaoOutput() *v1alpha14.DaoOutput {
	if x, ok := m.GetAction().(*ActionPlan_DaoOutput); ok {
		return x.DaoOutput
	}
	return nil
}

func (m *ActionPlan) GetDaoDeposit() *v1alpha14.DaoDeposit {
	if x, ok := m.GetAction().(*ActionPlan_DaoDeposit); ok {
		return x.DaoDeposit
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ActionPlan) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ActionPlan_Spend)(nil),
		(*ActionPlan_Output)(nil),
		(*ActionPlan_Swap)(nil),
		(*ActionPlan_SwapClaim)(nil),
		(*ActionPlan_ValidatorDefinition)(nil),
		(*ActionPlan_IbcAction)(nil),
		(*ActionPlan_ProposalSubmit)(nil),
		(*ActionPlan_ProposalWithdraw)(nil),
		(*ActionPlan_ValidatorVote)(nil),
		(*ActionPlan_DelegatorVote)(nil),
		(*ActionPlan_ProposalDepositClaim)(nil),
		(*ActionPlan_PositionOpen)(nil),
		(*ActionPlan_PositionClose)(nil),
		(*ActionPlan_PositionWithdraw)(nil),
		(*ActionPlan_PositionRewardClaim)(nil),
		(*ActionPlan_Delegate)(nil),
		(*ActionPlan_Undelegate)(nil),
		(*ActionPlan_UndelegateClaim)(nil),
		(*ActionPlan_DaoSpend)(nil),
		(*ActionPlan_DaoOutput)(nil),
		(*ActionPlan_DaoDeposit)(nil),
	}
}

// Describes a plan for forming a `Clue`.
type CluePlan struct {
	// The address.
	Address *v1alpha1.Address `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// The random seed to use for the clue plan.
	Rseed []byte `protobuf:"bytes,2,opt,name=rseed,proto3" json:"rseed,omitempty"`
	// The bits of precision.
	PrecisionBits uint64 `protobuf:"varint,3,opt,name=precision_bits,json=precisionBits,proto3" json:"precision_bits,omitempty"`
}

func (m *CluePlan) Reset()         { *m = CluePlan{} }
func (m *CluePlan) String() string { return proto.CompactTextString(m) }
func (*CluePlan) ProtoMessage()    {}
func (*CluePlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{20}
}
func (m *CluePlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CluePlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CluePlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CluePlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CluePlan.Merge(m, src)
}
func (m *CluePlan) XXX_Size() int {
	return m.Size()
}
func (m *CluePlan) XXX_DiscardUnknown() {
	xxx_messageInfo_CluePlan.DiscardUnknown(m)
}

var xxx_messageInfo_CluePlan proto.InternalMessageInfo

func (m *CluePlan) GetAddress() *v1alpha1.Address {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *CluePlan) GetRseed() []byte {
	if m != nil {
		return m.Rseed
	}
	return nil
}

func (m *CluePlan) GetPrecisionBits() uint64 {
	if m != nil {
		return m.PrecisionBits
	}
	return 0
}

// Describes a plan for forming a `Memo`.
type MemoPlan struct {
	// The plaintext.
	Plaintext []byte `protobuf:"bytes,1,opt,name=plaintext,proto3" json:"plaintext,omitempty"`
	// The key to use to encrypt the memo.
	Key []byte `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *MemoPlan) Reset()         { *m = MemoPlan{} }
func (m *MemoPlan) String() string { return proto.CompactTextString(m) }
func (*MemoPlan) ProtoMessage()    {}
func (*MemoPlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{21}
}
func (m *MemoPlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemoPlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemoPlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemoPlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemoPlan.Merge(m, src)
}
func (m *MemoPlan) XXX_Size() int {
	return m.Size()
}
func (m *MemoPlan) XXX_DiscardUnknown() {
	xxx_messageInfo_MemoPlan.DiscardUnknown(m)
}

var xxx_messageInfo_MemoPlan proto.InternalMessageInfo

func (m *MemoPlan) GetPlaintext() []byte {
	if m != nil {
		return m.Plaintext
	}
	return nil
}

func (m *MemoPlan) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type SpendPlan struct {
	// The plaintext note we plan to spend.
	Note *v1alpha1.Note `protobuf:"bytes,1,opt,name=note,proto3" json:"note,omitempty"`
	// The position of the note we plan to spend.
	Position uint64 `protobuf:"varint,2,opt,name=position,proto3" json:"position,omitempty"`
	// The randomizer to use for the spend.
	Randomizer []byte `protobuf:"bytes,3,opt,name=randomizer,proto3" json:"randomizer,omitempty"`
	// The blinding factor to use for the value commitment.
	ValueBlinding []byte `protobuf:"bytes,4,opt,name=value_blinding,json=valueBlinding,proto3" json:"value_blinding,omitempty"`
}

func (m *SpendPlan) Reset()         { *m = SpendPlan{} }
func (m *SpendPlan) String() string { return proto.CompactTextString(m) }
func (*SpendPlan) ProtoMessage()    {}
func (*SpendPlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{22}
}
func (m *SpendPlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpendPlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpendPlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpendPlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpendPlan.Merge(m, src)
}
func (m *SpendPlan) XXX_Size() int {
	return m.Size()
}
func (m *SpendPlan) XXX_DiscardUnknown() {
	xxx_messageInfo_SpendPlan.DiscardUnknown(m)
}

var xxx_messageInfo_SpendPlan proto.InternalMessageInfo

func (m *SpendPlan) GetNote() *v1alpha1.Note {
	if m != nil {
		return m.Note
	}
	return nil
}

func (m *SpendPlan) GetPosition() uint64 {
	if m != nil {
		return m.Position
	}
	return 0
}

func (m *SpendPlan) GetRandomizer() []byte {
	if m != nil {
		return m.Randomizer
	}
	return nil
}

func (m *SpendPlan) GetValueBlinding() []byte {
	if m != nil {
		return m.ValueBlinding
	}
	return nil
}

type OutputPlan struct {
	// The value to send to this output.
	Value *v1alpha1.Value `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	// The destination address to send it to.
	DestAddress *v1alpha1.Address `protobuf:"bytes,2,opt,name=dest_address,json=destAddress,proto3" json:"dest_address,omitempty"`
	// The rseed to use for the new note.
	Rseed []byte `protobuf:"bytes,3,opt,name=rseed,proto3" json:"rseed,omitempty"`
	// The blinding factor to use for the value commitment.
	ValueBlinding []byte `protobuf:"bytes,4,opt,name=value_blinding,json=valueBlinding,proto3" json:"value_blinding,omitempty"`
}

func (m *OutputPlan) Reset()         { *m = OutputPlan{} }
func (m *OutputPlan) String() string { return proto.CompactTextString(m) }
func (*OutputPlan) ProtoMessage()    {}
func (*OutputPlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{23}
}
func (m *OutputPlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OutputPlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OutputPlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OutputPlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutputPlan.Merge(m, src)
}
func (m *OutputPlan) XXX_Size() int {
	return m.Size()
}
func (m *OutputPlan) XXX_DiscardUnknown() {
	xxx_messageInfo_OutputPlan.DiscardUnknown(m)
}

var xxx_messageInfo_OutputPlan proto.InternalMessageInfo

func (m *OutputPlan) GetValue() *v1alpha1.Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *OutputPlan) GetDestAddress() *v1alpha1.Address {
	if m != nil {
		return m.DestAddress
	}
	return nil
}

func (m *OutputPlan) GetRseed() []byte {
	if m != nil {
		return m.Rseed
	}
	return nil
}

func (m *OutputPlan) GetValueBlinding() []byte {
	if m != nil {
		return m.ValueBlinding
	}
	return nil
}

func init() {
	proto.RegisterType((*Transaction)(nil), "penumbra.core.transaction.v1alpha1.Transaction")
	proto.RegisterType((*Id)(nil), "penumbra.core.transaction.v1alpha1.Id")
	proto.RegisterType((*TransactionBody)(nil), "penumbra.core.transaction.v1alpha1.TransactionBody")
	proto.RegisterType((*Action)(nil), "penumbra.core.transaction.v1alpha1.Action")
	proto.RegisterType((*TransactionPerspective)(nil), "penumbra.core.transaction.v1alpha1.TransactionPerspective")
	proto.RegisterType((*PayloadKeyWithCommitment)(nil), "penumbra.core.transaction.v1alpha1.PayloadKeyWithCommitment")
	proto.RegisterType((*NullifierWithNote)(nil), "penumbra.core.transaction.v1alpha1.NullifierWithNote")
	proto.RegisterType((*TransactionView)(nil), "penumbra.core.transaction.v1alpha1.TransactionView")
	proto.RegisterType((*ActionView)(nil), "penumbra.core.transaction.v1alpha1.ActionView")
	proto.RegisterType((*SpendView)(nil), "penumbra.core.transaction.v1alpha1.SpendView")
	proto.RegisterType((*SpendView_Visible)(nil), "penumbra.core.transaction.v1alpha1.SpendView.Visible")
	proto.RegisterType((*SpendView_Opaque)(nil), "penumbra.core.transaction.v1alpha1.SpendView.Opaque")
	proto.RegisterType((*DelegatorVoteView)(nil), "penumbra.core.transaction.v1alpha1.DelegatorVoteView")
	proto.RegisterType((*DelegatorVoteView_Visible)(nil), "penumbra.core.transaction.v1alpha1.DelegatorVoteView.Visible")
	proto.RegisterType((*DelegatorVoteView_Opaque)(nil), "penumbra.core.transaction.v1alpha1.DelegatorVoteView.Opaque")
	proto.RegisterType((*OutputView)(nil), "penumbra.core.transaction.v1alpha1.OutputView")
	proto.RegisterType((*OutputView_Visible)(nil), "penumbra.core.transaction.v1alpha1.OutputView.Visible")
	proto.RegisterType((*OutputView_Opaque)(nil), "penumbra.core.transaction.v1alpha1.OutputView.Opaque")
	proto.RegisterType((*Spend)(nil), "penumbra.core.transaction.v1alpha1.Spend")
	proto.RegisterType((*SpendBody)(nil), "penumbra.core.transaction.v1alpha1.SpendBody")
	proto.RegisterType((*Output)(nil), "penumbra.core.transaction.v1alpha1.Output")
	proto.RegisterType((*OutputBody)(nil), "penumbra.core.transaction.v1alpha1.OutputBody")
	proto.RegisterType((*AuthorizationData)(nil), "penumbra.core.transaction.v1alpha1.AuthorizationData")
	proto.RegisterType((*WitnessData)(nil), "penumbra.core.transaction.v1alpha1.WitnessData")
	proto.RegisterType((*TransactionPlan)(nil), "penumbra.core.transaction.v1alpha1.TransactionPlan")
	proto.RegisterType((*ActionPlan)(nil), "penumbra.core.transaction.v1alpha1.ActionPlan")
	proto.RegisterType((*CluePlan)(nil), "penumbra.core.transaction.v1alpha1.CluePlan")
	proto.RegisterType((*MemoPlan)(nil), "penumbra.core.transaction.v1alpha1.MemoPlan")
	proto.RegisterType((*SpendPlan)(nil), "penumbra.core.transaction.v1alpha1.SpendPlan")
	proto.RegisterType((*OutputPlan)(nil), "penumbra.core.transaction.v1alpha1.OutputPlan")
}

func init() {
	proto.RegisterFile("penumbra/core/transaction/v1alpha1/transaction.proto", fileDescriptor_cd20ea79758052c4)
}

var fileDescriptor_cd20ea79758052c4 = []byte{
	// 2406 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5a, 0xcd, 0x6f, 0x1b, 0xc7,
	0x15, 0xe7, 0x92, 0xfa, 0x7c, 0xa4, 0xbe, 0xc6, 0x1f, 0xd9, 0x0a, 0x85, 0x62, 0x6c, 0x6c, 0x43,
	0xb6, 0x13, 0xca, 0x96, 0xed, 0x04, 0x50, 0x53, 0x34, 0xa2, 0x14, 0x87, 0xb2, 0x23, 0x9b, 0x59,
	0xa7, 0x32, 0xec, 0xba, 0xd9, 0x0e, 0x77, 0x47, 0xe2, 0x42, 0xcb, 0x9d, 0xed, 0xee, 0x92, 0xb2,
	0x72, 0xed, 0x25, 0x45, 0xd1, 0xc2, 0x87, 0x1e, 0x8a, 0xb6, 0xa7, 0x5e, 0x02, 0xf4, 0x2f, 0x28,
	0x0a, 0xf4, 0x1e, 0xf4, 0x50, 0x18, 0xe8, 0xa5, 0x45, 0x2f, 0xad, 0x7d, 0x6a, 0x6f, 0x05, 0xfa,
	0x07, 0x14, 0x33, 0x3b, 0xfb, 0x49, 0xca, 0x5c, 0xd2, 0x0a, 0x82, 0xc4, 0x3e, 0x69, 0xe7, 0xe9,
	0xbd, 0xdf, 0xcc, 0xbc, 0xf7, 0x66, 0xe6, 0x37, 0x6f, 0x08, 0xd7, 0x1c, 0x62, 0x77, 0xda, 0x4d,
	0x17, 0xaf, 0xe8, 0xd4, 0x25, 0x2b, 0xbe, 0x8b, 0x6d, 0x0f, 0xeb, 0xbe, 0x49, 0xed, 0x95, 0xee,
	0x15, 0x6c, 0x39, 0x2d, 0x7c, 0x25, 0x29, 0xac, 0x3a, 0x2e, 0xf5, 0x29, 0x52, 0x42, 0xab, 0x2a,
	0xb3, 0xaa, 0x26, 0x15, 0x42, 0xab, 0xc5, 0x8b, 0x69, 0x64, 0xdd, 0x3d, 0x74, 0x7c, 0x1a, 0x83,
	0x06, 0xed, 0x00, 0x6f, 0x71, 0x39, 0xad, 0xeb, 0xf9, 0x78, 0x9f, 0xc4, 0xaa, 0xbc, 0x29, 0x34,
	0xcf, 0xa6, 0x35, 0xcd, 0xa6, 0x1e, 0xeb, 0x99, 0x4d, 0xbd, 0xbf, 0x96, 0x41, 0x1e, 0xc5, 0x5a,
	0x06, 0x79, 0x24, 0xb4, 0x56, 0xd3, 0x5a, 0x7b, 0xb4, 0x4b, 0x5c, 0x1b, 0xdb, 0x7a, 0xa2, 0xeb,
	0x58, 0x16, 0xd8, 0x28, 0x7f, 0x94, 0xa0, 0xfc, 0x71, 0x3c, 0x5d, 0xf4, 0x01, 0x8c, 0x35, 0xa9,
	0x71, 0x28, 0x4b, 0x67, 0xa4, 0xe5, 0xf2, 0xea, 0xd5, 0xea, 0x60, 0xc7, 0x54, 0x13, 0xe6, 0x35,
	0x6a, 0x1c, 0xaa, 0x1c, 0x00, 0xbd, 0x0e, 0xe5, 0xa6, 0x69, 0x1b, 0xa6, 0xbd, 0xa7, 0x79, 0xe6,
	0x9e, 0x5c, 0x3c, 0x23, 0x2d, 0x57, 0x54, 0x10, 0xa2, 0xbb, 0xe6, 0x1e, 0x5a, 0x87, 0x09, 0x6c,
	0xeb, 0x2d, 0xea, 0xca, 0x25, 0xde, 0xd7, 0x85, 0x4c, 0x5f, 0xc2, 0xa1, 0x51, 0x37, 0xdb, 0xc4,
	0xdd, 0xb7, 0x88, 0x4a, 0xa9, 0xaf, 0x0a, 0x43, 0x45, 0x86, 0xe2, 0x96, 0x81, 0x10, 0x8c, 0xb5,
	0xb0, 0xd7, 0xe2, 0x43, 0xae, 0xa8, 0xfc, 0x5b, 0xf9, 0x4b, 0x11, 0xe6, 0x32, 0xe3, 0x42, 0x9b,
	0x30, 0x19, 0xb4, 0x3c, 0x59, 0x3a, 0x53, 0x5a, 0x2e, 0xaf, 0x5e, 0xcc, 0x33, 0xbb, 0x75, 0xde,
	0x56, 0x43, 0x53, 0xf4, 0x06, 0xcc, 0x90, 0x47, 0x8e, 0xe9, 0x1e, 0x6a, 0x2d, 0x62, 0xee, 0xb5,
	0x7c, 0x3e, 0xb3, 0x31, 0xb5, 0x12, 0x08, 0xeb, 0x5c, 0x86, 0xbe, 0x05, 0x53, 0x7a, 0x0b, 0x9b,
	0xb6, 0x66, 0x1a, 0x7c, 0x76, 0xd3, 0xea, 0x24, 0x6f, 0x6f, 0x19, 0xe8, 0x1a, 0x94, 0x76, 0x09,
	0x91, 0xc7, 0xf8, 0x9c, 0x95, 0x01, 0x73, 0xbe, 0x41, 0x88, 0xca, 0xd4, 0xd1, 0x7b, 0x30, 0xbd,
	0xdb, 0x36, 0x34, 0xdd, 0xea, 0x10, 0x4f, 0x1e, 0xe7, 0xa3, 0x7f, 0x63, 0x80, 0xed, 0x86, 0xd5,
	0x21, 0xea, 0xd4, 0x6e, 0xdb, 0x60, 0x1f, 0x1e, 0xba, 0x08, 0xb3, 0xc4, 0xe6, 0x3a, 0xc4, 0xd0,
	0xda, 0xa4, 0x4d, 0xe5, 0x09, 0xe6, 0xaf, 0x7a, 0x41, 0x9d, 0x89, 0xe4, 0xdb, 0xa4, 0x4d, 0x3f,
	0x93, 0xa4, 0xda, 0x02, 0xcc, 0x69, 0x69, 0x65, 0xe5, 0xaf, 0xb3, 0x30, 0x11, 0xb8, 0x02, 0xad,
	0xc3, 0xb8, 0xe7, 0x10, 0xdb, 0x10, 0x39, 0x72, 0x21, 0x8f, 0x17, 0xef, 0x32, 0x83, 0x7a, 0x41,
	0x0d, 0x2c, 0xd1, 0x26, 0x4c, 0xd0, 0x8e, 0xef, 0x74, 0x02, 0xef, 0xe5, 0x8c, 0xc4, 0x1d, 0x6e,
	0x51, 0x2f, 0xa8, 0xc2, 0x16, 0xbd, 0x0d, 0x63, 0xde, 0x01, 0x76, 0x44, 0xfe, 0x9c, 0xc9, 0x60,
	0xb0, 0x75, 0x11, 0xf7, 0x7f, 0x80, 0x9d, 0x7a, 0x41, 0xe5, 0xfa, 0xe8, 0x06, 0x00, 0xfb, 0xab,
	0xe9, 0x16, 0x36, 0xdb, 0x22, 0x12, 0xe7, 0x06, 0x59, 0x6f, 0x30, 0xe5, 0x7a, 0x41, 0x9d, 0xf6,
	0xc2, 0x06, 0xda, 0x85, 0x93, 0x5d, 0x6c, 0x99, 0x06, 0xf6, 0xa9, 0xab, 0x19, 0x64, 0xd7, 0xb4,
	0x4d, 0x36, 0x62, 0x79, 0x9e, 0x23, 0x5e, 0xc9, 0x20, 0x06, 0xab, 0x3e, 0xc2, 0xdc, 0x09, 0x2d,
	0x37, 0x23, 0xc3, 0x7a, 0x41, 0x3d, 0xd1, 0xed, 0x15, 0xb3, 0xf1, 0x9a, 0x4d, 0x5d, 0x0b, 0xfc,
	0x21, 0x2f, 0xf4, 0x1d, 0x2f, 0xdb, 0x2b, 0x22, 0xec, 0xad, 0xa6, 0x1e, 0xc4, 0x8a, 0x8d, 0xd7,
	0x0c, 0x1b, 0xe8, 0x21, 0xcc, 0x39, 0x2e, 0x75, 0xa8, 0x87, 0x2d, 0xcd, 0xeb, 0x34, 0xdb, 0xa6,
	0x2f, 0xa3, 0xbe, 0x43, 0x4d, 0xec, 0x12, 0x11, 0x66, 0x43, 0x58, 0xde, 0xe5, 0x86, 0xf5, 0x82,
	0x3a, 0xeb, 0xa4, 0x24, 0xa8, 0x09, 0x0b, 0x11, 0xfa, 0x81, 0xe9, 0xb7, 0x0c, 0x17, 0x1f, 0xc8,
	0x27, 0xfa, 0x6e, 0x23, 0xcf, 0xc3, 0xbf, 0x27, 0x4c, 0xeb, 0x05, 0x75, 0xde, 0xc9, 0xc8, 0xd0,
	0x7d, 0x98, 0x8d, 0x3d, 0xde, 0xa5, 0x3e, 0x91, 0x4f, 0xf2, 0x0e, 0x2e, 0xe7, 0xe8, 0x20, 0x72,
	0xf8, 0x0e, 0xf5, 0x09, 0x4b, 0xfb, 0x6e, 0x52, 0xc0, 0xa0, 0x0d, 0x62, 0x91, 0xbd, 0x18, 0xfa,
	0x54, 0x6e, 0xe8, 0xcd, 0xd0, 0x30, 0x84, 0x36, 0x92, 0x02, 0x44, 0xe1, 0x74, 0xe4, 0x19, 0x83,
	0x38, 0xd4, 0x33, 0x7d, 0x91, 0x7b, 0xa7, 0x79, 0x17, 0xef, 0x0c, 0xe1, 0x9e, 0xcd, 0xc0, 0x3e,
	0xcc, 0xc6, 0x93, 0x4e, 0x1f, 0x39, 0xba, 0x03, 0x33, 0xbc, 0x65, 0x52, 0x5b, 0xa3, 0x0e, 0xb1,
	0xe5, 0x25, 0xde, 0xcf, 0xf2, 0xf3, 0x72, 0xbc, 0x21, 0x0c, 0xee, 0x38, 0x84, 0xa5, 0x4d, 0xc5,
	0x49, 0xb4, 0x91, 0x0a, 0xb3, 0x11, 0xa0, 0x6e, 0x51, 0x8f, 0xc8, 0xaf, 0xf7, 0x5d, 0xfb, 0x7d,
	0x11, 0x37, 0x98, 0x01, 0xf3, 0x8a, 0x93, 0x14, 0xa0, 0x1f, 0xc0, 0x42, 0x84, 0x19, 0xe5, 0xcb,
	0x19, 0x0e, 0xfb, 0x66, 0x1e, 0xd8, 0x54, 0xa2, 0x64, 0x64, 0x88, 0xc0, 0xa9, 0x08, 0xdc, 0x25,
	0x07, 0xd8, 0x35, 0x84, 0xc7, 0x15, 0xde, 0xc1, 0x4a, 0x9e, 0x0e, 0x54, 0x6e, 0x17, 0x7a, 0xfa,
	0x84, 0xd3, 0x2b, 0x46, 0x9b, 0x30, 0x25, 0x42, 0x4d, 0xe4, 0x65, 0x8e, 0x7c, 0xfe, 0xf9, 0xab,
	0x5e, 0x64, 0x0a, 0x73, 0x47, 0x64, 0x89, 0x6e, 0x02, 0x74, 0xec, 0x08, 0xe7, 0x42, 0xdf, 0x58,
	0x65, 0x70, 0xbe, 0x1f, 0xe9, 0xd7, 0x0b, 0x6a, 0xc2, 0x1a, 0x3d, 0x80, 0xf9, 0xb8, 0x25, 0xe6,
	0x7c, 0x91, 0x23, 0xbe, 0x95, 0x17, 0x31, 0x9c, 0xf1, 0x5c, 0x27, 0x2d, 0x42, 0x37, 0x61, 0xda,
	0xc0, 0x54, 0x0b, 0x36, 0xff, 0x55, 0x0e, 0x7a, 0x29, 0xcf, 0xea, 0xc0, 0x34, 0xdc, 0xfe, 0xa7,
	0x0c, 0xf1, 0x8d, 0xb6, 0x01, 0x18, 0x96, 0x38, 0x05, 0xae, 0xf6, 0x0d, 0xfb, 0x11, 0x60, 0xd1,
	0x39, 0xc0, 0x46, 0x13, 0x34, 0x50, 0x03, 0xca, 0x0c, 0x4e, 0xac, 0x2e, 0xf9, 0x5a, 0xdf, 0x19,
	0x1f, 0x81, 0x27, 0x96, 0x0e, 0x73, 0xa4, 0x11, 0xb5, 0xd0, 0x7d, 0x98, 0x37, 0x75, 0x6f, 0xf5,
	0x72, 0x94, 0x9b, 0xd8, 0x92, 0xbf, 0x90, 0xfa, 0x4e, 0x3a, 0xbd, 0xf7, 0x32, 0xa3, 0x7b, 0x91,
	0x0d, 0xf3, 0xa3, 0x99, 0x16, 0xd5, 0xa6, 0x60, 0x22, 0xd8, 0xcb, 0x95, 0xff, 0x15, 0xe1, 0x74,
	0x82, 0xa6, 0x34, 0x88, 0xeb, 0x39, 0x44, 0xf7, 0xcd, 0x2e, 0x41, 0x1a, 0x54, 0x1c, 0x7c, 0x68,
	0x51, 0x6c, 0x68, 0xfb, 0xe4, 0x30, 0xa4, 0x2c, 0xef, 0xe6, 0x39, 0x28, 0x1b, 0x81, 0xdd, 0x2d,
	0x72, 0xc8, 0x3a, 0xdd, 0xa0, 0xed, 0xb6, 0xe9, 0xb7, 0x89, 0xed, 0xab, 0x65, 0x27, 0xfa, 0x8f,
	0x87, 0x7e, 0x04, 0xf3, 0x3c, 0x92, 0x9a, 0xdd, 0xb1, 0x2c, 0x73, 0xd7, 0x24, 0xae, 0x27, 0x17,
	0x79, 0x27, 0xd7, 0xf3, 0x74, 0x72, 0x3b, 0xb4, 0x62, 0x7d, 0xdc, 0xa6, 0x3e, 0x51, 0xe7, 0x38,
	0x5c, 0x24, 0xf7, 0xd0, 0x0d, 0xa8, 0x60, 0xa3, 0x6b, 0xea, 0x44, 0xb3, 0xa9, 0x4f, 0x3c, 0xb9,
	0x94, 0x8b, 0xb7, 0x70, 0xac, 0x72, 0x60, 0xc8, 0xbe, 0x3d, 0xb6, 0x9d, 0x61, 0xc3, 0x70, 0x89,
	0xe7, 0x69, 0x5d, 0x93, 0x1c, 0x78, 0xf2, 0x58, 0x5f, 0xfa, 0x96, 0x05, 0x5a, 0x0f, 0x6c, 0x76,
	0x4c, 0x72, 0xa0, 0x56, 0x70, 0xdc, 0xf0, 0x94, 0x9f, 0x49, 0x20, 0x1f, 0xe5, 0x24, 0x46, 0x5c,
	0x13, 0x8e, 0x17, 0xac, 0x12, 0x62, 0xcf, 0xa1, 0xdb, 0x00, 0x7a, 0xa4, 0x2e, 0x08, 0x4c, 0x75,
	0xc0, 0x58, 0xee, 0xfa, 0x6c, 0x15, 0xc5, 0x91, 0x48, 0x20, 0x28, 0xbf, 0x94, 0x60, 0xa1, 0xc7,
	0x9b, 0xe8, 0x06, 0x4c, 0x47, 0x81, 0x11, 0x4c, 0x6b, 0x79, 0x90, 0xe7, 0x42, 0x7d, 0x35, 0x36,
	0x45, 0xef, 0xc0, 0x18, 0xf3, 0xbe, 0x18, 0x67, 0x2e, 0xe7, 0x73, 0x03, 0xe5, 0x71, 0x29, 0x45,
	0xa1, 0x99, 0xe7, 0xd0, 0x47, 0x50, 0x09, 0x5a, 0x22, 0x10, 0x41, 0x52, 0x56, 0xf3, 0xf3, 0x68,
	0x1e, 0x8c, 0x72, 0x8c, 0xf8, 0xf5, 0xe5, 0xd3, 0xaf, 0xc1, 0x58, 0x8a, 0x45, 0xf3, 0xd6, 0x67,
	0x92, 0x84, 0x1a, 0xd9, 0x6c, 0x7d, 0x5c, 0x7a, 0xb1, 0x74, 0xad, 0x4d, 0xc2, 0x78, 0x40, 0xc2,
	0xff, 0x3b, 0x0b, 0x10, 0xfb, 0x11, 0xbd, 0x9f, 0x26, 0xe2, 0x6f, 0xe5, 0x26, 0xe2, 0xcc, 0x3a,
	0x26, 0xe3, 0xf5, 0x0c, 0x19, 0xaf, 0xe6, 0x27, 0xe3, 0x02, 0x28, 0x24, 0xe4, 0x6b, 0x29, 0x42,
	0x7e, 0x76, 0x10, 0xa5, 0x16, 0xd6, 0x01, 0x29, 0xbf, 0xd9, 0x87, 0x94, 0x5f, 0xc8, 0x45, 0xca,
	0x05, 0xcc, 0x2b, 0x62, 0xfe, 0xcd, 0x24, 0xe6, 0x9f, 0x1c, 0x41, 0xcc, 0x73, 0x9d, 0x52, 0x29,
	0x66, 0x2e, 0x12, 0xe5, 0x15, 0x3b, 0x7f, 0x09, 0xd9, 0xf9, 0x85, 0x63, 0x62, 0xe7, 0x17, 0x5f,
	0x88, 0x9d, 0xbf, 0x54, 0x0c, 0xba, 0xdf, 0x55, 0xe4, 0xd2, 0x31, 0x5d, 0x45, 0xbe, 0x44, 0x76,
	0x3e, 0x03, 0xe5, 0x04, 0xc7, 0x51, 0x7e, 0x5e, 0x82, 0xe9, 0xe8, 0xd0, 0x44, 0x1f, 0xc1, 0x64,
	0xd7, 0xf4, 0xcc, 0xa6, 0x45, 0xc4, 0xa1, 0x7b, 0x7d, 0xa8, 0x43, 0xb7, 0xba, 0x13, 0x18, 0xd7,
	0x0b, 0x6a, 0x88, 0x83, 0x6e, 0xc3, 0x04, 0x75, 0xf0, 0x8f, 0x3b, 0x21, 0x45, 0xbb, 0x36, 0x1c,
	0xe2, 0x1d, 0x6e, 0xcb, 0x0f, 0x61, 0xfe, 0xb5, 0xf8, 0x13, 0x09, 0x26, 0x45, 0x37, 0xe8, 0x7b,
	0xa3, 0x96, 0xea, 0x42, 0x6e, 0x30, 0x2a, 0x7b, 0x5c, 0xdc, 0x82, 0x89, 0x60, 0x64, 0x2f, 0x3c,
	0x86, 0x5a, 0x05, 0x20, 0xb8, 0xa8, 0xf0, 0x78, 0xfc, 0xbd, 0x04, 0x0b, 0x3d, 0xbb, 0x3a, 0xba,
	0x9f, 0x8d, 0xcb, 0x77, 0x47, 0x3a, 0x1d, 0xfa, 0xc5, 0x67, 0x27, 0x13, 0x9f, 0x77, 0x47, 0x43,
	0xee, 0x89, 0xd3, 0x6f, 0x12, 0x71, 0xba, 0xd7, 0x73, 0xc6, 0x49, 0xa3, 0x15, 0x9f, 0xb2, 0x87,
	0xdb, 0xc8, 0xf1, 0xc3, 0x51, 0xfc, 0xbe, 0xac, 0xb1, 0xd5, 0xe6, 0xb3, 0xc0, 0xca, 0x1f, 0x4a,
	0x00, 0x31, 0xb1, 0x44, 0x6a, 0x36, 0xa8, 0x6f, 0x0f, 0xc7, 0x4c, 0xfb, 0x45, 0xf3, 0x4e, 0x26,
	0x9a, 0xd7, 0x87, 0x84, 0xec, 0x09, 0xe3, 0xe7, 0x89, 0x30, 0xd6, 0x22, 0x26, 0x2d, 0x0d, 0x5b,
	0xd6, 0x8e, 0x38, 0xf4, 0xa8, 0x11, 0xcb, 0xde, 0x5b, 0x4b, 0xd9, 0x7b, 0xeb, 0xe2, 0x87, 0x51,
	0x48, 0x8f, 0x61, 0x9c, 0x6c, 0x9b, 0x0c, 0xbe, 0x82, 0x65, 0xf9, 0x0f, 0x09, 0xc6, 0x83, 0x73,
	0x69, 0x3d, 0xf5, 0x82, 0x94, 0xff, 0x52, 0x92, 0x78, 0x3b, 0xfa, 0x10, 0xa6, 0x70, 0xc7, 0x6f,
	0x45, 0x0f, 0x47, 0xbd, 0x44, 0xb8, 0xe7, 0x7e, 0xcd, 0x10, 0xd6, 0x3b, 0x7e, 0xeb, 0xae, 0xb9,
	0x67, 0x63, 0xbf, 0xe3, 0x12, 0x75, 0x12, 0x07, 0x4d, 0xb4, 0x0e, 0xe3, 0x8e, 0x4b, 0xe9, 0xae,
	0xb8, 0x96, 0x5c, 0x1a, 0x00, 0xf5, 0xe0, 0x16, 0x07, 0x6b, 0x30, 0x13, 0x35, 0xb0, 0x54, 0x7e,
	0x2d, 0x89, 0x43, 0x80, 0x3f, 0x24, 0x69, 0x80, 0x9a, 0xd8, 0x62, 0x99, 0xae, 0x25, 0x0a, 0x01,
	0xfd, 0x57, 0x45, 0x16, 0xbd, 0x16, 0x18, 0x26, 0x4a, 0x01, 0x0b, 0xcd, 0xac, 0x08, 0x7d, 0x3b,
	0x79, 0xf7, 0x0f, 0x02, 0x99, 0xb8, 0xd1, 0xcf, 0x42, 0xd1, 0xdd, 0xe7, 0x37, 0xa4, 0x8a, 0x5a,
	0x74, 0xf7, 0x95, 0xc7, 0x12, 0x4c, 0x88, 0x43, 0xbc, 0x96, 0xf2, 0xfd, 0x10, 0x17, 0xb9, 0x84,
	0xf3, 0x6b, 0xa1, 0xbb, 0x8a, 0x7d, 0x29, 0x45, 0xaf, 0xbb, 0x02, 0x84, 0x94, 0xbf, 0x7e, 0x51,
	0x0c, 0x17, 0x32, 0x77, 0xd8, 0x36, 0x54, 0x58, 0x8a, 0x6a, 0x22, 0x19, 0x8f, 0xc8, 0xba, 0x7e,
	0xb9, 0x2d, 0xaa, 0x34, 0x6a, 0xd9, 0x8e, 0x1b, 0x47, 0xf8, 0xbf, 0x78, 0x7c, 0xfe, 0x5f, 0x86,
	0xf9, 0x03, 0x17, 0x3b, 0x8e, 0x78, 0xfc, 0x4a, 0xac, 0xa7, 0x59, 0x21, 0xdf, 0x26, 0x6d, 0x7a,
	0x8b, 0x1c, 0xa2, 0xf3, 0x30, 0x47, 0xbb, 0xfb, 0x5a, 0xa8, 0xcd, 0x14, 0x83, 0xc0, 0xcc, 0xd0,
	0xee, 0xfe, 0xbd, 0x40, 0x7a, 0x8b, 0x1c, 0x2a, 0xbf, 0x2a, 0xc2, 0x02, 0x4b, 0x4f, 0xea, 0x9a,
	0x9f, 0x62, 0x16, 0x80, 0x4d, 0xec, 0x63, 0x74, 0x13, 0xca, 0x64, 0x77, 0x97, 0xe8, 0xbe, 0x16,
	0x3d, 0x60, 0x0e, 0x7e, 0x07, 0x7d, 0x9f, 0x5b, 0xd4, 0xb1, 0xd7, 0x52, 0x81, 0x44, 0xdf, 0x48,
	0x85, 0x72, 0x70, 0x4a, 0xb2, 0xb4, 0x0f, 0x2b, 0x79, 0x23, 0x2c, 0x9b, 0xe0, 0xac, 0x65, 0x32,
	0x0f, 0xe9, 0x70, 0x32, 0xbd, 0x43, 0x0b, 0xf0, 0xd2, 0xa8, 0xe0, 0x28, 0x75, 0x02, 0xf0, 0x4e,
	0x94, 0x3f, 0x49, 0x50, 0xbe, 0x67, 0xfa, 0x36, 0xf1, 0x3c, 0xee, 0x94, 0xf8, 0x5d, 0x58, 0x1a,
	0xf1, 0x5d, 0x18, 0xed, 0xc3, 0x6b, 0x9e, 0xcf, 0x49, 0x67, 0x14, 0x53, 0x8d, 0x27, 0x66, 0xe8,
	0x97, 0xab, 0xc3, 0x95, 0xeb, 0x82, 0xdc, 0x3e, 0xe5, 0xf5, 0x91, 0x7a, 0xca, 0xbf, 0xd3, 0x4f,
	0xcd, 0x0d, 0x0b, 0xdb, 0xa8, 0x9e, 0x7d, 0x6a, 0x1e, 0xa2, 0x44, 0xc6, 0x00, 0xbe, 0xea, 0xe7,
	0xe6, 0x5b, 0x00, 0xba, 0xd5, 0x21, 0x9a, 0x63, 0x61, 0x3b, 0xac, 0x8f, 0xbd, 0x99, 0x67, 0x0a,
	0x1b, 0x56, 0x87, 0xf0, 0x09, 0x4c, 0xeb, 0xe2, 0xcb, 0x43, 0x5b, 0x30, 0xcd, 0x57, 0x11, 0x03,
	0xe3, 0xe5, 0xb2, 0x9c, 0x58, 0x6c, 0x8d, 0x71, 0xac, 0xa9, 0xb6, 0xf8, 0x52, 0x7e, 0x1b, 0x15,
	0xc0, 0xb8, 0x9b, 0x47, 0x2e, 0x80, 0x31, 0xeb, 0x63, 0x29, 0x80, 0x09, 0xa0, 0x11, 0x0b, 0x60,
	0xc2, 0xfa, 0x45, 0x0b, 0x60, 0x02, 0xe6, 0x55, 0x01, 0xec, 0x9b, 0x59, 0x00, 0xfb, 0xe1, 0x11,
	0x05, 0xb0, 0x6b, 0xc3, 0x12, 0x70, 0x91, 0x27, 0xaf, 0xea, 0x5f, 0x39, 0xea, 0x5f, 0xda, 0xd1,
	0xf5, 0xaf, 0xcb, 0xc3, 0xd4, 0xbf, 0x84, 0xcf, 0x7b, 0x6b, 0x60, 0xe6, 0xf3, 0x6b, 0x60, 0x57,
	0x87, 0xac, 0x81, 0x89, 0x7e, 0xbe, 0x26, 0xaf, 0xd4, 0x9f, 0x1c, 0xf9, 0x4a, 0x7d, 0x65, 0xa8,
	0xd2, 0x90, 0x98, 0xf5, 0x4b, 0xfd, 0x52, 0x9d, 0x78, 0x4e, 0xfe, 0xa9, 0x04, 0x53, 0xe1, 0x09,
	0x8c, 0xde, 0x83, 0x49, 0xf1, 0x8a, 0x24, 0x8e, 0xc7, 0xf3, 0xf9, 0x1e, 0xa0, 0xd4, 0xd0, 0x0c,
	0x9d, 0x84, 0x71, 0xd7, 0x23, 0xc4, 0x10, 0x3f, 0xde, 0x0b, 0x1a, 0xe8, 0x1c, 0xcc, 0x3a, 0x2e,
	0xd1, 0x4d, 0x8f, 0x65, 0x6e, 0xd3, 0xf4, 0x3d, 0x7e, 0xda, 0x8d, 0xa9, 0x33, 0x91, 0xb4, 0x66,
	0xfa, 0x9e, 0xb2, 0x06, 0x53, 0xe1, 0x01, 0xce, 0xee, 0x33, 0x8e, 0x85, 0x4d, 0xdb, 0x27, 0x8f,
	0x7c, 0xf1, 0xa0, 0x1a, 0x0b, 0xd0, 0x3c, 0x94, 0x18, 0x6f, 0x0e, 0x3a, 0x61, 0x9f, 0xca, 0xe7,
	0xe1, 0x75, 0x8b, 0x5b, 0x87, 0x37, 0x62, 0x69, 0xd8, 0x1b, 0xf1, 0x22, 0x4c, 0x85, 0xcb, 0x41,
	0xd0, 0xa6, 0xa8, 0x8d, 0x96, 0x00, 0x5c, 0x6c, 0x1b, 0xb4, 0x6d, 0x7e, 0x1a, 0xdd, 0xb1, 0x12,
	0x12, 0x36, 0xcb, 0x2e, 0x66, 0x14, 0xa8, 0x69, 0x05, 0x3f, 0x59, 0x0c, 0x79, 0x3d, 0x97, 0xd6,
	0x84, 0x50, 0x79, 0x22, 0x85, 0x17, 0x1d, 0x3e, 0xd4, 0x35, 0x18, 0xe7, 0xff, 0x17, 0x63, 0x3d,
	0x3b, 0x60, 0xac, 0x3b, 0x4c, 0x57, 0x0d, 0x4c, 0xd0, 0x16, 0x54, 0x0c, 0xe2, 0xf9, 0x5a, 0x18,
	0xb4, 0xe2, 0x50, 0x41, 0x2b, 0x33, 0xdb, 0xf5, 0x6c, 0xe0, 0x4a, 0x99, 0xc0, 0xe5, 0x98, 0x52,
	0xed, 0x5f, 0xc5, 0x2f, 0x9e, 0x2e, 0x49, 0x4f, 0x9e, 0x2e, 0x49, 0xff, 0x7c, 0xba, 0x24, 0x3d,
	0x7e, 0xb6, 0x54, 0x78, 0xf2, 0x6c, 0xa9, 0xf0, 0xb7, 0x67, 0x4b, 0x05, 0x38, 0xaf, 0xd3, 0x76,
	0x0e, 0x6e, 0x54, 0x9b, 0x4f, 0xf2, 0x61, 0x97, 0xfa, 0xb4, 0x21, 0x3d, 0x68, 0xee, 0x99, 0x7e,
	0xab, 0xd3, 0xac, 0xea, 0xb4, 0xbd, 0xa2, 0x53, 0xaf, 0x4d, 0xbd, 0x15, 0x97, 0x58, 0xf8, 0x90,
	0xb8, 0x2b, 0xdd, 0xd5, 0xe8, 0x93, 0xd3, 0x56, 0x6f, 0x65, 0xf0, 0x8f, 0x78, 0xbf, 0x93, 0x10,
	0x86, 0xb2, 0xdf, 0x15, 0x4b, 0x8d, 0x8d, 0x8f, 0x7f, 0x5f, 0x54, 0x1a, 0xe1, 0x10, 0x37, 0xd8,
	0x10, 0x13, 0x83, 0xa9, 0xee, 0x08, 0xd5, 0x3f, 0xc7, 0x4a, 0x0f, 0x99, 0xd2, 0xc3, 0x84, 0xd2,
	0xc3, 0x50, 0xe9, 0x69, 0xb1, 0x3a, 0x58, 0xe9, 0xe1, 0x07, 0x8d, 0xda, 0x36, 0xf1, 0xb1, 0x81,
	0x7d, 0xfc, 0x9f, 0xe2, 0xb9, 0xd0, 0x60, 0x6d, 0x8d, 0x59, 0xac, 0xad, 0x25, 0x4c, 0xd6, 0xd6,
	0x42, 0x9b, 0xe6, 0x04, 0xff, 0xf1, 0xed, 0xd5, 0xff, 0x07, 0x00, 0x00, 0xff, 0xff, 0x6d, 0x15,
	0x12, 0x01, 0xae, 0x2c, 0x00, 0x00,
}

func (m *Transaction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Transaction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Transaction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Anchor != nil {
		{
			size, err := m.Anchor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BindingSig) > 0 {
		i -= len(m.BindingSig)
		copy(dAtA[i:], m.BindingSig)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.BindingSig)))
		i--
		dAtA[i] = 0x12
	}
	if m.Body != nil {
		{
			size, err := m.Body.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Id) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Id) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Id) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TransactionBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransactionBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XEncryptedMemo != nil {
		{
			size := m.XEncryptedMemo.Size()
			i -= size
			if _, err := m.XEncryptedMemo.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.FmdClues) > 0 {
		for iNdEx := len(m.FmdClues) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FmdClues[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransaction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Fee != nil {
		{
			size, err := m.Fee.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ExpiryHeight != 0 {
		i = encodeVarintTransaction(dAtA, i, uint64(m.ExpiryHeight))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Actions) > 0 {
		for iNdEx := len(m.Actions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Actions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransaction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TransactionBody_EncryptedMemo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransactionBody_EncryptedMemo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EncryptedMemo != nil {
		i -= len(m.EncryptedMemo)
		copy(dAtA[i:], m.EncryptedMemo)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.EncryptedMemo)))
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *Action) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Action) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Action != nil {
		{
			size := m.Action.Size()
			i -= size
			if _, err := m.Action.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Action_Spend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_Spend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Spend != nil {
		{
			size, err := m.Spend.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Action_Output) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_Output) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Output != nil {
		{
			size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Action_Swap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_Swap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Swap != nil {
		{
			size, err := m.Swap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Action_SwapClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_SwapClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SwapClaim != nil {
		{
			size, err := m.SwapClaim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Action_ValidatorDefinition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_ValidatorDefinition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ValidatorDefinition != nil {
		{
			size, err := m.ValidatorDefinition.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *Action_IbcAction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_IbcAction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IbcAction != nil {
		{
			size, err := m.IbcAction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *Action_ProposalSubmit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_ProposalSubmit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ProposalSubmit != nil {
		{
			size, err := m.ProposalSubmit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *Action_ProposalWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_ProposalWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ProposalWithdraw != nil {
		{
			size, err := m.ProposalWithdraw.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *Action_ValidatorVote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_ValidatorVote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ValidatorVote != nil {
		{
			size, err := m.ValidatorVote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *Action_DelegatorVote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_DelegatorVote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DelegatorVote != nil {
		{
			size, err := m.DelegatorVote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *Action_ProposalDepositClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_ProposalDepositClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ProposalDepositClaim != nil {
		{
			size, err := m.ProposalDepositClaim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *Action_PositionOpen) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_PositionOpen) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PositionOpen != nil {
		{
			size, err := m.PositionOpen.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	return len(dAtA) - i, nil
}
func (m *Action_PositionClose) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_PositionClose) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PositionClose != nil {
		{
			size, err := m.PositionClose.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	return len(dAtA) - i, nil
}
func (m *Action_PositionWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_PositionWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PositionWithdraw != nil {
		{
			size, err := m.PositionWithdraw.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *Action_PositionRewardClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_PositionRewardClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PositionRewardClaim != nil {
		{
			size, err := m.PositionRewardClaim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *Action_Delegate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_Delegate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Delegate != nil {
		{
			size, err := m.Delegate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *Action_Undelegate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_Undelegate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Undelegate != nil {
		{
			size, err := m.Undelegate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *Action_UndelegateClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_UndelegateClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UndelegateClaim != nil {
		{
			size, err := m.UndelegateClaim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *Action_DaoSpend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_DaoSpend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DaoSpend != nil {
		{
			size, err := m.DaoSpend.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *Action_DaoOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_DaoOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DaoOutput != nil {
		{
			size, err := m.DaoOutput.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *Action_DaoDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_DaoDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DaoDeposit != nil {
		{
			size, err := m.DaoDeposit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *Action_Ics20Withdrawal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_Ics20Withdrawal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ics20Withdrawal != nil {
		{
			size, err := m.Ics20Withdrawal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *TransactionPerspective) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionPerspective) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransactionPerspective) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AddressViews) > 0 {
		for iNdEx := len(m.AddressViews) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AddressViews[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransaction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.AdviceNotes) > 0 {
		for iNdEx := len(m.AdviceNotes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AdviceNotes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransaction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.SpendNullifiers) > 0 {
		for iNdEx := len(m.SpendNullifiers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SpendNullifiers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransaction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.PayloadKeys) > 0 {
		for iNdEx := len(m.PayloadKeys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PayloadKeys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransaction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PayloadKeyWithCommitment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PayloadKeyWithCommitment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PayloadKeyWithCommitment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Commitment != nil {
		{
			size, err := m.Commitment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.PayloadKey) > 0 {
		i -= len(m.PayloadKey)
		copy(dAtA[i:], m.PayloadKey)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.PayloadKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NullifierWithNote) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NullifierWithNote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NullifierWithNote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Note != nil {
		{
			size, err := m.Note.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Nullifier != nil {
		{
			size, err := m.Nullifier.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TransactionView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionView) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransactionView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AddressViews) > 0 {
		for iNdEx := len(m.AddressViews) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AddressViews[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransaction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x19
			i--
			dAtA[i] = 0x82
		}
	}
	if m.XMemo != nil {
		{
			size := m.XMemo.Size()
			i -= size
			if _, err := m.XMemo.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.FmdClues) > 0 {
		for iNdEx := len(m.FmdClues) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FmdClues[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransaction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Fee != nil {
		{
			size, err := m.Fee.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ExpiryHeight != 0 {
		i = encodeVarintTransaction(dAtA, i, uint64(m.ExpiryHeight))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ActionViews) > 0 {
		for iNdEx := len(m.ActionViews) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ActionViews[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransaction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TransactionView_Memo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransactionView_Memo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Memo != nil {
		i -= len(m.Memo)
		copy(dAtA[i:], m.Memo)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Memo)))
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *ActionView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionView) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ActionView != nil {
		{
			size := m.ActionView.Size()
			i -= size
			if _, err := m.ActionView.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ActionView_Spend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_Spend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Spend != nil {
		{
			size, err := m.Spend.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_Output) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_Output) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Output != nil {
		{
			size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_Swap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_Swap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Swap != nil {
		{
			size, err := m.Swap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_SwapClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_SwapClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SwapClaim != nil {
		{
			size, err := m.SwapClaim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_ValidatorDefinition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_ValidatorDefinition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ValidatorDefinition != nil {
		{
			size, err := m.ValidatorDefinition.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_IbcAction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_IbcAction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IbcAction != nil {
		{
			size, err := m.IbcAction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_ProposalSubmit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_ProposalSubmit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ProposalSubmit != nil {
		{
			size, err := m.ProposalSubmit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_ProposalWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_ProposalWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ProposalWithdraw != nil {
		{
			size, err := m.ProposalWithdraw.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_ValidatorVote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_ValidatorVote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ValidatorVote != nil {
		{
			size, err := m.ValidatorVote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_DelegatorVote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_DelegatorVote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DelegatorVote != nil {
		{
			size, err := m.DelegatorVote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_ProposalDepositClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_ProposalDepositClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ProposalDepositClaim != nil {
		{
			size, err := m.ProposalDepositClaim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_PositionOpen) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_PositionOpen) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PositionOpen != nil {
		{
			size, err := m.PositionOpen.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_PositionClose) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_PositionClose) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PositionClose != nil {
		{
			size, err := m.PositionClose.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_PositionWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_PositionWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PositionWithdraw != nil {
		{
			size, err := m.PositionWithdraw.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_PositionRewardClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_PositionRewardClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PositionRewardClaim != nil {
		{
			size, err := m.PositionRewardClaim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_Delegate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_Delegate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Delegate != nil {
		{
			size, err := m.Delegate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_Undelegate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_Undelegate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Undelegate != nil {
		{
			size, err := m.Undelegate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_UndelegateClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_UndelegateClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UndelegateClaim != nil {
		{
			size, err := m.UndelegateClaim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_DaoSpend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_DaoSpend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DaoSpend != nil {
		{
			size, err := m.DaoSpend.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_DaoOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_DaoOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DaoOutput != nil {
		{
			size, err := m.DaoOutput.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_DaoDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_DaoDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DaoDeposit != nil {
		{
			size, err := m.DaoDeposit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_Ics20Withdrawal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_Ics20Withdrawal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ics20Withdrawal != nil {
		{
			size, err := m.Ics20Withdrawal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *SpendView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpendView) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpendView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SpendView != nil {
		{
			size := m.SpendView.Size()
			i -= size
			if _, err := m.SpendView.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *SpendView_Visible_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpendView_Visible_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Visible != nil {
		{
			size, err := m.Visible.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *SpendView_Opaque_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpendView_Opaque_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Opaque != nil {
		{
			size, err := m.Opaque.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *SpendView_Visible) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpendView_Visible) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpendView_Visible) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Note != nil {
		{
			size, err := m.Note.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Spend != nil {
		{
			size, err := m.Spend.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpendView_Opaque) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpendView_Opaque) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpendView_Opaque) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Spend != nil {
		{
			size, err := m.Spend.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DelegatorVoteView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelegatorVoteView) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelegatorVoteView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DelegatorVote != nil {
		{
			size := m.DelegatorVote.Size()
			i -= size
			if _, err := m.DelegatorVote.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *DelegatorVoteView_Visible_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelegatorVoteView_Visible_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Visible != nil {
		{
			size, err := m.Visible.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *DelegatorVoteView_Opaque_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelegatorVoteView_Opaque_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Opaque != nil {
		{
			size, err := m.Opaque.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *DelegatorVoteView_Visible) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelegatorVoteView_Visible) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelegatorVoteView_Visible) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Note != nil {
		{
			size, err := m.Note.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.DelegatorVote != nil {
		{
			size, err := m.DelegatorVote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DelegatorVoteView_Opaque) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelegatorVoteView_Opaque) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelegatorVoteView_Opaque) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DelegatorVote != nil {
		{
			size, err := m.DelegatorVote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OutputView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OutputView) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutputView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OutputView != nil {
		{
			size := m.OutputView.Size()
			i -= size
			if _, err := m.OutputView.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *OutputView_Visible_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutputView_Visible_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Visible != nil {
		{
			size, err := m.Visible.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *OutputView_Opaque_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutputView_Opaque_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Opaque != nil {
		{
			size, err := m.Opaque.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *OutputView_Visible) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OutputView_Visible) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutputView_Visible) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PayloadKey) > 0 {
		i -= len(m.PayloadKey)
		copy(dAtA[i:], m.PayloadKey)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.PayloadKey)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Note != nil {
		{
			size, err := m.Note.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Output != nil {
		{
			size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OutputView_Opaque) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OutputView_Opaque) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutputView_Opaque) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Output != nil {
		{
			size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Spend) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Spend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Spend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Proof != nil {
		{
			size, err := m.Proof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.AuthSig != nil {
		{
			size, err := m.AuthSig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Body != nil {
		{
			size, err := m.Body.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpendBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpendBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpendBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Rk) > 0 {
		i -= len(m.Rk)
		copy(dAtA[i:], m.Rk)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Rk)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Nullifier) > 0 {
		i -= len(m.Nullifier)
		copy(dAtA[i:], m.Nullifier)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Nullifier)))
		i--
		dAtA[i] = 0x1a
	}
	if m.BalanceCommitment != nil {
		{
			size, err := m.BalanceCommitment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Output) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Output) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Output) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Proof != nil {
		{
			size, err := m.Proof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Body != nil {
		{
			size, err := m.Body.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OutputBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OutputBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutputBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OvkWrappedKey) > 0 {
		i -= len(m.OvkWrappedKey)
		copy(dAtA[i:], m.OvkWrappedKey)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.OvkWrappedKey)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.WrappedMemoKey) > 0 {
		i -= len(m.WrappedMemoKey)
		copy(dAtA[i:], m.WrappedMemoKey)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.WrappedMemoKey)))
		i--
		dAtA[i] = 0x1a
	}
	if m.BalanceCommitment != nil {
		{
			size, err := m.BalanceCommitment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.NotePayload != nil {
		{
			size, err := m.NotePayload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuthorizationData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthorizationData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthorizationData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DelegatorVoteAuths) > 0 {
		for iNdEx := len(m.DelegatorVoteAuths) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DelegatorVoteAuths[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransaction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.SpendAuths) > 0 {
		for iNdEx := len(m.SpendAuths) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SpendAuths[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransaction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.EffectHash != nil {
		{
			size, err := m.EffectHash.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WitnessData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WitnessData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WitnessData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StateCommitmentProofs) > 0 {
		for iNdEx := len(m.StateCommitmentProofs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StateCommitmentProofs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransaction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Anchor != nil {
		{
			size, err := m.Anchor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TransactionPlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionPlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransactionPlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MemoPlan != nil {
		{
			size, err := m.MemoPlan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.CluePlans) > 0 {
		for iNdEx := len(m.CluePlans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CluePlans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransaction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Fee != nil {
		{
			size, err := m.Fee.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ExpiryHeight != 0 {
		i = encodeVarintTransaction(dAtA, i, uint64(m.ExpiryHeight))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Actions) > 0 {
		for iNdEx := len(m.Actions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Actions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransaction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ActionPlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionPlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Action != nil {
		{
			size := m.Action.Size()
			i -= size
			if _, err := m.Action.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ActionPlan_Spend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_Spend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Spend != nil {
		{
			size, err := m.Spend.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_Output) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_Output) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Output != nil {
		{
			size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_Swap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_Swap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Swap != nil {
		{
			size, err := m.Swap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_SwapClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_SwapClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SwapClaim != nil {
		{
			size, err := m.SwapClaim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_ValidatorDefinition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_ValidatorDefinition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ValidatorDefinition != nil {
		{
			size, err := m.ValidatorDefinition.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_IbcAction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_IbcAction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IbcAction != nil {
		{
			size, err := m.IbcAction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_ProposalSubmit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_ProposalSubmit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ProposalSubmit != nil {
		{
			size, err := m.ProposalSubmit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_ProposalWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_ProposalWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ProposalWithdraw != nil {
		{
			size, err := m.ProposalWithdraw.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_ValidatorVote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_ValidatorVote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ValidatorVote != nil {
		{
			size, err := m.ValidatorVote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_DelegatorVote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_DelegatorVote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DelegatorVote != nil {
		{
			size, err := m.DelegatorVote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_ProposalDepositClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_ProposalDepositClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ProposalDepositClaim != nil {
		{
			size, err := m.ProposalDepositClaim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_PositionOpen) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_PositionOpen) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PositionOpen != nil {
		{
			size, err := m.PositionOpen.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_PositionClose) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_PositionClose) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PositionClose != nil {
		{
			size, err := m.PositionClose.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_PositionWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_PositionWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PositionWithdraw != nil {
		{
			size, err := m.PositionWithdraw.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_PositionRewardClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_PositionRewardClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PositionRewardClaim != nil {
		{
			size, err := m.PositionRewardClaim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_Delegate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_Delegate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Delegate != nil {
		{
			size, err := m.Delegate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_Undelegate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_Undelegate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Undelegate != nil {
		{
			size, err := m.Undelegate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_UndelegateClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_UndelegateClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UndelegateClaim != nil {
		{
			size, err := m.UndelegateClaim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_DaoSpend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_DaoSpend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DaoSpend != nil {
		{
			size, err := m.DaoSpend.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_DaoOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_DaoOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DaoOutput != nil {
		{
			size, err := m.DaoOutput.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_DaoDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_DaoDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DaoDeposit != nil {
		{
			size, err := m.DaoDeposit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *CluePlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CluePlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CluePlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PrecisionBits != 0 {
		i = encodeVarintTransaction(dAtA, i, uint64(m.PrecisionBits))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Rseed) > 0 {
		i -= len(m.Rseed)
		copy(dAtA[i:], m.Rseed)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Rseed)))
		i--
		dAtA[i] = 0x12
	}
	if m.Address != nil {
		{
			size, err := m.Address.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MemoPlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemoPlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemoPlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Plaintext) > 0 {
		i -= len(m.Plaintext)
		copy(dAtA[i:], m.Plaintext)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Plaintext)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpendPlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpendPlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpendPlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ValueBlinding) > 0 {
		i -= len(m.ValueBlinding)
		copy(dAtA[i:], m.ValueBlinding)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.ValueBlinding)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Randomizer) > 0 {
		i -= len(m.Randomizer)
		copy(dAtA[i:], m.Randomizer)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Randomizer)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Position != 0 {
		i = encodeVarintTransaction(dAtA, i, uint64(m.Position))
		i--
		dAtA[i] = 0x10
	}
	if m.Note != nil {
		{
			size, err := m.Note.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OutputPlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OutputPlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutputPlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ValueBlinding) > 0 {
		i -= len(m.ValueBlinding)
		copy(dAtA[i:], m.ValueBlinding)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.ValueBlinding)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Rseed) > 0 {
		i -= len(m.Rseed)
		copy(dAtA[i:], m.Rseed)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Rseed)))
		i--
		dAtA[i] = 0x1a
	}
	if m.DestAddress != nil {
		{
			size, err := m.DestAddress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTransaction(dAtA []byte, offset int, v uint64) int {
	offset -= sovTransaction(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Transaction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Body != nil {
		l = m.Body.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.BindingSig)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Anchor != nil {
		l = m.Anchor.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *Id) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *TransactionBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Actions) > 0 {
		for _, e := range m.Actions {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	if m.ExpiryHeight != 0 {
		n += 1 + sovTransaction(uint64(m.ExpiryHeight))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Fee != nil {
		l = m.Fee.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if len(m.FmdClues) > 0 {
		for _, e := range m.FmdClues {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	if m.XEncryptedMemo != nil {
		n += m.XEncryptedMemo.Size()
	}
	return n
}

func (m *TransactionBody_EncryptedMemo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EncryptedMemo != nil {
		l = len(m.EncryptedMemo)
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Action != nil {
		n += m.Action.Size()
	}
	return n
}

func (m *Action_Spend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spend != nil {
		l = m.Spend.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_Output) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Output != nil {
		l = m.Output.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_Swap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Swap != nil {
		l = m.Swap.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_SwapClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SwapClaim != nil {
		l = m.SwapClaim.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_ValidatorDefinition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ValidatorDefinition != nil {
		l = m.ValidatorDefinition.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_IbcAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IbcAction != nil {
		l = m.IbcAction.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_ProposalSubmit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalSubmit != nil {
		l = m.ProposalSubmit.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_ProposalWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalWithdraw != nil {
		l = m.ProposalWithdraw.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_ValidatorVote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ValidatorVote != nil {
		l = m.ValidatorVote.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_DelegatorVote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DelegatorVote != nil {
		l = m.DelegatorVote.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_ProposalDepositClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalDepositClaim != nil {
		l = m.ProposalDepositClaim.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_PositionOpen) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionOpen != nil {
		l = m.PositionOpen.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_PositionClose) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionClose != nil {
		l = m.PositionClose.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_PositionWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionWithdraw != nil {
		l = m.PositionWithdraw.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_PositionRewardClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionRewardClaim != nil {
		l = m.PositionRewardClaim.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_Delegate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Delegate != nil {
		l = m.Delegate.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_Undelegate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Undelegate != nil {
		l = m.Undelegate.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_UndelegateClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UndelegateClaim != nil {
		l = m.UndelegateClaim.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_DaoSpend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DaoSpend != nil {
		l = m.DaoSpend.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_DaoOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DaoOutput != nil {
		l = m.DaoOutput.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_DaoDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DaoDeposit != nil {
		l = m.DaoDeposit.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_Ics20Withdrawal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ics20Withdrawal != nil {
		l = m.Ics20Withdrawal.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *TransactionPerspective) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PayloadKeys) > 0 {
		for _, e := range m.PayloadKeys {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	if len(m.SpendNullifiers) > 0 {
		for _, e := range m.SpendNullifiers {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	if len(m.AdviceNotes) > 0 {
		for _, e := range m.AdviceNotes {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	if len(m.AddressViews) > 0 {
		for _, e := range m.AddressViews {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	return n
}

func (m *PayloadKeyWithCommitment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PayloadKey)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Commitment != nil {
		l = m.Commitment.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *NullifierWithNote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nullifier != nil {
		l = m.Nullifier.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Note != nil {
		l = m.Note.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *TransactionView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ActionViews) > 0 {
		for _, e := range m.ActionViews {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	if m.ExpiryHeight != 0 {
		n += 1 + sovTransaction(uint64(m.ExpiryHeight))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Fee != nil {
		l = m.Fee.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if len(m.FmdClues) > 0 {
		for _, e := range m.FmdClues {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	if m.XMemo != nil {
		n += m.XMemo.Size()
	}
	if len(m.AddressViews) > 0 {
		for _, e := range m.AddressViews {
			l = e.Size()
			n += 2 + l + sovTransaction(uint64(l))
		}
	}
	return n
}

func (m *TransactionView_Memo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Memo != nil {
		l = len(m.Memo)
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ActionView != nil {
		n += m.ActionView.Size()
	}
	return n
}

func (m *ActionView_Spend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spend != nil {
		l = m.Spend.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_Output) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Output != nil {
		l = m.Output.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_Swap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Swap != nil {
		l = m.Swap.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_SwapClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SwapClaim != nil {
		l = m.SwapClaim.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_ValidatorDefinition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ValidatorDefinition != nil {
		l = m.ValidatorDefinition.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_IbcAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IbcAction != nil {
		l = m.IbcAction.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_ProposalSubmit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalSubmit != nil {
		l = m.ProposalSubmit.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_ProposalWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalWithdraw != nil {
		l = m.ProposalWithdraw.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_ValidatorVote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ValidatorVote != nil {
		l = m.ValidatorVote.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_DelegatorVote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DelegatorVote != nil {
		l = m.DelegatorVote.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_ProposalDepositClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalDepositClaim != nil {
		l = m.ProposalDepositClaim.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_PositionOpen) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionOpen != nil {
		l = m.PositionOpen.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_PositionClose) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionClose != nil {
		l = m.PositionClose.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_PositionWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionWithdraw != nil {
		l = m.PositionWithdraw.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_PositionRewardClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionRewardClaim != nil {
		l = m.PositionRewardClaim.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_Delegate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Delegate != nil {
		l = m.Delegate.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_Undelegate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Undelegate != nil {
		l = m.Undelegate.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_UndelegateClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UndelegateClaim != nil {
		l = m.UndelegateClaim.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_DaoSpend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DaoSpend != nil {
		l = m.DaoSpend.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_DaoOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DaoOutput != nil {
		l = m.DaoOutput.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_DaoDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DaoDeposit != nil {
		l = m.DaoDeposit.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_Ics20Withdrawal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ics20Withdrawal != nil {
		l = m.Ics20Withdrawal.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *SpendView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SpendView != nil {
		n += m.SpendView.Size()
	}
	return n
}

func (m *SpendView_Visible_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Visible != nil {
		l = m.Visible.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *SpendView_Opaque_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Opaque != nil {
		l = m.Opaque.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *SpendView_Visible) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spend != nil {
		l = m.Spend.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Note != nil {
		l = m.Note.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *SpendView_Opaque) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spend != nil {
		l = m.Spend.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *DelegatorVoteView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DelegatorVote != nil {
		n += m.DelegatorVote.Size()
	}
	return n
}

func (m *DelegatorVoteView_Visible_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Visible != nil {
		l = m.Visible.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *DelegatorVoteView_Opaque_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Opaque != nil {
		l = m.Opaque.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *DelegatorVoteView_Visible) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DelegatorVote != nil {
		l = m.DelegatorVote.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Note != nil {
		l = m.Note.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *DelegatorVoteView_Opaque) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DelegatorVote != nil {
		l = m.DelegatorVote.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *OutputView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OutputView != nil {
		n += m.OutputView.Size()
	}
	return n
}

func (m *OutputView_Visible_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Visible != nil {
		l = m.Visible.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *OutputView_Opaque_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Opaque != nil {
		l = m.Opaque.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *OutputView_Visible) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Output != nil {
		l = m.Output.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Note != nil {
		l = m.Note.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.PayloadKey)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *OutputView_Opaque) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Output != nil {
		l = m.Output.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *Spend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Body != nil {
		l = m.Body.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.AuthSig != nil {
		l = m.AuthSig.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Proof != nil {
		l = m.Proof.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *SpendBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BalanceCommitment != nil {
		l = m.BalanceCommitment.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.Nullifier)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.Rk)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *Output) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Body != nil {
		l = m.Body.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Proof != nil {
		l = m.Proof.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *OutputBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NotePayload != nil {
		l = m.NotePayload.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.BalanceCommitment != nil {
		l = m.BalanceCommitment.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.WrappedMemoKey)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.OvkWrappedKey)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *AuthorizationData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EffectHash != nil {
		l = m.EffectHash.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if len(m.SpendAuths) > 0 {
		for _, e := range m.SpendAuths {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	if len(m.DelegatorVoteAuths) > 0 {
		for _, e := range m.DelegatorVoteAuths {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	return n
}

func (m *WitnessData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Anchor != nil {
		l = m.Anchor.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if len(m.StateCommitmentProofs) > 0 {
		for _, e := range m.StateCommitmentProofs {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	return n
}

func (m *TransactionPlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Actions) > 0 {
		for _, e := range m.Actions {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	if m.ExpiryHeight != 0 {
		n += 1 + sovTransaction(uint64(m.ExpiryHeight))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Fee != nil {
		l = m.Fee.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if len(m.CluePlans) > 0 {
		for _, e := range m.CluePlans {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	if m.MemoPlan != nil {
		l = m.MemoPlan.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *ActionPlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Action != nil {
		n += m.Action.Size()
	}
	return n
}

func (m *ActionPlan_Spend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spend != nil {
		l = m.Spend.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_Output) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Output != nil {
		l = m.Output.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_Swap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Swap != nil {
		l = m.Swap.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_SwapClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SwapClaim != nil {
		l = m.SwapClaim.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_ValidatorDefinition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ValidatorDefinition != nil {
		l = m.ValidatorDefinition.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_IbcAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IbcAction != nil {
		l = m.IbcAction.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_ProposalSubmit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalSubmit != nil {
		l = m.ProposalSubmit.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_ProposalWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalWithdraw != nil {
		l = m.ProposalWithdraw.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_ValidatorVote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ValidatorVote != nil {
		l = m.ValidatorVote.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_DelegatorVote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DelegatorVote != nil {
		l = m.DelegatorVote.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_ProposalDepositClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalDepositClaim != nil {
		l = m.ProposalDepositClaim.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_PositionOpen) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionOpen != nil {
		l = m.PositionOpen.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_PositionClose) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionClose != nil {
		l = m.PositionClose.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_PositionWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionWithdraw != nil {
		l = m.PositionWithdraw.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_PositionRewardClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionRewardClaim != nil {
		l = m.PositionRewardClaim.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_Delegate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Delegate != nil {
		l = m.Delegate.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_Undelegate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Undelegate != nil {
		l = m.Undelegate.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_UndelegateClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UndelegateClaim != nil {
		l = m.UndelegateClaim.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_DaoSpend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DaoSpend != nil {
		l = m.DaoSpend.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_DaoOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DaoOutput != nil {
		l = m.DaoOutput.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_DaoDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DaoDeposit != nil {
		l = m.DaoDeposit.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *CluePlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Address != nil {
		l = m.Address.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.Rseed)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.PrecisionBits != 0 {
		n += 1 + sovTransaction(uint64(m.PrecisionBits))
	}
	return n
}

func (m *MemoPlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Plaintext)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *SpendPlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Note != nil {
		l = m.Note.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Position != 0 {
		n += 1 + sovTransaction(uint64(m.Position))
	}
	l = len(m.Randomizer)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.ValueBlinding)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *OutputPlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.DestAddress != nil {
		l = m.DestAddress.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.Rseed)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.ValueBlinding)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func sovTransaction(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTransaction(x uint64) (n int) {
	return sovTransaction(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Transaction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Transaction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Transaction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Body == nil {
				m.Body = &TransactionBody{}
			}
			if err := m.Body.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BindingSig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BindingSig = append(m.BindingSig[:0], dAtA[iNdEx:postIndex]...)
			if m.BindingSig == nil {
				m.BindingSig = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Anchor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Anchor == nil {
				m.Anchor = &v1alpha1.MerkleRoot{}
			}
			if err := m.Anchor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Id) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Id: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Id: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actions = append(m.Actions, &Action{})
			if err := m.Actions[len(m.Actions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiryHeight", wireType)
			}
			m.ExpiryHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiryHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fee == nil {
				m.Fee = &v1alpha1.Fee{}
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FmdClues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FmdClues = append(m.FmdClues, &v1alpha1.Clue{})
			if err := m.FmdClues[len(m.FmdClues)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedMemo", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.XEncryptedMemo = &TransactionBody_EncryptedMemo{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Action) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Action: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Action: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Spend{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_Spend{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Output{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_Output{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Swap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha11.Swap{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_Swap{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha11.SwapClaim{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_SwapClaim{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorDefinition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha12.ValidatorDefinition{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_ValidatorDefinition{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IbcAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha13.IbcAction{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_IbcAction{v}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalSubmit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.ProposalSubmit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_ProposalSubmit{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalWithdraw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.ProposalWithdraw{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_ProposalWithdraw{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorVote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.ValidatorVote{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_ValidatorVote{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorVote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.DelegatorVote{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_DelegatorVote{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalDepositClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.ProposalDepositClaim{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_ProposalDepositClaim{v}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionOpen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha11.PositionOpen{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_PositionOpen{v}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionClose", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha11.PositionClose{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_PositionClose{v}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionWithdraw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha11.PositionWithdraw{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_PositionWithdraw{v}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionRewardClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha11.PositionRewardClaim{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_PositionRewardClaim{v}
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delegate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha12.Delegate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_Delegate{v}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Undelegate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha12.Undelegate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_Undelegate{v}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UndelegateClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha12.UndelegateClaim{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_UndelegateClaim{v}
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DaoSpend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.DaoSpend{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_DaoSpend{v}
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DaoOutput", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.DaoOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_DaoOutput{v}
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DaoDeposit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.DaoDeposit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_DaoDeposit{v}
			iNdEx = postIndex
		case 200:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ics20Withdrawal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha13.Ics20Withdrawal{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_Ics20Withdrawal{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionPerspective) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionPerspective: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionPerspective: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PayloadKeys = append(m.PayloadKeys, &PayloadKeyWithCommitment{})
			if err := m.PayloadKeys[len(m.PayloadKeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpendNullifiers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpendNullifiers = append(m.SpendNullifiers, &NullifierWithNote{})
			if err := m.SpendNullifiers[len(m.SpendNullifiers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdviceNotes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdviceNotes = append(m.AdviceNotes, &v1alpha1.Note{})
			if err := m.AdviceNotes[len(m.AdviceNotes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressViews", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressViews = append(m.AddressViews, &v1alpha1.AddressView{})
			if err := m.AddressViews[len(m.AddressViews)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PayloadKeyWithCommitment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PayloadKeyWithCommitment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PayloadKeyWithCommitment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PayloadKey = append(m.PayloadKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PayloadKey == nil {
				m.PayloadKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commitment == nil {
				m.Commitment = &v1alpha1.StateCommitment{}
			}
			if err := m.Commitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NullifierWithNote) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NullifierWithNote: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NullifierWithNote: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nullifier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Nullifier == nil {
				m.Nullifier = &v1alpha1.Nullifier{}
			}
			if err := m.Nullifier.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Note", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Note == nil {
				m.Note = &v1alpha1.Note{}
			}
			if err := m.Note.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionViews", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionViews = append(m.ActionViews, &ActionView{})
			if err := m.ActionViews[len(m.ActionViews)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiryHeight", wireType)
			}
			m.ExpiryHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiryHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fee == nil {
				m.Fee = &v1alpha1.Fee{}
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FmdClues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FmdClues = append(m.FmdClues, &v1alpha1.Clue{})
			if err := m.FmdClues[len(m.FmdClues)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memo", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.XMemo = &TransactionView_Memo{v}
			iNdEx = postIndex
		case 400:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressViews", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressViews = append(m.AddressViews, &v1alpha1.AddressView{})
			if err := m.AddressViews[len(m.AddressViews)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SpendView{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_Spend{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OutputView{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_Output{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Swap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha11.SwapView{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_Swap{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha11.SwapClaimView{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_SwapClaim{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorDefinition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha12.ValidatorDefinition{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_ValidatorDefinition{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IbcAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha13.IbcAction{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_IbcAction{v}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalSubmit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.ProposalSubmit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_ProposalSubmit{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalWithdraw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.ProposalWithdraw{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_ProposalWithdraw{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorVote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.ValidatorVote{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_ValidatorVote{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorVote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DelegatorVoteView{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_DelegatorVote{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalDepositClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.ProposalDepositClaim{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_ProposalDepositClaim{v}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionOpen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha11.PositionOpen{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_PositionOpen{v}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionClose", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha11.PositionClose{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_PositionClose{v}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionWithdraw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha11.PositionWithdraw{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_PositionWithdraw{v}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionRewardClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha11.PositionRewardClaim{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_PositionRewardClaim{v}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delegate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha12.Delegate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_Delegate{v}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Undelegate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha12.Undelegate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_Undelegate{v}
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UndelegateClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha12.UndelegateClaim{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_UndelegateClaim{v}
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DaoSpend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.DaoSpend{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_DaoSpend{v}
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DaoOutput", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.DaoOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_DaoOutput{v}
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DaoDeposit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.DaoDeposit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_DaoDeposit{v}
			iNdEx = postIndex
		case 200:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ics20Withdrawal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha13.Ics20Withdrawal{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_Ics20Withdrawal{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpendView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpendView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpendView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visible", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SpendView_Visible{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SpendView = &SpendView_Visible_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opaque", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SpendView_Opaque{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SpendView = &SpendView_Opaque_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpendView_Visible) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Visible: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Visible: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spend == nil {
				m.Spend = &Spend{}
			}
			if err := m.Spend.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Note", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Note == nil {
				m.Note = &v1alpha1.Note{}
			}
			if err := m.Note.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpendView_Opaque) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Opaque: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Opaque: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spend == nil {
				m.Spend = &Spend{}
			}
			if err := m.Spend.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelegatorVoteView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelegatorVoteView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelegatorVoteView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visible", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DelegatorVoteView_Visible{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DelegatorVote = &DelegatorVoteView_Visible_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opaque", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DelegatorVoteView_Opaque{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DelegatorVote = &DelegatorVoteView_Opaque_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelegatorVoteView_Visible) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Visible: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Visible: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorVote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DelegatorVote == nil {
				m.DelegatorVote = &v1alpha14.DelegatorVote{}
			}
			if err := m.DelegatorVote.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Note", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Note == nil {
				m.Note = &v1alpha1.Note{}
			}
			if err := m.Note.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelegatorVoteView_Opaque) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Opaque: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Opaque: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorVote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DelegatorVote == nil {
				m.DelegatorVote = &v1alpha14.DelegatorVote{}
			}
			if err := m.DelegatorVote.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutputView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OutputView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OutputView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visible", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OutputView_Visible{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.OutputView = &OutputView_Visible_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opaque", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OutputView_Opaque{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.OutputView = &OutputView_Opaque_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutputView_Visible) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Visible: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Visible: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output == nil {
				m.Output = &Output{}
			}
			if err := m.Output.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Note", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Note == nil {
				m.Note = &v1alpha1.Note{}
			}
			if err := m.Note.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PayloadKey = append(m.PayloadKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PayloadKey == nil {
				m.PayloadKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutputView_Opaque) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Opaque: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Opaque: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output == nil {
				m.Output = &Output{}
			}
			if err := m.Output.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Spend) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Spend: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Spend: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Body == nil {
				m.Body = &SpendBody{}
			}
			if err := m.Body.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthSig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuthSig == nil {
				m.AuthSig = &v1alpha1.SpendAuthSignature{}
			}
			if err := m.AuthSig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proof == nil {
				m.Proof = &v1alpha1.ZKSpendProof{}
			}
			if err := m.Proof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpendBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpendBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpendBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BalanceCommitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BalanceCommitment == nil {
				m.BalanceCommitment = &v1alpha1.BalanceCommitment{}
			}
			if err := m.BalanceCommitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nullifier", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nullifier = append(m.Nullifier[:0], dAtA[iNdEx:postIndex]...)
			if m.Nullifier == nil {
				m.Nullifier = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rk = append(m.Rk[:0], dAtA[iNdEx:postIndex]...)
			if m.Rk == nil {
				m.Rk = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Output) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Output: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Output: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Body == nil {
				m.Body = &OutputBody{}
			}
			if err := m.Body.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proof == nil {
				m.Proof = &v1alpha1.ZKOutputProof{}
			}
			if err := m.Proof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutputBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OutputBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OutputBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotePayload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NotePayload == nil {
				m.NotePayload = &v1alpha1.NotePayload{}
			}
			if err := m.NotePayload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BalanceCommitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BalanceCommitment == nil {
				m.BalanceCommitment = &v1alpha1.BalanceCommitment{}
			}
			if err := m.BalanceCommitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WrappedMemoKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WrappedMemoKey = append(m.WrappedMemoKey[:0], dAtA[iNdEx:postIndex]...)
			if m.WrappedMemoKey == nil {
				m.WrappedMemoKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OvkWrappedKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OvkWrappedKey = append(m.OvkWrappedKey[:0], dAtA[iNdEx:postIndex]...)
			if m.OvkWrappedKey == nil {
				m.OvkWrappedKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthorizationData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthorizationData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthorizationData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectHash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EffectHash == nil {
				m.EffectHash = &v1alpha1.EffectHash{}
			}
			if err := m.EffectHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpendAuths", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpendAuths = append(m.SpendAuths, &v1alpha1.SpendAuthSignature{})
			if err := m.SpendAuths[len(m.SpendAuths)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorVoteAuths", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelegatorVoteAuths = append(m.DelegatorVoteAuths, &v1alpha1.SpendAuthSignature{})
			if err := m.DelegatorVoteAuths[len(m.DelegatorVoteAuths)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WitnessData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WitnessData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WitnessData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Anchor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Anchor == nil {
				m.Anchor = &v1alpha1.MerkleRoot{}
			}
			if err := m.Anchor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateCommitmentProofs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StateCommitmentProofs = append(m.StateCommitmentProofs, &v1alpha1.StateCommitmentProof{})
			if err := m.StateCommitmentProofs[len(m.StateCommitmentProofs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionPlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionPlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionPlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actions = append(m.Actions, &ActionPlan{})
			if err := m.Actions[len(m.Actions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiryHeight", wireType)
			}
			m.ExpiryHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiryHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fee == nil {
				m.Fee = &v1alpha1.Fee{}
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CluePlans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CluePlans = append(m.CluePlans, &CluePlan{})
			if err := m.CluePlans[len(m.CluePlans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoPlan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MemoPlan == nil {
				m.MemoPlan = &MemoPlan{}
			}
			if err := m.MemoPlan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionPlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionPlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionPlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SpendPlan{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_Spend{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OutputPlan{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_Output{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Swap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha11.SwapPlan{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_Swap{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha11.SwapClaimPlan{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_SwapClaim{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorDefinition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha12.ValidatorDefinition{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_ValidatorDefinition{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IbcAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha13.IbcAction{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_IbcAction{v}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalSubmit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.ProposalSubmit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_ProposalSubmit{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalWithdraw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.ProposalWithdraw{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_ProposalWithdraw{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorVote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.ValidatorVote{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_ValidatorVote{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorVote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.DelegatorVotePlan{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_DelegatorVote{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalDepositClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.ProposalDepositClaim{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_ProposalDepositClaim{v}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionOpen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha11.PositionOpen{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_PositionOpen{v}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionClose", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha11.PositionClose{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_PositionClose{v}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionWithdraw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha11.PositionWithdrawPlan{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_PositionWithdraw{v}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionRewardClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha11.PositionRewardClaimPlan{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_PositionRewardClaim{v}
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delegate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha12.Delegate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_Delegate{v}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Undelegate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha12.Undelegate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_Undelegate{v}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UndelegateClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha12.UndelegateClaimPlan{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_UndelegateClaim{v}
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DaoSpend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.DaoSpend{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_DaoSpend{v}
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DaoOutput", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.DaoOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_DaoOutput{v}
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DaoDeposit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.DaoDeposit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_DaoDeposit{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CluePlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CluePlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CluePlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Address == nil {
				m.Address = &v1alpha1.Address{}
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rseed", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rseed = append(m.Rseed[:0], dAtA[iNdEx:postIndex]...)
			if m.Rseed == nil {
				m.Rseed = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrecisionBits", wireType)
			}
			m.PrecisionBits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrecisionBits |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemoPlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemoPlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemoPlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plaintext", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Plaintext = append(m.Plaintext[:0], dAtA[iNdEx:postIndex]...)
			if m.Plaintext == nil {
				m.Plaintext = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpendPlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpendPlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpendPlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Note", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Note == nil {
				m.Note = &v1alpha1.Note{}
			}
			if err := m.Note.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			m.Position = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Position |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Randomizer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Randomizer = append(m.Randomizer[:0], dAtA[iNdEx:postIndex]...)
			if m.Randomizer == nil {
				m.Randomizer = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueBlinding", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueBlinding = append(m.ValueBlinding[:0], dAtA[iNdEx:postIndex]...)
			if m.ValueBlinding == nil {
				m.ValueBlinding = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutputPlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OutputPlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OutputPlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &v1alpha1.Value{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DestAddress == nil {
				m.DestAddress = &v1alpha1.Address{}
			}
			if err := m.DestAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rseed", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rseed = append(m.Rseed[:0], dAtA[iNdEx:postIndex]...)
			if m.Rseed == nil {
				m.Rseed = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueBlinding", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueBlinding = append(m.ValueBlinding[:0], dAtA[iNdEx:postIndex]...)
			if m.ValueBlinding == nil {
				m.ValueBlinding = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTransaction(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTransaction
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTransaction
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTransaction
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTransaction        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTransaction          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTransaction = fmt.Errorf("proto: unexpected end of group")
)
