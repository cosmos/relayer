// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: penumbra/core/transaction/v1alpha1/transaction.proto

package transactionv1alpha1

import (
	fmt "fmt"
	proto "github.com/cosmos/gogoproto/proto"
	v1alpha1 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/crypto/v1alpha1"
	v1alpha11 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/dex/v1alpha1"
	v1alpha14 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/governance/v1alpha1"
	v1alpha13 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/ibc/v1alpha1"
	v1alpha12 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/stake/v1alpha1"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// A Penumbra transaction.
type Transaction struct {
	Body *TransactionBody `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// The binding signature is stored separately from the transaction body that it signs.
	BindingSig []byte `protobuf:"bytes,2,opt,name=binding_sig,json=bindingSig,proto3" json:"binding_sig,omitempty"`
	// The root of some previous state of the state commitment tree, used as an anchor for all
	// ZK state transition proofs.
	Anchor *v1alpha1.MerkleRoot `protobuf:"bytes,3,opt,name=anchor,proto3" json:"anchor,omitempty"`
}

func (m *Transaction) Reset()         { *m = Transaction{} }
func (m *Transaction) String() string { return proto.CompactTextString(m) }
func (*Transaction) ProtoMessage()    {}
func (*Transaction) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{0}
}
func (m *Transaction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Transaction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Transaction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Transaction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Transaction.Merge(m, src)
}
func (m *Transaction) XXX_Size() int {
	return m.Size()
}
func (m *Transaction) XXX_DiscardUnknown() {
	xxx_messageInfo_Transaction.DiscardUnknown(m)
}

var xxx_messageInfo_Transaction proto.InternalMessageInfo

func (m *Transaction) GetBody() *TransactionBody {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *Transaction) GetBindingSig() []byte {
	if m != nil {
		return m.BindingSig
	}
	return nil
}

func (m *Transaction) GetAnchor() *v1alpha1.MerkleRoot {
	if m != nil {
		return m.Anchor
	}
	return nil
}

// A transaction ID, the Sha256 hash of a transaction.
type Id struct {
	Hash []byte `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
}

func (m *Id) Reset()         { *m = Id{} }
func (m *Id) String() string { return proto.CompactTextString(m) }
func (*Id) ProtoMessage()    {}
func (*Id) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{1}
}
func (m *Id) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Id) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Id.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Id) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Id.Merge(m, src)
}
func (m *Id) XXX_Size() int {
	return m.Size()
}
func (m *Id) XXX_DiscardUnknown() {
	xxx_messageInfo_Id.DiscardUnknown(m)
}

var xxx_messageInfo_Id proto.InternalMessageInfo

func (m *Id) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

type EffectHash struct {
	Inner []byte `protobuf:"bytes,1,opt,name=inner,proto3" json:"inner,omitempty"`
}

func (m *EffectHash) Reset()         { *m = EffectHash{} }
func (m *EffectHash) String() string { return proto.CompactTextString(m) }
func (*EffectHash) ProtoMessage()    {}
func (*EffectHash) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{2}
}
func (m *EffectHash) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EffectHash) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EffectHash.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EffectHash) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EffectHash.Merge(m, src)
}
func (m *EffectHash) XXX_Size() int {
	return m.Size()
}
func (m *EffectHash) XXX_DiscardUnknown() {
	xxx_messageInfo_EffectHash.DiscardUnknown(m)
}

var xxx_messageInfo_EffectHash proto.InternalMessageInfo

func (m *EffectHash) GetInner() []byte {
	if m != nil {
		return m.Inner
	}
	return nil
}

// The body of a transaction.
type TransactionBody struct {
	// A list of actions (state changes) performed by this transaction.
	Actions []*Action `protobuf:"bytes,1,rep,name=actions,proto3" json:"actions,omitempty"`
	// Parameters determining if a transaction should be accepted by this chain.
	TransactionParameters *TransactionParameters `protobuf:"bytes,2,opt,name=transaction_parameters,json=transactionParameters,proto3" json:"transaction_parameters,omitempty"`
	// The transaction fee.
	Fee *v1alpha1.Fee `protobuf:"bytes,3,opt,name=fee,proto3" json:"fee,omitempty"`
	// Detection data for use with Fuzzy Message Detection
	DetectionData *DetectionData `protobuf:"bytes,4,opt,name=detection_data,json=detectionData,proto3" json:"detection_data,omitempty"`
	// Sub-message containing memo ciphertext if a memo was added to the transaction.
	MemoData *MemoData `protobuf:"bytes,5,opt,name=memo_data,json=memoData,proto3" json:"memo_data,omitempty"`
}

func (m *TransactionBody) Reset()         { *m = TransactionBody{} }
func (m *TransactionBody) String() string { return proto.CompactTextString(m) }
func (*TransactionBody) ProtoMessage()    {}
func (*TransactionBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{3}
}
func (m *TransactionBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactionBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransactionBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransactionBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionBody.Merge(m, src)
}
func (m *TransactionBody) XXX_Size() int {
	return m.Size()
}
func (m *TransactionBody) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionBody.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionBody proto.InternalMessageInfo

func (m *TransactionBody) GetActions() []*Action {
	if m != nil {
		return m.Actions
	}
	return nil
}

func (m *TransactionBody) GetTransactionParameters() *TransactionParameters {
	if m != nil {
		return m.TransactionParameters
	}
	return nil
}

func (m *TransactionBody) GetFee() *v1alpha1.Fee {
	if m != nil {
		return m.Fee
	}
	return nil
}

func (m *TransactionBody) GetDetectionData() *DetectionData {
	if m != nil {
		return m.DetectionData
	}
	return nil
}

func (m *TransactionBody) GetMemoData() *MemoData {
	if m != nil {
		return m.MemoData
	}
	return nil
}

// Represents the encrypted memo data.
type MemoData struct {
	// Types that are valid to be assigned to XEncryptedMemo:
	//	*MemoData_EncryptedMemo
	XEncryptedMemo isMemoData_XEncryptedMemo `protobuf_oneof:"_encrypted_memo"`
}

func (m *MemoData) Reset()         { *m = MemoData{} }
func (m *MemoData) String() string { return proto.CompactTextString(m) }
func (*MemoData) ProtoMessage()    {}
func (*MemoData) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{4}
}
func (m *MemoData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemoData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemoData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemoData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemoData.Merge(m, src)
}
func (m *MemoData) XXX_Size() int {
	return m.Size()
}
func (m *MemoData) XXX_DiscardUnknown() {
	xxx_messageInfo_MemoData.DiscardUnknown(m)
}

var xxx_messageInfo_MemoData proto.InternalMessageInfo

type isMemoData_XEncryptedMemo interface {
	isMemoData_XEncryptedMemo()
	MarshalTo([]byte) (int, error)
	Size() int
}

type MemoData_EncryptedMemo struct {
	EncryptedMemo []byte `protobuf:"bytes,1,opt,name=encrypted_memo,json=encryptedMemo,proto3,oneof" json:"encrypted_memo,omitempty"`
}

func (*MemoData_EncryptedMemo) isMemoData_XEncryptedMemo() {}

func (m *MemoData) GetXEncryptedMemo() isMemoData_XEncryptedMemo {
	if m != nil {
		return m.XEncryptedMemo
	}
	return nil
}

func (m *MemoData) GetEncryptedMemo() []byte {
	if x, ok := m.GetXEncryptedMemo().(*MemoData_EncryptedMemo); ok {
		return x.EncryptedMemo
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MemoData) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MemoData_EncryptedMemo)(nil),
	}
}

// The parameters determining if a transaction should be accepted by the chain.
type TransactionParameters struct {
	// The maximum height that this transaction can be included in the chain.
	//
	// If zero, there is no maximum.
	ExpiryHeight uint64 `protobuf:"varint,1,opt,name=expiry_height,json=expiryHeight,proto3" json:"expiry_height,omitempty"`
	// The chain this transaction is intended for.  Including this prevents
	// replaying a transaction on one chain onto a different chain.
	ChainId string `protobuf:"bytes,2,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
}

func (m *TransactionParameters) Reset()         { *m = TransactionParameters{} }
func (m *TransactionParameters) String() string { return proto.CompactTextString(m) }
func (*TransactionParameters) ProtoMessage()    {}
func (*TransactionParameters) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{5}
}
func (m *TransactionParameters) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactionParameters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransactionParameters.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransactionParameters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionParameters.Merge(m, src)
}
func (m *TransactionParameters) XXX_Size() int {
	return m.Size()
}
func (m *TransactionParameters) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionParameters.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionParameters proto.InternalMessageInfo

func (m *TransactionParameters) GetExpiryHeight() uint64 {
	if m != nil {
		return m.ExpiryHeight
	}
	return 0
}

func (m *TransactionParameters) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

// Detection data used by a detection server performing Fuzzy Message Detection.
type DetectionData struct {
	// A list of clues for use with Fuzzy Message Detection.
	FmdClues []*v1alpha1.Clue `protobuf:"bytes,4,rep,name=fmd_clues,json=fmdClues,proto3" json:"fmd_clues,omitempty"`
}

func (m *DetectionData) Reset()         { *m = DetectionData{} }
func (m *DetectionData) String() string { return proto.CompactTextString(m) }
func (*DetectionData) ProtoMessage()    {}
func (*DetectionData) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{6}
}
func (m *DetectionData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DetectionData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DetectionData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DetectionData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetectionData.Merge(m, src)
}
func (m *DetectionData) XXX_Size() int {
	return m.Size()
}
func (m *DetectionData) XXX_DiscardUnknown() {
	xxx_messageInfo_DetectionData.DiscardUnknown(m)
}

var xxx_messageInfo_DetectionData proto.InternalMessageInfo

func (m *DetectionData) GetFmdClues() []*v1alpha1.Clue {
	if m != nil {
		return m.FmdClues
	}
	return nil
}

// A state change performed by a transaction.
type Action struct {
	// Types that are valid to be assigned to Action:
	//	*Action_Spend
	//	*Action_Output
	//	*Action_Swap
	//	*Action_SwapClaim
	//	*Action_ValidatorDefinition
	//	*Action_IbcAction
	//	*Action_ProposalSubmit
	//	*Action_ProposalWithdraw
	//	*Action_ValidatorVote
	//	*Action_DelegatorVote
	//	*Action_ProposalDepositClaim
	//	*Action_PositionOpen
	//	*Action_PositionClose
	//	*Action_PositionWithdraw
	//	*Action_PositionRewardClaim
	//	*Action_Delegate
	//	*Action_Undelegate
	//	*Action_UndelegateClaim
	//	*Action_DaoSpend
	//	*Action_DaoOutput
	//	*Action_DaoDeposit
	//	*Action_Ics20Withdrawal
	Action isAction_Action `protobuf_oneof:"action"`
}

func (m *Action) Reset()         { *m = Action{} }
func (m *Action) String() string { return proto.CompactTextString(m) }
func (*Action) ProtoMessage()    {}
func (*Action) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{7}
}
func (m *Action) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Action) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Action.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Action) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Action.Merge(m, src)
}
func (m *Action) XXX_Size() int {
	return m.Size()
}
func (m *Action) XXX_DiscardUnknown() {
	xxx_messageInfo_Action.DiscardUnknown(m)
}

var xxx_messageInfo_Action proto.InternalMessageInfo

type isAction_Action interface {
	isAction_Action()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Action_Spend struct {
	Spend *Spend `protobuf:"bytes,1,opt,name=spend,proto3,oneof" json:"spend,omitempty"`
}
type Action_Output struct {
	Output *Output `protobuf:"bytes,2,opt,name=output,proto3,oneof" json:"output,omitempty"`
}
type Action_Swap struct {
	Swap *v1alpha11.Swap `protobuf:"bytes,3,opt,name=swap,proto3,oneof" json:"swap,omitempty"`
}
type Action_SwapClaim struct {
	SwapClaim *v1alpha11.SwapClaim `protobuf:"bytes,4,opt,name=swap_claim,json=swapClaim,proto3,oneof" json:"swap_claim,omitempty"`
}
type Action_ValidatorDefinition struct {
	ValidatorDefinition *v1alpha12.ValidatorDefinition `protobuf:"bytes,16,opt,name=validator_definition,json=validatorDefinition,proto3,oneof" json:"validator_definition,omitempty"`
}
type Action_IbcAction struct {
	IbcAction *v1alpha13.IbcAction `protobuf:"bytes,17,opt,name=ibc_action,json=ibcAction,proto3,oneof" json:"ibc_action,omitempty"`
}
type Action_ProposalSubmit struct {
	ProposalSubmit *v1alpha14.ProposalSubmit `protobuf:"bytes,18,opt,name=proposal_submit,json=proposalSubmit,proto3,oneof" json:"proposal_submit,omitempty"`
}
type Action_ProposalWithdraw struct {
	ProposalWithdraw *v1alpha14.ProposalWithdraw `protobuf:"bytes,19,opt,name=proposal_withdraw,json=proposalWithdraw,proto3,oneof" json:"proposal_withdraw,omitempty"`
}
type Action_ValidatorVote struct {
	ValidatorVote *v1alpha14.ValidatorVote `protobuf:"bytes,20,opt,name=validator_vote,json=validatorVote,proto3,oneof" json:"validator_vote,omitempty"`
}
type Action_DelegatorVote struct {
	DelegatorVote *v1alpha14.DelegatorVote `protobuf:"bytes,21,opt,name=delegator_vote,json=delegatorVote,proto3,oneof" json:"delegator_vote,omitempty"`
}
type Action_ProposalDepositClaim struct {
	ProposalDepositClaim *v1alpha14.ProposalDepositClaim `protobuf:"bytes,22,opt,name=proposal_deposit_claim,json=proposalDepositClaim,proto3,oneof" json:"proposal_deposit_claim,omitempty"`
}
type Action_PositionOpen struct {
	PositionOpen *v1alpha11.PositionOpen `protobuf:"bytes,30,opt,name=position_open,json=positionOpen,proto3,oneof" json:"position_open,omitempty"`
}
type Action_PositionClose struct {
	PositionClose *v1alpha11.PositionClose `protobuf:"bytes,31,opt,name=position_close,json=positionClose,proto3,oneof" json:"position_close,omitempty"`
}
type Action_PositionWithdraw struct {
	PositionWithdraw *v1alpha11.PositionWithdraw `protobuf:"bytes,32,opt,name=position_withdraw,json=positionWithdraw,proto3,oneof" json:"position_withdraw,omitempty"`
}
type Action_PositionRewardClaim struct {
	PositionRewardClaim *v1alpha11.PositionRewardClaim `protobuf:"bytes,34,opt,name=position_reward_claim,json=positionRewardClaim,proto3,oneof" json:"position_reward_claim,omitempty"`
}
type Action_Delegate struct {
	Delegate *v1alpha12.Delegate `protobuf:"bytes,40,opt,name=delegate,proto3,oneof" json:"delegate,omitempty"`
}
type Action_Undelegate struct {
	Undelegate *v1alpha12.Undelegate `protobuf:"bytes,41,opt,name=undelegate,proto3,oneof" json:"undelegate,omitempty"`
}
type Action_UndelegateClaim struct {
	UndelegateClaim *v1alpha12.UndelegateClaim `protobuf:"bytes,42,opt,name=undelegate_claim,json=undelegateClaim,proto3,oneof" json:"undelegate_claim,omitempty"`
}
type Action_DaoSpend struct {
	DaoSpend *v1alpha14.DaoSpend `protobuf:"bytes,50,opt,name=dao_spend,json=daoSpend,proto3,oneof" json:"dao_spend,omitempty"`
}
type Action_DaoOutput struct {
	DaoOutput *v1alpha14.DaoOutput `protobuf:"bytes,51,opt,name=dao_output,json=daoOutput,proto3,oneof" json:"dao_output,omitempty"`
}
type Action_DaoDeposit struct {
	DaoDeposit *v1alpha14.DaoDeposit `protobuf:"bytes,52,opt,name=dao_deposit,json=daoDeposit,proto3,oneof" json:"dao_deposit,omitempty"`
}
type Action_Ics20Withdrawal struct {
	Ics20Withdrawal *v1alpha13.Ics20Withdrawal `protobuf:"bytes,200,opt,name=ics20_withdrawal,json=ics20Withdrawal,proto3,oneof" json:"ics20_withdrawal,omitempty"`
}

func (*Action_Spend) isAction_Action()                {}
func (*Action_Output) isAction_Action()               {}
func (*Action_Swap) isAction_Action()                 {}
func (*Action_SwapClaim) isAction_Action()            {}
func (*Action_ValidatorDefinition) isAction_Action()  {}
func (*Action_IbcAction) isAction_Action()            {}
func (*Action_ProposalSubmit) isAction_Action()       {}
func (*Action_ProposalWithdraw) isAction_Action()     {}
func (*Action_ValidatorVote) isAction_Action()        {}
func (*Action_DelegatorVote) isAction_Action()        {}
func (*Action_ProposalDepositClaim) isAction_Action() {}
func (*Action_PositionOpen) isAction_Action()         {}
func (*Action_PositionClose) isAction_Action()        {}
func (*Action_PositionWithdraw) isAction_Action()     {}
func (*Action_PositionRewardClaim) isAction_Action()  {}
func (*Action_Delegate) isAction_Action()             {}
func (*Action_Undelegate) isAction_Action()           {}
func (*Action_UndelegateClaim) isAction_Action()      {}
func (*Action_DaoSpend) isAction_Action()             {}
func (*Action_DaoOutput) isAction_Action()            {}
func (*Action_DaoDeposit) isAction_Action()           {}
func (*Action_Ics20Withdrawal) isAction_Action()      {}

func (m *Action) GetAction() isAction_Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *Action) GetSpend() *Spend {
	if x, ok := m.GetAction().(*Action_Spend); ok {
		return x.Spend
	}
	return nil
}

func (m *Action) GetOutput() *Output {
	if x, ok := m.GetAction().(*Action_Output); ok {
		return x.Output
	}
	return nil
}

func (m *Action) GetSwap() *v1alpha11.Swap {
	if x, ok := m.GetAction().(*Action_Swap); ok {
		return x.Swap
	}
	return nil
}

func (m *Action) GetSwapClaim() *v1alpha11.SwapClaim {
	if x, ok := m.GetAction().(*Action_SwapClaim); ok {
		return x.SwapClaim
	}
	return nil
}

func (m *Action) GetValidatorDefinition() *v1alpha12.ValidatorDefinition {
	if x, ok := m.GetAction().(*Action_ValidatorDefinition); ok {
		return x.ValidatorDefinition
	}
	return nil
}

func (m *Action) GetIbcAction() *v1alpha13.IbcAction {
	if x, ok := m.GetAction().(*Action_IbcAction); ok {
		return x.IbcAction
	}
	return nil
}

func (m *Action) GetProposalSubmit() *v1alpha14.ProposalSubmit {
	if x, ok := m.GetAction().(*Action_ProposalSubmit); ok {
		return x.ProposalSubmit
	}
	return nil
}

func (m *Action) GetProposalWithdraw() *v1alpha14.ProposalWithdraw {
	if x, ok := m.GetAction().(*Action_ProposalWithdraw); ok {
		return x.ProposalWithdraw
	}
	return nil
}

func (m *Action) GetValidatorVote() *v1alpha14.ValidatorVote {
	if x, ok := m.GetAction().(*Action_ValidatorVote); ok {
		return x.ValidatorVote
	}
	return nil
}

func (m *Action) GetDelegatorVote() *v1alpha14.DelegatorVote {
	if x, ok := m.GetAction().(*Action_DelegatorVote); ok {
		return x.DelegatorVote
	}
	return nil
}

func (m *Action) GetProposalDepositClaim() *v1alpha14.ProposalDepositClaim {
	if x, ok := m.GetAction().(*Action_ProposalDepositClaim); ok {
		return x.ProposalDepositClaim
	}
	return nil
}

func (m *Action) GetPositionOpen() *v1alpha11.PositionOpen {
	if x, ok := m.GetAction().(*Action_PositionOpen); ok {
		return x.PositionOpen
	}
	return nil
}

func (m *Action) GetPositionClose() *v1alpha11.PositionClose {
	if x, ok := m.GetAction().(*Action_PositionClose); ok {
		return x.PositionClose
	}
	return nil
}

func (m *Action) GetPositionWithdraw() *v1alpha11.PositionWithdraw {
	if x, ok := m.GetAction().(*Action_PositionWithdraw); ok {
		return x.PositionWithdraw
	}
	return nil
}

func (m *Action) GetPositionRewardClaim() *v1alpha11.PositionRewardClaim {
	if x, ok := m.GetAction().(*Action_PositionRewardClaim); ok {
		return x.PositionRewardClaim
	}
	return nil
}

func (m *Action) GetDelegate() *v1alpha12.Delegate {
	if x, ok := m.GetAction().(*Action_Delegate); ok {
		return x.Delegate
	}
	return nil
}

func (m *Action) GetUndelegate() *v1alpha12.Undelegate {
	if x, ok := m.GetAction().(*Action_Undelegate); ok {
		return x.Undelegate
	}
	return nil
}

func (m *Action) GetUndelegateClaim() *v1alpha12.UndelegateClaim {
	if x, ok := m.GetAction().(*Action_UndelegateClaim); ok {
		return x.UndelegateClaim
	}
	return nil
}

func (m *Action) GetDaoSpend() *v1alpha14.DaoSpend {
	if x, ok := m.GetAction().(*Action_DaoSpend); ok {
		return x.DaoSpend
	}
	return nil
}

func (m *Action) GetDaoOutput() *v1alpha14.DaoOutput {
	if x, ok := m.GetAction().(*Action_DaoOutput); ok {
		return x.DaoOutput
	}
	return nil
}

func (m *Action) GetDaoDeposit() *v1alpha14.DaoDeposit {
	if x, ok := m.GetAction().(*Action_DaoDeposit); ok {
		return x.DaoDeposit
	}
	return nil
}

func (m *Action) GetIcs20Withdrawal() *v1alpha13.Ics20Withdrawal {
	if x, ok := m.GetAction().(*Action_Ics20Withdrawal); ok {
		return x.Ics20Withdrawal
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Action) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Action_Spend)(nil),
		(*Action_Output)(nil),
		(*Action_Swap)(nil),
		(*Action_SwapClaim)(nil),
		(*Action_ValidatorDefinition)(nil),
		(*Action_IbcAction)(nil),
		(*Action_ProposalSubmit)(nil),
		(*Action_ProposalWithdraw)(nil),
		(*Action_ValidatorVote)(nil),
		(*Action_DelegatorVote)(nil),
		(*Action_ProposalDepositClaim)(nil),
		(*Action_PositionOpen)(nil),
		(*Action_PositionClose)(nil),
		(*Action_PositionWithdraw)(nil),
		(*Action_PositionRewardClaim)(nil),
		(*Action_Delegate)(nil),
		(*Action_Undelegate)(nil),
		(*Action_UndelegateClaim)(nil),
		(*Action_DaoSpend)(nil),
		(*Action_DaoOutput)(nil),
		(*Action_DaoDeposit)(nil),
		(*Action_Ics20Withdrawal)(nil),
	}
}

// A transaction perspective is a bundle of key material and commitment openings
// that allow generating a view of a transaction from that perspective.
type TransactionPerspective struct {
	PayloadKeys     []*PayloadKeyWithCommitment `protobuf:"bytes,1,rep,name=payload_keys,json=payloadKeys,proto3" json:"payload_keys,omitempty"`
	SpendNullifiers []*NullifierWithNote        `protobuf:"bytes,2,rep,name=spend_nullifiers,json=spendNullifiers,proto3" json:"spend_nullifiers,omitempty"`
	// The openings of note commitments referred to in the transaction
	// but not included in the transaction.
	AdviceNotes []*v1alpha1.Note `protobuf:"bytes,3,rep,name=advice_notes,json=adviceNotes,proto3" json:"advice_notes,omitempty"`
	// Any relevant address views.
	AddressViews []*v1alpha1.AddressView `protobuf:"bytes,4,rep,name=address_views,json=addressViews,proto3" json:"address_views,omitempty"`
	// Any relevant denoms for viewed assets.
	Denoms []*v1alpha1.DenomMetadata `protobuf:"bytes,5,rep,name=denoms,proto3" json:"denoms,omitempty"`
	// The transaction ID associated with this TransactionPerspective
	TransactionId *Id `protobuf:"bytes,6,opt,name=transaction_id,json=transactionId,proto3" json:"transaction_id,omitempty"`
}

func (m *TransactionPerspective) Reset()         { *m = TransactionPerspective{} }
func (m *TransactionPerspective) String() string { return proto.CompactTextString(m) }
func (*TransactionPerspective) ProtoMessage()    {}
func (*TransactionPerspective) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{8}
}
func (m *TransactionPerspective) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactionPerspective) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransactionPerspective.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransactionPerspective) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionPerspective.Merge(m, src)
}
func (m *TransactionPerspective) XXX_Size() int {
	return m.Size()
}
func (m *TransactionPerspective) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionPerspective.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionPerspective proto.InternalMessageInfo

func (m *TransactionPerspective) GetPayloadKeys() []*PayloadKeyWithCommitment {
	if m != nil {
		return m.PayloadKeys
	}
	return nil
}

func (m *TransactionPerspective) GetSpendNullifiers() []*NullifierWithNote {
	if m != nil {
		return m.SpendNullifiers
	}
	return nil
}

func (m *TransactionPerspective) GetAdviceNotes() []*v1alpha1.Note {
	if m != nil {
		return m.AdviceNotes
	}
	return nil
}

func (m *TransactionPerspective) GetAddressViews() []*v1alpha1.AddressView {
	if m != nil {
		return m.AddressViews
	}
	return nil
}

func (m *TransactionPerspective) GetDenoms() []*v1alpha1.DenomMetadata {
	if m != nil {
		return m.Denoms
	}
	return nil
}

func (m *TransactionPerspective) GetTransactionId() *Id {
	if m != nil {
		return m.TransactionId
	}
	return nil
}

type PayloadKey struct {
	Inner []byte `protobuf:"bytes,1,opt,name=inner,proto3" json:"inner,omitempty"`
}

func (m *PayloadKey) Reset()         { *m = PayloadKey{} }
func (m *PayloadKey) String() string { return proto.CompactTextString(m) }
func (*PayloadKey) ProtoMessage()    {}
func (*PayloadKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{9}
}
func (m *PayloadKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PayloadKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PayloadKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PayloadKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PayloadKey.Merge(m, src)
}
func (m *PayloadKey) XXX_Size() int {
	return m.Size()
}
func (m *PayloadKey) XXX_DiscardUnknown() {
	xxx_messageInfo_PayloadKey.DiscardUnknown(m)
}

var xxx_messageInfo_PayloadKey proto.InternalMessageInfo

func (m *PayloadKey) GetInner() []byte {
	if m != nil {
		return m.Inner
	}
	return nil
}

type PayloadKeyWithCommitment struct {
	PayloadKey *PayloadKey               `protobuf:"bytes,1,opt,name=payload_key,json=payloadKey,proto3" json:"payload_key,omitempty"`
	Commitment *v1alpha1.StateCommitment `protobuf:"bytes,2,opt,name=commitment,proto3" json:"commitment,omitempty"`
}

func (m *PayloadKeyWithCommitment) Reset()         { *m = PayloadKeyWithCommitment{} }
func (m *PayloadKeyWithCommitment) String() string { return proto.CompactTextString(m) }
func (*PayloadKeyWithCommitment) ProtoMessage()    {}
func (*PayloadKeyWithCommitment) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{10}
}
func (m *PayloadKeyWithCommitment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PayloadKeyWithCommitment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PayloadKeyWithCommitment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PayloadKeyWithCommitment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PayloadKeyWithCommitment.Merge(m, src)
}
func (m *PayloadKeyWithCommitment) XXX_Size() int {
	return m.Size()
}
func (m *PayloadKeyWithCommitment) XXX_DiscardUnknown() {
	xxx_messageInfo_PayloadKeyWithCommitment.DiscardUnknown(m)
}

var xxx_messageInfo_PayloadKeyWithCommitment proto.InternalMessageInfo

func (m *PayloadKeyWithCommitment) GetPayloadKey() *PayloadKey {
	if m != nil {
		return m.PayloadKey
	}
	return nil
}

func (m *PayloadKeyWithCommitment) GetCommitment() *v1alpha1.StateCommitment {
	if m != nil {
		return m.Commitment
	}
	return nil
}

type NullifierWithNote struct {
	Nullifier *v1alpha1.Nullifier `protobuf:"bytes,1,opt,name=nullifier,proto3" json:"nullifier,omitempty"`
	Note      *v1alpha1.Note      `protobuf:"bytes,2,opt,name=note,proto3" json:"note,omitempty"`
}

func (m *NullifierWithNote) Reset()         { *m = NullifierWithNote{} }
func (m *NullifierWithNote) String() string { return proto.CompactTextString(m) }
func (*NullifierWithNote) ProtoMessage()    {}
func (*NullifierWithNote) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{11}
}
func (m *NullifierWithNote) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NullifierWithNote) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NullifierWithNote.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NullifierWithNote) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NullifierWithNote.Merge(m, src)
}
func (m *NullifierWithNote) XXX_Size() int {
	return m.Size()
}
func (m *NullifierWithNote) XXX_DiscardUnknown() {
	xxx_messageInfo_NullifierWithNote.DiscardUnknown(m)
}

var xxx_messageInfo_NullifierWithNote proto.InternalMessageInfo

func (m *NullifierWithNote) GetNullifier() *v1alpha1.Nullifier {
	if m != nil {
		return m.Nullifier
	}
	return nil
}

func (m *NullifierWithNote) GetNote() *v1alpha1.Note {
	if m != nil {
		return m.Note
	}
	return nil
}

// View of a Penumbra transaction.
type TransactionView struct {
	// View of the transaction body
	BodyView *TransactionBodyView `protobuf:"bytes,1,opt,name=body_view,json=bodyView,proto3" json:"body_view,omitempty"`
	// The binding signature is stored separately from the transaction body that it signs.
	BindingSig []byte `protobuf:"bytes,2,opt,name=binding_sig,json=bindingSig,proto3" json:"binding_sig,omitempty"`
	// The root of some previous state of the state commitment tree, used as an anchor for all
	// ZK state transition proofs.
	Anchor *v1alpha1.MerkleRoot `protobuf:"bytes,3,opt,name=anchor,proto3" json:"anchor,omitempty"`
}

func (m *TransactionView) Reset()         { *m = TransactionView{} }
func (m *TransactionView) String() string { return proto.CompactTextString(m) }
func (*TransactionView) ProtoMessage()    {}
func (*TransactionView) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{12}
}
func (m *TransactionView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactionView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransactionView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransactionView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionView.Merge(m, src)
}
func (m *TransactionView) XXX_Size() int {
	return m.Size()
}
func (m *TransactionView) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionView.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionView proto.InternalMessageInfo

func (m *TransactionView) GetBodyView() *TransactionBodyView {
	if m != nil {
		return m.BodyView
	}
	return nil
}

func (m *TransactionView) GetBindingSig() []byte {
	if m != nil {
		return m.BindingSig
	}
	return nil
}

func (m *TransactionView) GetAnchor() *v1alpha1.MerkleRoot {
	if m != nil {
		return m.Anchor
	}
	return nil
}

type TransactionBodyView struct {
	// A list views into of actions (state changes) performed by this transaction.
	ActionViews []*ActionView `protobuf:"bytes,1,rep,name=action_views,json=actionViews,proto3" json:"action_views,omitempty"`
	// Transaction parameters.
	TransactionParameters *TransactionParameters `protobuf:"bytes,2,opt,name=transaction_parameters,json=transactionParameters,proto3" json:"transaction_parameters,omitempty"`
	// The transaction fee.
	Fee *v1alpha1.Fee `protobuf:"bytes,3,opt,name=fee,proto3" json:"fee,omitempty"`
	// Types that are valid to be assigned to XDetectionData:
	//
	//	*TransactionBodyView_DetectionData
	XDetectionData isTransactionBodyView_XDetectionData `protobuf_oneof:"_detection_data"`
	// Types that are valid to be assigned to XMemoView:
	//
	//	*TransactionBodyView_MemoView
	XMemoView isTransactionBodyView_XMemoView `protobuf_oneof:"_memo_view"`
}

func (m *TransactionBodyView) Reset()         { *m = TransactionBodyView{} }
func (m *TransactionBodyView) String() string { return proto.CompactTextString(m) }
func (*TransactionBodyView) ProtoMessage()    {}
func (*TransactionBodyView) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{13}
}
func (m *TransactionBodyView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactionBodyView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransactionBodyView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransactionBodyView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionBodyView.Merge(m, src)
}
func (m *TransactionBodyView) XXX_Size() int {
	return m.Size()
}
func (m *TransactionBodyView) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionBodyView.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionBodyView proto.InternalMessageInfo

type isTransactionBodyView_XDetectionData interface {
	isTransactionBodyView_XDetectionData()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isTransactionBodyView_XMemoView interface {
	isTransactionBodyView_XMemoView()
	MarshalTo([]byte) (int, error)
	Size() int
}

type TransactionBodyView_DetectionData struct {
	DetectionData *DetectionData `protobuf:"bytes,4,opt,name=detection_data,json=detectionData,proto3,oneof" json:"detection_data,omitempty"`
}
type TransactionBodyView_MemoView struct {
	MemoView *MemoView `protobuf:"bytes,5,opt,name=memo_view,json=memoView,proto3,oneof" json:"memo_view,omitempty"`
}

func (*TransactionBodyView_DetectionData) isTransactionBodyView_XDetectionData() {}
func (*TransactionBodyView_MemoView) isTransactionBodyView_XMemoView()           {}

func (m *TransactionBodyView) GetXDetectionData() isTransactionBodyView_XDetectionData {
	if m != nil {
		return m.XDetectionData
	}
	return nil
}
func (m *TransactionBodyView) GetXMemoView() isTransactionBodyView_XMemoView {
	if m != nil {
		return m.XMemoView
	}
	return nil
}

func (m *TransactionBodyView) GetActionViews() []*ActionView {
	if m != nil {
		return m.ActionViews
	}
	return nil
}

func (m *TransactionBodyView) GetTransactionParameters() *TransactionParameters {
	if m != nil {
		return m.TransactionParameters
	}
	return nil
}

func (m *TransactionBodyView) GetFee() *v1alpha1.Fee {
	if m != nil {
		return m.Fee
	}
	return nil
}

func (m *TransactionBodyView) GetDetectionData() *DetectionData {
	if x, ok := m.GetXDetectionData().(*TransactionBodyView_DetectionData); ok {
		return x.DetectionData
	}
	return nil
}

func (m *TransactionBodyView) GetMemoView() *MemoView {
	if x, ok := m.GetXMemoView().(*TransactionBodyView_MemoView); ok {
		return x.MemoView
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TransactionBodyView) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TransactionBodyView_DetectionData)(nil),
		(*TransactionBodyView_MemoView)(nil),
	}
}

// A view of a specific state change action performed by a transaction.
type ActionView struct {
	// Types that are valid to be assigned to ActionView:
	//
	//	*ActionView_Spend
	//	*ActionView_Output
	//	*ActionView_Swap
	//	*ActionView_SwapClaim
	//	*ActionView_ValidatorDefinition
	//	*ActionView_IbcAction
	//	*ActionView_ProposalSubmit
	//	*ActionView_ProposalWithdraw
	//	*ActionView_ValidatorVote
	//	*ActionView_DelegatorVote
	//	*ActionView_ProposalDepositClaim
	//	*ActionView_PositionOpen
	//	*ActionView_PositionClose
	//	*ActionView_PositionWithdraw
	//	*ActionView_PositionRewardClaim
	//	*ActionView_Delegate
	//	*ActionView_Undelegate
	//	*ActionView_DaoSpend
	//	*ActionView_DaoOutput
	//	*ActionView_DaoDeposit
	//	*ActionView_UndelegateClaim
	//	*ActionView_Ics20Withdrawal
	ActionView isActionView_ActionView `protobuf_oneof:"action_view"`
}

func (m *ActionView) Reset()         { *m = ActionView{} }
func (m *ActionView) String() string { return proto.CompactTextString(m) }
func (*ActionView) ProtoMessage()    {}
func (*ActionView) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{14}
}
func (m *ActionView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionView.Merge(m, src)
}
func (m *ActionView) XXX_Size() int {
	return m.Size()
}
func (m *ActionView) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionView.DiscardUnknown(m)
}

var xxx_messageInfo_ActionView proto.InternalMessageInfo

type isActionView_ActionView interface {
	isActionView_ActionView()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ActionView_Spend struct {
	Spend *SpendView `protobuf:"bytes,1,opt,name=spend,proto3,oneof" json:"spend,omitempty"`
}
type ActionView_Output struct {
	Output *OutputView `protobuf:"bytes,2,opt,name=output,proto3,oneof" json:"output,omitempty"`
}
type ActionView_Swap struct {
	Swap *v1alpha11.SwapView `protobuf:"bytes,3,opt,name=swap,proto3,oneof" json:"swap,omitempty"`
}
type ActionView_SwapClaim struct {
	SwapClaim *v1alpha11.SwapClaimView `protobuf:"bytes,4,opt,name=swap_claim,json=swapClaim,proto3,oneof" json:"swap_claim,omitempty"`
}
type ActionView_ValidatorDefinition struct {
	ValidatorDefinition *v1alpha12.ValidatorDefinition `protobuf:"bytes,16,opt,name=validator_definition,json=validatorDefinition,proto3,oneof" json:"validator_definition,omitempty"`
}
type ActionView_IbcAction struct {
	IbcAction *v1alpha13.IbcAction `protobuf:"bytes,17,opt,name=ibc_action,json=ibcAction,proto3,oneof" json:"ibc_action,omitempty"`
}
type ActionView_ProposalSubmit struct {
	ProposalSubmit *v1alpha14.ProposalSubmit `protobuf:"bytes,18,opt,name=proposal_submit,json=proposalSubmit,proto3,oneof" json:"proposal_submit,omitempty"`
}
type ActionView_ProposalWithdraw struct {
	ProposalWithdraw *v1alpha14.ProposalWithdraw `protobuf:"bytes,19,opt,name=proposal_withdraw,json=proposalWithdraw,proto3,oneof" json:"proposal_withdraw,omitempty"`
}
type ActionView_ValidatorVote struct {
	ValidatorVote *v1alpha14.ValidatorVote `protobuf:"bytes,20,opt,name=validator_vote,json=validatorVote,proto3,oneof" json:"validator_vote,omitempty"`
}
type ActionView_DelegatorVote struct {
	DelegatorVote *DelegatorVoteView `protobuf:"bytes,21,opt,name=delegator_vote,json=delegatorVote,proto3,oneof" json:"delegator_vote,omitempty"`
}
type ActionView_ProposalDepositClaim struct {
	ProposalDepositClaim *v1alpha14.ProposalDepositClaim `protobuf:"bytes,22,opt,name=proposal_deposit_claim,json=proposalDepositClaim,proto3,oneof" json:"proposal_deposit_claim,omitempty"`
}
type ActionView_PositionOpen struct {
	PositionOpen *v1alpha11.PositionOpen `protobuf:"bytes,30,opt,name=position_open,json=positionOpen,proto3,oneof" json:"position_open,omitempty"`
}
type ActionView_PositionClose struct {
	PositionClose *v1alpha11.PositionClose `protobuf:"bytes,31,opt,name=position_close,json=positionClose,proto3,oneof" json:"position_close,omitempty"`
}
type ActionView_PositionWithdraw struct {
	PositionWithdraw *v1alpha11.PositionWithdraw `protobuf:"bytes,32,opt,name=position_withdraw,json=positionWithdraw,proto3,oneof" json:"position_withdraw,omitempty"`
}
type ActionView_PositionRewardClaim struct {
	PositionRewardClaim *v1alpha11.PositionRewardClaim `protobuf:"bytes,34,opt,name=position_reward_claim,json=positionRewardClaim,proto3,oneof" json:"position_reward_claim,omitempty"`
}
type ActionView_Delegate struct {
	Delegate *v1alpha12.Delegate `protobuf:"bytes,41,opt,name=delegate,proto3,oneof" json:"delegate,omitempty"`
}
type ActionView_Undelegate struct {
	Undelegate *v1alpha12.Undelegate `protobuf:"bytes,42,opt,name=undelegate,proto3,oneof" json:"undelegate,omitempty"`
}
type ActionView_DaoSpend struct {
	DaoSpend *v1alpha14.DaoSpend `protobuf:"bytes,50,opt,name=dao_spend,json=daoSpend,proto3,oneof" json:"dao_spend,omitempty"`
}
type ActionView_DaoOutput struct {
	DaoOutput *v1alpha14.DaoOutput `protobuf:"bytes,51,opt,name=dao_output,json=daoOutput,proto3,oneof" json:"dao_output,omitempty"`
}
type ActionView_DaoDeposit struct {
	DaoDeposit *v1alpha14.DaoDeposit `protobuf:"bytes,52,opt,name=dao_deposit,json=daoDeposit,proto3,oneof" json:"dao_deposit,omitempty"`
}
type ActionView_UndelegateClaim struct {
	UndelegateClaim *v1alpha12.UndelegateClaim `protobuf:"bytes,43,opt,name=undelegate_claim,json=undelegateClaim,proto3,oneof" json:"undelegate_claim,omitempty"`
}
type ActionView_Ics20Withdrawal struct {
	Ics20Withdrawal *v1alpha13.Ics20Withdrawal `protobuf:"bytes,200,opt,name=ics20_withdrawal,json=ics20Withdrawal,proto3,oneof" json:"ics20_withdrawal,omitempty"`
}

func (*ActionView_Spend) isActionView_ActionView()                {}
func (*ActionView_Output) isActionView_ActionView()               {}
func (*ActionView_Swap) isActionView_ActionView()                 {}
func (*ActionView_SwapClaim) isActionView_ActionView()            {}
func (*ActionView_ValidatorDefinition) isActionView_ActionView()  {}
func (*ActionView_IbcAction) isActionView_ActionView()            {}
func (*ActionView_ProposalSubmit) isActionView_ActionView()       {}
func (*ActionView_ProposalWithdraw) isActionView_ActionView()     {}
func (*ActionView_ValidatorVote) isActionView_ActionView()        {}
func (*ActionView_DelegatorVote) isActionView_ActionView()        {}
func (*ActionView_ProposalDepositClaim) isActionView_ActionView() {}
func (*ActionView_PositionOpen) isActionView_ActionView()         {}
func (*ActionView_PositionClose) isActionView_ActionView()        {}
func (*ActionView_PositionWithdraw) isActionView_ActionView()     {}
func (*ActionView_PositionRewardClaim) isActionView_ActionView()  {}
func (*ActionView_Delegate) isActionView_ActionView()             {}
func (*ActionView_Undelegate) isActionView_ActionView()           {}
func (*ActionView_DaoSpend) isActionView_ActionView()             {}
func (*ActionView_DaoOutput) isActionView_ActionView()            {}
func (*ActionView_DaoDeposit) isActionView_ActionView()           {}
func (*ActionView_UndelegateClaim) isActionView_ActionView()      {}
func (*ActionView_Ics20Withdrawal) isActionView_ActionView()      {}

func (m *ActionView) GetActionView() isActionView_ActionView {
	if m != nil {
		return m.ActionView
	}
	return nil
}

func (m *ActionView) GetSpend() *SpendView {
	if x, ok := m.GetActionView().(*ActionView_Spend); ok {
		return x.Spend
	}
	return nil
}

func (m *ActionView) GetOutput() *OutputView {
	if x, ok := m.GetActionView().(*ActionView_Output); ok {
		return x.Output
	}
	return nil
}

func (m *ActionView) GetSwap() *v1alpha11.SwapView {
	if x, ok := m.GetActionView().(*ActionView_Swap); ok {
		return x.Swap
	}
	return nil
}

func (m *ActionView) GetSwapClaim() *v1alpha11.SwapClaimView {
	if x, ok := m.GetActionView().(*ActionView_SwapClaim); ok {
		return x.SwapClaim
	}
	return nil
}

func (m *ActionView) GetValidatorDefinition() *v1alpha12.ValidatorDefinition {
	if x, ok := m.GetActionView().(*ActionView_ValidatorDefinition); ok {
		return x.ValidatorDefinition
	}
	return nil
}

func (m *ActionView) GetIbcAction() *v1alpha13.IbcAction {
	if x, ok := m.GetActionView().(*ActionView_IbcAction); ok {
		return x.IbcAction
	}
	return nil
}

func (m *ActionView) GetProposalSubmit() *v1alpha14.ProposalSubmit {
	if x, ok := m.GetActionView().(*ActionView_ProposalSubmit); ok {
		return x.ProposalSubmit
	}
	return nil
}

func (m *ActionView) GetProposalWithdraw() *v1alpha14.ProposalWithdraw {
	if x, ok := m.GetActionView().(*ActionView_ProposalWithdraw); ok {
		return x.ProposalWithdraw
	}
	return nil
}

func (m *ActionView) GetValidatorVote() *v1alpha14.ValidatorVote {
	if x, ok := m.GetActionView().(*ActionView_ValidatorVote); ok {
		return x.ValidatorVote
	}
	return nil
}

func (m *ActionView) GetDelegatorVote() *DelegatorVoteView {
	if x, ok := m.GetActionView().(*ActionView_DelegatorVote); ok {
		return x.DelegatorVote
	}
	return nil
}

func (m *ActionView) GetProposalDepositClaim() *v1alpha14.ProposalDepositClaim {
	if x, ok := m.GetActionView().(*ActionView_ProposalDepositClaim); ok {
		return x.ProposalDepositClaim
	}
	return nil
}

func (m *ActionView) GetPositionOpen() *v1alpha11.PositionOpen {
	if x, ok := m.GetActionView().(*ActionView_PositionOpen); ok {
		return x.PositionOpen
	}
	return nil
}

func (m *ActionView) GetPositionClose() *v1alpha11.PositionClose {
	if x, ok := m.GetActionView().(*ActionView_PositionClose); ok {
		return x.PositionClose
	}
	return nil
}

func (m *ActionView) GetPositionWithdraw() *v1alpha11.PositionWithdraw {
	if x, ok := m.GetActionView().(*ActionView_PositionWithdraw); ok {
		return x.PositionWithdraw
	}
	return nil
}

func (m *ActionView) GetPositionRewardClaim() *v1alpha11.PositionRewardClaim {
	if x, ok := m.GetActionView().(*ActionView_PositionRewardClaim); ok {
		return x.PositionRewardClaim
	}
	return nil
}

func (m *ActionView) GetDelegate() *v1alpha12.Delegate {
	if x, ok := m.GetActionView().(*ActionView_Delegate); ok {
		return x.Delegate
	}
	return nil
}

func (m *ActionView) GetUndelegate() *v1alpha12.Undelegate {
	if x, ok := m.GetActionView().(*ActionView_Undelegate); ok {
		return x.Undelegate
	}
	return nil
}

func (m *ActionView) GetDaoSpend() *v1alpha14.DaoSpend {
	if x, ok := m.GetActionView().(*ActionView_DaoSpend); ok {
		return x.DaoSpend
	}
	return nil
}

func (m *ActionView) GetDaoOutput() *v1alpha14.DaoOutput {
	if x, ok := m.GetActionView().(*ActionView_DaoOutput); ok {
		return x.DaoOutput
	}
	return nil
}

func (m *ActionView) GetDaoDeposit() *v1alpha14.DaoDeposit {
	if x, ok := m.GetActionView().(*ActionView_DaoDeposit); ok {
		return x.DaoDeposit
	}
	return nil
}

func (m *ActionView) GetUndelegateClaim() *v1alpha12.UndelegateClaim {
	if x, ok := m.GetActionView().(*ActionView_UndelegateClaim); ok {
		return x.UndelegateClaim
	}
	return nil
}

func (m *ActionView) GetIcs20Withdrawal() *v1alpha13.Ics20Withdrawal {
	if x, ok := m.GetActionView().(*ActionView_Ics20Withdrawal); ok {
		return x.Ics20Withdrawal
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ActionView) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ActionView_Spend)(nil),
		(*ActionView_Output)(nil),
		(*ActionView_Swap)(nil),
		(*ActionView_SwapClaim)(nil),
		(*ActionView_ValidatorDefinition)(nil),
		(*ActionView_IbcAction)(nil),
		(*ActionView_ProposalSubmit)(nil),
		(*ActionView_ProposalWithdraw)(nil),
		(*ActionView_ValidatorVote)(nil),
		(*ActionView_DelegatorVote)(nil),
		(*ActionView_ProposalDepositClaim)(nil),
		(*ActionView_PositionOpen)(nil),
		(*ActionView_PositionClose)(nil),
		(*ActionView_PositionWithdraw)(nil),
		(*ActionView_PositionRewardClaim)(nil),
		(*ActionView_Delegate)(nil),
		(*ActionView_Undelegate)(nil),
		(*ActionView_DaoSpend)(nil),
		(*ActionView_DaoOutput)(nil),
		(*ActionView_DaoDeposit)(nil),
		(*ActionView_UndelegateClaim)(nil),
		(*ActionView_Ics20Withdrawal)(nil),
	}
}

type SpendView struct {
	// Types that are valid to be assigned to SpendView:
	//
	//	*SpendView_Visible_
	//	*SpendView_Opaque_
	SpendView isSpendView_SpendView `protobuf_oneof:"spend_view"`
}

func (m *SpendView) Reset()         { *m = SpendView{} }
func (m *SpendView) String() string { return proto.CompactTextString(m) }
func (*SpendView) ProtoMessage()    {}
func (*SpendView) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{15}
}
func (m *SpendView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpendView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpendView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpendView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpendView.Merge(m, src)
}
func (m *SpendView) XXX_Size() int {
	return m.Size()
}
func (m *SpendView) XXX_DiscardUnknown() {
	xxx_messageInfo_SpendView.DiscardUnknown(m)
}

var xxx_messageInfo_SpendView proto.InternalMessageInfo

type isSpendView_SpendView interface {
	isSpendView_SpendView()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SpendView_Visible_ struct {
	Visible *SpendView_Visible `protobuf:"bytes,1,opt,name=visible,proto3,oneof" json:"visible,omitempty"`
}
type SpendView_Opaque_ struct {
	Opaque *SpendView_Opaque `protobuf:"bytes,2,opt,name=opaque,proto3,oneof" json:"opaque,omitempty"`
}

func (*SpendView_Visible_) isSpendView_SpendView() {}
func (*SpendView_Opaque_) isSpendView_SpendView()  {}

func (m *SpendView) GetSpendView() isSpendView_SpendView {
	if m != nil {
		return m.SpendView
	}
	return nil
}

func (m *SpendView) GetVisible() *SpendView_Visible {
	if x, ok := m.GetSpendView().(*SpendView_Visible_); ok {
		return x.Visible
	}
	return nil
}

func (m *SpendView) GetOpaque() *SpendView_Opaque {
	if x, ok := m.GetSpendView().(*SpendView_Opaque_); ok {
		return x.Opaque
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SpendView) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SpendView_Visible_)(nil),
		(*SpendView_Opaque_)(nil),
	}
}

type SpendView_Visible struct {
	Spend *Spend             `protobuf:"bytes,1,opt,name=spend,proto3" json:"spend,omitempty"`
	Note  *v1alpha1.NoteView `protobuf:"bytes,2,opt,name=note,proto3" json:"note,omitempty"`
}

func (m *SpendView_Visible) Reset()         { *m = SpendView_Visible{} }
func (m *SpendView_Visible) String() string { return proto.CompactTextString(m) }
func (*SpendView_Visible) ProtoMessage()    {}
func (*SpendView_Visible) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{15, 0}
}
func (m *SpendView_Visible) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpendView_Visible) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpendView_Visible.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpendView_Visible) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpendView_Visible.Merge(m, src)
}
func (m *SpendView_Visible) XXX_Size() int {
	return m.Size()
}
func (m *SpendView_Visible) XXX_DiscardUnknown() {
	xxx_messageInfo_SpendView_Visible.DiscardUnknown(m)
}

var xxx_messageInfo_SpendView_Visible proto.InternalMessageInfo

func (m *SpendView_Visible) GetSpend() *Spend {
	if m != nil {
		return m.Spend
	}
	return nil
}

func (m *SpendView_Visible) GetNote() *v1alpha1.NoteView {
	if m != nil {
		return m.Note
	}
	return nil
}

type SpendView_Opaque struct {
	Spend *Spend `protobuf:"bytes,1,opt,name=spend,proto3" json:"spend,omitempty"`
}

func (m *SpendView_Opaque) Reset()         { *m = SpendView_Opaque{} }
func (m *SpendView_Opaque) String() string { return proto.CompactTextString(m) }
func (*SpendView_Opaque) ProtoMessage()    {}
func (*SpendView_Opaque) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{15, 1}
}
func (m *SpendView_Opaque) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpendView_Opaque) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpendView_Opaque.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpendView_Opaque) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpendView_Opaque.Merge(m, src)
}
func (m *SpendView_Opaque) XXX_Size() int {
	return m.Size()
}
func (m *SpendView_Opaque) XXX_DiscardUnknown() {
	xxx_messageInfo_SpendView_Opaque.DiscardUnknown(m)
}

var xxx_messageInfo_SpendView_Opaque proto.InternalMessageInfo

func (m *SpendView_Opaque) GetSpend() *Spend {
	if m != nil {
		return m.Spend
	}
	return nil
}

type DelegatorVoteView struct {
	// Types that are valid to be assigned to DelegatorVote:
	//
	//	*DelegatorVoteView_Visible_
	//	*DelegatorVoteView_Opaque_
	DelegatorVote isDelegatorVoteView_DelegatorVote `protobuf_oneof:"delegator_vote"`
}

func (m *DelegatorVoteView) Reset()         { *m = DelegatorVoteView{} }
func (m *DelegatorVoteView) String() string { return proto.CompactTextString(m) }
func (*DelegatorVoteView) ProtoMessage()    {}
func (*DelegatorVoteView) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{16}
}
func (m *DelegatorVoteView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelegatorVoteView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelegatorVoteView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelegatorVoteView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelegatorVoteView.Merge(m, src)
}
func (m *DelegatorVoteView) XXX_Size() int {
	return m.Size()
}
func (m *DelegatorVoteView) XXX_DiscardUnknown() {
	xxx_messageInfo_DelegatorVoteView.DiscardUnknown(m)
}

var xxx_messageInfo_DelegatorVoteView proto.InternalMessageInfo

type isDelegatorVoteView_DelegatorVote interface {
	isDelegatorVoteView_DelegatorVote()
	MarshalTo([]byte) (int, error)
	Size() int
}

type DelegatorVoteView_Visible_ struct {
	Visible *DelegatorVoteView_Visible `protobuf:"bytes,1,opt,name=visible,proto3,oneof" json:"visible,omitempty"`
}
type DelegatorVoteView_Opaque_ struct {
	Opaque *DelegatorVoteView_Opaque `protobuf:"bytes,2,opt,name=opaque,proto3,oneof" json:"opaque,omitempty"`
}

func (*DelegatorVoteView_Visible_) isDelegatorVoteView_DelegatorVote() {}
func (*DelegatorVoteView_Opaque_) isDelegatorVoteView_DelegatorVote()  {}

func (m *DelegatorVoteView) GetDelegatorVote() isDelegatorVoteView_DelegatorVote {
	if m != nil {
		return m.DelegatorVote
	}
	return nil
}

func (m *DelegatorVoteView) GetVisible() *DelegatorVoteView_Visible {
	if x, ok := m.GetDelegatorVote().(*DelegatorVoteView_Visible_); ok {
		return x.Visible
	}
	return nil
}

func (m *DelegatorVoteView) GetOpaque() *DelegatorVoteView_Opaque {
	if x, ok := m.GetDelegatorVote().(*DelegatorVoteView_Opaque_); ok {
		return x.Opaque
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DelegatorVoteView) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DelegatorVoteView_Visible_)(nil),
		(*DelegatorVoteView_Opaque_)(nil),
	}
}

type DelegatorVoteView_Visible struct {
	DelegatorVote *v1alpha14.DelegatorVote `protobuf:"bytes,1,opt,name=delegator_vote,json=delegatorVote,proto3" json:"delegator_vote,omitempty"`
	Note          *v1alpha1.NoteView       `protobuf:"bytes,2,opt,name=note,proto3" json:"note,omitempty"`
}

func (m *DelegatorVoteView_Visible) Reset()         { *m = DelegatorVoteView_Visible{} }
func (m *DelegatorVoteView_Visible) String() string { return proto.CompactTextString(m) }
func (*DelegatorVoteView_Visible) ProtoMessage()    {}
func (*DelegatorVoteView_Visible) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{16, 0}
}
func (m *DelegatorVoteView_Visible) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelegatorVoteView_Visible) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelegatorVoteView_Visible.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelegatorVoteView_Visible) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelegatorVoteView_Visible.Merge(m, src)
}
func (m *DelegatorVoteView_Visible) XXX_Size() int {
	return m.Size()
}
func (m *DelegatorVoteView_Visible) XXX_DiscardUnknown() {
	xxx_messageInfo_DelegatorVoteView_Visible.DiscardUnknown(m)
}

var xxx_messageInfo_DelegatorVoteView_Visible proto.InternalMessageInfo

func (m *DelegatorVoteView_Visible) GetDelegatorVote() *v1alpha14.DelegatorVote {
	if m != nil {
		return m.DelegatorVote
	}
	return nil
}

func (m *DelegatorVoteView_Visible) GetNote() *v1alpha1.NoteView {
	if m != nil {
		return m.Note
	}
	return nil
}

type DelegatorVoteView_Opaque struct {
	DelegatorVote *v1alpha14.DelegatorVote `protobuf:"bytes,1,opt,name=delegator_vote,json=delegatorVote,proto3" json:"delegator_vote,omitempty"`
}

func (m *DelegatorVoteView_Opaque) Reset()         { *m = DelegatorVoteView_Opaque{} }
func (m *DelegatorVoteView_Opaque) String() string { return proto.CompactTextString(m) }
func (*DelegatorVoteView_Opaque) ProtoMessage()    {}
func (*DelegatorVoteView_Opaque) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{16, 1}
}
func (m *DelegatorVoteView_Opaque) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelegatorVoteView_Opaque) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelegatorVoteView_Opaque.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelegatorVoteView_Opaque) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelegatorVoteView_Opaque.Merge(m, src)
}
func (m *DelegatorVoteView_Opaque) XXX_Size() int {
	return m.Size()
}
func (m *DelegatorVoteView_Opaque) XXX_DiscardUnknown() {
	xxx_messageInfo_DelegatorVoteView_Opaque.DiscardUnknown(m)
}

var xxx_messageInfo_DelegatorVoteView_Opaque proto.InternalMessageInfo

func (m *DelegatorVoteView_Opaque) GetDelegatorVote() *v1alpha14.DelegatorVote {
	if m != nil {
		return m.DelegatorVote
	}
	return nil
}

type OutputView struct {
	// Types that are valid to be assigned to OutputView:
	//
	//	*OutputView_Visible_
	//	*OutputView_Opaque_
	OutputView isOutputView_OutputView `protobuf_oneof:"output_view"`
}

func (m *OutputView) Reset()         { *m = OutputView{} }
func (m *OutputView) String() string { return proto.CompactTextString(m) }
func (*OutputView) ProtoMessage()    {}
func (*OutputView) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{17}
}
func (m *OutputView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OutputView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OutputView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OutputView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutputView.Merge(m, src)
}
func (m *OutputView) XXX_Size() int {
	return m.Size()
}
func (m *OutputView) XXX_DiscardUnknown() {
	xxx_messageInfo_OutputView.DiscardUnknown(m)
}

var xxx_messageInfo_OutputView proto.InternalMessageInfo

type isOutputView_OutputView interface {
	isOutputView_OutputView()
	MarshalTo([]byte) (int, error)
	Size() int
}

type OutputView_Visible_ struct {
	Visible *OutputView_Visible `protobuf:"bytes,1,opt,name=visible,proto3,oneof" json:"visible,omitempty"`
}
type OutputView_Opaque_ struct {
	Opaque *OutputView_Opaque `protobuf:"bytes,2,opt,name=opaque,proto3,oneof" json:"opaque,omitempty"`
}

func (*OutputView_Visible_) isOutputView_OutputView() {}
func (*OutputView_Opaque_) isOutputView_OutputView()  {}

func (m *OutputView) GetOutputView() isOutputView_OutputView {
	if m != nil {
		return m.OutputView
	}
	return nil
}

func (m *OutputView) GetVisible() *OutputView_Visible {
	if x, ok := m.GetOutputView().(*OutputView_Visible_); ok {
		return x.Visible
	}
	return nil
}

func (m *OutputView) GetOpaque() *OutputView_Opaque {
	if x, ok := m.GetOutputView().(*OutputView_Opaque_); ok {
		return x.Opaque
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*OutputView) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*OutputView_Visible_)(nil),
		(*OutputView_Opaque_)(nil),
	}
}

type OutputView_Visible struct {
	Output     *Output            `protobuf:"bytes,1,opt,name=output,proto3" json:"output,omitempty"`
	Note       *v1alpha1.NoteView `protobuf:"bytes,2,opt,name=note,proto3" json:"note,omitempty"`
	PayloadKey *PayloadKey        `protobuf:"bytes,3,opt,name=payload_key,json=payloadKey,proto3" json:"payload_key,omitempty"`
}

func (m *OutputView_Visible) Reset()         { *m = OutputView_Visible{} }
func (m *OutputView_Visible) String() string { return proto.CompactTextString(m) }
func (*OutputView_Visible) ProtoMessage()    {}
func (*OutputView_Visible) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{17, 0}
}
func (m *OutputView_Visible) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OutputView_Visible) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OutputView_Visible.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OutputView_Visible) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutputView_Visible.Merge(m, src)
}
func (m *OutputView_Visible) XXX_Size() int {
	return m.Size()
}
func (m *OutputView_Visible) XXX_DiscardUnknown() {
	xxx_messageInfo_OutputView_Visible.DiscardUnknown(m)
}

var xxx_messageInfo_OutputView_Visible proto.InternalMessageInfo

func (m *OutputView_Visible) GetOutput() *Output {
	if m != nil {
		return m.Output
	}
	return nil
}

func (m *OutputView_Visible) GetNote() *v1alpha1.NoteView {
	if m != nil {
		return m.Note
	}
	return nil
}

func (m *OutputView_Visible) GetPayloadKey() *PayloadKey {
	if m != nil {
		return m.PayloadKey
	}
	return nil
}

type OutputView_Opaque struct {
	Output *Output `protobuf:"bytes,1,opt,name=output,proto3" json:"output,omitempty"`
}

func (m *OutputView_Opaque) Reset()         { *m = OutputView_Opaque{} }
func (m *OutputView_Opaque) String() string { return proto.CompactTextString(m) }
func (*OutputView_Opaque) ProtoMessage()    {}
func (*OutputView_Opaque) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{17, 1}
}
func (m *OutputView_Opaque) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OutputView_Opaque) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OutputView_Opaque.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OutputView_Opaque) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutputView_Opaque.Merge(m, src)
}
func (m *OutputView_Opaque) XXX_Size() int {
	return m.Size()
}
func (m *OutputView_Opaque) XXX_DiscardUnknown() {
	xxx_messageInfo_OutputView_Opaque.DiscardUnknown(m)
}

var xxx_messageInfo_OutputView_Opaque proto.InternalMessageInfo

func (m *OutputView_Opaque) GetOutput() *Output {
	if m != nil {
		return m.Output
	}
	return nil
}

// Spends a shielded note.
type Spend struct {
	// The effecting data of the spend.
	Body *SpendBody `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// The authorizing signature for the spend.
	AuthSig *v1alpha1.SpendAuthSignature `protobuf:"bytes,2,opt,name=auth_sig,json=authSig,proto3" json:"auth_sig,omitempty"`
	// The proof that the spend is well-formed is authorizing data.
	Proof *v1alpha1.ZKSpendProof `protobuf:"bytes,3,opt,name=proof,proto3" json:"proof,omitempty"`
}

func (m *Spend) Reset()         { *m = Spend{} }
func (m *Spend) String() string { return proto.CompactTextString(m) }
func (*Spend) ProtoMessage()    {}
func (*Spend) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{18}
}
func (m *Spend) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Spend) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Spend.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Spend) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Spend.Merge(m, src)
}
func (m *Spend) XXX_Size() int {
	return m.Size()
}
func (m *Spend) XXX_DiscardUnknown() {
	xxx_messageInfo_Spend.DiscardUnknown(m)
}

var xxx_messageInfo_Spend proto.InternalMessageInfo

func (m *Spend) GetBody() *SpendBody {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *Spend) GetAuthSig() *v1alpha1.SpendAuthSignature {
	if m != nil {
		return m.AuthSig
	}
	return nil
}

func (m *Spend) GetProof() *v1alpha1.ZKSpendProof {
	if m != nil {
		return m.Proof
	}
	return nil
}

// The body of a spend description, containing only the effecting data
// describing changes to the ledger, and not the authorizing data that allows
// those changes to be performed.
type SpendBody struct {
	// A commitment to the value of the input note.
	BalanceCommitment *v1alpha1.BalanceCommitment `protobuf:"bytes,1,opt,name=balance_commitment,json=balanceCommitment,proto3" json:"balance_commitment,omitempty"`
	// The nullifier of the input note.
	Nullifier []byte `protobuf:"bytes,3,opt,name=nullifier,proto3" json:"nullifier,omitempty"`
	// The randomized validating key for the spend authorization signature.
	Rk []byte `protobuf:"bytes,4,opt,name=rk,proto3" json:"rk,omitempty"`
}

func (m *SpendBody) Reset()         { *m = SpendBody{} }
func (m *SpendBody) String() string { return proto.CompactTextString(m) }
func (*SpendBody) ProtoMessage()    {}
func (*SpendBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{19}
}
func (m *SpendBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpendBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpendBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpendBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpendBody.Merge(m, src)
}
func (m *SpendBody) XXX_Size() int {
	return m.Size()
}
func (m *SpendBody) XXX_DiscardUnknown() {
	xxx_messageInfo_SpendBody.DiscardUnknown(m)
}

var xxx_messageInfo_SpendBody proto.InternalMessageInfo

func (m *SpendBody) GetBalanceCommitment() *v1alpha1.BalanceCommitment {
	if m != nil {
		return m.BalanceCommitment
	}
	return nil
}

func (m *SpendBody) GetNullifier() []byte {
	if m != nil {
		return m.Nullifier
	}
	return nil
}

func (m *SpendBody) GetRk() []byte {
	if m != nil {
		return m.Rk
	}
	return nil
}

// Creates a new shielded note.
type Output struct {
	// The effecting data for the output.
	Body *OutputBody `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// The output proof is authorizing data.
	Proof *v1alpha1.ZKOutputProof `protobuf:"bytes,2,opt,name=proof,proto3" json:"proof,omitempty"`
}

func (m *Output) Reset()         { *m = Output{} }
func (m *Output) String() string { return proto.CompactTextString(m) }
func (*Output) ProtoMessage()    {}
func (*Output) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{20}
}
func (m *Output) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Output) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Output.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Output) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Output.Merge(m, src)
}
func (m *Output) XXX_Size() int {
	return m.Size()
}
func (m *Output) XXX_DiscardUnknown() {
	xxx_messageInfo_Output.DiscardUnknown(m)
}

var xxx_messageInfo_Output proto.InternalMessageInfo

func (m *Output) GetBody() *OutputBody {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *Output) GetProof() *v1alpha1.ZKOutputProof {
	if m != nil {
		return m.Proof
	}
	return nil
}

// The body of an output description, containing only the effecting data
// describing changes to the ledger, and not the authorizing data that allows
// those changes to be performed.
type OutputBody struct {
	// The minimal data required to scan and process the new output note.
	NotePayload *v1alpha1.NotePayload `protobuf:"bytes,1,opt,name=note_payload,json=notePayload,proto3" json:"note_payload,omitempty"`
	// A commitment to the value of the output note. 32 bytes.
	BalanceCommitment *v1alpha1.BalanceCommitment `protobuf:"bytes,2,opt,name=balance_commitment,json=balanceCommitment,proto3" json:"balance_commitment,omitempty"`
	// An encrypted key for decrypting the memo.
	WrappedMemoKey []byte `protobuf:"bytes,3,opt,name=wrapped_memo_key,json=wrappedMemoKey,proto3" json:"wrapped_memo_key,omitempty"`
	// The key material used for note encryption, wrapped in encryption to the
	// sender's outgoing viewing key. 80 bytes.
	OvkWrappedKey []byte `protobuf:"bytes,4,opt,name=ovk_wrapped_key,json=ovkWrappedKey,proto3" json:"ovk_wrapped_key,omitempty"`
}

func (m *OutputBody) Reset()         { *m = OutputBody{} }
func (m *OutputBody) String() string { return proto.CompactTextString(m) }
func (*OutputBody) ProtoMessage()    {}
func (*OutputBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{21}
}
func (m *OutputBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OutputBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OutputBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OutputBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutputBody.Merge(m, src)
}
func (m *OutputBody) XXX_Size() int {
	return m.Size()
}
func (m *OutputBody) XXX_DiscardUnknown() {
	xxx_messageInfo_OutputBody.DiscardUnknown(m)
}

var xxx_messageInfo_OutputBody proto.InternalMessageInfo

func (m *OutputBody) GetNotePayload() *v1alpha1.NotePayload {
	if m != nil {
		return m.NotePayload
	}
	return nil
}

func (m *OutputBody) GetBalanceCommitment() *v1alpha1.BalanceCommitment {
	if m != nil {
		return m.BalanceCommitment
	}
	return nil
}

func (m *OutputBody) GetWrappedMemoKey() []byte {
	if m != nil {
		return m.WrappedMemoKey
	}
	return nil
}

func (m *OutputBody) GetOvkWrappedKey() []byte {
	if m != nil {
		return m.OvkWrappedKey
	}
	return nil
}

// The data required to authorize a transaction plan.
type AuthorizationData struct {
	// The computed auth hash for the approved transaction plan.
	EffectHash *v1alpha1.EffectHash `protobuf:"bytes,1,opt,name=effect_hash,json=effectHash,proto3" json:"effect_hash,omitempty"`
	// The required spend authorizations, returned in the same order as the
	// Spend actions in the original request.
	SpendAuths []*v1alpha1.SpendAuthSignature `protobuf:"bytes,2,rep,name=spend_auths,json=spendAuths,proto3" json:"spend_auths,omitempty"`
	// The required delegator vote authorizations, returned in the same order as the
	// DelegatorVote actions in the original request.
	DelegatorVoteAuths []*v1alpha1.SpendAuthSignature `protobuf:"bytes,3,rep,name=delegator_vote_auths,json=delegatorVoteAuths,proto3" json:"delegator_vote_auths,omitempty"`
}

func (m *AuthorizationData) Reset()         { *m = AuthorizationData{} }
func (m *AuthorizationData) String() string { return proto.CompactTextString(m) }
func (*AuthorizationData) ProtoMessage()    {}
func (*AuthorizationData) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{22}
}
func (m *AuthorizationData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthorizationData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthorizationData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthorizationData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthorizationData.Merge(m, src)
}
func (m *AuthorizationData) XXX_Size() int {
	return m.Size()
}
func (m *AuthorizationData) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthorizationData.DiscardUnknown(m)
}

var xxx_messageInfo_AuthorizationData proto.InternalMessageInfo

func (m *AuthorizationData) GetEffectHash() *v1alpha1.EffectHash {
	if m != nil {
		return m.EffectHash
	}
	return nil
}

func (m *AuthorizationData) GetSpendAuths() []*v1alpha1.SpendAuthSignature {
	if m != nil {
		return m.SpendAuths
	}
	return nil
}

func (m *AuthorizationData) GetDelegatorVoteAuths() []*v1alpha1.SpendAuthSignature {
	if m != nil {
		return m.DelegatorVoteAuths
	}
	return nil
}

// The data required for proving when building a transaction from a plan.
type WitnessData struct {
	// The anchor for the state transition proofs.
	Anchor *v1alpha1.MerkleRoot `protobuf:"bytes,1,opt,name=anchor,proto3" json:"anchor,omitempty"`
	// The auth paths for the notes the transaction spends, in the
	// same order as the spends in the transaction plan.
	StateCommitmentProofs []*v1alpha1.StateCommitmentProof `protobuf:"bytes,2,rep,name=state_commitment_proofs,json=stateCommitmentProofs,proto3" json:"state_commitment_proofs,omitempty"`
}

func (m *WitnessData) Reset()         { *m = WitnessData{} }
func (m *WitnessData) String() string { return proto.CompactTextString(m) }
func (*WitnessData) ProtoMessage()    {}
func (*WitnessData) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{23}
}
func (m *WitnessData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WitnessData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WitnessData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WitnessData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WitnessData.Merge(m, src)
}
func (m *WitnessData) XXX_Size() int {
	return m.Size()
}
func (m *WitnessData) XXX_DiscardUnknown() {
	xxx_messageInfo_WitnessData.DiscardUnknown(m)
}

var xxx_messageInfo_WitnessData proto.InternalMessageInfo

func (m *WitnessData) GetAnchor() *v1alpha1.MerkleRoot {
	if m != nil {
		return m.Anchor
	}
	return nil
}

func (m *WitnessData) GetStateCommitmentProofs() []*v1alpha1.StateCommitmentProof {
	if m != nil {
		return m.StateCommitmentProofs
	}
	return nil
}

// Describes a planned transaction. Permits clients to prepare a transaction
// prior submission, so that a user can review it prior to authorizing its execution.
type TransactionPlan struct {
	// The planner interface(s) for Actions to be performed, such as a Spend, Swap,
	// or Delegation. See the ActionPlan docs for a full list of options.
	Actions []*ActionPlan `protobuf:"bytes,1,rep,name=actions,proto3" json:"actions,omitempty"`
	// Time, as block height, after which TransactionPlan should be considered invalid.
	ExpiryHeight uint64 `protobuf:"varint,2,opt,name=expiry_height,json=expiryHeight,proto3" json:"expiry_height,omitempty"`
	// The name of the network for which this TransactionPlan was built.
	ChainId   string        `protobuf:"bytes,3,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	Fee       *v1alpha1.Fee `protobuf:"bytes,4,opt,name=fee,proto3" json:"fee,omitempty"`
	CluePlans []*CluePlan   `protobuf:"bytes,5,rep,name=clue_plans,json=cluePlans,proto3" json:"clue_plans,omitempty"`
	// Planning interface for constructing an optional Memo for the Transaction.
	MemoPlan *MemoPlan `protobuf:"bytes,6,opt,name=memo_plan,json=memoPlan,proto3" json:"memo_plan,omitempty"`
}

func (m *TransactionPlan) Reset()         { *m = TransactionPlan{} }
func (m *TransactionPlan) String() string { return proto.CompactTextString(m) }
func (*TransactionPlan) ProtoMessage()    {}
func (*TransactionPlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{24}
}
func (m *TransactionPlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactionPlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransactionPlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransactionPlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionPlan.Merge(m, src)
}
func (m *TransactionPlan) XXX_Size() int {
	return m.Size()
}
func (m *TransactionPlan) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionPlan.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionPlan proto.InternalMessageInfo

func (m *TransactionPlan) GetActions() []*ActionPlan {
	if m != nil {
		return m.Actions
	}
	return nil
}

func (m *TransactionPlan) GetExpiryHeight() uint64 {
	if m != nil {
		return m.ExpiryHeight
	}
	return 0
}

func (m *TransactionPlan) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *TransactionPlan) GetFee() *v1alpha1.Fee {
	if m != nil {
		return m.Fee
	}
	return nil
}

func (m *TransactionPlan) GetCluePlans() []*CluePlan {
	if m != nil {
		return m.CluePlans
	}
	return nil
}

func (m *TransactionPlan) GetMemoPlan() *MemoPlan {
	if m != nil {
		return m.MemoPlan
	}
	return nil
}

// Describes a planned transaction action.
//
// Some transaction Actions don't have any private data and are treated as being plans
// themselves.
type ActionPlan struct {
	// Types that are valid to be assigned to Action:
	//
	//	*ActionPlan_Spend
	//	*ActionPlan_Output
	//	*ActionPlan_Swap
	//	*ActionPlan_SwapClaim
	//	*ActionPlan_ValidatorDefinition
	//	*ActionPlan_IbcAction
	//	*ActionPlan_ProposalSubmit
	//	*ActionPlan_ProposalWithdraw
	//	*ActionPlan_ValidatorVote
	//	*ActionPlan_DelegatorVote
	//	*ActionPlan_ProposalDepositClaim
	//	*ActionPlan_Withdrawal
	//	*ActionPlan_PositionOpen
	//	*ActionPlan_PositionClose
	//	*ActionPlan_PositionWithdraw
	//	*ActionPlan_PositionRewardClaim
	//	*ActionPlan_Delegate
	//	*ActionPlan_Undelegate
	//	*ActionPlan_UndelegateClaim
	//	*ActionPlan_DaoSpend
	//	*ActionPlan_DaoOutput
	//	*ActionPlan_DaoDeposit
	Action isActionPlan_Action `protobuf_oneof:"action"`
}

func (m *ActionPlan) Reset()         { *m = ActionPlan{} }
func (m *ActionPlan) String() string { return proto.CompactTextString(m) }
func (*ActionPlan) ProtoMessage()    {}
func (*ActionPlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{25}
}
func (m *ActionPlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionPlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionPlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionPlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionPlan.Merge(m, src)
}
func (m *ActionPlan) XXX_Size() int {
	return m.Size()
}
func (m *ActionPlan) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionPlan.DiscardUnknown(m)
}

var xxx_messageInfo_ActionPlan proto.InternalMessageInfo

type isActionPlan_Action interface {
	isActionPlan_Action()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ActionPlan_Spend struct {
	Spend *SpendPlan `protobuf:"bytes,1,opt,name=spend,proto3,oneof" json:"spend,omitempty"`
}
type ActionPlan_Output struct {
	Output *OutputPlan `protobuf:"bytes,2,opt,name=output,proto3,oneof" json:"output,omitempty"`
}
type ActionPlan_Swap struct {
	Swap *v1alpha11.SwapPlan `protobuf:"bytes,3,opt,name=swap,proto3,oneof" json:"swap,omitempty"`
}
type ActionPlan_SwapClaim struct {
	SwapClaim *v1alpha11.SwapClaimPlan `protobuf:"bytes,4,opt,name=swap_claim,json=swapClaim,proto3,oneof" json:"swap_claim,omitempty"`
}
type ActionPlan_ValidatorDefinition struct {
	ValidatorDefinition *v1alpha12.ValidatorDefinition `protobuf:"bytes,16,opt,name=validator_definition,json=validatorDefinition,proto3,oneof" json:"validator_definition,omitempty"`
}
type ActionPlan_IbcAction struct {
	IbcAction *v1alpha13.IbcAction `protobuf:"bytes,17,opt,name=ibc_action,json=ibcAction,proto3,oneof" json:"ibc_action,omitempty"`
}
type ActionPlan_ProposalSubmit struct {
	ProposalSubmit *v1alpha14.ProposalSubmit `protobuf:"bytes,18,opt,name=proposal_submit,json=proposalSubmit,proto3,oneof" json:"proposal_submit,omitempty"`
}
type ActionPlan_ProposalWithdraw struct {
	ProposalWithdraw *v1alpha14.ProposalWithdraw `protobuf:"bytes,19,opt,name=proposal_withdraw,json=proposalWithdraw,proto3,oneof" json:"proposal_withdraw,omitempty"`
}
type ActionPlan_ValidatorVote struct {
	ValidatorVote *v1alpha14.ValidatorVote `protobuf:"bytes,20,opt,name=validator_vote,json=validatorVote,proto3,oneof" json:"validator_vote,omitempty"`
}
type ActionPlan_DelegatorVote struct {
	DelegatorVote *v1alpha14.DelegatorVotePlan `protobuf:"bytes,21,opt,name=delegator_vote,json=delegatorVote,proto3,oneof" json:"delegator_vote,omitempty"`
}
type ActionPlan_ProposalDepositClaim struct {
	ProposalDepositClaim *v1alpha14.ProposalDepositClaim `protobuf:"bytes,22,opt,name=proposal_deposit_claim,json=proposalDepositClaim,proto3,oneof" json:"proposal_deposit_claim,omitempty"`
}
type ActionPlan_Withdrawal struct {
	Withdrawal *v1alpha13.Ics20Withdrawal `protobuf:"bytes,23,opt,name=withdrawal,proto3,oneof" json:"withdrawal,omitempty"`
}
type ActionPlan_PositionOpen struct {
	PositionOpen *v1alpha11.PositionOpen `protobuf:"bytes,30,opt,name=position_open,json=positionOpen,proto3,oneof" json:"position_open,omitempty"`
}
type ActionPlan_PositionClose struct {
	PositionClose *v1alpha11.PositionClose `protobuf:"bytes,31,opt,name=position_close,json=positionClose,proto3,oneof" json:"position_close,omitempty"`
}
type ActionPlan_PositionWithdraw struct {
	PositionWithdraw *v1alpha11.PositionWithdrawPlan `protobuf:"bytes,32,opt,name=position_withdraw,json=positionWithdraw,proto3,oneof" json:"position_withdraw,omitempty"`
}
type ActionPlan_PositionRewardClaim struct {
	PositionRewardClaim *v1alpha11.PositionRewardClaimPlan `protobuf:"bytes,34,opt,name=position_reward_claim,json=positionRewardClaim,proto3,oneof" json:"position_reward_claim,omitempty"`
}
type ActionPlan_Delegate struct {
	Delegate *v1alpha12.Delegate `protobuf:"bytes,40,opt,name=delegate,proto3,oneof" json:"delegate,omitempty"`
}
type ActionPlan_Undelegate struct {
	Undelegate *v1alpha12.Undelegate `protobuf:"bytes,41,opt,name=undelegate,proto3,oneof" json:"undelegate,omitempty"`
}
type ActionPlan_UndelegateClaim struct {
	UndelegateClaim *v1alpha12.UndelegateClaimPlan `protobuf:"bytes,42,opt,name=undelegate_claim,json=undelegateClaim,proto3,oneof" json:"undelegate_claim,omitempty"`
}
type ActionPlan_DaoSpend struct {
	DaoSpend *v1alpha14.DaoSpend `protobuf:"bytes,50,opt,name=dao_spend,json=daoSpend,proto3,oneof" json:"dao_spend,omitempty"`
}
type ActionPlan_DaoOutput struct {
	DaoOutput *v1alpha14.DaoOutput `protobuf:"bytes,51,opt,name=dao_output,json=daoOutput,proto3,oneof" json:"dao_output,omitempty"`
}
type ActionPlan_DaoDeposit struct {
	DaoDeposit *v1alpha14.DaoDeposit `protobuf:"bytes,52,opt,name=dao_deposit,json=daoDeposit,proto3,oneof" json:"dao_deposit,omitempty"`
}

func (*ActionPlan_Spend) isActionPlan_Action()                {}
func (*ActionPlan_Output) isActionPlan_Action()               {}
func (*ActionPlan_Swap) isActionPlan_Action()                 {}
func (*ActionPlan_SwapClaim) isActionPlan_Action()            {}
func (*ActionPlan_ValidatorDefinition) isActionPlan_Action()  {}
func (*ActionPlan_IbcAction) isActionPlan_Action()            {}
func (*ActionPlan_ProposalSubmit) isActionPlan_Action()       {}
func (*ActionPlan_ProposalWithdraw) isActionPlan_Action()     {}
func (*ActionPlan_ValidatorVote) isActionPlan_Action()        {}
func (*ActionPlan_DelegatorVote) isActionPlan_Action()        {}
func (*ActionPlan_ProposalDepositClaim) isActionPlan_Action() {}
func (*ActionPlan_Withdrawal) isActionPlan_Action()           {}
func (*ActionPlan_PositionOpen) isActionPlan_Action()         {}
func (*ActionPlan_PositionClose) isActionPlan_Action()        {}
func (*ActionPlan_PositionWithdraw) isActionPlan_Action()     {}
func (*ActionPlan_PositionRewardClaim) isActionPlan_Action()  {}
func (*ActionPlan_Delegate) isActionPlan_Action()             {}
func (*ActionPlan_Undelegate) isActionPlan_Action()           {}
func (*ActionPlan_UndelegateClaim) isActionPlan_Action()      {}
func (*ActionPlan_DaoSpend) isActionPlan_Action()             {}
func (*ActionPlan_DaoOutput) isActionPlan_Action()            {}
func (*ActionPlan_DaoDeposit) isActionPlan_Action()           {}

func (m *ActionPlan) GetAction() isActionPlan_Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *ActionPlan) GetSpend() *SpendPlan {
	if x, ok := m.GetAction().(*ActionPlan_Spend); ok {
		return x.Spend
	}
	return nil
}

func (m *ActionPlan) GetOutput() *OutputPlan {
	if x, ok := m.GetAction().(*ActionPlan_Output); ok {
		return x.Output
	}
	return nil
}

func (m *ActionPlan) GetSwap() *v1alpha11.SwapPlan {
	if x, ok := m.GetAction().(*ActionPlan_Swap); ok {
		return x.Swap
	}
	return nil
}

func (m *ActionPlan) GetSwapClaim() *v1alpha11.SwapClaimPlan {
	if x, ok := m.GetAction().(*ActionPlan_SwapClaim); ok {
		return x.SwapClaim
	}
	return nil
}

func (m *ActionPlan) GetValidatorDefinition() *v1alpha12.ValidatorDefinition {
	if x, ok := m.GetAction().(*ActionPlan_ValidatorDefinition); ok {
		return x.ValidatorDefinition
	}
	return nil
}

func (m *ActionPlan) GetIbcAction() *v1alpha13.IbcAction {
	if x, ok := m.GetAction().(*ActionPlan_IbcAction); ok {
		return x.IbcAction
	}
	return nil
}

func (m *ActionPlan) GetProposalSubmit() *v1alpha14.ProposalSubmit {
	if x, ok := m.GetAction().(*ActionPlan_ProposalSubmit); ok {
		return x.ProposalSubmit
	}
	return nil
}

func (m *ActionPlan) GetProposalWithdraw() *v1alpha14.ProposalWithdraw {
	if x, ok := m.GetAction().(*ActionPlan_ProposalWithdraw); ok {
		return x.ProposalWithdraw
	}
	return nil
}

func (m *ActionPlan) GetValidatorVote() *v1alpha14.ValidatorVote {
	if x, ok := m.GetAction().(*ActionPlan_ValidatorVote); ok {
		return x.ValidatorVote
	}
	return nil
}

func (m *ActionPlan) GetDelegatorVote() *v1alpha14.DelegatorVotePlan {
	if x, ok := m.GetAction().(*ActionPlan_DelegatorVote); ok {
		return x.DelegatorVote
	}
	return nil
}

func (m *ActionPlan) GetProposalDepositClaim() *v1alpha14.ProposalDepositClaim {
	if x, ok := m.GetAction().(*ActionPlan_ProposalDepositClaim); ok {
		return x.ProposalDepositClaim
	}
	return nil
}

func (m *ActionPlan) GetWithdrawal() *v1alpha13.Ics20Withdrawal {
	if x, ok := m.GetAction().(*ActionPlan_Withdrawal); ok {
		return x.Withdrawal
	}
	return nil
}

func (m *ActionPlan) GetPositionOpen() *v1alpha11.PositionOpen {
	if x, ok := m.GetAction().(*ActionPlan_PositionOpen); ok {
		return x.PositionOpen
	}
	return nil
}

func (m *ActionPlan) GetPositionClose() *v1alpha11.PositionClose {
	if x, ok := m.GetAction().(*ActionPlan_PositionClose); ok {
		return x.PositionClose
	}
	return nil
}

func (m *ActionPlan) GetPositionWithdraw() *v1alpha11.PositionWithdrawPlan {
	if x, ok := m.GetAction().(*ActionPlan_PositionWithdraw); ok {
		return x.PositionWithdraw
	}
	return nil
}

func (m *ActionPlan) GetPositionRewardClaim() *v1alpha11.PositionRewardClaimPlan {
	if x, ok := m.GetAction().(*ActionPlan_PositionRewardClaim); ok {
		return x.PositionRewardClaim
	}
	return nil
}

func (m *ActionPlan) GetDelegate() *v1alpha12.Delegate {
	if x, ok := m.GetAction().(*ActionPlan_Delegate); ok {
		return x.Delegate
	}
	return nil
}

func (m *ActionPlan) GetUndelegate() *v1alpha12.Undelegate {
	if x, ok := m.GetAction().(*ActionPlan_Undelegate); ok {
		return x.Undelegate
	}
	return nil
}

func (m *ActionPlan) GetUndelegateClaim() *v1alpha12.UndelegateClaimPlan {
	if x, ok := m.GetAction().(*ActionPlan_UndelegateClaim); ok {
		return x.UndelegateClaim
	}
	return nil
}

func (m *ActionPlan) GetDaoSpend() *v1alpha14.DaoSpend {
	if x, ok := m.GetAction().(*ActionPlan_DaoSpend); ok {
		return x.DaoSpend
	}
	return nil
}

func (m *ActionPlan) GetDaoOutput() *v1alpha14.DaoOutput {
	if x, ok := m.GetAction().(*ActionPlan_DaoOutput); ok {
		return x.DaoOutput
	}
	return nil
}

func (m *ActionPlan) GetDaoDeposit() *v1alpha14.DaoDeposit {
	if x, ok := m.GetAction().(*ActionPlan_DaoDeposit); ok {
		return x.DaoDeposit
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ActionPlan) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ActionPlan_Spend)(nil),
		(*ActionPlan_Output)(nil),
		(*ActionPlan_Swap)(nil),
		(*ActionPlan_SwapClaim)(nil),
		(*ActionPlan_ValidatorDefinition)(nil),
		(*ActionPlan_IbcAction)(nil),
		(*ActionPlan_ProposalSubmit)(nil),
		(*ActionPlan_ProposalWithdraw)(nil),
		(*ActionPlan_ValidatorVote)(nil),
		(*ActionPlan_DelegatorVote)(nil),
		(*ActionPlan_ProposalDepositClaim)(nil),
		(*ActionPlan_Withdrawal)(nil),
		(*ActionPlan_PositionOpen)(nil),
		(*ActionPlan_PositionClose)(nil),
		(*ActionPlan_PositionWithdraw)(nil),
		(*ActionPlan_PositionRewardClaim)(nil),
		(*ActionPlan_Delegate)(nil),
		(*ActionPlan_Undelegate)(nil),
		(*ActionPlan_UndelegateClaim)(nil),
		(*ActionPlan_DaoSpend)(nil),
		(*ActionPlan_DaoOutput)(nil),
		(*ActionPlan_DaoDeposit)(nil),
	}
}

// Describes a plan for forming a `Clue`.
type CluePlan struct {
	// The address.
	Address *v1alpha1.Address `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// The random seed to use for the clue plan.
	Rseed []byte `protobuf:"bytes,2,opt,name=rseed,proto3" json:"rseed,omitempty"`
	// The bits of precision.
	PrecisionBits uint64 `protobuf:"varint,3,opt,name=precision_bits,json=precisionBits,proto3" json:"precision_bits,omitempty"`
}

func (m *CluePlan) Reset()         { *m = CluePlan{} }
func (m *CluePlan) String() string { return proto.CompactTextString(m) }
func (*CluePlan) ProtoMessage()    {}
func (*CluePlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{26}
}
func (m *CluePlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CluePlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CluePlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CluePlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CluePlan.Merge(m, src)
}
func (m *CluePlan) XXX_Size() int {
	return m.Size()
}
func (m *CluePlan) XXX_DiscardUnknown() {
	xxx_messageInfo_CluePlan.DiscardUnknown(m)
}

var xxx_messageInfo_CluePlan proto.InternalMessageInfo

func (m *CluePlan) GetAddress() *v1alpha1.Address {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *CluePlan) GetRseed() []byte {
	if m != nil {
		return m.Rseed
	}
	return nil
}

func (m *CluePlan) GetPrecisionBits() uint64 {
	if m != nil {
		return m.PrecisionBits
	}
	return 0
}

// Describes a plan for forming a `Memo`.
type MemoPlan struct {
	// The plaintext.
	Plaintext *MemoPlaintext `protobuf:"bytes,1,opt,name=plaintext,proto3" json:"plaintext,omitempty"`
	// The key to use to encrypt the memo.
	Key []byte `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *MemoPlan) Reset()         { *m = MemoPlan{} }
func (m *MemoPlan) String() string { return proto.CompactTextString(m) }
func (*MemoPlan) ProtoMessage()    {}
func (*MemoPlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{27}
}
func (m *MemoPlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemoPlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemoPlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemoPlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemoPlan.Merge(m, src)
}
func (m *MemoPlan) XXX_Size() int {
	return m.Size()
}
func (m *MemoPlan) XXX_DiscardUnknown() {
	xxx_messageInfo_MemoPlan.DiscardUnknown(m)
}

var xxx_messageInfo_MemoPlan proto.InternalMessageInfo

func (m *MemoPlan) GetPlaintext() *MemoPlaintext {
	if m != nil {
		return m.Plaintext
	}
	return nil
}

func (m *MemoPlan) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type MemoCiphertext struct {
	Inner []byte `protobuf:"bytes,1,opt,name=inner,proto3" json:"inner,omitempty"`
}

func (m *MemoCiphertext) Reset()         { *m = MemoCiphertext{} }
func (m *MemoCiphertext) String() string { return proto.CompactTextString(m) }
func (*MemoCiphertext) ProtoMessage()    {}
func (*MemoCiphertext) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{28}
}
func (m *MemoCiphertext) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemoCiphertext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemoCiphertext.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemoCiphertext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemoCiphertext.Merge(m, src)
}
func (m *MemoCiphertext) XXX_Size() int {
	return m.Size()
}
func (m *MemoCiphertext) XXX_DiscardUnknown() {
	xxx_messageInfo_MemoCiphertext.DiscardUnknown(m)
}

var xxx_messageInfo_MemoCiphertext proto.InternalMessageInfo

func (m *MemoCiphertext) GetInner() []byte {
	if m != nil {
		return m.Inner
	}
	return nil
}

type MemoPlaintext struct {
	Sender *v1alpha1.Address `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Text   string            `protobuf:"bytes,2,opt,name=text,proto3" json:"text,omitempty"`
}

func (m *MemoPlaintext) Reset()         { *m = MemoPlaintext{} }
func (m *MemoPlaintext) String() string { return proto.CompactTextString(m) }
func (*MemoPlaintext) ProtoMessage()    {}
func (*MemoPlaintext) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{29}
}
func (m *MemoPlaintext) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemoPlaintext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemoPlaintext.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemoPlaintext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemoPlaintext.Merge(m, src)
}
func (m *MemoPlaintext) XXX_Size() int {
	return m.Size()
}
func (m *MemoPlaintext) XXX_DiscardUnknown() {
	xxx_messageInfo_MemoPlaintext.DiscardUnknown(m)
}

var xxx_messageInfo_MemoPlaintext proto.InternalMessageInfo

func (m *MemoPlaintext) GetSender() *v1alpha1.Address {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *MemoPlaintext) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

type MemoView struct {
	// Types that are valid to be assigned to MemoView:
	//
	//	*MemoView_Visible_
	//	*MemoView_Opaque_
	MemoView isMemoView_MemoView `protobuf_oneof:"memo_view"`
}

func (m *MemoView) Reset()         { *m = MemoView{} }
func (m *MemoView) String() string { return proto.CompactTextString(m) }
func (*MemoView) ProtoMessage()    {}
func (*MemoView) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{30}
}
func (m *MemoView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemoView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemoView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemoView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemoView.Merge(m, src)
}
func (m *MemoView) XXX_Size() int {
	return m.Size()
}
func (m *MemoView) XXX_DiscardUnknown() {
	xxx_messageInfo_MemoView.DiscardUnknown(m)
}

var xxx_messageInfo_MemoView proto.InternalMessageInfo

type isMemoView_MemoView interface {
	isMemoView_MemoView()
	MarshalTo([]byte) (int, error)
	Size() int
}

type MemoView_Visible_ struct {
	Visible *MemoView_Visible `protobuf:"bytes,1,opt,name=visible,proto3,oneof" json:"visible,omitempty"`
}
type MemoView_Opaque_ struct {
	Opaque *MemoView_Opaque `protobuf:"bytes,2,opt,name=opaque,proto3,oneof" json:"opaque,omitempty"`
}

func (*MemoView_Visible_) isMemoView_MemoView() {}
func (*MemoView_Opaque_) isMemoView_MemoView()  {}

func (m *MemoView) GetMemoView() isMemoView_MemoView {
	if m != nil {
		return m.MemoView
	}
	return nil
}

func (m *MemoView) GetVisible() *MemoView_Visible {
	if x, ok := m.GetMemoView().(*MemoView_Visible_); ok {
		return x.Visible
	}
	return nil
}

func (m *MemoView) GetOpaque() *MemoView_Opaque {
	if x, ok := m.GetMemoView().(*MemoView_Opaque_); ok {
		return x.Opaque
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MemoView) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MemoView_Visible_)(nil),
		(*MemoView_Opaque_)(nil),
	}
}

type MemoView_Visible struct {
	Ciphertext *MemoCiphertext `protobuf:"bytes,1,opt,name=ciphertext,proto3" json:"ciphertext,omitempty"`
	Plaintext  *MemoPlaintext  `protobuf:"bytes,2,opt,name=plaintext,proto3" json:"plaintext,omitempty"`
}

func (m *MemoView_Visible) Reset()         { *m = MemoView_Visible{} }
func (m *MemoView_Visible) String() string { return proto.CompactTextString(m) }
func (*MemoView_Visible) ProtoMessage()    {}
func (*MemoView_Visible) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{30, 0}
}
func (m *MemoView_Visible) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemoView_Visible) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemoView_Visible.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemoView_Visible) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemoView_Visible.Merge(m, src)
}
func (m *MemoView_Visible) XXX_Size() int {
	return m.Size()
}
func (m *MemoView_Visible) XXX_DiscardUnknown() {
	xxx_messageInfo_MemoView_Visible.DiscardUnknown(m)
}

var xxx_messageInfo_MemoView_Visible proto.InternalMessageInfo

func (m *MemoView_Visible) GetCiphertext() *MemoCiphertext {
	if m != nil {
		return m.Ciphertext
	}
	return nil
}

func (m *MemoView_Visible) GetPlaintext() *MemoPlaintext {
	if m != nil {
		return m.Plaintext
	}
	return nil
}

type MemoView_Opaque struct {
	Ciphertext *MemoCiphertext `protobuf:"bytes,1,opt,name=ciphertext,proto3" json:"ciphertext,omitempty"`
}

func (m *MemoView_Opaque) Reset()         { *m = MemoView_Opaque{} }
func (m *MemoView_Opaque) String() string { return proto.CompactTextString(m) }
func (*MemoView_Opaque) ProtoMessage()    {}
func (*MemoView_Opaque) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{30, 1}
}
func (m *MemoView_Opaque) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemoView_Opaque) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemoView_Opaque.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemoView_Opaque) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemoView_Opaque.Merge(m, src)
}
func (m *MemoView_Opaque) XXX_Size() int {
	return m.Size()
}
func (m *MemoView_Opaque) XXX_DiscardUnknown() {
	xxx_messageInfo_MemoView_Opaque.DiscardUnknown(m)
}

var xxx_messageInfo_MemoView_Opaque proto.InternalMessageInfo

func (m *MemoView_Opaque) GetCiphertext() *MemoCiphertext {
	if m != nil {
		return m.Ciphertext
	}
	return nil
}

type SpendPlan struct {
	// The plaintext note we plan to spend.
	Note *v1alpha1.Note `protobuf:"bytes,1,opt,name=note,proto3" json:"note,omitempty"`
	// The position of the note we plan to spend.
	Position uint64 `protobuf:"varint,2,opt,name=position,proto3" json:"position,omitempty"`
	// The randomizer to use for the spend.
	Randomizer []byte `protobuf:"bytes,3,opt,name=randomizer,proto3" json:"randomizer,omitempty"`
	// The blinding factor to use for the value commitment.
	ValueBlinding []byte `protobuf:"bytes,4,opt,name=value_blinding,json=valueBlinding,proto3" json:"value_blinding,omitempty"`
	// The first blinding factor to use for the ZK spend proof.
	ProofBlindingR []byte `protobuf:"bytes,5,opt,name=proof_blinding_r,json=proofBlindingR,proto3" json:"proof_blinding_r,omitempty"`
	// The second blinding factor to use for the ZK spend proof.
	ProofBlindingS []byte `protobuf:"bytes,6,opt,name=proof_blinding_s,json=proofBlindingS,proto3" json:"proof_blinding_s,omitempty"`
}

func (m *SpendPlan) Reset()         { *m = SpendPlan{} }
func (m *SpendPlan) String() string { return proto.CompactTextString(m) }
func (*SpendPlan) ProtoMessage()    {}
func (*SpendPlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{31}
}
func (m *SpendPlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpendPlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpendPlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpendPlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpendPlan.Merge(m, src)
}
func (m *SpendPlan) XXX_Size() int {
	return m.Size()
}
func (m *SpendPlan) XXX_DiscardUnknown() {
	xxx_messageInfo_SpendPlan.DiscardUnknown(m)
}

var xxx_messageInfo_SpendPlan proto.InternalMessageInfo

func (m *SpendPlan) GetNote() *v1alpha1.Note {
	if m != nil {
		return m.Note
	}
	return nil
}

func (m *SpendPlan) GetPosition() uint64 {
	if m != nil {
		return m.Position
	}
	return 0
}

func (m *SpendPlan) GetRandomizer() []byte {
	if m != nil {
		return m.Randomizer
	}
	return nil
}

func (m *SpendPlan) GetValueBlinding() []byte {
	if m != nil {
		return m.ValueBlinding
	}
	return nil
}

func (m *SpendPlan) GetProofBlindingR() []byte {
	if m != nil {
		return m.ProofBlindingR
	}
	return nil
}

func (m *SpendPlan) GetProofBlindingS() []byte {
	if m != nil {
		return m.ProofBlindingS
	}
	return nil
}

type OutputPlan struct {
	// The value to send to this output.
	Value *v1alpha1.Value `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	// The destination address to send it to.
	DestAddress *v1alpha1.Address `protobuf:"bytes,2,opt,name=dest_address,json=destAddress,proto3" json:"dest_address,omitempty"`
	// The rseed to use for the new note.
	Rseed []byte `protobuf:"bytes,3,opt,name=rseed,proto3" json:"rseed,omitempty"`
	// The blinding factor to use for the value commitment.
	ValueBlinding []byte `protobuf:"bytes,4,opt,name=value_blinding,json=valueBlinding,proto3" json:"value_blinding,omitempty"`
	// The first blinding factor to use for the ZK output proof.
	ProofBlindingR []byte `protobuf:"bytes,5,opt,name=proof_blinding_r,json=proofBlindingR,proto3" json:"proof_blinding_r,omitempty"`
	// The second blinding factor to use for the ZK output proof.
	ProofBlindingS []byte `protobuf:"bytes,6,opt,name=proof_blinding_s,json=proofBlindingS,proto3" json:"proof_blinding_s,omitempty"`
}

func (m *OutputPlan) Reset()         { *m = OutputPlan{} }
func (m *OutputPlan) String() string { return proto.CompactTextString(m) }
func (*OutputPlan) ProtoMessage()    {}
func (*OutputPlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{32}
}
func (m *OutputPlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OutputPlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OutputPlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OutputPlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutputPlan.Merge(m, src)
}
func (m *OutputPlan) XXX_Size() int {
	return m.Size()
}
func (m *OutputPlan) XXX_DiscardUnknown() {
	xxx_messageInfo_OutputPlan.DiscardUnknown(m)
}

var xxx_messageInfo_OutputPlan proto.InternalMessageInfo

func (m *OutputPlan) GetValue() *v1alpha1.Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *OutputPlan) GetDestAddress() *v1alpha1.Address {
	if m != nil {
		return m.DestAddress
	}
	return nil
}

func (m *OutputPlan) GetRseed() []byte {
	if m != nil {
		return m.Rseed
	}
	return nil
}

func (m *OutputPlan) GetValueBlinding() []byte {
	if m != nil {
		return m.ValueBlinding
	}
	return nil
}

func (m *OutputPlan) GetProofBlindingR() []byte {
	if m != nil {
		return m.ProofBlindingR
	}
	return nil
}

func (m *OutputPlan) GetProofBlindingS() []byte {
	if m != nil {
		return m.ProofBlindingS
	}
	return nil
}

func init() {
	proto.RegisterType((*Transaction)(nil), "penumbra.core.transaction.v1alpha1.Transaction")
	proto.RegisterType((*Id)(nil), "penumbra.core.transaction.v1alpha1.Id")
	proto.RegisterType((*EffectHash)(nil), "penumbra.core.transaction.v1alpha1.EffectHash")
	proto.RegisterType((*TransactionBody)(nil), "penumbra.core.transaction.v1alpha1.TransactionBody")
	proto.RegisterType((*MemoData)(nil), "penumbra.core.transaction.v1alpha1.MemoData")
	proto.RegisterType((*TransactionParameters)(nil), "penumbra.core.transaction.v1alpha1.TransactionParameters")
	proto.RegisterType((*DetectionData)(nil), "penumbra.core.transaction.v1alpha1.DetectionData")
	proto.RegisterType((*Action)(nil), "penumbra.core.transaction.v1alpha1.Action")
	proto.RegisterType((*TransactionPerspective)(nil), "penumbra.core.transaction.v1alpha1.TransactionPerspective")
	proto.RegisterType((*PayloadKey)(nil), "penumbra.core.transaction.v1alpha1.PayloadKey")
	proto.RegisterType((*PayloadKeyWithCommitment)(nil), "penumbra.core.transaction.v1alpha1.PayloadKeyWithCommitment")
	proto.RegisterType((*NullifierWithNote)(nil), "penumbra.core.transaction.v1alpha1.NullifierWithNote")
	proto.RegisterType((*TransactionView)(nil), "penumbra.core.transaction.v1alpha1.TransactionView")
	proto.RegisterType((*TransactionBodyView)(nil), "penumbra.core.transaction.v1alpha1.TransactionBodyView")
	proto.RegisterType((*ActionView)(nil), "penumbra.core.transaction.v1alpha1.ActionView")
	proto.RegisterType((*SpendView)(nil), "penumbra.core.transaction.v1alpha1.SpendView")
	proto.RegisterType((*SpendView_Visible)(nil), "penumbra.core.transaction.v1alpha1.SpendView.Visible")
	proto.RegisterType((*SpendView_Opaque)(nil), "penumbra.core.transaction.v1alpha1.SpendView.Opaque")
	proto.RegisterType((*DelegatorVoteView)(nil), "penumbra.core.transaction.v1alpha1.DelegatorVoteView")
	proto.RegisterType((*DelegatorVoteView_Visible)(nil), "penumbra.core.transaction.v1alpha1.DelegatorVoteView.Visible")
	proto.RegisterType((*DelegatorVoteView_Opaque)(nil), "penumbra.core.transaction.v1alpha1.DelegatorVoteView.Opaque")
	proto.RegisterType((*OutputView)(nil), "penumbra.core.transaction.v1alpha1.OutputView")
	proto.RegisterType((*OutputView_Visible)(nil), "penumbra.core.transaction.v1alpha1.OutputView.Visible")
	proto.RegisterType((*OutputView_Opaque)(nil), "penumbra.core.transaction.v1alpha1.OutputView.Opaque")
	proto.RegisterType((*Spend)(nil), "penumbra.core.transaction.v1alpha1.Spend")
	proto.RegisterType((*SpendBody)(nil), "penumbra.core.transaction.v1alpha1.SpendBody")
	proto.RegisterType((*Output)(nil), "penumbra.core.transaction.v1alpha1.Output")
	proto.RegisterType((*OutputBody)(nil), "penumbra.core.transaction.v1alpha1.OutputBody")
	proto.RegisterType((*AuthorizationData)(nil), "penumbra.core.transaction.v1alpha1.AuthorizationData")
	proto.RegisterType((*WitnessData)(nil), "penumbra.core.transaction.v1alpha1.WitnessData")
	proto.RegisterType((*TransactionPlan)(nil), "penumbra.core.transaction.v1alpha1.TransactionPlan")
	proto.RegisterType((*ActionPlan)(nil), "penumbra.core.transaction.v1alpha1.ActionPlan")
	proto.RegisterType((*CluePlan)(nil), "penumbra.core.transaction.v1alpha1.CluePlan")
	proto.RegisterType((*MemoPlan)(nil), "penumbra.core.transaction.v1alpha1.MemoPlan")
	proto.RegisterType((*MemoCiphertext)(nil), "penumbra.core.transaction.v1alpha1.MemoCiphertext")
	proto.RegisterType((*MemoPlaintext)(nil), "penumbra.core.transaction.v1alpha1.MemoPlaintext")
	proto.RegisterType((*MemoView)(nil), "penumbra.core.transaction.v1alpha1.MemoView")
	proto.RegisterType((*MemoView_Visible)(nil), "penumbra.core.transaction.v1alpha1.MemoView.Visible")
	proto.RegisterType((*MemoView_Opaque)(nil), "penumbra.core.transaction.v1alpha1.MemoView.Opaque")
	proto.RegisterType((*SpendPlan)(nil), "penumbra.core.transaction.v1alpha1.SpendPlan")
	proto.RegisterType((*OutputPlan)(nil), "penumbra.core.transaction.v1alpha1.OutputPlan")
}

func init() {
	proto.RegisterFile("penumbra/core/transaction/v1alpha1/transaction.proto", fileDescriptor_cd20ea79758052c4)
}

var fileDescriptor_cd20ea79758052c4 = []byte{
	// 2795 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5b, 0xcf, 0x6f, 0xe3, 0xc6,
	0xf5, 0x17, 0x25, 0xdb, 0x6b, 0x3f, 0xc9, 0x5a, 0x7b, 0xf6, 0x47, 0xf4, 0x35, 0xbe, 0x70, 0x16,
	0x4c, 0xb2, 0xf5, 0x6e, 0x12, 0x39, 0xeb, 0xdd, 0x4d, 0x50, 0x27, 0x6d, 0x63, 0xd9, 0xd9, 0xc8,
	0xbb, 0xf1, 0x5a, 0xa1, 0x53, 0xbb, 0x49, 0x9d, 0xb0, 0x23, 0x72, 0x6c, 0x11, 0x96, 0x48, 0x96,
	0xa4, 0xe4, 0x75, 0xfe, 0x81, 0xa6, 0x97, 0x22, 0x05, 0x7a, 0x28, 0x7a, 0x29, 0x50, 0xe4, 0xd4,
	0x43, 0xff, 0x80, 0x16, 0x3d, 0x37, 0x68, 0x2f, 0x01, 0x7a, 0x29, 0x10, 0x14, 0x48, 0x37, 0xa7,
	0xfe, 0xb8, 0xf4, 0xdc, 0x4b, 0x31, 0x3f, 0x38, 0x24, 0x25, 0x7a, 0x45, 0xd9, 0x4e, 0x83, 0xfc,
	0x38, 0x99, 0xf3, 0xfc, 0xde, 0x67, 0x66, 0xde, 0x7b, 0x33, 0xf3, 0xde, 0x9b, 0x11, 0xdc, 0x72,
	0x89, 0xdd, 0xed, 0x34, 0x3d, 0xbc, 0x68, 0x38, 0x1e, 0x59, 0x0c, 0x3c, 0x6c, 0xfb, 0xd8, 0x08,
	0x2c, 0xc7, 0x5e, 0xec, 0xdd, 0xc0, 0x6d, 0xb7, 0x85, 0x6f, 0xc4, 0x89, 0x55, 0xd7, 0x73, 0x02,
	0x07, 0xa9, 0xa1, 0x54, 0x95, 0x4a, 0x55, 0xe3, 0x0c, 0xa1, 0xd4, 0xdc, 0xf5, 0x24, 0xb2, 0xe1,
	0x1d, 0xb9, 0x81, 0x13, 0x81, 0xf2, 0x36, 0xc7, 0x9b, 0x5b, 0x48, 0xf2, 0xfa, 0x01, 0x3e, 0x20,
	0x11, 0x2b, 0x6b, 0x0a, 0xce, 0x27, 0x93, 0x9c, 0x56, 0xd3, 0x88, 0xf8, 0xac, 0xa6, 0x91, 0xce,
	0x65, 0x92, 0x07, 0x11, 0x97, 0x49, 0x1e, 0x08, 0xae, 0xa5, 0x24, 0xd7, 0xbe, 0xd3, 0x23, 0x9e,
	0x8d, 0x6d, 0x23, 0xd6, 0x75, 0x44, 0xe3, 0x32, 0xea, 0x6f, 0x15, 0x28, 0xbe, 0x11, 0x4d, 0x17,
	0xbd, 0x0a, 0x63, 0x4d, 0xc7, 0x3c, 0xaa, 0x28, 0x57, 0x94, 0x85, 0xe2, 0xd2, 0xcd, 0xea, 0x70,
	0xc5, 0x54, 0x63, 0xe2, 0x35, 0xc7, 0x3c, 0xd2, 0x18, 0x00, 0x7a, 0x1c, 0x8a, 0x4d, 0xcb, 0x36,
	0x2d, 0x7b, 0x5f, 0xf7, 0xad, 0xfd, 0x4a, 0xfe, 0x8a, 0xb2, 0x50, 0xd2, 0x40, 0x90, 0xb6, 0xac,
	0x7d, 0xb4, 0x02, 0x13, 0xd8, 0x36, 0x5a, 0x8e, 0x57, 0x29, 0xb0, 0xbe, 0xae, 0xf5, 0xf5, 0x25,
	0x14, 0x2a, 0xbb, 0xd9, 0x20, 0xde, 0x41, 0x9b, 0x68, 0x8e, 0x13, 0x68, 0x42, 0x50, 0xad, 0x40,
	0x7e, 0xdd, 0x44, 0x08, 0xc6, 0x5a, 0xd8, 0x6f, 0xb1, 0x21, 0x97, 0x34, 0xf6, 0xad, 0xaa, 0x00,
	0xaf, 0xec, 0xed, 0x11, 0x23, 0xa8, 0x63, 0xbf, 0x85, 0x2e, 0xc2, 0xb8, 0x65, 0xdb, 0xc4, 0x13,
	0x2c, 0xbc, 0xa1, 0x7e, 0x50, 0x80, 0xf3, 0x7d, 0x63, 0x47, 0x6b, 0x70, 0x8e, 0xb7, 0xfc, 0x8a,
	0x72, 0xa5, 0xb0, 0x50, 0x5c, 0xba, 0x9e, 0x45, 0x03, 0x2b, 0xac, 0xad, 0x85, 0xa2, 0xc8, 0x85,
	0xcb, 0x31, 0x3e, 0xdd, 0xc5, 0x1e, 0xee, 0x90, 0x80, 0x78, 0x3e, 0x53, 0x43, 0x71, 0xe9, 0x9b,
	0x23, 0xaa, 0xb5, 0x21, 0x01, 0xb4, 0x4b, 0x41, 0x1a, 0x19, 0xdd, 0x82, 0xc2, 0x1e, 0x21, 0x42,
	0x93, 0xea, 0x10, 0x4d, 0xde, 0x21, 0x44, 0xa3, 0xec, 0xe8, 0x7b, 0x50, 0x36, 0x49, 0x40, 0xf8,
	0x28, 0x4d, 0x1c, 0xe0, 0xca, 0x18, 0x03, 0xb8, 0x91, 0x65, 0x7c, 0x6b, 0xa1, 0xe4, 0x1a, 0x0e,
	0xb0, 0x36, 0x6d, 0xc6, 0x9b, 0x68, 0x1d, 0xa6, 0x3a, 0xa4, 0xe3, 0x70, 0xd0, 0x71, 0x06, 0xfa,
	0x4c, 0x16, 0xd0, 0x0d, 0xd2, 0x71, 0x18, 0xde, 0x64, 0x47, 0x7c, 0xa9, 0xeb, 0x30, 0x19, 0x52,
	0xd1, 0x75, 0x28, 0x13, 0x9b, 0x4d, 0x87, 0x98, 0x3a, 0xe5, 0xe0, 0x16, 0xad, 0xe7, 0xb4, 0x69,
	0x49, 0xa7, 0xcc, 0xef, 0x29, 0x4a, 0x6d, 0x16, 0xce, 0xeb, 0x49, 0x66, 0x75, 0x07, 0x2e, 0xa5,
	0x6a, 0x15, 0x3d, 0x01, 0xd3, 0xe4, 0x81, 0x6b, 0x79, 0x47, 0x7a, 0x8b, 0x58, 0xfb, 0xad, 0x80,
	0xc1, 0x8e, 0x69, 0x25, 0x4e, 0xac, 0x33, 0x1a, 0xfa, 0x3f, 0x98, 0x34, 0x5a, 0xd8, 0xb2, 0x75,
	0xcb, 0x64, 0x76, 0x9c, 0xd2, 0xce, 0xb1, 0xf6, 0xba, 0xa9, 0xbe, 0x0e, 0xd3, 0x09, 0x75, 0xa0,
	0x97, 0x61, 0x6a, 0xaf, 0x63, 0xea, 0x46, 0xbb, 0x4b, 0xfc, 0xca, 0x18, 0xf3, 0xa4, 0x27, 0x86,
	0x58, 0x65, 0xb5, 0xdd, 0x25, 0xda, 0xe4, 0x5e, 0xc7, 0xa4, 0x1f, 0xbe, 0xfa, 0xe7, 0x32, 0x4c,
	0x70, 0xbf, 0x42, 0x2b, 0x30, 0xee, 0xbb, 0xc4, 0x36, 0xc5, 0xa2, 0xbc, 0x96, 0x45, 0x91, 0x5b,
	0x54, 0xa0, 0x9e, 0xd3, 0xb8, 0x24, 0x5a, 0x83, 0x09, 0xa7, 0x1b, 0xb8, 0xdd, 0x40, 0x78, 0x60,
	0x26, 0xb7, 0xde, 0x64, 0x12, 0xf5, 0x9c, 0x26, 0x64, 0xd1, 0xf3, 0x30, 0xe6, 0x1f, 0x62, 0x57,
	0xb8, 0xd9, 0x95, 0x3e, 0x0c, 0xba, 0x11, 0x45, 0xfd, 0x1f, 0x62, 0xb7, 0x9e, 0xd3, 0x18, 0x3f,
	0xba, 0x03, 0x40, 0xff, 0xea, 0x46, 0x1b, 0x5b, 0x1d, 0xe1, 0x63, 0x4f, 0x0d, 0x93, 0x5e, 0xa5,
	0xcc, 0xf5, 0x9c, 0x36, 0xe5, 0x87, 0x0d, 0xb4, 0x07, 0x17, 0x7b, 0xb8, 0x6d, 0x99, 0x38, 0x70,
	0x3c, 0xdd, 0x24, 0x7b, 0x96, 0x6d, 0xd1, 0x11, 0x57, 0x66, 0x52, 0xbd, 0x96, 0x6f, 0xb3, 0x12,
	0x73, 0x3b, 0x94, 0x5c, 0x93, 0x82, 0xf5, 0x9c, 0x76, 0xa1, 0x37, 0x48, 0xa6, 0xe3, 0xb5, 0x9a,
	0x86, 0xce, 0xf5, 0x51, 0x99, 0x4d, 0x1d, 0x2f, 0xdd, 0x9c, 0x25, 0xf6, 0x7a, 0xd3, 0xe0, 0xb6,
	0xa2, 0xe3, 0xb5, 0xc2, 0x06, 0xda, 0x85, 0xf3, 0xae, 0xe7, 0xb8, 0x8e, 0x8f, 0xdb, 0xba, 0xdf,
	0x6d, 0x76, 0xac, 0xa0, 0x82, 0x52, 0x87, 0x1a, 0xdb, 0x96, 0x25, 0x66, 0x43, 0x48, 0x6e, 0x31,
	0xc1, 0x7a, 0x4e, 0x2b, 0xbb, 0x09, 0x0a, 0x6a, 0xc2, 0xac, 0x44, 0x3f, 0xb4, 0x82, 0x96, 0xe9,
	0xe1, 0xc3, 0xca, 0x85, 0xd4, 0x7d, 0xfb, 0x51, 0xf8, 0x3b, 0x42, 0xb4, 0x9e, 0xd3, 0x66, 0xdc,
	0x3e, 0x1a, 0x7a, 0x13, 0xca, 0x91, 0xc6, 0x7b, 0x4e, 0x40, 0x2a, 0x17, 0x59, 0x07, 0xcf, 0x65,
	0xe8, 0x40, 0x2a, 0x7c, 0xdb, 0x09, 0x08, 0x5d, 0xa2, 0xbd, 0x38, 0x81, 0x42, 0x9b, 0xa4, 0x4d,
	0xf6, 0x23, 0xe8, 0x4b, 0x99, 0xa1, 0xd7, 0x42, 0xc1, 0x10, 0xda, 0x8c, 0x13, 0x90, 0x03, 0x97,
	0xa5, 0x66, 0x4c, 0xe2, 0x3a, 0xbe, 0x15, 0x08, 0xdf, 0xbb, 0xcc, 0xba, 0x78, 0x61, 0x04, 0xf5,
	0xac, 0x71, 0xf9, 0xd0, 0x1b, 0x2f, 0xba, 0x29, 0x74, 0xb4, 0x09, 0xd3, 0xac, 0x45, 0xf7, 0x51,
	0xc7, 0x25, 0x76, 0x65, 0x9e, 0xf5, 0xb3, 0xf0, 0x28, 0x1f, 0x6f, 0x08, 0x81, 0x4d, 0x97, 0x50,
	0xb7, 0x29, 0xb9, 0xb1, 0x36, 0xd2, 0xa0, 0x2c, 0x01, 0x8d, 0xb6, 0xe3, 0x93, 0xca, 0xe3, 0xa9,
	0x6b, 0x3f, 0x15, 0x71, 0x95, 0x0a, 0x50, 0xad, 0xb8, 0x71, 0x02, 0xfa, 0x3e, 0xcc, 0x4a, 0x4c,
	0xe9, 0x2f, 0x57, 0x52, 0xf7, 0xe6, 0x54, 0xd8, 0x84, 0xa3, 0xf4, 0xd1, 0x10, 0x81, 0x4b, 0x12,
	0xdc, 0x23, 0x87, 0xd8, 0x33, 0x85, 0xc6, 0x55, 0xd6, 0xc1, 0x62, 0x96, 0x0e, 0x34, 0x26, 0x17,
	0x6a, 0xfa, 0x82, 0x3b, 0x48, 0x46, 0x6b, 0x30, 0x29, 0x4c, 0x4d, 0x2a, 0x0b, 0x0c, 0xf9, 0xea,
	0xa3, 0x57, 0xbd, 0xf0, 0x14, 0xaa, 0x0e, 0x29, 0x89, 0xee, 0x02, 0x74, 0x6d, 0x89, 0x73, 0x2d,
	0xd5, 0x56, 0x7d, 0x38, 0xdf, 0x95, 0xfc, 0xf5, 0x9c, 0x16, 0x93, 0x46, 0x6f, 0xc1, 0x4c, 0xd4,
	0x12, 0x73, 0xbe, 0xce, 0x10, 0x9f, 0xcd, 0x8a, 0x18, 0xce, 0xf8, 0x7c, 0x37, 0x49, 0x42, 0x77,
	0x61, 0xca, 0xc4, 0x8e, 0xce, 0x37, 0xff, 0x25, 0x06, 0xfa, 0x74, 0x96, 0xd5, 0x81, 0x9d, 0x70,
	0xfb, 0x9f, 0x34, 0xc5, 0x37, 0xda, 0x00, 0xa0, 0x58, 0xe2, 0x14, 0xb8, 0x99, 0x6a, 0xf6, 0x63,
	0xc0, 0xe4, 0x39, 0x40, 0x47, 0xc3, 0x1b, 0xa8, 0x01, 0x45, 0x0a, 0x27, 0x56, 0x57, 0xe5, 0x56,
	0xea, 0x8c, 0x8f, 0xc1, 0x13, 0x4b, 0x87, 0x2a, 0xd2, 0x94, 0x2d, 0xf4, 0x26, 0xcc, 0x58, 0x86,
	0xbf, 0xf4, 0x9c, 0xf4, 0x4d, 0xdc, 0xae, 0x7c, 0xa8, 0xa4, 0x4e, 0x3a, 0xb9, 0xf7, 0x52, 0xa1,
	0x1d, 0x29, 0x43, 0xf5, 0x68, 0x25, 0x49, 0xb5, 0x49, 0x98, 0xe0, 0x7b, 0xb9, 0xfa, 0xe3, 0x31,
	0xb8, 0x1c, 0x0f, 0x01, 0x88, 0xe7, 0xbb, 0xf4, 0xd8, 0xee, 0x11, 0xa4, 0x43, 0xc9, 0xc5, 0x47,
	0x6d, 0x07, 0x9b, 0xfa, 0x01, 0x39, 0x0a, 0xe3, 0xbf, 0x97, 0xb2, 0x1c, 0x94, 0x0d, 0x2e, 0x77,
	0x8f, 0x1c, 0xd1, 0x4e, 0x57, 0x9d, 0x4e, 0xc7, 0x0a, 0x3a, 0xc4, 0x0e, 0xb4, 0xa2, 0x2b, 0xff,
	0xe3, 0xa3, 0x1f, 0xc0, 0x0c, 0xb3, 0xa4, 0x6e, 0x77, 0xdb, 0x6d, 0x6b, 0xcf, 0xe2, 0xf1, 0x20,
	0xed, 0xe4, 0x76, 0x96, 0x4e, 0xee, 0x87, 0x52, 0xb4, 0x8f, 0xfb, 0x4e, 0x40, 0xb4, 0xf3, 0x0c,
	0x4e, 0xd2, 0x7d, 0x74, 0x07, 0x4a, 0xd8, 0xec, 0x59, 0x06, 0xd1, 0x6d, 0x27, 0x20, 0x7e, 0xa5,
	0x90, 0x29, 0xf0, 0x60, 0x58, 0x45, 0x2e, 0x48, 0xbf, 0x7d, 0xba, 0x9d, 0x61, 0xd3, 0xf4, 0x88,
	0xef, 0xeb, 0x3d, 0x8b, 0x1c, 0x86, 0x11, 0xcc, 0xf5, 0x21, 0x40, 0x2b, 0x5c, 0x66, 0xdb, 0x22,
	0x87, 0x5a, 0x09, 0x47, 0x0d, 0x9f, 0x86, 0x1f, 0x26, 0xb1, 0x9d, 0x8e, 0x5f, 0x19, 0x67, 0x48,
	0xcf, 0x0c, 0x41, 0x5a, 0xa3, 0xcc, 0x1b, 0x24, 0xc0, 0x34, 0x7e, 0xd4, 0x84, 0x2c, 0xda, 0x80,
	0x72, 0x3c, 0xac, 0xb6, 0xcc, 0xca, 0x44, 0xea, 0x16, 0x90, 0xaa, 0xbe, 0x75, 0x53, 0x9b, 0x8e,
	0xfd, 0x63, 0xdd, 0xa4, 0x39, 0x42, 0x64, 0xb8, 0x63, 0x72, 0x84, 0xdf, 0x29, 0x50, 0x39, 0xce,
	0xba, 0x68, 0x13, 0x8a, 0x31, 0x8f, 0x11, 0xd1, 0x59, 0x75, 0x34, 0x87, 0xd1, 0x20, 0x72, 0x11,
	0x74, 0x1f, 0xc0, 0x90, 0xf0, 0x22, 0x52, 0xab, 0x0e, 0x51, 0xd5, 0x56, 0x40, 0xb7, 0x8b, 0xc8,
	0xe5, 0x62, 0x08, 0xea, 0xcf, 0x14, 0x98, 0x1d, 0x70, 0x1b, 0x74, 0x07, 0xa6, 0xa4, 0x07, 0x8a,
	0x41, 0x2f, 0x0c, 0x73, 0x91, 0x90, 0x5f, 0x8b, 0x44, 0xd1, 0x0b, 0x30, 0x46, 0xdd, 0x4c, 0x8c,
	0x33, 0x93, 0x97, 0x31, 0x01, 0xf5, 0x4f, 0x4a, 0x22, 0xf1, 0xa2, 0x2e, 0x82, 0xde, 0x80, 0x29,
	0x9a, 0x36, 0x32, 0x7f, 0x13, 0x83, 0x7a, 0xe1, 0x04, 0xc9, 0x27, 0xf3, 0xbd, 0xc9, 0xa6, 0xf8,
	0xfa, 0x9f, 0x24, 0xa1, 0x9f, 0x14, 0xe0, 0x42, 0xca, 0x28, 0xd0, 0xeb, 0x50, 0x12, 0x8e, 0xca,
	0xd7, 0x10, 0xdf, 0x4f, 0xaa, 0xd9, 0xf3, 0x49, 0x36, 0x97, 0x62, 0xa4, 0xa3, 0x2f, 0x4e, 0x5e,
	0xf9, 0xf6, 0x99, 0xe5, 0x95, 0x3c, 0xb6, 0x8b, 0x11, 0xde, 0x53, 0x14, 0x74, 0x5f, 0x24, 0x97,
	0xcc, 0x57, 0x46, 0x4c, 0x2e, 0xa9, 0x22, 0xeb, 0x0a, 0x4f, 0x2f, 0xe9, 0x77, 0x98, 0x29, 0x26,
	0xc7, 0x5b, 0x2b, 0x01, 0xe8, 0xb2, 0x0f, 0xf5, 0xdf, 0x65, 0x80, 0xc8, 0x26, 0xe8, 0x95, 0x64,
	0x3e, 0xf6, 0x6c, 0xe6, 0x7c, 0x8c, 0x75, 0x2e, 0x73, 0xb2, 0x7a, 0x5f, 0x4e, 0x56, 0xcd, 0x9e,
	0x93, 0x09, 0xa0, 0x30, 0x2f, 0x5b, 0x4e, 0xe4, 0x65, 0x4f, 0x0e, 0xcb, 0xac, 0x84, 0x34, 0xcf,
	0xcd, 0xee, 0xa6, 0xe4, 0x66, 0xd7, 0x32, 0xe5, 0x66, 0x02, 0xe6, 0xeb, 0xfc, 0xec, 0xcb, 0x99,
	0x9f, 0xbd, 0x73, 0x4c, 0x7e, 0x76, 0x3b, 0xdb, 0x22, 0x8e, 0xe5, 0x63, 0xc2, 0x51, 0xbe, 0x4e,
	0xd2, 0xbe, 0x82, 0x49, 0xda, 0xb5, 0x33, 0x4a, 0xd2, 0xae, 0x9f, 0x2a, 0x49, 0xfb, 0x4a, 0x25,
	0x52, 0x69, 0x19, 0xe9, 0xd3, 0x67, 0x94, 0x91, 0x7e, 0x86, 0x49, 0xda, 0x34, 0x14, 0x63, 0xf1,
	0x92, 0xfa, 0xd3, 0x02, 0x4c, 0xc9, 0x43, 0x13, 0xbd, 0x0e, 0xe7, 0x7a, 0x96, 0x6f, 0x35, 0xdb,
	0x44, 0x1c, 0xba, 0xb7, 0x47, 0x3a, 0x74, 0xab, 0xdb, 0x5c, 0xb8, 0x9e, 0xd3, 0x42, 0x1c, 0x74,
	0x1f, 0x26, 0x1c, 0x17, 0xff, 0xb0, 0x1b, 0x06, 0xb0, 0xb7, 0x46, 0x43, 0xdc, 0x64, 0xb2, 0xec,
	0x10, 0x66, 0x5f, 0x73, 0x3f, 0x52, 0xe0, 0x9c, 0xe8, 0x06, 0x7d, 0xe7, 0xa4, 0x15, 0xdb, 0x30,
	0x36, 0x78, 0x31, 0x11, 0x5b, 0x7f, 0x23, 0x43, 0x6c, 0xcd, 0xa2, 0x45, 0x26, 0x34, 0xb7, 0x0e,
	0x13, 0x7c, 0x74, 0xa7, 0x1e, 0x07, 0x8d, 0x83, 0x78, 0xce, 0xca, 0x6c, 0xf2, 0xd7, 0x02, 0xcc,
	0x0e, 0xec, 0xec, 0xe8, 0xcd, 0x7e, 0xdb, 0x7c, 0xeb, 0x44, 0x27, 0x44, 0x9a, 0x8d, 0xb6, 0xfb,
	0x6c, 0xf4, 0xd2, 0xc9, 0x90, 0x07, 0x6c, 0xf5, 0xcb, 0x98, 0xad, 0x76, 0x06, 0xce, 0x39, 0xe5,
	0x64, 0x75, 0xc8, 0xfe, 0x03, 0xee, 0x54, 0x36, 0xc4, 0xd2, 0x86, 0x9f, 0xd5, 0xf8, 0x6a, 0x33,
	0xfd, 0xc0, 0xea, 0xbf, 0x0a, 0x00, 0x51, 0x80, 0x89, 0xb4, 0x7e, 0xc3, 0x3e, 0x3f, 0x5a, 0x84,
	0x9a, 0x66, 0xd1, 0xcd, 0x3e, 0x8b, 0xde, 0x1e, 0x11, 0x72, 0xc0, 0x94, 0x1f, 0xc7, 0x4c, 0x59,
	0x93, 0x11, 0xb5, 0x32, 0xea, 0x2d, 0x87, 0x8c, 0xa5, 0x4f, 0x63, 0xb5, 0xfe, 0x8a, 0x40, 0xe1,
	0xb4, 0x15, 0x81, 0xb9, 0xd7, 0xa4, 0x1b, 0x9c, 0xc1, 0xdc, 0xe8, 0x16, 0xcb, 0xbf, 0xf8, 0x72,
	0xfe, 0x58, 0x81, 0x71, 0x7e, 0xa6, 0xad, 0x24, 0x6e, 0x7d, 0xb3, 0x27, 0x34, 0xb1, 0xfb, 0xde,
	0xd7, 0x60, 0x12, 0x77, 0x83, 0x96, 0xcc, 0xb3, 0x07, 0x83, 0xe8, 0x81, 0xca, 0x05, 0x45, 0x58,
	0xe9, 0x06, 0xad, 0x2d, 0x6b, 0xdf, 0xc6, 0x41, 0xd7, 0x23, 0xda, 0x39, 0xcc, 0x9b, 0x68, 0x05,
	0xc6, 0x5d, 0xcf, 0x71, 0xf6, 0x84, 0x0a, 0x9f, 0x1e, 0x02, 0xf5, 0xd6, 0x3d, 0x06, 0xd6, 0xa0,
	0x22, 0x1a, 0x97, 0x54, 0x7f, 0xa1, 0x88, 0x03, 0x84, 0x5d, 0xec, 0xea, 0x80, 0x9a, 0xb8, 0x4d,
	0x57, 0x87, 0x1e, 0x2b, 0xb1, 0xa4, 0xaf, 0xa4, 0x7e, 0xf4, 0x1a, 0x17, 0x8c, 0x15, 0x59, 0x66,
	0x9b, 0xfd, 0x24, 0xf4, 0xff, 0xf1, 0xaa, 0x4a, 0x81, 0x15, 0x1a, 0x62, 0xb5, 0x92, 0x32, 0xe4,
	0xbd, 0x03, 0x96, 0x5d, 0x95, 0xb4, 0xbc, 0x77, 0xa0, 0xbe, 0xaf, 0xc0, 0x84, 0x08, 0x00, 0x6a,
	0x09, 0xdd, 0x8f, 0x90, 0x04, 0xc6, 0x94, 0x5f, 0x0b, 0xd5, 0x95, 0x4f, 0x0d, 0x47, 0x06, 0xd5,
	0xc5, 0x11, 0x12, 0xfa, 0xfa, 0x49, 0x3e, 0x5c, 0xfc, 0x4c, 0x61, 0x1b, 0x50, 0xa2, 0x2e, 0xad,
	0x0b, 0x67, 0x3c, 0xc6, 0xeb, 0xd2, 0xd6, 0x83, 0x70, 0x65, 0xad, 0x68, 0x47, 0x8d, 0x63, 0xf4,
	0x9f, 0x3f, 0x3b, 0xfd, 0x2f, 0xc0, 0xcc, 0xa1, 0x87, 0x5d, 0x57, 0xdc, 0xf5, 0xca, 0xf5, 0x57,
	0xd2, 0xca, 0x82, 0x4e, 0xd3, 0xff, 0x7b, 0xe4, 0x08, 0x5d, 0x85, 0xf3, 0x4e, 0xef, 0x40, 0x0f,
	0xb9, 0x29, 0x23, 0x37, 0xcc, 0xb4, 0xd3, 0x3b, 0xd8, 0xe1, 0xd4, 0x7b, 0xe4, 0x48, 0xfd, 0x79,
	0x1e, 0x66, 0xa9, 0x7b, 0x3a, 0x9e, 0xf5, 0x2e, 0x96, 0x37, 0xbb, 0x77, 0xa1, 0x48, 0xd8, 0xcb,
	0x02, 0x5d, 0x3e, 0x3a, 0x18, 0x5e, 0x36, 0x8a, 0xde, 0x22, 0x68, 0x40, 0xa2, 0x77, 0x09, 0x1a,
	0x14, 0xf9, 0xe9, 0x4a, 0xdd, 0x3e, 0x2c, 0x06, 0x9f, 0x60, 0xd9, 0xf0, 0x33, 0x9a, 0xd2, 0x7c,
	0x64, 0xc0, 0xc5, 0xe4, 0xae, 0x2e, 0xc0, 0x0b, 0x27, 0x05, 0x47, 0x89, 0x53, 0x83, 0x75, 0xa2,
	0xfe, 0x5e, 0x81, 0xe2, 0x8e, 0x15, 0xd8, 0xc4, 0xf7, 0x99, 0x52, 0xa2, 0x32, 0x9a, 0x72, 0xc2,
	0x32, 0x1a, 0x3a, 0x80, 0xc7, 0xfc, 0x80, 0x05, 0xac, 0xd2, 0xa6, 0x3a, 0x73, 0xcc, 0x50, 0x2f,
	0x37, 0x47, 0x2b, 0x84, 0x72, 0xdf, 0xbe, 0xe4, 0xa7, 0x50, 0x7d, 0xf5, 0xef, 0xf9, 0x44, 0x05,
	0xb2, 0xd1, 0xc6, 0x36, 0xaa, 0xf7, 0x3f, 0xfd, 0x18, 0xa1, 0x54, 0x47, 0x01, 0xa2, 0xe7, 0x1f,
	0x03, 0xaf, 0x09, 0xf2, 0x43, 0x5e, 0x13, 0x14, 0x12, 0xaf, 0x09, 0xc2, 0xa2, 0xdb, 0xd8, 0x68,
	0x45, 0xb7, 0x7b, 0x00, 0x46, 0xbb, 0x4b, 0x74, 0xb7, 0x8d, 0xed, 0xe3, 0xea, 0xec, 0xa9, 0x53,
	0x58, 0x6d, 0x77, 0x09, 0x9b, 0xc0, 0x94, 0x21, 0xbe, 0x7c, 0xf9, 0x7e, 0x83, 0x82, 0x89, 0x2a,
	0x7b, 0xe6, 0x12, 0x1b, 0xc3, 0x62, 0x05, 0x36, 0xfa, 0xa5, 0xfe, 0x53, 0x16, 0xcf, 0x98, 0x9a,
	0x4f, 0x5c, 0x3c, 0xa3, 0xd2, 0x67, 0x52, 0x3c, 0x13, 0x40, 0x27, 0x2c, 0x9e, 0x09, 0xe9, 0xd3,
	0x16, 0xcf, 0x04, 0xcc, 0xd7, 0xc5, 0xb3, 0x2f, 0x67, 0xf1, 0xec, 0xed, 0x63, 0x8a, 0x67, 0xb7,
	0x46, 0x0d, 0xda, 0x85, 0x9f, 0x7c, 0xde, 0xb5, 0xb3, 0x0d, 0x80, 0x58, 0xc6, 0xff, 0xd8, 0x49,
	0x12, 0xfe, 0x18, 0xc0, 0x17, 0xa3, 0x14, 0xa7, 0x1f, 0x5f, 0x8a, 0x7b, 0x6e, 0x94, 0x52, 0x9c,
	0x30, 0xe1, 0x60, 0x39, 0xce, 0x7a, 0x74, 0x39, 0xee, 0xe6, 0x88, 0xe5, 0x38, 0xd1, 0xcf, 0x17,
	0xe4, 0xdd, 0xc4, 0x3b, 0xc7, 0xbe, 0x9b, 0xb8, 0x31, 0x52, 0x95, 0x4a, 0xcc, 0xfa, 0x2b, 0xfd,
	0x76, 0x22, 0xfe, 0xc0, 0x41, 0x81, 0xc9, 0xf0, 0x40, 0x47, 0x2f, 0xc3, 0x39, 0x71, 0x0d, 0x2f,
	0x4e, 0xdb, 0xab, 0xd9, 0x6e, 0xf0, 0xb5, 0x50, 0x0c, 0x5d, 0x84, 0x71, 0xcf, 0x27, 0xc4, 0x14,
	0x57, 0xa7, 0xbc, 0x81, 0x9e, 0x82, 0xb2, 0xeb, 0x11, 0xc3, 0xf2, 0xa9, 0xe7, 0x36, 0xad, 0xc0,
	0x67, 0x87, 0xe7, 0x98, 0x36, 0x2d, 0xa9, 0x35, 0x2b, 0xf0, 0xd5, 0x0e, 0x7f, 0xb9, 0xc9, 0x86,
	0xb2, 0x09, 0x53, 0x6e, 0x1b, 0x5b, 0x76, 0x40, 0x1e, 0x84, 0x69, 0xd7, 0x8d, 0x11, 0x02, 0x0a,
	0x2e, 0xa8, 0x45, 0x18, 0x68, 0x06, 0x0a, 0x34, 0x72, 0xe7, 0xe3, 0xa2, 0x9f, 0xea, 0x55, 0x28,
	0x53, 0xee, 0x55, 0xcb, 0x6d, 0x11, 0x8f, 0xf1, 0xa4, 0xdf, 0xe9, 0x1b, 0x30, 0x9d, 0x40, 0x45,
	0xdf, 0x86, 0x09, 0x9f, 0xd8, 0xa6, 0xbc, 0x0d, 0xcf, 0xaa, 0x25, 0x21, 0x85, 0x10, 0x8c, 0xb1,
	0x69, 0xf1, 0x47, 0xa1, 0xec, 0x5b, 0xfd, 0x43, 0x81, 0x4f, 0x9e, 0x15, 0x52, 0x1a, 0xfd, 0x85,
	0x94, 0x5b, 0xa3, 0x5c, 0x57, 0xa6, 0x95, 0x51, 0x36, 0xfa, 0xca, 0x28, 0x37, 0x47, 0x02, 0x1c,
	0x28, 0xa2, 0xfc, 0x26, 0x56, 0x44, 0xd1, 0x00, 0x0c, 0xa9, 0x42, 0x31, 0xde, 0xa5, 0xac, 0xf0,
	0x91, 0xf2, 0xb5, 0x18, 0x4a, 0xd2, 0xfa, 0xf9, 0xd3, 0x5b, 0x7f, 0x6e, 0x57, 0xd6, 0x45, 0x3e,
	0x83, 0xe1, 0xd6, 0x8a, 0xb1, 0x0b, 0x66, 0xf5, 0x3f, 0x61, 0x1d, 0x81, 0xf9, 0x71, 0xf8, 0xe8,
	0x41, 0x19, 0xf1, 0xd1, 0x03, 0x9a, 0x83, 0xc9, 0x70, 0x63, 0x16, 0xf9, 0x80, 0x6c, 0xa3, 0x79,
	0x00, 0x0f, 0xdb, 0xa6, 0xd3, 0xb1, 0xde, 0x95, 0xc5, 0x83, 0x18, 0x85, 0xae, 0xb7, 0x1e, 0xa6,
	0xb1, 0x7d, 0xb3, 0xcd, 0x9f, 0x2e, 0x84, 0x09, 0x2b, 0xa3, 0xd6, 0x04, 0x91, 0xa6, 0xc0, 0x2c,
	0x63, 0x92, 0x6c, 0xba, 0xc7, 0xae, 0xc7, 0x4b, 0x2c, 0xba, 0x72, 0xf6, 0x42, 0x46, 0x2d, 0x85,
	0xd3, 0x67, 0x51, 0x7e, 0x3f, 0xe7, 0x96, 0xfa, 0x81, 0xac, 0x0a, 0xb0, 0xe9, 0x2f, 0xc3, 0x38,
	0xeb, 0x53, 0xcc, 0xff, 0xc9, 0x21, 0xf3, 0xdf, 0xa6, 0xbc, 0x1a, 0x17, 0x41, 0xeb, 0x50, 0x32,
	0x89, 0x1f, 0xe8, 0xe1, 0x96, 0x94, 0x1f, 0x69, 0xb1, 0x15, 0xa9, 0xec, 0x4a, 0xff, 0xb6, 0x54,
	0xe8, 0xdb, 0x96, 0x3e, 0x27, 0x35, 0xd5, 0xfe, 0x96, 0xff, 0xf0, 0xe1, 0xbc, 0xf2, 0xd1, 0xc3,
	0x79, 0xe5, 0x93, 0x87, 0xf3, 0xca, 0xfb, 0x9f, 0xce, 0xe7, 0x3e, 0xfa, 0x74, 0x3e, 0xf7, 0x97,
	0x4f, 0xe7, 0x73, 0x70, 0xd5, 0x70, 0x3a, 0x19, 0xfc, 0xb1, 0x36, 0x13, 0x4f, 0x48, 0x3d, 0x27,
	0x70, 0x1a, 0xca, 0x5b, 0xcd, 0x7d, 0x2b, 0x68, 0x75, 0x9b, 0x55, 0xc3, 0xe9, 0x2c, 0x1a, 0x8e,
	0xdf, 0x71, 0xfc, 0x45, 0x8f, 0xb4, 0xf1, 0x11, 0xf1, 0x16, 0x7b, 0x4b, 0xf2, 0x93, 0xe5, 0x8d,
	0xfe, 0xe2, 0xf0, 0x5f, 0xbe, 0xbc, 0x18, 0x23, 0x86, 0xb4, 0x5f, 0xe5, 0x0b, 0x8d, 0xd5, 0x37,
	0x7e, 0x9d, 0x57, 0x1b, 0xe1, 0x10, 0x57, 0xe9, 0x10, 0x63, 0x83, 0xa9, 0x6e, 0x0b, 0xd6, 0x3f,
	0x46, 0x4c, 0xbb, 0x94, 0x69, 0x37, 0xc6, 0xb4, 0x1b, 0x32, 0x3d, 0xcc, 0x57, 0x87, 0x33, 0xed,
	0xbe, 0xda, 0xa8, 0x85, 0xcf, 0xbb, 0xfe, 0x91, 0x7f, 0x2a, 0x14, 0x58, 0x5e, 0xa6, 0x12, 0xcb,
	0xcb, 0x31, 0x91, 0xe5, 0xe5, 0x50, 0xa6, 0x39, 0xc1, 0x7e, 0xb1, 0x72, 0xf3, 0xbf, 0x01, 0x00,
	0x00, 0xff, 0xff, 0x96, 0xcf, 0xfa, 0xae, 0xe3, 0x33, 0x00, 0x00,
}

func (m *Transaction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Transaction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Transaction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Anchor != nil {
		{
			size, err := m.Anchor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BindingSig) > 0 {
		i -= len(m.BindingSig)
		copy(dAtA[i:], m.BindingSig)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.BindingSig)))
		i--
		dAtA[i] = 0x12
	}
	if m.Body != nil {
		{
			size, err := m.Body.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Id) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Id) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Id) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EffectHash) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EffectHash) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EffectHash) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Inner) > 0 {
		i -= len(m.Inner)
		copy(dAtA[i:], m.Inner)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Inner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TransactionBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransactionBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MemoData != nil {
		{
			size, err := m.MemoData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.DetectionData != nil {
		{
			size, err := m.DetectionData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Fee != nil {
		{
			size, err := m.Fee.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.TransactionParameters != nil {
		{
			size, err := m.TransactionParameters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Actions) > 0 {
		for iNdEx := len(m.Actions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Actions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransaction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MemoData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemoData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemoData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XEncryptedMemo != nil {
		{
			size := m.XEncryptedMemo.Size()
			i -= size
			if _, err := m.XEncryptedMemo.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *MemoData_EncryptedMemo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemoData_EncryptedMemo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EncryptedMemo != nil {
		i -= len(m.EncryptedMemo)
		copy(dAtA[i:], m.EncryptedMemo)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.EncryptedMemo)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *TransactionParameters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionParameters) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransactionParameters) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x12
	}
	if m.ExpiryHeight != 0 {
		i = encodeVarintTransaction(dAtA, i, uint64(m.ExpiryHeight))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DetectionData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DetectionData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DetectionData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FmdClues) > 0 {
		for iNdEx := len(m.FmdClues) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FmdClues[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransaction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	return len(dAtA) - i, nil
}

func (m *Action) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Action) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Action != nil {
		{
			size := m.Action.Size()
			i -= size
			if _, err := m.Action.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Action_Spend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_Spend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Spend != nil {
		{
			size, err := m.Spend.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Action_Output) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_Output) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Output != nil {
		{
			size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Action_Swap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_Swap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Swap != nil {
		{
			size, err := m.Swap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Action_SwapClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_SwapClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SwapClaim != nil {
		{
			size, err := m.SwapClaim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Action_ValidatorDefinition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_ValidatorDefinition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ValidatorDefinition != nil {
		{
			size, err := m.ValidatorDefinition.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *Action_IbcAction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_IbcAction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IbcAction != nil {
		{
			size, err := m.IbcAction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *Action_ProposalSubmit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_ProposalSubmit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ProposalSubmit != nil {
		{
			size, err := m.ProposalSubmit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *Action_ProposalWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_ProposalWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ProposalWithdraw != nil {
		{
			size, err := m.ProposalWithdraw.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *Action_ValidatorVote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_ValidatorVote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ValidatorVote != nil {
		{
			size, err := m.ValidatorVote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *Action_DelegatorVote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_DelegatorVote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DelegatorVote != nil {
		{
			size, err := m.DelegatorVote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *Action_ProposalDepositClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_ProposalDepositClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ProposalDepositClaim != nil {
		{
			size, err := m.ProposalDepositClaim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *Action_PositionOpen) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_PositionOpen) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PositionOpen != nil {
		{
			size, err := m.PositionOpen.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	return len(dAtA) - i, nil
}
func (m *Action_PositionClose) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_PositionClose) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PositionClose != nil {
		{
			size, err := m.PositionClose.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	return len(dAtA) - i, nil
}
func (m *Action_PositionWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_PositionWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PositionWithdraw != nil {
		{
			size, err := m.PositionWithdraw.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *Action_PositionRewardClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_PositionRewardClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PositionRewardClaim != nil {
		{
			size, err := m.PositionRewardClaim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *Action_Delegate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_Delegate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Delegate != nil {
		{
			size, err := m.Delegate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *Action_Undelegate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_Undelegate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Undelegate != nil {
		{
			size, err := m.Undelegate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *Action_UndelegateClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_UndelegateClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UndelegateClaim != nil {
		{
			size, err := m.UndelegateClaim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *Action_DaoSpend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_DaoSpend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DaoSpend != nil {
		{
			size, err := m.DaoSpend.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *Action_DaoOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_DaoOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DaoOutput != nil {
		{
			size, err := m.DaoOutput.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *Action_DaoDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_DaoDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DaoDeposit != nil {
		{
			size, err := m.DaoDeposit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *Action_Ics20Withdrawal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_Ics20Withdrawal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ics20Withdrawal != nil {
		{
			size, err := m.Ics20Withdrawal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *TransactionPerspective) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionPerspective) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransactionPerspective) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TransactionId != nil {
		{
			size, err := m.TransactionId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Denoms) > 0 {
		for iNdEx := len(m.Denoms) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Denoms[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransaction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.AddressViews) > 0 {
		for iNdEx := len(m.AddressViews) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AddressViews[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransaction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.AdviceNotes) > 0 {
		for iNdEx := len(m.AdviceNotes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AdviceNotes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransaction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.SpendNullifiers) > 0 {
		for iNdEx := len(m.SpendNullifiers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SpendNullifiers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransaction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.PayloadKeys) > 0 {
		for iNdEx := len(m.PayloadKeys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PayloadKeys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransaction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PayloadKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PayloadKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PayloadKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Inner) > 0 {
		i -= len(m.Inner)
		copy(dAtA[i:], m.Inner)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Inner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PayloadKeyWithCommitment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PayloadKeyWithCommitment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PayloadKeyWithCommitment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Commitment != nil {
		{
			size, err := m.Commitment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.PayloadKey != nil {
		{
			size, err := m.PayloadKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NullifierWithNote) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NullifierWithNote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NullifierWithNote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Note != nil {
		{
			size, err := m.Note.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Nullifier != nil {
		{
			size, err := m.Nullifier.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TransactionView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionView) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransactionView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Anchor != nil {
		{
			size, err := m.Anchor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BindingSig) > 0 {
		i -= len(m.BindingSig)
		copy(dAtA[i:], m.BindingSig)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.BindingSig)))
		i--
		dAtA[i] = 0x12
	}
	if m.BodyView != nil {
		{
			size, err := m.BodyView.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TransactionBodyView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionBodyView) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransactionBodyView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XMemoView != nil {
		{
			size := m.XMemoView.Size()
			i -= size
			if _, err := m.XMemoView.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.XDetectionData != nil {
		{
			size := m.XDetectionData.Size()
			i -= size
			if _, err := m.XDetectionData.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Fee != nil {
		{
			size, err := m.Fee.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.TransactionParameters != nil {
		{
			size, err := m.TransactionParameters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ActionViews) > 0 {
		for iNdEx := len(m.ActionViews) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ActionViews[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransaction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TransactionBodyView_DetectionData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransactionBodyView_DetectionData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DetectionData != nil {
		{
			size, err := m.DetectionData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *TransactionBodyView_MemoView) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransactionBodyView_MemoView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MemoView != nil {
		{
			size, err := m.MemoView.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *ActionView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionView) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ActionView != nil {
		{
			size := m.ActionView.Size()
			i -= size
			if _, err := m.ActionView.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ActionView_Spend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_Spend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Spend != nil {
		{
			size, err := m.Spend.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_Output) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_Output) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Output != nil {
		{
			size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_Swap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_Swap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Swap != nil {
		{
			size, err := m.Swap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_SwapClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_SwapClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SwapClaim != nil {
		{
			size, err := m.SwapClaim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_ValidatorDefinition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_ValidatorDefinition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ValidatorDefinition != nil {
		{
			size, err := m.ValidatorDefinition.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_IbcAction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_IbcAction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IbcAction != nil {
		{
			size, err := m.IbcAction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_ProposalSubmit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_ProposalSubmit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ProposalSubmit != nil {
		{
			size, err := m.ProposalSubmit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_ProposalWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_ProposalWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ProposalWithdraw != nil {
		{
			size, err := m.ProposalWithdraw.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_ValidatorVote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_ValidatorVote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ValidatorVote != nil {
		{
			size, err := m.ValidatorVote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_DelegatorVote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_DelegatorVote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DelegatorVote != nil {
		{
			size, err := m.DelegatorVote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_ProposalDepositClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_ProposalDepositClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ProposalDepositClaim != nil {
		{
			size, err := m.ProposalDepositClaim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_PositionOpen) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_PositionOpen) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PositionOpen != nil {
		{
			size, err := m.PositionOpen.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_PositionClose) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_PositionClose) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PositionClose != nil {
		{
			size, err := m.PositionClose.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_PositionWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_PositionWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PositionWithdraw != nil {
		{
			size, err := m.PositionWithdraw.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_PositionRewardClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_PositionRewardClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PositionRewardClaim != nil {
		{
			size, err := m.PositionRewardClaim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_Delegate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_Delegate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Delegate != nil {
		{
			size, err := m.Delegate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_Undelegate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_Undelegate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Undelegate != nil {
		{
			size, err := m.Undelegate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_UndelegateClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_UndelegateClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UndelegateClaim != nil {
		{
			size, err := m.UndelegateClaim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_DaoSpend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_DaoSpend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DaoSpend != nil {
		{
			size, err := m.DaoSpend.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_DaoOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_DaoOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DaoOutput != nil {
		{
			size, err := m.DaoOutput.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_DaoDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_DaoDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DaoDeposit != nil {
		{
			size, err := m.DaoDeposit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_Ics20Withdrawal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_Ics20Withdrawal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ics20Withdrawal != nil {
		{
			size, err := m.Ics20Withdrawal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *SpendView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpendView) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpendView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SpendView != nil {
		{
			size := m.SpendView.Size()
			i -= size
			if _, err := m.SpendView.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *SpendView_Visible_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpendView_Visible_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Visible != nil {
		{
			size, err := m.Visible.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *SpendView_Opaque_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpendView_Opaque_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Opaque != nil {
		{
			size, err := m.Opaque.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *SpendView_Visible) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpendView_Visible) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpendView_Visible) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Note != nil {
		{
			size, err := m.Note.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Spend != nil {
		{
			size, err := m.Spend.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpendView_Opaque) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpendView_Opaque) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpendView_Opaque) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Spend != nil {
		{
			size, err := m.Spend.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DelegatorVoteView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelegatorVoteView) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelegatorVoteView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DelegatorVote != nil {
		{
			size := m.DelegatorVote.Size()
			i -= size
			if _, err := m.DelegatorVote.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *DelegatorVoteView_Visible_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelegatorVoteView_Visible_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Visible != nil {
		{
			size, err := m.Visible.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *DelegatorVoteView_Opaque_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelegatorVoteView_Opaque_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Opaque != nil {
		{
			size, err := m.Opaque.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *DelegatorVoteView_Visible) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelegatorVoteView_Visible) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelegatorVoteView_Visible) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Note != nil {
		{
			size, err := m.Note.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.DelegatorVote != nil {
		{
			size, err := m.DelegatorVote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DelegatorVoteView_Opaque) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelegatorVoteView_Opaque) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelegatorVoteView_Opaque) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DelegatorVote != nil {
		{
			size, err := m.DelegatorVote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OutputView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OutputView) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutputView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OutputView != nil {
		{
			size := m.OutputView.Size()
			i -= size
			if _, err := m.OutputView.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *OutputView_Visible_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutputView_Visible_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Visible != nil {
		{
			size, err := m.Visible.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *OutputView_Opaque_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutputView_Opaque_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Opaque != nil {
		{
			size, err := m.Opaque.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *OutputView_Visible) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OutputView_Visible) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutputView_Visible) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PayloadKey != nil {
		{
			size, err := m.PayloadKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Note != nil {
		{
			size, err := m.Note.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Output != nil {
		{
			size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OutputView_Opaque) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OutputView_Opaque) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutputView_Opaque) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Output != nil {
		{
			size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Spend) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Spend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Spend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Proof != nil {
		{
			size, err := m.Proof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.AuthSig != nil {
		{
			size, err := m.AuthSig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Body != nil {
		{
			size, err := m.Body.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpendBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpendBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpendBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Rk) > 0 {
		i -= len(m.Rk)
		copy(dAtA[i:], m.Rk)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Rk)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Nullifier) > 0 {
		i -= len(m.Nullifier)
		copy(dAtA[i:], m.Nullifier)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Nullifier)))
		i--
		dAtA[i] = 0x1a
	}
	if m.BalanceCommitment != nil {
		{
			size, err := m.BalanceCommitment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Output) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Output) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Output) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Proof != nil {
		{
			size, err := m.Proof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Body != nil {
		{
			size, err := m.Body.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OutputBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OutputBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutputBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OvkWrappedKey) > 0 {
		i -= len(m.OvkWrappedKey)
		copy(dAtA[i:], m.OvkWrappedKey)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.OvkWrappedKey)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.WrappedMemoKey) > 0 {
		i -= len(m.WrappedMemoKey)
		copy(dAtA[i:], m.WrappedMemoKey)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.WrappedMemoKey)))
		i--
		dAtA[i] = 0x1a
	}
	if m.BalanceCommitment != nil {
		{
			size, err := m.BalanceCommitment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.NotePayload != nil {
		{
			size, err := m.NotePayload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuthorizationData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthorizationData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthorizationData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DelegatorVoteAuths) > 0 {
		for iNdEx := len(m.DelegatorVoteAuths) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DelegatorVoteAuths[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransaction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.SpendAuths) > 0 {
		for iNdEx := len(m.SpendAuths) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SpendAuths[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransaction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.EffectHash != nil {
		{
			size, err := m.EffectHash.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WitnessData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WitnessData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WitnessData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StateCommitmentProofs) > 0 {
		for iNdEx := len(m.StateCommitmentProofs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StateCommitmentProofs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransaction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Anchor != nil {
		{
			size, err := m.Anchor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TransactionPlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionPlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransactionPlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MemoPlan != nil {
		{
			size, err := m.MemoPlan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.CluePlans) > 0 {
		for iNdEx := len(m.CluePlans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CluePlans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransaction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Fee != nil {
		{
			size, err := m.Fee.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ExpiryHeight != 0 {
		i = encodeVarintTransaction(dAtA, i, uint64(m.ExpiryHeight))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Actions) > 0 {
		for iNdEx := len(m.Actions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Actions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransaction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ActionPlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionPlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Action != nil {
		{
			size := m.Action.Size()
			i -= size
			if _, err := m.Action.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ActionPlan_Spend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_Spend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Spend != nil {
		{
			size, err := m.Spend.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_Output) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_Output) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Output != nil {
		{
			size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_Swap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_Swap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Swap != nil {
		{
			size, err := m.Swap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_SwapClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_SwapClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SwapClaim != nil {
		{
			size, err := m.SwapClaim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_ValidatorDefinition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_ValidatorDefinition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ValidatorDefinition != nil {
		{
			size, err := m.ValidatorDefinition.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_IbcAction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_IbcAction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IbcAction != nil {
		{
			size, err := m.IbcAction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_ProposalSubmit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_ProposalSubmit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ProposalSubmit != nil {
		{
			size, err := m.ProposalSubmit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_ProposalWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_ProposalWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ProposalWithdraw != nil {
		{
			size, err := m.ProposalWithdraw.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_ValidatorVote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_ValidatorVote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ValidatorVote != nil {
		{
			size, err := m.ValidatorVote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_DelegatorVote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_DelegatorVote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DelegatorVote != nil {
		{
			size, err := m.DelegatorVote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_ProposalDepositClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_ProposalDepositClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ProposalDepositClaim != nil {
		{
			size, err := m.ProposalDepositClaim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_Withdrawal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_Withdrawal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Withdrawal != nil {
		{
			size, err := m.Withdrawal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_PositionOpen) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_PositionOpen) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PositionOpen != nil {
		{
			size, err := m.PositionOpen.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_PositionClose) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_PositionClose) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PositionClose != nil {
		{
			size, err := m.PositionClose.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_PositionWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_PositionWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PositionWithdraw != nil {
		{
			size, err := m.PositionWithdraw.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_PositionRewardClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_PositionRewardClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PositionRewardClaim != nil {
		{
			size, err := m.PositionRewardClaim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_Delegate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_Delegate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Delegate != nil {
		{
			size, err := m.Delegate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_Undelegate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_Undelegate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Undelegate != nil {
		{
			size, err := m.Undelegate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_UndelegateClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_UndelegateClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UndelegateClaim != nil {
		{
			size, err := m.UndelegateClaim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_DaoSpend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_DaoSpend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DaoSpend != nil {
		{
			size, err := m.DaoSpend.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_DaoOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_DaoOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DaoOutput != nil {
		{
			size, err := m.DaoOutput.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_DaoDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_DaoDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DaoDeposit != nil {
		{
			size, err := m.DaoDeposit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *CluePlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CluePlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CluePlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PrecisionBits != 0 {
		i = encodeVarintTransaction(dAtA, i, uint64(m.PrecisionBits))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Rseed) > 0 {
		i -= len(m.Rseed)
		copy(dAtA[i:], m.Rseed)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Rseed)))
		i--
		dAtA[i] = 0x12
	}
	if m.Address != nil {
		{
			size, err := m.Address.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MemoPlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemoPlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemoPlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if m.Plaintext != nil {
		{
			size, err := m.Plaintext.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MemoCiphertext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemoCiphertext) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemoCiphertext) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Inner) > 0 {
		i -= len(m.Inner)
		copy(dAtA[i:], m.Inner)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Inner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MemoPlaintext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemoPlaintext) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemoPlaintext) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Text) > 0 {
		i -= len(m.Text)
		copy(dAtA[i:], m.Text)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Text)))
		i--
		dAtA[i] = 0x12
	}
	if m.Sender != nil {
		{
			size, err := m.Sender.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MemoView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemoView) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemoView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MemoView != nil {
		{
			size := m.MemoView.Size()
			i -= size
			if _, err := m.MemoView.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *MemoView_Visible_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemoView_Visible_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Visible != nil {
		{
			size, err := m.Visible.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *MemoView_Opaque_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemoView_Opaque_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Opaque != nil {
		{
			size, err := m.Opaque.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *MemoView_Visible) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemoView_Visible) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemoView_Visible) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Plaintext != nil {
		{
			size, err := m.Plaintext.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Ciphertext != nil {
		{
			size, err := m.Ciphertext.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MemoView_Opaque) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemoView_Opaque) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemoView_Opaque) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ciphertext != nil {
		{
			size, err := m.Ciphertext.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpendPlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpendPlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpendPlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProofBlindingS) > 0 {
		i -= len(m.ProofBlindingS)
		copy(dAtA[i:], m.ProofBlindingS)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.ProofBlindingS)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ProofBlindingR) > 0 {
		i -= len(m.ProofBlindingR)
		copy(dAtA[i:], m.ProofBlindingR)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.ProofBlindingR)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ValueBlinding) > 0 {
		i -= len(m.ValueBlinding)
		copy(dAtA[i:], m.ValueBlinding)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.ValueBlinding)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Randomizer) > 0 {
		i -= len(m.Randomizer)
		copy(dAtA[i:], m.Randomizer)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Randomizer)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Position != 0 {
		i = encodeVarintTransaction(dAtA, i, uint64(m.Position))
		i--
		dAtA[i] = 0x10
	}
	if m.Note != nil {
		{
			size, err := m.Note.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OutputPlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OutputPlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutputPlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProofBlindingS) > 0 {
		i -= len(m.ProofBlindingS)
		copy(dAtA[i:], m.ProofBlindingS)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.ProofBlindingS)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ProofBlindingR) > 0 {
		i -= len(m.ProofBlindingR)
		copy(dAtA[i:], m.ProofBlindingR)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.ProofBlindingR)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ValueBlinding) > 0 {
		i -= len(m.ValueBlinding)
		copy(dAtA[i:], m.ValueBlinding)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.ValueBlinding)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Rseed) > 0 {
		i -= len(m.Rseed)
		copy(dAtA[i:], m.Rseed)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Rseed)))
		i--
		dAtA[i] = 0x1a
	}
	if m.DestAddress != nil {
		{
			size, err := m.DestAddress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTransaction(dAtA []byte, offset int, v uint64) int {
	offset -= sovTransaction(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Transaction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Body != nil {
		l = m.Body.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.BindingSig)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Anchor != nil {
		l = m.Anchor.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *Id) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *EffectHash) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Inner)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *TransactionBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Actions) > 0 {
		for _, e := range m.Actions {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	if m.TransactionParameters != nil {
		l = m.TransactionParameters.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Fee != nil {
		l = m.Fee.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.DetectionData != nil {
		l = m.DetectionData.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.MemoData != nil {
		l = m.MemoData.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *MemoData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XEncryptedMemo != nil {
		n += m.XEncryptedMemo.Size()
	}
	return n
}

func (m *MemoData_EncryptedMemo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EncryptedMemo != nil {
		l = len(m.EncryptedMemo)
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *TransactionParameters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExpiryHeight != 0 {
		n += 1 + sovTransaction(uint64(m.ExpiryHeight))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *DetectionData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.FmdClues) > 0 {
		for _, e := range m.FmdClues {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	return n
}

func (m *Action) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Action != nil {
		n += m.Action.Size()
	}
	return n
}

func (m *Action_Spend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spend != nil {
		l = m.Spend.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_Output) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Output != nil {
		l = m.Output.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_Swap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Swap != nil {
		l = m.Swap.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_SwapClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SwapClaim != nil {
		l = m.SwapClaim.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_ValidatorDefinition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ValidatorDefinition != nil {
		l = m.ValidatorDefinition.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_IbcAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IbcAction != nil {
		l = m.IbcAction.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_ProposalSubmit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalSubmit != nil {
		l = m.ProposalSubmit.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_ProposalWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalWithdraw != nil {
		l = m.ProposalWithdraw.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_ValidatorVote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ValidatorVote != nil {
		l = m.ValidatorVote.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_DelegatorVote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DelegatorVote != nil {
		l = m.DelegatorVote.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_ProposalDepositClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalDepositClaim != nil {
		l = m.ProposalDepositClaim.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_PositionOpen) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionOpen != nil {
		l = m.PositionOpen.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_PositionClose) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionClose != nil {
		l = m.PositionClose.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_PositionWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionWithdraw != nil {
		l = m.PositionWithdraw.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_PositionRewardClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionRewardClaim != nil {
		l = m.PositionRewardClaim.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_Delegate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Delegate != nil {
		l = m.Delegate.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_Undelegate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Undelegate != nil {
		l = m.Undelegate.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_UndelegateClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UndelegateClaim != nil {
		l = m.UndelegateClaim.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_DaoSpend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DaoSpend != nil {
		l = m.DaoSpend.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_DaoOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DaoOutput != nil {
		l = m.DaoOutput.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_DaoDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DaoDeposit != nil {
		l = m.DaoDeposit.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_Ics20Withdrawal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ics20Withdrawal != nil {
		l = m.Ics20Withdrawal.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *TransactionPerspective) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PayloadKeys) > 0 {
		for _, e := range m.PayloadKeys {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	if len(m.SpendNullifiers) > 0 {
		for _, e := range m.SpendNullifiers {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	if len(m.AdviceNotes) > 0 {
		for _, e := range m.AdviceNotes {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	if len(m.AddressViews) > 0 {
		for _, e := range m.AddressViews {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	if len(m.Denoms) > 0 {
		for _, e := range m.Denoms {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	if m.TransactionId != nil {
		l = m.TransactionId.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *PayloadKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Inner)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *PayloadKeyWithCommitment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PayloadKey != nil {
		l = m.PayloadKey.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Commitment != nil {
		l = m.Commitment.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *NullifierWithNote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nullifier != nil {
		l = m.Nullifier.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Note != nil {
		l = m.Note.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *TransactionView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BodyView != nil {
		l = m.BodyView.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.BindingSig)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Anchor != nil {
		l = m.Anchor.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *TransactionBodyView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ActionViews) > 0 {
		for _, e := range m.ActionViews {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	if m.TransactionParameters != nil {
		l = m.TransactionParameters.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Fee != nil {
		l = m.Fee.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.XDetectionData != nil {
		n += m.XDetectionData.Size()
	}
	if m.XMemoView != nil {
		n += m.XMemoView.Size()
	}
	return n
}

func (m *TransactionBodyView_DetectionData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DetectionData != nil {
		l = m.DetectionData.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *TransactionBodyView_MemoView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MemoView != nil {
		l = m.MemoView.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ActionView != nil {
		n += m.ActionView.Size()
	}
	return n
}

func (m *ActionView_Spend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spend != nil {
		l = m.Spend.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_Output) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Output != nil {
		l = m.Output.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_Swap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Swap != nil {
		l = m.Swap.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_SwapClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SwapClaim != nil {
		l = m.SwapClaim.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_ValidatorDefinition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ValidatorDefinition != nil {
		l = m.ValidatorDefinition.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_IbcAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IbcAction != nil {
		l = m.IbcAction.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_ProposalSubmit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalSubmit != nil {
		l = m.ProposalSubmit.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_ProposalWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalWithdraw != nil {
		l = m.ProposalWithdraw.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_ValidatorVote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ValidatorVote != nil {
		l = m.ValidatorVote.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_DelegatorVote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DelegatorVote != nil {
		l = m.DelegatorVote.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_ProposalDepositClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalDepositClaim != nil {
		l = m.ProposalDepositClaim.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_PositionOpen) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionOpen != nil {
		l = m.PositionOpen.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_PositionClose) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionClose != nil {
		l = m.PositionClose.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_PositionWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionWithdraw != nil {
		l = m.PositionWithdraw.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_PositionRewardClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionRewardClaim != nil {
		l = m.PositionRewardClaim.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_Delegate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Delegate != nil {
		l = m.Delegate.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_Undelegate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Undelegate != nil {
		l = m.Undelegate.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_UndelegateClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UndelegateClaim != nil {
		l = m.UndelegateClaim.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_DaoSpend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DaoSpend != nil {
		l = m.DaoSpend.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_DaoOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DaoOutput != nil {
		l = m.DaoOutput.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_DaoDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DaoDeposit != nil {
		l = m.DaoDeposit.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_Ics20Withdrawal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ics20Withdrawal != nil {
		l = m.Ics20Withdrawal.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *SpendView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SpendView != nil {
		n += m.SpendView.Size()
	}
	return n
}

func (m *SpendView_Visible_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Visible != nil {
		l = m.Visible.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *SpendView_Opaque_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Opaque != nil {
		l = m.Opaque.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *SpendView_Visible) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spend != nil {
		l = m.Spend.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Note != nil {
		l = m.Note.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *SpendView_Opaque) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spend != nil {
		l = m.Spend.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *DelegatorVoteView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DelegatorVote != nil {
		n += m.DelegatorVote.Size()
	}
	return n
}

func (m *DelegatorVoteView_Visible_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Visible != nil {
		l = m.Visible.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *DelegatorVoteView_Opaque_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Opaque != nil {
		l = m.Opaque.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *DelegatorVoteView_Visible) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DelegatorVote != nil {
		l = m.DelegatorVote.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Note != nil {
		l = m.Note.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *DelegatorVoteView_Opaque) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DelegatorVote != nil {
		l = m.DelegatorVote.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *OutputView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OutputView != nil {
		n += m.OutputView.Size()
	}
	return n
}

func (m *OutputView_Visible_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Visible != nil {
		l = m.Visible.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *OutputView_Opaque_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Opaque != nil {
		l = m.Opaque.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *OutputView_Visible) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Output != nil {
		l = m.Output.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Note != nil {
		l = m.Note.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.PayloadKey != nil {
		l = m.PayloadKey.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *OutputView_Opaque) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Output != nil {
		l = m.Output.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *Spend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Body != nil {
		l = m.Body.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.AuthSig != nil {
		l = m.AuthSig.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Proof != nil {
		l = m.Proof.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *SpendBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BalanceCommitment != nil {
		l = m.BalanceCommitment.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.Nullifier)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.Rk)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *Output) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Body != nil {
		l = m.Body.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Proof != nil {
		l = m.Proof.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *OutputBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NotePayload != nil {
		l = m.NotePayload.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.BalanceCommitment != nil {
		l = m.BalanceCommitment.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.WrappedMemoKey)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.OvkWrappedKey)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *AuthorizationData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EffectHash != nil {
		l = m.EffectHash.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if len(m.SpendAuths) > 0 {
		for _, e := range m.SpendAuths {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	if len(m.DelegatorVoteAuths) > 0 {
		for _, e := range m.DelegatorVoteAuths {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	return n
}

func (m *WitnessData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Anchor != nil {
		l = m.Anchor.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if len(m.StateCommitmentProofs) > 0 {
		for _, e := range m.StateCommitmentProofs {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	return n
}

func (m *TransactionPlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Actions) > 0 {
		for _, e := range m.Actions {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	if m.ExpiryHeight != 0 {
		n += 1 + sovTransaction(uint64(m.ExpiryHeight))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Fee != nil {
		l = m.Fee.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if len(m.CluePlans) > 0 {
		for _, e := range m.CluePlans {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	if m.MemoPlan != nil {
		l = m.MemoPlan.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *ActionPlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Action != nil {
		n += m.Action.Size()
	}
	return n
}

func (m *ActionPlan_Spend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spend != nil {
		l = m.Spend.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_Output) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Output != nil {
		l = m.Output.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_Swap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Swap != nil {
		l = m.Swap.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_SwapClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SwapClaim != nil {
		l = m.SwapClaim.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_ValidatorDefinition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ValidatorDefinition != nil {
		l = m.ValidatorDefinition.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_IbcAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IbcAction != nil {
		l = m.IbcAction.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_ProposalSubmit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalSubmit != nil {
		l = m.ProposalSubmit.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_ProposalWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalWithdraw != nil {
		l = m.ProposalWithdraw.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_ValidatorVote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ValidatorVote != nil {
		l = m.ValidatorVote.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_DelegatorVote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DelegatorVote != nil {
		l = m.DelegatorVote.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_ProposalDepositClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalDepositClaim != nil {
		l = m.ProposalDepositClaim.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_Withdrawal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Withdrawal != nil {
		l = m.Withdrawal.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_PositionOpen) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionOpen != nil {
		l = m.PositionOpen.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_PositionClose) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionClose != nil {
		l = m.PositionClose.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_PositionWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionWithdraw != nil {
		l = m.PositionWithdraw.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_PositionRewardClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionRewardClaim != nil {
		l = m.PositionRewardClaim.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_Delegate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Delegate != nil {
		l = m.Delegate.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_Undelegate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Undelegate != nil {
		l = m.Undelegate.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_UndelegateClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UndelegateClaim != nil {
		l = m.UndelegateClaim.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_DaoSpend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DaoSpend != nil {
		l = m.DaoSpend.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_DaoOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DaoOutput != nil {
		l = m.DaoOutput.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_DaoDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DaoDeposit != nil {
		l = m.DaoDeposit.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *CluePlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Address != nil {
		l = m.Address.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.Rseed)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.PrecisionBits != 0 {
		n += 1 + sovTransaction(uint64(m.PrecisionBits))
	}
	return n
}

func (m *MemoPlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Plaintext != nil {
		l = m.Plaintext.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *MemoCiphertext) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Inner)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *MemoPlaintext) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sender != nil {
		l = m.Sender.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *MemoView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MemoView != nil {
		n += m.MemoView.Size()
	}
	return n
}

func (m *MemoView_Visible_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Visible != nil {
		l = m.Visible.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *MemoView_Opaque_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Opaque != nil {
		l = m.Opaque.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *MemoView_Visible) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ciphertext != nil {
		l = m.Ciphertext.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Plaintext != nil {
		l = m.Plaintext.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *MemoView_Opaque) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ciphertext != nil {
		l = m.Ciphertext.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *SpendPlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Note != nil {
		l = m.Note.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Position != 0 {
		n += 1 + sovTransaction(uint64(m.Position))
	}
	l = len(m.Randomizer)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.ValueBlinding)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.ProofBlindingR)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.ProofBlindingS)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *OutputPlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.DestAddress != nil {
		l = m.DestAddress.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.Rseed)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.ValueBlinding)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.ProofBlindingR)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.ProofBlindingS)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func sovTransaction(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTransaction(x uint64) (n int) {
	return sovTransaction(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Transaction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Transaction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Transaction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Body == nil {
				m.Body = &TransactionBody{}
			}
			if err := m.Body.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BindingSig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BindingSig = append(m.BindingSig[:0], dAtA[iNdEx:postIndex]...)
			if m.BindingSig == nil {
				m.BindingSig = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Anchor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Anchor == nil {
				m.Anchor = &v1alpha1.MerkleRoot{}
			}
			if err := m.Anchor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Id) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Id: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Id: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EffectHash) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EffectHash: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EffectHash: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inner = append(m.Inner[:0], dAtA[iNdEx:postIndex]...)
			if m.Inner == nil {
				m.Inner = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actions = append(m.Actions, &Action{})
			if err := m.Actions[len(m.Actions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransactionParameters == nil {
				m.TransactionParameters = &TransactionParameters{}
			}
			if err := m.TransactionParameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fee == nil {
				m.Fee = &v1alpha1.Fee{}
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DetectionData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DetectionData == nil {
				m.DetectionData = &DetectionData{}
			}
			if err := m.DetectionData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MemoData == nil {
				m.MemoData = &MemoData{}
			}
			if err := m.MemoData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemoData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemoData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemoData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedMemo", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.XEncryptedMemo = &MemoData_EncryptedMemo{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionParameters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionParameters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionParameters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiryHeight", wireType)
			}
			m.ExpiryHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiryHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DetectionData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DetectionData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DetectionData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FmdClues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FmdClues = append(m.FmdClues, &v1alpha1.Clue{})
			if err := m.FmdClues[len(m.FmdClues)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Action) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Action: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Action: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Spend{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_Spend{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Output{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_Output{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Swap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha11.Swap{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_Swap{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha11.SwapClaim{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_SwapClaim{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorDefinition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha12.ValidatorDefinition{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_ValidatorDefinition{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IbcAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha13.IbcAction{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_IbcAction{v}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalSubmit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.ProposalSubmit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_ProposalSubmit{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalWithdraw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.ProposalWithdraw{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_ProposalWithdraw{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorVote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.ValidatorVote{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_ValidatorVote{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorVote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.DelegatorVote{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_DelegatorVote{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalDepositClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.ProposalDepositClaim{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_ProposalDepositClaim{v}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionOpen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha11.PositionOpen{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_PositionOpen{v}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionClose", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha11.PositionClose{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_PositionClose{v}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionWithdraw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha11.PositionWithdraw{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_PositionWithdraw{v}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionRewardClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha11.PositionRewardClaim{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_PositionRewardClaim{v}
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delegate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha12.Delegate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_Delegate{v}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Undelegate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha12.Undelegate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_Undelegate{v}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UndelegateClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha12.UndelegateClaim{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_UndelegateClaim{v}
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DaoSpend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.DaoSpend{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_DaoSpend{v}
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DaoOutput", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.DaoOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_DaoOutput{v}
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DaoDeposit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.DaoDeposit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_DaoDeposit{v}
			iNdEx = postIndex
		case 200:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ics20Withdrawal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha13.Ics20Withdrawal{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_Ics20Withdrawal{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionPerspective) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionPerspective: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionPerspective: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PayloadKeys = append(m.PayloadKeys, &PayloadKeyWithCommitment{})
			if err := m.PayloadKeys[len(m.PayloadKeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpendNullifiers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpendNullifiers = append(m.SpendNullifiers, &NullifierWithNote{})
			if err := m.SpendNullifiers[len(m.SpendNullifiers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdviceNotes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdviceNotes = append(m.AdviceNotes, &v1alpha1.Note{})
			if err := m.AdviceNotes[len(m.AdviceNotes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressViews", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressViews = append(m.AddressViews, &v1alpha1.AddressView{})
			if err := m.AddressViews[len(m.AddressViews)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denoms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denoms = append(m.Denoms, &v1alpha1.DenomMetadata{})
			if err := m.Denoms[len(m.Denoms)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransactionId == nil {
				m.TransactionId = &Id{}
			}
			if err := m.TransactionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PayloadKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PayloadKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PayloadKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inner = append(m.Inner[:0], dAtA[iNdEx:postIndex]...)
			if m.Inner == nil {
				m.Inner = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PayloadKeyWithCommitment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PayloadKeyWithCommitment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PayloadKeyWithCommitment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PayloadKey == nil {
				m.PayloadKey = &PayloadKey{}
			}
			if err := m.PayloadKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commitment == nil {
				m.Commitment = &v1alpha1.StateCommitment{}
			}
			if err := m.Commitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NullifierWithNote) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NullifierWithNote: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NullifierWithNote: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nullifier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Nullifier == nil {
				m.Nullifier = &v1alpha1.Nullifier{}
			}
			if err := m.Nullifier.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Note", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Note == nil {
				m.Note = &v1alpha1.Note{}
			}
			if err := m.Note.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BodyView", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BodyView == nil {
				m.BodyView = &TransactionBodyView{}
			}
			if err := m.BodyView.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BindingSig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BindingSig = append(m.BindingSig[:0], dAtA[iNdEx:postIndex]...)
			if m.BindingSig == nil {
				m.BindingSig = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Anchor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Anchor == nil {
				m.Anchor = &v1alpha1.MerkleRoot{}
			}
			if err := m.Anchor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionBodyView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionBodyView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionBodyView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionViews", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionViews = append(m.ActionViews, &ActionView{})
			if err := m.ActionViews[len(m.ActionViews)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransactionParameters == nil {
				m.TransactionParameters = &TransactionParameters{}
			}
			if err := m.TransactionParameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fee == nil {
				m.Fee = &v1alpha1.Fee{}
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DetectionData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DetectionData{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.XDetectionData = &TransactionBodyView_DetectionData{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoView", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MemoView{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.XMemoView = &TransactionBodyView_MemoView{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SpendView{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_Spend{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OutputView{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_Output{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Swap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha11.SwapView{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_Swap{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha11.SwapClaimView{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_SwapClaim{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorDefinition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha12.ValidatorDefinition{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_ValidatorDefinition{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IbcAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha13.IbcAction{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_IbcAction{v}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalSubmit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.ProposalSubmit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_ProposalSubmit{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalWithdraw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.ProposalWithdraw{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_ProposalWithdraw{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorVote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.ValidatorVote{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_ValidatorVote{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorVote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DelegatorVoteView{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_DelegatorVote{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalDepositClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.ProposalDepositClaim{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_ProposalDepositClaim{v}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionOpen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha11.PositionOpen{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_PositionOpen{v}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionClose", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha11.PositionClose{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_PositionClose{v}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionWithdraw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha11.PositionWithdraw{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_PositionWithdraw{v}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionRewardClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha11.PositionRewardClaim{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_PositionRewardClaim{v}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delegate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha12.Delegate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_Delegate{v}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Undelegate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha12.Undelegate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_Undelegate{v}
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UndelegateClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha12.UndelegateClaim{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_UndelegateClaim{v}
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DaoSpend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.DaoSpend{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_DaoSpend{v}
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DaoOutput", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.DaoOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_DaoOutput{v}
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DaoDeposit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.DaoDeposit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_DaoDeposit{v}
			iNdEx = postIndex
		case 200:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ics20Withdrawal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha13.Ics20Withdrawal{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_Ics20Withdrawal{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpendView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpendView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpendView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visible", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SpendView_Visible{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SpendView = &SpendView_Visible_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opaque", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SpendView_Opaque{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SpendView = &SpendView_Opaque_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpendView_Visible) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Visible: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Visible: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spend == nil {
				m.Spend = &Spend{}
			}
			if err := m.Spend.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Note", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Note == nil {
				m.Note = &v1alpha1.NoteView{}
			}
			if err := m.Note.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpendView_Opaque) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Opaque: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Opaque: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spend == nil {
				m.Spend = &Spend{}
			}
			if err := m.Spend.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelegatorVoteView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelegatorVoteView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelegatorVoteView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visible", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DelegatorVoteView_Visible{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DelegatorVote = &DelegatorVoteView_Visible_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opaque", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DelegatorVoteView_Opaque{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DelegatorVote = &DelegatorVoteView_Opaque_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelegatorVoteView_Visible) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Visible: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Visible: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorVote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DelegatorVote == nil {
				m.DelegatorVote = &v1alpha14.DelegatorVote{}
			}
			if err := m.DelegatorVote.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Note", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Note == nil {
				m.Note = &v1alpha1.NoteView{}
			}
			if err := m.Note.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelegatorVoteView_Opaque) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Opaque: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Opaque: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorVote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DelegatorVote == nil {
				m.DelegatorVote = &v1alpha14.DelegatorVote{}
			}
			if err := m.DelegatorVote.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutputView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OutputView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OutputView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visible", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OutputView_Visible{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.OutputView = &OutputView_Visible_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opaque", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OutputView_Opaque{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.OutputView = &OutputView_Opaque_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutputView_Visible) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Visible: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Visible: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output == nil {
				m.Output = &Output{}
			}
			if err := m.Output.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Note", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Note == nil {
				m.Note = &v1alpha1.NoteView{}
			}
			if err := m.Note.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PayloadKey == nil {
				m.PayloadKey = &PayloadKey{}
			}
			if err := m.PayloadKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutputView_Opaque) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Opaque: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Opaque: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output == nil {
				m.Output = &Output{}
			}
			if err := m.Output.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Spend) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Spend: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Spend: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Body == nil {
				m.Body = &SpendBody{}
			}
			if err := m.Body.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthSig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuthSig == nil {
				m.AuthSig = &v1alpha1.SpendAuthSignature{}
			}
			if err := m.AuthSig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proof == nil {
				m.Proof = &v1alpha1.ZKSpendProof{}
			}
			if err := m.Proof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpendBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpendBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpendBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BalanceCommitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BalanceCommitment == nil {
				m.BalanceCommitment = &v1alpha1.BalanceCommitment{}
			}
			if err := m.BalanceCommitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nullifier", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nullifier = append(m.Nullifier[:0], dAtA[iNdEx:postIndex]...)
			if m.Nullifier == nil {
				m.Nullifier = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rk = append(m.Rk[:0], dAtA[iNdEx:postIndex]...)
			if m.Rk == nil {
				m.Rk = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Output) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Output: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Output: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Body == nil {
				m.Body = &OutputBody{}
			}
			if err := m.Body.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proof == nil {
				m.Proof = &v1alpha1.ZKOutputProof{}
			}
			if err := m.Proof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutputBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OutputBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OutputBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotePayload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NotePayload == nil {
				m.NotePayload = &v1alpha1.NotePayload{}
			}
			if err := m.NotePayload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BalanceCommitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BalanceCommitment == nil {
				m.BalanceCommitment = &v1alpha1.BalanceCommitment{}
			}
			if err := m.BalanceCommitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WrappedMemoKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WrappedMemoKey = append(m.WrappedMemoKey[:0], dAtA[iNdEx:postIndex]...)
			if m.WrappedMemoKey == nil {
				m.WrappedMemoKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OvkWrappedKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OvkWrappedKey = append(m.OvkWrappedKey[:0], dAtA[iNdEx:postIndex]...)
			if m.OvkWrappedKey == nil {
				m.OvkWrappedKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthorizationData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthorizationData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthorizationData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectHash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EffectHash == nil {
				m.EffectHash = &v1alpha1.EffectHash{}
			}
			if err := m.EffectHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpendAuths", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpendAuths = append(m.SpendAuths, &v1alpha1.SpendAuthSignature{})
			if err := m.SpendAuths[len(m.SpendAuths)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorVoteAuths", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelegatorVoteAuths = append(m.DelegatorVoteAuths, &v1alpha1.SpendAuthSignature{})
			if err := m.DelegatorVoteAuths[len(m.DelegatorVoteAuths)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WitnessData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WitnessData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WitnessData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Anchor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Anchor == nil {
				m.Anchor = &v1alpha1.MerkleRoot{}
			}
			if err := m.Anchor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateCommitmentProofs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StateCommitmentProofs = append(m.StateCommitmentProofs, &v1alpha1.StateCommitmentProof{})
			if err := m.StateCommitmentProofs[len(m.StateCommitmentProofs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionPlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionPlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionPlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actions = append(m.Actions, &ActionPlan{})
			if err := m.Actions[len(m.Actions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiryHeight", wireType)
			}
			m.ExpiryHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiryHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fee == nil {
				m.Fee = &v1alpha1.Fee{}
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CluePlans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CluePlans = append(m.CluePlans, &CluePlan{})
			if err := m.CluePlans[len(m.CluePlans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoPlan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MemoPlan == nil {
				m.MemoPlan = &MemoPlan{}
			}
			if err := m.MemoPlan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionPlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionPlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionPlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SpendPlan{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_Spend{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OutputPlan{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_Output{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Swap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha11.SwapPlan{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_Swap{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha11.SwapClaimPlan{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_SwapClaim{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorDefinition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha12.ValidatorDefinition{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_ValidatorDefinition{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IbcAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha13.IbcAction{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_IbcAction{v}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalSubmit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.ProposalSubmit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_ProposalSubmit{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalWithdraw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.ProposalWithdraw{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_ProposalWithdraw{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorVote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.ValidatorVote{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_ValidatorVote{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorVote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.DelegatorVotePlan{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_DelegatorVote{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalDepositClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.ProposalDepositClaim{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_ProposalDepositClaim{v}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Withdrawal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha13.Ics20Withdrawal{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_Withdrawal{v}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionOpen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha11.PositionOpen{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_PositionOpen{v}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionClose", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha11.PositionClose{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_PositionClose{v}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionWithdraw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha11.PositionWithdrawPlan{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_PositionWithdraw{v}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionRewardClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha11.PositionRewardClaimPlan{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_PositionRewardClaim{v}
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delegate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha12.Delegate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_Delegate{v}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Undelegate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha12.Undelegate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_Undelegate{v}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UndelegateClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha12.UndelegateClaimPlan{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_UndelegateClaim{v}
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DaoSpend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.DaoSpend{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_DaoSpend{v}
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DaoOutput", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.DaoOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_DaoOutput{v}
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DaoDeposit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.DaoDeposit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_DaoDeposit{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CluePlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CluePlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CluePlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Address == nil {
				m.Address = &v1alpha1.Address{}
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rseed", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rseed = append(m.Rseed[:0], dAtA[iNdEx:postIndex]...)
			if m.Rseed == nil {
				m.Rseed = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrecisionBits", wireType)
			}
			m.PrecisionBits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrecisionBits |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemoPlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemoPlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemoPlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plaintext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Plaintext == nil {
				m.Plaintext = &MemoPlaintext{}
			}
			if err := m.Plaintext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemoCiphertext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemoCiphertext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemoCiphertext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inner = append(m.Inner[:0], dAtA[iNdEx:postIndex]...)
			if m.Inner == nil {
				m.Inner = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemoPlaintext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemoPlaintext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemoPlaintext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sender == nil {
				m.Sender = &v1alpha1.Address{}
			}
			if err := m.Sender.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemoView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemoView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemoView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visible", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MemoView_Visible{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.MemoView = &MemoView_Visible_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opaque", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MemoView_Opaque{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.MemoView = &MemoView_Opaque_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemoView_Visible) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Visible: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Visible: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ciphertext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ciphertext == nil {
				m.Ciphertext = &MemoCiphertext{}
			}
			if err := m.Ciphertext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plaintext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Plaintext == nil {
				m.Plaintext = &MemoPlaintext{}
			}
			if err := m.Plaintext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemoView_Opaque) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Opaque: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Opaque: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ciphertext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ciphertext == nil {
				m.Ciphertext = &MemoCiphertext{}
			}
			if err := m.Ciphertext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpendPlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpendPlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpendPlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Note", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Note == nil {
				m.Note = &v1alpha1.Note{}
			}
			if err := m.Note.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			m.Position = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Position |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Randomizer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Randomizer = append(m.Randomizer[:0], dAtA[iNdEx:postIndex]...)
			if m.Randomizer == nil {
				m.Randomizer = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueBlinding", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueBlinding = append(m.ValueBlinding[:0], dAtA[iNdEx:postIndex]...)
			if m.ValueBlinding == nil {
				m.ValueBlinding = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofBlindingR", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofBlindingR = append(m.ProofBlindingR[:0], dAtA[iNdEx:postIndex]...)
			if m.ProofBlindingR == nil {
				m.ProofBlindingR = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofBlindingS", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofBlindingS = append(m.ProofBlindingS[:0], dAtA[iNdEx:postIndex]...)
			if m.ProofBlindingS == nil {
				m.ProofBlindingS = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutputPlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OutputPlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OutputPlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &v1alpha1.Value{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DestAddress == nil {
				m.DestAddress = &v1alpha1.Address{}
			}
			if err := m.DestAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rseed", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rseed = append(m.Rseed[:0], dAtA[iNdEx:postIndex]...)
			if m.Rseed == nil {
				m.Rseed = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueBlinding", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueBlinding = append(m.ValueBlinding[:0], dAtA[iNdEx:postIndex]...)
			if m.ValueBlinding == nil {
				m.ValueBlinding = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofBlindingR", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofBlindingR = append(m.ProofBlindingR[:0], dAtA[iNdEx:postIndex]...)
			if m.ProofBlindingR == nil {
				m.ProofBlindingR = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofBlindingS", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofBlindingS = append(m.ProofBlindingS[:0], dAtA[iNdEx:postIndex]...)
			if m.ProofBlindingS == nil {
				m.ProofBlindingS = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTransaction(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTransaction
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTransaction
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTransaction
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTransaction        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTransaction          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTransaction = fmt.Errorf("proto: unexpected end of group")
)
