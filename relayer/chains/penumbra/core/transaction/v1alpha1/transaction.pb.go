// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: penumbra/core/transaction/v1alpha1/transaction.proto

package transactionv1alpha1

import (
	fmt "fmt"
	proto "github.com/cosmos/gogoproto/proto"
	v1alpha19 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/asset/v1alpha1"
	v1alpha14 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/component/dex/v1alpha1"
	v1alpha11 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/component/fee/v1alpha1"
	v1alpha17 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/component/governance/v1alpha1"
	v1alpha16 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/component/ibc/v1alpha1"
	v1alpha110 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/component/sct/v1alpha1"
	v1alpha13 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/component/shielded_pool/v1alpha1"
	v1alpha15 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/component/stake/v1alpha1"
	v1alpha18 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/keys/v1alpha1"
	v1alpha12 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/crypto/decaf377_fmd/v1alpha1"
	v1alpha111 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/crypto/decaf377_rdsa/v1alpha1"
	v1alpha1 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/crypto/tct/v1alpha1"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// A Penumbra transaction.
type Transaction struct {
	Body *TransactionBody `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// The binding signature is stored separately from the transaction body that it signs.
	BindingSig []byte `protobuf:"bytes,2,opt,name=binding_sig,json=bindingSig,proto3" json:"binding_sig,omitempty"`
	// The root of some previous state of the state commitment tree, used as an anchor for all
	// ZK state transition proofs.
	Anchor *v1alpha1.MerkleRoot `protobuf:"bytes,3,opt,name=anchor,proto3" json:"anchor,omitempty"`
}

func (m *Transaction) Reset()         { *m = Transaction{} }
func (m *Transaction) String() string { return proto.CompactTextString(m) }
func (*Transaction) ProtoMessage()    {}
func (*Transaction) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{0}
}
func (m *Transaction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Transaction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Transaction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Transaction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Transaction.Merge(m, src)
}
func (m *Transaction) XXX_Size() int {
	return m.Size()
}
func (m *Transaction) XXX_DiscardUnknown() {
	xxx_messageInfo_Transaction.DiscardUnknown(m)
}

var xxx_messageInfo_Transaction proto.InternalMessageInfo

func (m *Transaction) GetBody() *TransactionBody {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *Transaction) GetBindingSig() []byte {
	if m != nil {
		return m.BindingSig
	}
	return nil
}

func (m *Transaction) GetAnchor() *v1alpha1.MerkleRoot {
	if m != nil {
		return m.Anchor
	}
	return nil
}

// A transaction ID, the Sha256 hash of a transaction.
type Id struct {
	Hash []byte `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
}

func (m *Id) Reset()         { *m = Id{} }
func (m *Id) String() string { return proto.CompactTextString(m) }
func (*Id) ProtoMessage()    {}
func (*Id) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{1}
}
func (m *Id) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Id) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Id.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Id) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Id.Merge(m, src)
}
func (m *Id) XXX_Size() int {
	return m.Size()
}
func (m *Id) XXX_DiscardUnknown() {
	xxx_messageInfo_Id.DiscardUnknown(m)
}

var xxx_messageInfo_Id proto.InternalMessageInfo

func (m *Id) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

// The body of a transaction.
type TransactionBody struct {
	// A list of actions (state changes) performed by this transaction.
	Actions []*Action `protobuf:"bytes,1,rep,name=actions,proto3" json:"actions,omitempty"`
	// Parameters determining if a transaction should be accepted by this chain.
	TransactionParameters *TransactionParameters `protobuf:"bytes,2,opt,name=transaction_parameters,json=transactionParameters,proto3" json:"transaction_parameters,omitempty"`
	// The transaction fee.
	Fee *v1alpha11.Fee `protobuf:"bytes,3,opt,name=fee,proto3" json:"fee,omitempty"`
	// Detection data for use with Fuzzy Message Detection
	DetectionData *DetectionData `protobuf:"bytes,4,opt,name=detection_data,json=detectionData,proto3" json:"detection_data,omitempty"`
	// Sub-message containing memo ciphertext if a memo was added to the transaction.
	MemoData *MemoData `protobuf:"bytes,5,opt,name=memo_data,json=memoData,proto3" json:"memo_data,omitempty"`
}

func (m *TransactionBody) Reset()         { *m = TransactionBody{} }
func (m *TransactionBody) String() string { return proto.CompactTextString(m) }
func (*TransactionBody) ProtoMessage()    {}
func (*TransactionBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{2}
}
func (m *TransactionBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactionBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransactionBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransactionBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionBody.Merge(m, src)
}
func (m *TransactionBody) XXX_Size() int {
	return m.Size()
}
func (m *TransactionBody) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionBody.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionBody proto.InternalMessageInfo

func (m *TransactionBody) GetActions() []*Action {
	if m != nil {
		return m.Actions
	}
	return nil
}

func (m *TransactionBody) GetTransactionParameters() *TransactionParameters {
	if m != nil {
		return m.TransactionParameters
	}
	return nil
}

func (m *TransactionBody) GetFee() *v1alpha11.Fee {
	if m != nil {
		return m.Fee
	}
	return nil
}

func (m *TransactionBody) GetDetectionData() *DetectionData {
	if m != nil {
		return m.DetectionData
	}
	return nil
}

func (m *TransactionBody) GetMemoData() *MemoData {
	if m != nil {
		return m.MemoData
	}
	return nil
}

// Represents the encrypted memo data.
type MemoData struct {
	// The encrypted data. It will only be populated if there are
	// outputs in the actions of the transaction. 528 bytes.
	EncryptedMemo []byte `protobuf:"bytes,1,opt,name=encrypted_memo,json=encryptedMemo,proto3" json:"encrypted_memo,omitempty"`
}

func (m *MemoData) Reset()         { *m = MemoData{} }
func (m *MemoData) String() string { return proto.CompactTextString(m) }
func (*MemoData) ProtoMessage()    {}
func (*MemoData) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{3}
}
func (m *MemoData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemoData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemoData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemoData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemoData.Merge(m, src)
}
func (m *MemoData) XXX_Size() int {
	return m.Size()
}
func (m *MemoData) XXX_DiscardUnknown() {
	xxx_messageInfo_MemoData.DiscardUnknown(m)
}

var xxx_messageInfo_MemoData proto.InternalMessageInfo

func (m *MemoData) GetEncryptedMemo() []byte {
	if m != nil {
		return m.EncryptedMemo
	}
	return nil
}

// The parameters determining if a transaction should be accepted by the chain.
type TransactionParameters struct {
	// The maximum height that this transaction can be included in the chain.
	//
	// If zero, there is no maximum.
	ExpiryHeight uint64 `protobuf:"varint,1,opt,name=expiry_height,json=expiryHeight,proto3" json:"expiry_height,omitempty"`
	// The chain this transaction is intended for.  Including this prevents
	// replaying a transaction on one chain onto a different chain.
	ChainId string `protobuf:"bytes,2,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
}

func (m *TransactionParameters) Reset()         { *m = TransactionParameters{} }
func (m *TransactionParameters) String() string { return proto.CompactTextString(m) }
func (*TransactionParameters) ProtoMessage()    {}
func (*TransactionParameters) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{4}
}
func (m *TransactionParameters) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactionParameters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransactionParameters.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransactionParameters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionParameters.Merge(m, src)
}
func (m *TransactionParameters) XXX_Size() int {
	return m.Size()
}
func (m *TransactionParameters) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionParameters.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionParameters proto.InternalMessageInfo

func (m *TransactionParameters) GetExpiryHeight() uint64 {
	if m != nil {
		return m.ExpiryHeight
	}
	return 0
}

func (m *TransactionParameters) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

// Detection data used by a detection server performing Fuzzy Message Detection.
type DetectionData struct {
	// A list of clues for use with Fuzzy Message Detection.
	FmdClues []*v1alpha12.Clue `protobuf:"bytes,4,rep,name=fmd_clues,json=fmdClues,proto3" json:"fmd_clues,omitempty"`
}

func (m *DetectionData) Reset()         { *m = DetectionData{} }
func (m *DetectionData) String() string { return proto.CompactTextString(m) }
func (*DetectionData) ProtoMessage()    {}
func (*DetectionData) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{5}
}
func (m *DetectionData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DetectionData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DetectionData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DetectionData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetectionData.Merge(m, src)
}
func (m *DetectionData) XXX_Size() int {
	return m.Size()
}
func (m *DetectionData) XXX_DiscardUnknown() {
	xxx_messageInfo_DetectionData.DiscardUnknown(m)
}

var xxx_messageInfo_DetectionData proto.InternalMessageInfo

func (m *DetectionData) GetFmdClues() []*v1alpha12.Clue {
	if m != nil {
		return m.FmdClues
	}
	return nil
}

// A state change performed by a transaction.
type Action struct {
	// Types that are valid to be assigned to Action:
	//	*Action_Spend
	//	*Action_Output
	//	*Action_Swap
	//	*Action_SwapClaim
	//	*Action_ValidatorDefinition
	//	*Action_IbcRelayAction
	//	*Action_ProposalSubmit
	//	*Action_ProposalWithdraw
	//	*Action_ValidatorVote
	//	*Action_DelegatorVote
	//	*Action_ProposalDepositClaim
	//	*Action_PositionOpen
	//	*Action_PositionClose
	//	*Action_PositionWithdraw
	//	*Action_PositionRewardClaim
	//	*Action_Delegate
	//	*Action_Undelegate
	//	*Action_UndelegateClaim
	//	*Action_DaoSpend
	//	*Action_DaoOutput
	//	*Action_DaoDeposit
	//	*Action_Ics20Withdrawal
	Action isAction_Action `protobuf_oneof:"action"`
}

func (m *Action) Reset()         { *m = Action{} }
func (m *Action) String() string { return proto.CompactTextString(m) }
func (*Action) ProtoMessage()    {}
func (*Action) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{6}
}
func (m *Action) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Action) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Action.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Action) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Action.Merge(m, src)
}
func (m *Action) XXX_Size() int {
	return m.Size()
}
func (m *Action) XXX_DiscardUnknown() {
	xxx_messageInfo_Action.DiscardUnknown(m)
}

var xxx_messageInfo_Action proto.InternalMessageInfo

type isAction_Action interface {
	isAction_Action()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Action_Spend struct {
	Spend *v1alpha13.Spend `protobuf:"bytes,1,opt,name=spend,proto3,oneof" json:"spend,omitempty"`
}
type Action_Output struct {
	Output *v1alpha13.Output `protobuf:"bytes,2,opt,name=output,proto3,oneof" json:"output,omitempty"`
}
type Action_Swap struct {
	Swap *v1alpha14.Swap `protobuf:"bytes,3,opt,name=swap,proto3,oneof" json:"swap,omitempty"`
}
type Action_SwapClaim struct {
	SwapClaim *v1alpha14.SwapClaim `protobuf:"bytes,4,opt,name=swap_claim,json=swapClaim,proto3,oneof" json:"swap_claim,omitempty"`
}
type Action_ValidatorDefinition struct {
	ValidatorDefinition *v1alpha15.ValidatorDefinition `protobuf:"bytes,16,opt,name=validator_definition,json=validatorDefinition,proto3,oneof" json:"validator_definition,omitempty"`
}
type Action_IbcRelayAction struct {
	IbcRelayAction *v1alpha16.IbcRelay `protobuf:"bytes,17,opt,name=ibc_relay_action,json=ibcRelayAction,proto3,oneof" json:"ibc_relay_action,omitempty"`
}
type Action_ProposalSubmit struct {
	ProposalSubmit *v1alpha17.ProposalSubmit `protobuf:"bytes,18,opt,name=proposal_submit,json=proposalSubmit,proto3,oneof" json:"proposal_submit,omitempty"`
}
type Action_ProposalWithdraw struct {
	ProposalWithdraw *v1alpha17.ProposalWithdraw `protobuf:"bytes,19,opt,name=proposal_withdraw,json=proposalWithdraw,proto3,oneof" json:"proposal_withdraw,omitempty"`
}
type Action_ValidatorVote struct {
	ValidatorVote *v1alpha17.ValidatorVote `protobuf:"bytes,20,opt,name=validator_vote,json=validatorVote,proto3,oneof" json:"validator_vote,omitempty"`
}
type Action_DelegatorVote struct {
	DelegatorVote *v1alpha17.DelegatorVote `protobuf:"bytes,21,opt,name=delegator_vote,json=delegatorVote,proto3,oneof" json:"delegator_vote,omitempty"`
}
type Action_ProposalDepositClaim struct {
	ProposalDepositClaim *v1alpha17.ProposalDepositClaim `protobuf:"bytes,22,opt,name=proposal_deposit_claim,json=proposalDepositClaim,proto3,oneof" json:"proposal_deposit_claim,omitempty"`
}
type Action_PositionOpen struct {
	PositionOpen *v1alpha14.PositionOpen `protobuf:"bytes,30,opt,name=position_open,json=positionOpen,proto3,oneof" json:"position_open,omitempty"`
}
type Action_PositionClose struct {
	PositionClose *v1alpha14.PositionClose `protobuf:"bytes,31,opt,name=position_close,json=positionClose,proto3,oneof" json:"position_close,omitempty"`
}
type Action_PositionWithdraw struct {
	PositionWithdraw *v1alpha14.PositionWithdraw `protobuf:"bytes,32,opt,name=position_withdraw,json=positionWithdraw,proto3,oneof" json:"position_withdraw,omitempty"`
}
type Action_PositionRewardClaim struct {
	PositionRewardClaim *v1alpha14.PositionRewardClaim `protobuf:"bytes,34,opt,name=position_reward_claim,json=positionRewardClaim,proto3,oneof" json:"position_reward_claim,omitempty"`
}
type Action_Delegate struct {
	Delegate *v1alpha15.Delegate `protobuf:"bytes,40,opt,name=delegate,proto3,oneof" json:"delegate,omitempty"`
}
type Action_Undelegate struct {
	Undelegate *v1alpha15.Undelegate `protobuf:"bytes,41,opt,name=undelegate,proto3,oneof" json:"undelegate,omitempty"`
}
type Action_UndelegateClaim struct {
	UndelegateClaim *v1alpha15.UndelegateClaim `protobuf:"bytes,42,opt,name=undelegate_claim,json=undelegateClaim,proto3,oneof" json:"undelegate_claim,omitempty"`
}
type Action_DaoSpend struct {
	DaoSpend *v1alpha17.DaoSpend `protobuf:"bytes,50,opt,name=dao_spend,json=daoSpend,proto3,oneof" json:"dao_spend,omitempty"`
}
type Action_DaoOutput struct {
	DaoOutput *v1alpha17.DaoOutput `protobuf:"bytes,51,opt,name=dao_output,json=daoOutput,proto3,oneof" json:"dao_output,omitempty"`
}
type Action_DaoDeposit struct {
	DaoDeposit *v1alpha17.DaoDeposit `protobuf:"bytes,52,opt,name=dao_deposit,json=daoDeposit,proto3,oneof" json:"dao_deposit,omitempty"`
}
type Action_Ics20Withdrawal struct {
	Ics20Withdrawal *v1alpha16.Ics20Withdrawal `protobuf:"bytes,200,opt,name=ics20_withdrawal,json=ics20Withdrawal,proto3,oneof" json:"ics20_withdrawal,omitempty"`
}

func (*Action_Spend) isAction_Action()                {}
func (*Action_Output) isAction_Action()               {}
func (*Action_Swap) isAction_Action()                 {}
func (*Action_SwapClaim) isAction_Action()            {}
func (*Action_ValidatorDefinition) isAction_Action()  {}
func (*Action_IbcRelayAction) isAction_Action()       {}
func (*Action_ProposalSubmit) isAction_Action()       {}
func (*Action_ProposalWithdraw) isAction_Action()     {}
func (*Action_ValidatorVote) isAction_Action()        {}
func (*Action_DelegatorVote) isAction_Action()        {}
func (*Action_ProposalDepositClaim) isAction_Action() {}
func (*Action_PositionOpen) isAction_Action()         {}
func (*Action_PositionClose) isAction_Action()        {}
func (*Action_PositionWithdraw) isAction_Action()     {}
func (*Action_PositionRewardClaim) isAction_Action()  {}
func (*Action_Delegate) isAction_Action()             {}
func (*Action_Undelegate) isAction_Action()           {}
func (*Action_UndelegateClaim) isAction_Action()      {}
func (*Action_DaoSpend) isAction_Action()             {}
func (*Action_DaoOutput) isAction_Action()            {}
func (*Action_DaoDeposit) isAction_Action()           {}
func (*Action_Ics20Withdrawal) isAction_Action()      {}

func (m *Action) GetAction() isAction_Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *Action) GetSpend() *v1alpha13.Spend {
	if x, ok := m.GetAction().(*Action_Spend); ok {
		return x.Spend
	}
	return nil
}

func (m *Action) GetOutput() *v1alpha13.Output {
	if x, ok := m.GetAction().(*Action_Output); ok {
		return x.Output
	}
	return nil
}

func (m *Action) GetSwap() *v1alpha14.Swap {
	if x, ok := m.GetAction().(*Action_Swap); ok {
		return x.Swap
	}
	return nil
}

func (m *Action) GetSwapClaim() *v1alpha14.SwapClaim {
	if x, ok := m.GetAction().(*Action_SwapClaim); ok {
		return x.SwapClaim
	}
	return nil
}

func (m *Action) GetValidatorDefinition() *v1alpha15.ValidatorDefinition {
	if x, ok := m.GetAction().(*Action_ValidatorDefinition); ok {
		return x.ValidatorDefinition
	}
	return nil
}

func (m *Action) GetIbcRelayAction() *v1alpha16.IbcRelay {
	if x, ok := m.GetAction().(*Action_IbcRelayAction); ok {
		return x.IbcRelayAction
	}
	return nil
}

func (m *Action) GetProposalSubmit() *v1alpha17.ProposalSubmit {
	if x, ok := m.GetAction().(*Action_ProposalSubmit); ok {
		return x.ProposalSubmit
	}
	return nil
}

func (m *Action) GetProposalWithdraw() *v1alpha17.ProposalWithdraw {
	if x, ok := m.GetAction().(*Action_ProposalWithdraw); ok {
		return x.ProposalWithdraw
	}
	return nil
}

func (m *Action) GetValidatorVote() *v1alpha17.ValidatorVote {
	if x, ok := m.GetAction().(*Action_ValidatorVote); ok {
		return x.ValidatorVote
	}
	return nil
}

func (m *Action) GetDelegatorVote() *v1alpha17.DelegatorVote {
	if x, ok := m.GetAction().(*Action_DelegatorVote); ok {
		return x.DelegatorVote
	}
	return nil
}

func (m *Action) GetProposalDepositClaim() *v1alpha17.ProposalDepositClaim {
	if x, ok := m.GetAction().(*Action_ProposalDepositClaim); ok {
		return x.ProposalDepositClaim
	}
	return nil
}

func (m *Action) GetPositionOpen() *v1alpha14.PositionOpen {
	if x, ok := m.GetAction().(*Action_PositionOpen); ok {
		return x.PositionOpen
	}
	return nil
}

func (m *Action) GetPositionClose() *v1alpha14.PositionClose {
	if x, ok := m.GetAction().(*Action_PositionClose); ok {
		return x.PositionClose
	}
	return nil
}

func (m *Action) GetPositionWithdraw() *v1alpha14.PositionWithdraw {
	if x, ok := m.GetAction().(*Action_PositionWithdraw); ok {
		return x.PositionWithdraw
	}
	return nil
}

func (m *Action) GetPositionRewardClaim() *v1alpha14.PositionRewardClaim {
	if x, ok := m.GetAction().(*Action_PositionRewardClaim); ok {
		return x.PositionRewardClaim
	}
	return nil
}

func (m *Action) GetDelegate() *v1alpha15.Delegate {
	if x, ok := m.GetAction().(*Action_Delegate); ok {
		return x.Delegate
	}
	return nil
}

func (m *Action) GetUndelegate() *v1alpha15.Undelegate {
	if x, ok := m.GetAction().(*Action_Undelegate); ok {
		return x.Undelegate
	}
	return nil
}

func (m *Action) GetUndelegateClaim() *v1alpha15.UndelegateClaim {
	if x, ok := m.GetAction().(*Action_UndelegateClaim); ok {
		return x.UndelegateClaim
	}
	return nil
}

func (m *Action) GetDaoSpend() *v1alpha17.DaoSpend {
	if x, ok := m.GetAction().(*Action_DaoSpend); ok {
		return x.DaoSpend
	}
	return nil
}

func (m *Action) GetDaoOutput() *v1alpha17.DaoOutput {
	if x, ok := m.GetAction().(*Action_DaoOutput); ok {
		return x.DaoOutput
	}
	return nil
}

func (m *Action) GetDaoDeposit() *v1alpha17.DaoDeposit {
	if x, ok := m.GetAction().(*Action_DaoDeposit); ok {
		return x.DaoDeposit
	}
	return nil
}

func (m *Action) GetIcs20Withdrawal() *v1alpha16.Ics20Withdrawal {
	if x, ok := m.GetAction().(*Action_Ics20Withdrawal); ok {
		return x.Ics20Withdrawal
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Action) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Action_Spend)(nil),
		(*Action_Output)(nil),
		(*Action_Swap)(nil),
		(*Action_SwapClaim)(nil),
		(*Action_ValidatorDefinition)(nil),
		(*Action_IbcRelayAction)(nil),
		(*Action_ProposalSubmit)(nil),
		(*Action_ProposalWithdraw)(nil),
		(*Action_ValidatorVote)(nil),
		(*Action_DelegatorVote)(nil),
		(*Action_ProposalDepositClaim)(nil),
		(*Action_PositionOpen)(nil),
		(*Action_PositionClose)(nil),
		(*Action_PositionWithdraw)(nil),
		(*Action_PositionRewardClaim)(nil),
		(*Action_Delegate)(nil),
		(*Action_Undelegate)(nil),
		(*Action_UndelegateClaim)(nil),
		(*Action_DaoSpend)(nil),
		(*Action_DaoOutput)(nil),
		(*Action_DaoDeposit)(nil),
		(*Action_Ics20Withdrawal)(nil),
	}
}

// A transaction perspective is a bundle of key material and commitment openings
// that allow generating a view of a transaction from that perspective.
type TransactionPerspective struct {
	PayloadKeys     []*PayloadKeyWithCommitment `protobuf:"bytes,1,rep,name=payload_keys,json=payloadKeys,proto3" json:"payload_keys,omitempty"`
	SpendNullifiers []*NullifierWithNote        `protobuf:"bytes,2,rep,name=spend_nullifiers,json=spendNullifiers,proto3" json:"spend_nullifiers,omitempty"`
	// The openings of note commitments referred to in the transaction
	// but not included in the transaction.
	AdviceNotes []*v1alpha13.Note `protobuf:"bytes,3,rep,name=advice_notes,json=adviceNotes,proto3" json:"advice_notes,omitempty"`
	// Any relevant address views.
	AddressViews []*v1alpha18.AddressView `protobuf:"bytes,4,rep,name=address_views,json=addressViews,proto3" json:"address_views,omitempty"`
	// Any relevant denoms for viewed assets.
	Denoms []*v1alpha19.DenomMetadata `protobuf:"bytes,5,rep,name=denoms,proto3" json:"denoms,omitempty"`
	// The transaction ID associated with this TransactionPerspective
	TransactionId *Id `protobuf:"bytes,6,opt,name=transaction_id,json=transactionId,proto3" json:"transaction_id,omitempty"`
}

func (m *TransactionPerspective) Reset()         { *m = TransactionPerspective{} }
func (m *TransactionPerspective) String() string { return proto.CompactTextString(m) }
func (*TransactionPerspective) ProtoMessage()    {}
func (*TransactionPerspective) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{7}
}
func (m *TransactionPerspective) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactionPerspective) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransactionPerspective.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransactionPerspective) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionPerspective.Merge(m, src)
}
func (m *TransactionPerspective) XXX_Size() int {
	return m.Size()
}
func (m *TransactionPerspective) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionPerspective.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionPerspective proto.InternalMessageInfo

func (m *TransactionPerspective) GetPayloadKeys() []*PayloadKeyWithCommitment {
	if m != nil {
		return m.PayloadKeys
	}
	return nil
}

func (m *TransactionPerspective) GetSpendNullifiers() []*NullifierWithNote {
	if m != nil {
		return m.SpendNullifiers
	}
	return nil
}

func (m *TransactionPerspective) GetAdviceNotes() []*v1alpha13.Note {
	if m != nil {
		return m.AdviceNotes
	}
	return nil
}

func (m *TransactionPerspective) GetAddressViews() []*v1alpha18.AddressView {
	if m != nil {
		return m.AddressViews
	}
	return nil
}

func (m *TransactionPerspective) GetDenoms() []*v1alpha19.DenomMetadata {
	if m != nil {
		return m.Denoms
	}
	return nil
}

func (m *TransactionPerspective) GetTransactionId() *Id {
	if m != nil {
		return m.TransactionId
	}
	return nil
}

type PayloadKeyWithCommitment struct {
	PayloadKey *v1alpha18.PayloadKey     `protobuf:"bytes,1,opt,name=payload_key,json=payloadKey,proto3" json:"payload_key,omitempty"`
	Commitment *v1alpha1.StateCommitment `protobuf:"bytes,2,opt,name=commitment,proto3" json:"commitment,omitempty"`
}

func (m *PayloadKeyWithCommitment) Reset()         { *m = PayloadKeyWithCommitment{} }
func (m *PayloadKeyWithCommitment) String() string { return proto.CompactTextString(m) }
func (*PayloadKeyWithCommitment) ProtoMessage()    {}
func (*PayloadKeyWithCommitment) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{8}
}
func (m *PayloadKeyWithCommitment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PayloadKeyWithCommitment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PayloadKeyWithCommitment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PayloadKeyWithCommitment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PayloadKeyWithCommitment.Merge(m, src)
}
func (m *PayloadKeyWithCommitment) XXX_Size() int {
	return m.Size()
}
func (m *PayloadKeyWithCommitment) XXX_DiscardUnknown() {
	xxx_messageInfo_PayloadKeyWithCommitment.DiscardUnknown(m)
}

var xxx_messageInfo_PayloadKeyWithCommitment proto.InternalMessageInfo

func (m *PayloadKeyWithCommitment) GetPayloadKey() *v1alpha18.PayloadKey {
	if m != nil {
		return m.PayloadKey
	}
	return nil
}

func (m *PayloadKeyWithCommitment) GetCommitment() *v1alpha1.StateCommitment {
	if m != nil {
		return m.Commitment
	}
	return nil
}

type NullifierWithNote struct {
	Nullifier *v1alpha110.Nullifier `protobuf:"bytes,1,opt,name=nullifier,proto3" json:"nullifier,omitempty"`
	Note      *v1alpha13.Note       `protobuf:"bytes,2,opt,name=note,proto3" json:"note,omitempty"`
}

func (m *NullifierWithNote) Reset()         { *m = NullifierWithNote{} }
func (m *NullifierWithNote) String() string { return proto.CompactTextString(m) }
func (*NullifierWithNote) ProtoMessage()    {}
func (*NullifierWithNote) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{9}
}
func (m *NullifierWithNote) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NullifierWithNote) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NullifierWithNote.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NullifierWithNote) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NullifierWithNote.Merge(m, src)
}
func (m *NullifierWithNote) XXX_Size() int {
	return m.Size()
}
func (m *NullifierWithNote) XXX_DiscardUnknown() {
	xxx_messageInfo_NullifierWithNote.DiscardUnknown(m)
}

var xxx_messageInfo_NullifierWithNote proto.InternalMessageInfo

func (m *NullifierWithNote) GetNullifier() *v1alpha110.Nullifier {
	if m != nil {
		return m.Nullifier
	}
	return nil
}

func (m *NullifierWithNote) GetNote() *v1alpha13.Note {
	if m != nil {
		return m.Note
	}
	return nil
}

// View of a Penumbra transaction.
type TransactionView struct {
	// View of the transaction body
	BodyView *TransactionBodyView `protobuf:"bytes,1,opt,name=body_view,json=bodyView,proto3" json:"body_view,omitempty"`
	// The binding signature is stored separately from the transaction body that it signs.
	BindingSig []byte `protobuf:"bytes,2,opt,name=binding_sig,json=bindingSig,proto3" json:"binding_sig,omitempty"`
	// The root of some previous state of the state commitment tree, used as an anchor for all
	// ZK state transition proofs.
	Anchor *v1alpha1.MerkleRoot `protobuf:"bytes,3,opt,name=anchor,proto3" json:"anchor,omitempty"`
}

func (m *TransactionView) Reset()         { *m = TransactionView{} }
func (m *TransactionView) String() string { return proto.CompactTextString(m) }
func (*TransactionView) ProtoMessage()    {}
func (*TransactionView) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{10}
}
func (m *TransactionView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactionView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransactionView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransactionView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionView.Merge(m, src)
}
func (m *TransactionView) XXX_Size() int {
	return m.Size()
}
func (m *TransactionView) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionView.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionView proto.InternalMessageInfo

func (m *TransactionView) GetBodyView() *TransactionBodyView {
	if m != nil {
		return m.BodyView
	}
	return nil
}

func (m *TransactionView) GetBindingSig() []byte {
	if m != nil {
		return m.BindingSig
	}
	return nil
}

func (m *TransactionView) GetAnchor() *v1alpha1.MerkleRoot {
	if m != nil {
		return m.Anchor
	}
	return nil
}

type TransactionBodyView struct {
	// A list views into of actions (state changes) performed by this transaction.
	ActionViews []*ActionView `protobuf:"bytes,1,rep,name=action_views,json=actionViews,proto3" json:"action_views,omitempty"`
	// Transaction parameters.
	TransactionParameters *TransactionParameters `protobuf:"bytes,2,opt,name=transaction_parameters,json=transactionParameters,proto3" json:"transaction_parameters,omitempty"`
	// The transaction fee.
	Fee *v1alpha11.Fee `protobuf:"bytes,3,opt,name=fee,proto3" json:"fee,omitempty"`
	// The detection data in this transaction, only populated if
	// there are outputs in the actions of this transaction.
	DetectionData *DetectionData `protobuf:"bytes,4,opt,name=detection_data,json=detectionData,proto3" json:"detection_data,omitempty"`
	// An optional view of a transaction memo. It will only be populated if there are
	// outputs in the actions of this transaction.
	MemoView *MemoView `protobuf:"bytes,5,opt,name=memo_view,json=memoView,proto3" json:"memo_view,omitempty"`
}

func (m *TransactionBodyView) Reset()         { *m = TransactionBodyView{} }
func (m *TransactionBodyView) String() string { return proto.CompactTextString(m) }
func (*TransactionBodyView) ProtoMessage()    {}
func (*TransactionBodyView) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{11}
}
func (m *TransactionBodyView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactionBodyView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransactionBodyView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransactionBodyView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionBodyView.Merge(m, src)
}
func (m *TransactionBodyView) XXX_Size() int {
	return m.Size()
}
func (m *TransactionBodyView) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionBodyView.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionBodyView proto.InternalMessageInfo

func (m *TransactionBodyView) GetActionViews() []*ActionView {
	if m != nil {
		return m.ActionViews
	}
	return nil
}

func (m *TransactionBodyView) GetTransactionParameters() *TransactionParameters {
	if m != nil {
		return m.TransactionParameters
	}
	return nil
}

func (m *TransactionBodyView) GetFee() *v1alpha11.Fee {
	if m != nil {
		return m.Fee
	}
	return nil
}

func (m *TransactionBodyView) GetDetectionData() *DetectionData {
	if m != nil {
		return m.DetectionData
	}
	return nil
}

func (m *TransactionBodyView) GetMemoView() *MemoView {
	if m != nil {
		return m.MemoView
	}
	return nil
}

// A view of a specific state change action performed by a transaction.
type ActionView struct {
	// Types that are valid to be assigned to ActionView:
	//	*ActionView_Spend
	//	*ActionView_Output
	//	*ActionView_Swap
	//	*ActionView_SwapClaim
	//	*ActionView_ValidatorDefinition
	//	*ActionView_IbcRelayAction
	//	*ActionView_ProposalSubmit
	//	*ActionView_ProposalWithdraw
	//	*ActionView_ValidatorVote
	//	*ActionView_DelegatorVote
	//	*ActionView_ProposalDepositClaim
	//	*ActionView_PositionOpen
	//	*ActionView_PositionClose
	//	*ActionView_PositionWithdraw
	//	*ActionView_PositionRewardClaim
	//	*ActionView_Delegate
	//	*ActionView_Undelegate
	//	*ActionView_DaoSpend
	//	*ActionView_DaoOutput
	//	*ActionView_DaoDeposit
	//	*ActionView_UndelegateClaim
	//	*ActionView_Ics20Withdrawal
	ActionView isActionView_ActionView `protobuf_oneof:"action_view"`
}

func (m *ActionView) Reset()         { *m = ActionView{} }
func (m *ActionView) String() string { return proto.CompactTextString(m) }
func (*ActionView) ProtoMessage()    {}
func (*ActionView) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{12}
}
func (m *ActionView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionView.Merge(m, src)
}
func (m *ActionView) XXX_Size() int {
	return m.Size()
}
func (m *ActionView) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionView.DiscardUnknown(m)
}

var xxx_messageInfo_ActionView proto.InternalMessageInfo

type isActionView_ActionView interface {
	isActionView_ActionView()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ActionView_Spend struct {
	Spend *v1alpha13.SpendView `protobuf:"bytes,1,opt,name=spend,proto3,oneof" json:"spend,omitempty"`
}
type ActionView_Output struct {
	Output *v1alpha13.OutputView `protobuf:"bytes,2,opt,name=output,proto3,oneof" json:"output,omitempty"`
}
type ActionView_Swap struct {
	Swap *v1alpha14.SwapView `protobuf:"bytes,3,opt,name=swap,proto3,oneof" json:"swap,omitempty"`
}
type ActionView_SwapClaim struct {
	SwapClaim *v1alpha14.SwapClaimView `protobuf:"bytes,4,opt,name=swap_claim,json=swapClaim,proto3,oneof" json:"swap_claim,omitempty"`
}
type ActionView_ValidatorDefinition struct {
	ValidatorDefinition *v1alpha15.ValidatorDefinition `protobuf:"bytes,16,opt,name=validator_definition,json=validatorDefinition,proto3,oneof" json:"validator_definition,omitempty"`
}
type ActionView_IbcRelayAction struct {
	IbcRelayAction *v1alpha16.IbcRelay `protobuf:"bytes,17,opt,name=ibc_relay_action,json=ibcRelayAction,proto3,oneof" json:"ibc_relay_action,omitempty"`
}
type ActionView_ProposalSubmit struct {
	ProposalSubmit *v1alpha17.ProposalSubmit `protobuf:"bytes,18,opt,name=proposal_submit,json=proposalSubmit,proto3,oneof" json:"proposal_submit,omitempty"`
}
type ActionView_ProposalWithdraw struct {
	ProposalWithdraw *v1alpha17.ProposalWithdraw `protobuf:"bytes,19,opt,name=proposal_withdraw,json=proposalWithdraw,proto3,oneof" json:"proposal_withdraw,omitempty"`
}
type ActionView_ValidatorVote struct {
	ValidatorVote *v1alpha17.ValidatorVote `protobuf:"bytes,20,opt,name=validator_vote,json=validatorVote,proto3,oneof" json:"validator_vote,omitempty"`
}
type ActionView_DelegatorVote struct {
	DelegatorVote *v1alpha17.DelegatorVoteView `protobuf:"bytes,21,opt,name=delegator_vote,json=delegatorVote,proto3,oneof" json:"delegator_vote,omitempty"`
}
type ActionView_ProposalDepositClaim struct {
	ProposalDepositClaim *v1alpha17.ProposalDepositClaim `protobuf:"bytes,22,opt,name=proposal_deposit_claim,json=proposalDepositClaim,proto3,oneof" json:"proposal_deposit_claim,omitempty"`
}
type ActionView_PositionOpen struct {
	PositionOpen *v1alpha14.PositionOpen `protobuf:"bytes,30,opt,name=position_open,json=positionOpen,proto3,oneof" json:"position_open,omitempty"`
}
type ActionView_PositionClose struct {
	PositionClose *v1alpha14.PositionClose `protobuf:"bytes,31,opt,name=position_close,json=positionClose,proto3,oneof" json:"position_close,omitempty"`
}
type ActionView_PositionWithdraw struct {
	PositionWithdraw *v1alpha14.PositionWithdraw `protobuf:"bytes,32,opt,name=position_withdraw,json=positionWithdraw,proto3,oneof" json:"position_withdraw,omitempty"`
}
type ActionView_PositionRewardClaim struct {
	PositionRewardClaim *v1alpha14.PositionRewardClaim `protobuf:"bytes,34,opt,name=position_reward_claim,json=positionRewardClaim,proto3,oneof" json:"position_reward_claim,omitempty"`
}
type ActionView_Delegate struct {
	Delegate *v1alpha15.Delegate `protobuf:"bytes,41,opt,name=delegate,proto3,oneof" json:"delegate,omitempty"`
}
type ActionView_Undelegate struct {
	Undelegate *v1alpha15.Undelegate `protobuf:"bytes,42,opt,name=undelegate,proto3,oneof" json:"undelegate,omitempty"`
}
type ActionView_DaoSpend struct {
	DaoSpend *v1alpha17.DaoSpend `protobuf:"bytes,50,opt,name=dao_spend,json=daoSpend,proto3,oneof" json:"dao_spend,omitempty"`
}
type ActionView_DaoOutput struct {
	DaoOutput *v1alpha17.DaoOutput `protobuf:"bytes,51,opt,name=dao_output,json=daoOutput,proto3,oneof" json:"dao_output,omitempty"`
}
type ActionView_DaoDeposit struct {
	DaoDeposit *v1alpha17.DaoDeposit `protobuf:"bytes,52,opt,name=dao_deposit,json=daoDeposit,proto3,oneof" json:"dao_deposit,omitempty"`
}
type ActionView_UndelegateClaim struct {
	UndelegateClaim *v1alpha15.UndelegateClaim `protobuf:"bytes,43,opt,name=undelegate_claim,json=undelegateClaim,proto3,oneof" json:"undelegate_claim,omitempty"`
}
type ActionView_Ics20Withdrawal struct {
	Ics20Withdrawal *v1alpha16.Ics20Withdrawal `protobuf:"bytes,200,opt,name=ics20_withdrawal,json=ics20Withdrawal,proto3,oneof" json:"ics20_withdrawal,omitempty"`
}

func (*ActionView_Spend) isActionView_ActionView()                {}
func (*ActionView_Output) isActionView_ActionView()               {}
func (*ActionView_Swap) isActionView_ActionView()                 {}
func (*ActionView_SwapClaim) isActionView_ActionView()            {}
func (*ActionView_ValidatorDefinition) isActionView_ActionView()  {}
func (*ActionView_IbcRelayAction) isActionView_ActionView()       {}
func (*ActionView_ProposalSubmit) isActionView_ActionView()       {}
func (*ActionView_ProposalWithdraw) isActionView_ActionView()     {}
func (*ActionView_ValidatorVote) isActionView_ActionView()        {}
func (*ActionView_DelegatorVote) isActionView_ActionView()        {}
func (*ActionView_ProposalDepositClaim) isActionView_ActionView() {}
func (*ActionView_PositionOpen) isActionView_ActionView()         {}
func (*ActionView_PositionClose) isActionView_ActionView()        {}
func (*ActionView_PositionWithdraw) isActionView_ActionView()     {}
func (*ActionView_PositionRewardClaim) isActionView_ActionView()  {}
func (*ActionView_Delegate) isActionView_ActionView()             {}
func (*ActionView_Undelegate) isActionView_ActionView()           {}
func (*ActionView_DaoSpend) isActionView_ActionView()             {}
func (*ActionView_DaoOutput) isActionView_ActionView()            {}
func (*ActionView_DaoDeposit) isActionView_ActionView()           {}
func (*ActionView_UndelegateClaim) isActionView_ActionView()      {}
func (*ActionView_Ics20Withdrawal) isActionView_ActionView()      {}

func (m *ActionView) GetActionView() isActionView_ActionView {
	if m != nil {
		return m.ActionView
	}
	return nil
}

func (m *ActionView) GetSpend() *v1alpha13.SpendView {
	if x, ok := m.GetActionView().(*ActionView_Spend); ok {
		return x.Spend
	}
	return nil
}

func (m *ActionView) GetOutput() *v1alpha13.OutputView {
	if x, ok := m.GetActionView().(*ActionView_Output); ok {
		return x.Output
	}
	return nil
}

func (m *ActionView) GetSwap() *v1alpha14.SwapView {
	if x, ok := m.GetActionView().(*ActionView_Swap); ok {
		return x.Swap
	}
	return nil
}

func (m *ActionView) GetSwapClaim() *v1alpha14.SwapClaimView {
	if x, ok := m.GetActionView().(*ActionView_SwapClaim); ok {
		return x.SwapClaim
	}
	return nil
}

func (m *ActionView) GetValidatorDefinition() *v1alpha15.ValidatorDefinition {
	if x, ok := m.GetActionView().(*ActionView_ValidatorDefinition); ok {
		return x.ValidatorDefinition
	}
	return nil
}

func (m *ActionView) GetIbcRelayAction() *v1alpha16.IbcRelay {
	if x, ok := m.GetActionView().(*ActionView_IbcRelayAction); ok {
		return x.IbcRelayAction
	}
	return nil
}

func (m *ActionView) GetProposalSubmit() *v1alpha17.ProposalSubmit {
	if x, ok := m.GetActionView().(*ActionView_ProposalSubmit); ok {
		return x.ProposalSubmit
	}
	return nil
}

func (m *ActionView) GetProposalWithdraw() *v1alpha17.ProposalWithdraw {
	if x, ok := m.GetActionView().(*ActionView_ProposalWithdraw); ok {
		return x.ProposalWithdraw
	}
	return nil
}

func (m *ActionView) GetValidatorVote() *v1alpha17.ValidatorVote {
	if x, ok := m.GetActionView().(*ActionView_ValidatorVote); ok {
		return x.ValidatorVote
	}
	return nil
}

func (m *ActionView) GetDelegatorVote() *v1alpha17.DelegatorVoteView {
	if x, ok := m.GetActionView().(*ActionView_DelegatorVote); ok {
		return x.DelegatorVote
	}
	return nil
}

func (m *ActionView) GetProposalDepositClaim() *v1alpha17.ProposalDepositClaim {
	if x, ok := m.GetActionView().(*ActionView_ProposalDepositClaim); ok {
		return x.ProposalDepositClaim
	}
	return nil
}

func (m *ActionView) GetPositionOpen() *v1alpha14.PositionOpen {
	if x, ok := m.GetActionView().(*ActionView_PositionOpen); ok {
		return x.PositionOpen
	}
	return nil
}

func (m *ActionView) GetPositionClose() *v1alpha14.PositionClose {
	if x, ok := m.GetActionView().(*ActionView_PositionClose); ok {
		return x.PositionClose
	}
	return nil
}

func (m *ActionView) GetPositionWithdraw() *v1alpha14.PositionWithdraw {
	if x, ok := m.GetActionView().(*ActionView_PositionWithdraw); ok {
		return x.PositionWithdraw
	}
	return nil
}

func (m *ActionView) GetPositionRewardClaim() *v1alpha14.PositionRewardClaim {
	if x, ok := m.GetActionView().(*ActionView_PositionRewardClaim); ok {
		return x.PositionRewardClaim
	}
	return nil
}

func (m *ActionView) GetDelegate() *v1alpha15.Delegate {
	if x, ok := m.GetActionView().(*ActionView_Delegate); ok {
		return x.Delegate
	}
	return nil
}

func (m *ActionView) GetUndelegate() *v1alpha15.Undelegate {
	if x, ok := m.GetActionView().(*ActionView_Undelegate); ok {
		return x.Undelegate
	}
	return nil
}

func (m *ActionView) GetDaoSpend() *v1alpha17.DaoSpend {
	if x, ok := m.GetActionView().(*ActionView_DaoSpend); ok {
		return x.DaoSpend
	}
	return nil
}

func (m *ActionView) GetDaoOutput() *v1alpha17.DaoOutput {
	if x, ok := m.GetActionView().(*ActionView_DaoOutput); ok {
		return x.DaoOutput
	}
	return nil
}

func (m *ActionView) GetDaoDeposit() *v1alpha17.DaoDeposit {
	if x, ok := m.GetActionView().(*ActionView_DaoDeposit); ok {
		return x.DaoDeposit
	}
	return nil
}

func (m *ActionView) GetUndelegateClaim() *v1alpha15.UndelegateClaim {
	if x, ok := m.GetActionView().(*ActionView_UndelegateClaim); ok {
		return x.UndelegateClaim
	}
	return nil
}

func (m *ActionView) GetIcs20Withdrawal() *v1alpha16.Ics20Withdrawal {
	if x, ok := m.GetActionView().(*ActionView_Ics20Withdrawal); ok {
		return x.Ics20Withdrawal
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ActionView) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ActionView_Spend)(nil),
		(*ActionView_Output)(nil),
		(*ActionView_Swap)(nil),
		(*ActionView_SwapClaim)(nil),
		(*ActionView_ValidatorDefinition)(nil),
		(*ActionView_IbcRelayAction)(nil),
		(*ActionView_ProposalSubmit)(nil),
		(*ActionView_ProposalWithdraw)(nil),
		(*ActionView_ValidatorVote)(nil),
		(*ActionView_DelegatorVote)(nil),
		(*ActionView_ProposalDepositClaim)(nil),
		(*ActionView_PositionOpen)(nil),
		(*ActionView_PositionClose)(nil),
		(*ActionView_PositionWithdraw)(nil),
		(*ActionView_PositionRewardClaim)(nil),
		(*ActionView_Delegate)(nil),
		(*ActionView_Undelegate)(nil),
		(*ActionView_DaoSpend)(nil),
		(*ActionView_DaoOutput)(nil),
		(*ActionView_DaoDeposit)(nil),
		(*ActionView_UndelegateClaim)(nil),
		(*ActionView_Ics20Withdrawal)(nil),
	}
}

// An authorization hash for a Penumbra transaction.
type EffectHash struct {
	Inner []byte `protobuf:"bytes,1,opt,name=inner,proto3" json:"inner,omitempty"`
}

func (m *EffectHash) Reset()         { *m = EffectHash{} }
func (m *EffectHash) String() string { return proto.CompactTextString(m) }
func (*EffectHash) ProtoMessage()    {}
func (*EffectHash) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{13}
}
func (m *EffectHash) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EffectHash) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EffectHash.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EffectHash) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EffectHash.Merge(m, src)
}
func (m *EffectHash) XXX_Size() int {
	return m.Size()
}
func (m *EffectHash) XXX_DiscardUnknown() {
	xxx_messageInfo_EffectHash.DiscardUnknown(m)
}

var xxx_messageInfo_EffectHash proto.InternalMessageInfo

func (m *EffectHash) GetInner() []byte {
	if m != nil {
		return m.Inner
	}
	return nil
}

// The data required to authorize a transaction plan.
type AuthorizationData struct {
	// The computed auth hash for the approved transaction plan.
	EffectHash *EffectHash `protobuf:"bytes,1,opt,name=effect_hash,json=effectHash,proto3" json:"effect_hash,omitempty"`
	// The required spend authorizations, returned in the same order as the
	// Spend actions in the original request.
	SpendAuths []*v1alpha111.SpendAuthSignature `protobuf:"bytes,2,rep,name=spend_auths,json=spendAuths,proto3" json:"spend_auths,omitempty"`
	// The required delegator vote authorizations, returned in the same order as the
	// DelegatorVote actions in the original request.
	DelegatorVoteAuths []*v1alpha111.SpendAuthSignature `protobuf:"bytes,3,rep,name=delegator_vote_auths,json=delegatorVoteAuths,proto3" json:"delegator_vote_auths,omitempty"`
}

func (m *AuthorizationData) Reset()         { *m = AuthorizationData{} }
func (m *AuthorizationData) String() string { return proto.CompactTextString(m) }
func (*AuthorizationData) ProtoMessage()    {}
func (*AuthorizationData) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{14}
}
func (m *AuthorizationData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthorizationData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthorizationData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthorizationData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthorizationData.Merge(m, src)
}
func (m *AuthorizationData) XXX_Size() int {
	return m.Size()
}
func (m *AuthorizationData) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthorizationData.DiscardUnknown(m)
}

var xxx_messageInfo_AuthorizationData proto.InternalMessageInfo

func (m *AuthorizationData) GetEffectHash() *EffectHash {
	if m != nil {
		return m.EffectHash
	}
	return nil
}

func (m *AuthorizationData) GetSpendAuths() []*v1alpha111.SpendAuthSignature {
	if m != nil {
		return m.SpendAuths
	}
	return nil
}

func (m *AuthorizationData) GetDelegatorVoteAuths() []*v1alpha111.SpendAuthSignature {
	if m != nil {
		return m.DelegatorVoteAuths
	}
	return nil
}

// The data required for proving when building a transaction from a plan.
type WitnessData struct {
	// The anchor for the state transition proofs.
	Anchor *v1alpha1.MerkleRoot `protobuf:"bytes,1,opt,name=anchor,proto3" json:"anchor,omitempty"`
	// The auth paths for the notes the transaction spends, in the
	// same order as the spends in the transaction plan.
	StateCommitmentProofs []*v1alpha1.StateCommitmentProof `protobuf:"bytes,2,rep,name=state_commitment_proofs,json=stateCommitmentProofs,proto3" json:"state_commitment_proofs,omitempty"`
}

func (m *WitnessData) Reset()         { *m = WitnessData{} }
func (m *WitnessData) String() string { return proto.CompactTextString(m) }
func (*WitnessData) ProtoMessage()    {}
func (*WitnessData) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{15}
}
func (m *WitnessData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WitnessData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WitnessData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WitnessData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WitnessData.Merge(m, src)
}
func (m *WitnessData) XXX_Size() int {
	return m.Size()
}
func (m *WitnessData) XXX_DiscardUnknown() {
	xxx_messageInfo_WitnessData.DiscardUnknown(m)
}

var xxx_messageInfo_WitnessData proto.InternalMessageInfo

func (m *WitnessData) GetAnchor() *v1alpha1.MerkleRoot {
	if m != nil {
		return m.Anchor
	}
	return nil
}

func (m *WitnessData) GetStateCommitmentProofs() []*v1alpha1.StateCommitmentProof {
	if m != nil {
		return m.StateCommitmentProofs
	}
	return nil
}

// Describes a planned transaction. Permits clients to prepare a transaction
// prior submission, so that a user can review it prior to authorizing its execution.
type TransactionPlan struct {
	// The planner interface(s) for Actions to be performed, such as a Spend, Swap,
	// or Delegation. See the ActionPlan docs for a full list of options.
	Actions []*ActionPlan `protobuf:"bytes,1,rep,name=actions,proto3" json:"actions,omitempty"`
	// Time, as block height, after which TransactionPlan should be considered invalid.
	ExpiryHeight uint64 `protobuf:"varint,2,opt,name=expiry_height,json=expiryHeight,proto3" json:"expiry_height,omitempty"`
	// The name of the network for which this TransactionPlan was built.
	ChainId   string         `protobuf:"bytes,3,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	Fee       *v1alpha11.Fee `protobuf:"bytes,4,opt,name=fee,proto3" json:"fee,omitempty"`
	CluePlans []*CluePlan    `protobuf:"bytes,5,rep,name=clue_plans,json=cluePlans,proto3" json:"clue_plans,omitempty"`
	// Planning interface for constructing an optional Memo for the Transaction.
	MemoPlan *MemoPlan `protobuf:"bytes,6,opt,name=memo_plan,json=memoPlan,proto3" json:"memo_plan,omitempty"`
}

func (m *TransactionPlan) Reset()         { *m = TransactionPlan{} }
func (m *TransactionPlan) String() string { return proto.CompactTextString(m) }
func (*TransactionPlan) ProtoMessage()    {}
func (*TransactionPlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{16}
}
func (m *TransactionPlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactionPlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransactionPlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransactionPlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionPlan.Merge(m, src)
}
func (m *TransactionPlan) XXX_Size() int {
	return m.Size()
}
func (m *TransactionPlan) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionPlan.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionPlan proto.InternalMessageInfo

func (m *TransactionPlan) GetActions() []*ActionPlan {
	if m != nil {
		return m.Actions
	}
	return nil
}

func (m *TransactionPlan) GetExpiryHeight() uint64 {
	if m != nil {
		return m.ExpiryHeight
	}
	return 0
}

func (m *TransactionPlan) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *TransactionPlan) GetFee() *v1alpha11.Fee {
	if m != nil {
		return m.Fee
	}
	return nil
}

func (m *TransactionPlan) GetCluePlans() []*CluePlan {
	if m != nil {
		return m.CluePlans
	}
	return nil
}

func (m *TransactionPlan) GetMemoPlan() *MemoPlan {
	if m != nil {
		return m.MemoPlan
	}
	return nil
}

// Describes a planned transaction action.
//
// Some transaction Actions don't have any private data and are treated as being plans
// themselves.
type ActionPlan struct {
	// Types that are valid to be assigned to Action:
	//
	//	*ActionPlan_Spend
	//	*ActionPlan_Output
	//	*ActionPlan_Swap
	//	*ActionPlan_SwapClaim
	//	*ActionPlan_ValidatorDefinition
	//	*ActionPlan_IbcRelayAction
	//	*ActionPlan_ProposalSubmit
	//	*ActionPlan_ProposalWithdraw
	//	*ActionPlan_ValidatorVote
	//	*ActionPlan_DelegatorVote
	//	*ActionPlan_ProposalDepositClaim
	//	*ActionPlan_Withdrawal
	//	*ActionPlan_PositionOpen
	//	*ActionPlan_PositionClose
	//	*ActionPlan_PositionWithdraw
	//	*ActionPlan_PositionRewardClaim
	//	*ActionPlan_Delegate
	//	*ActionPlan_Undelegate
	//	*ActionPlan_UndelegateClaim
	//	*ActionPlan_DaoSpend
	//	*ActionPlan_DaoOutput
	//	*ActionPlan_DaoDeposit
	Action isActionPlan_Action `protobuf_oneof:"action"`
}

func (m *ActionPlan) Reset()         { *m = ActionPlan{} }
func (m *ActionPlan) String() string { return proto.CompactTextString(m) }
func (*ActionPlan) ProtoMessage()    {}
func (*ActionPlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{17}
}
func (m *ActionPlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionPlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionPlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionPlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionPlan.Merge(m, src)
}
func (m *ActionPlan) XXX_Size() int {
	return m.Size()
}
func (m *ActionPlan) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionPlan.DiscardUnknown(m)
}

var xxx_messageInfo_ActionPlan proto.InternalMessageInfo

type isActionPlan_Action interface {
	isActionPlan_Action()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ActionPlan_Spend struct {
	Spend *v1alpha13.SpendPlan `protobuf:"bytes,1,opt,name=spend,proto3,oneof" json:"spend,omitempty"`
}
type ActionPlan_Output struct {
	Output *v1alpha13.OutputPlan `protobuf:"bytes,2,opt,name=output,proto3,oneof" json:"output,omitempty"`
}
type ActionPlan_Swap struct {
	Swap *v1alpha14.SwapPlan `protobuf:"bytes,3,opt,name=swap,proto3,oneof" json:"swap,omitempty"`
}
type ActionPlan_SwapClaim struct {
	SwapClaim *v1alpha14.SwapClaimPlan `protobuf:"bytes,4,opt,name=swap_claim,json=swapClaim,proto3,oneof" json:"swap_claim,omitempty"`
}
type ActionPlan_ValidatorDefinition struct {
	ValidatorDefinition *v1alpha15.ValidatorDefinition `protobuf:"bytes,16,opt,name=validator_definition,json=validatorDefinition,proto3,oneof" json:"validator_definition,omitempty"`
}
type ActionPlan_IbcRelayAction struct {
	IbcRelayAction *v1alpha16.IbcRelay `protobuf:"bytes,17,opt,name=ibc_relay_action,json=ibcRelayAction,proto3,oneof" json:"ibc_relay_action,omitempty"`
}
type ActionPlan_ProposalSubmit struct {
	ProposalSubmit *v1alpha17.ProposalSubmit `protobuf:"bytes,18,opt,name=proposal_submit,json=proposalSubmit,proto3,oneof" json:"proposal_submit,omitempty"`
}
type ActionPlan_ProposalWithdraw struct {
	ProposalWithdraw *v1alpha17.ProposalWithdraw `protobuf:"bytes,19,opt,name=proposal_withdraw,json=proposalWithdraw,proto3,oneof" json:"proposal_withdraw,omitempty"`
}
type ActionPlan_ValidatorVote struct {
	ValidatorVote *v1alpha17.ValidatorVote `protobuf:"bytes,20,opt,name=validator_vote,json=validatorVote,proto3,oneof" json:"validator_vote,omitempty"`
}
type ActionPlan_DelegatorVote struct {
	DelegatorVote *v1alpha17.DelegatorVotePlan `protobuf:"bytes,21,opt,name=delegator_vote,json=delegatorVote,proto3,oneof" json:"delegator_vote,omitempty"`
}
type ActionPlan_ProposalDepositClaim struct {
	ProposalDepositClaim *v1alpha17.ProposalDepositClaim `protobuf:"bytes,22,opt,name=proposal_deposit_claim,json=proposalDepositClaim,proto3,oneof" json:"proposal_deposit_claim,omitempty"`
}
type ActionPlan_Withdrawal struct {
	Withdrawal *v1alpha16.Ics20Withdrawal `protobuf:"bytes,23,opt,name=withdrawal,proto3,oneof" json:"withdrawal,omitempty"`
}
type ActionPlan_PositionOpen struct {
	PositionOpen *v1alpha14.PositionOpen `protobuf:"bytes,30,opt,name=position_open,json=positionOpen,proto3,oneof" json:"position_open,omitempty"`
}
type ActionPlan_PositionClose struct {
	PositionClose *v1alpha14.PositionClose `protobuf:"bytes,31,opt,name=position_close,json=positionClose,proto3,oneof" json:"position_close,omitempty"`
}
type ActionPlan_PositionWithdraw struct {
	PositionWithdraw *v1alpha14.PositionWithdrawPlan `protobuf:"bytes,32,opt,name=position_withdraw,json=positionWithdraw,proto3,oneof" json:"position_withdraw,omitempty"`
}
type ActionPlan_PositionRewardClaim struct {
	PositionRewardClaim *v1alpha14.PositionRewardClaimPlan `protobuf:"bytes,34,opt,name=position_reward_claim,json=positionRewardClaim,proto3,oneof" json:"position_reward_claim,omitempty"`
}
type ActionPlan_Delegate struct {
	Delegate *v1alpha15.Delegate `protobuf:"bytes,40,opt,name=delegate,proto3,oneof" json:"delegate,omitempty"`
}
type ActionPlan_Undelegate struct {
	Undelegate *v1alpha15.Undelegate `protobuf:"bytes,41,opt,name=undelegate,proto3,oneof" json:"undelegate,omitempty"`
}
type ActionPlan_UndelegateClaim struct {
	UndelegateClaim *v1alpha15.UndelegateClaimPlan `protobuf:"bytes,42,opt,name=undelegate_claim,json=undelegateClaim,proto3,oneof" json:"undelegate_claim,omitempty"`
}
type ActionPlan_DaoSpend struct {
	DaoSpend *v1alpha17.DaoSpend `protobuf:"bytes,50,opt,name=dao_spend,json=daoSpend,proto3,oneof" json:"dao_spend,omitempty"`
}
type ActionPlan_DaoOutput struct {
	DaoOutput *v1alpha17.DaoOutput `protobuf:"bytes,51,opt,name=dao_output,json=daoOutput,proto3,oneof" json:"dao_output,omitempty"`
}
type ActionPlan_DaoDeposit struct {
	DaoDeposit *v1alpha17.DaoDeposit `protobuf:"bytes,52,opt,name=dao_deposit,json=daoDeposit,proto3,oneof" json:"dao_deposit,omitempty"`
}

func (*ActionPlan_Spend) isActionPlan_Action()                {}
func (*ActionPlan_Output) isActionPlan_Action()               {}
func (*ActionPlan_Swap) isActionPlan_Action()                 {}
func (*ActionPlan_SwapClaim) isActionPlan_Action()            {}
func (*ActionPlan_ValidatorDefinition) isActionPlan_Action()  {}
func (*ActionPlan_IbcRelayAction) isActionPlan_Action()       {}
func (*ActionPlan_ProposalSubmit) isActionPlan_Action()       {}
func (*ActionPlan_ProposalWithdraw) isActionPlan_Action()     {}
func (*ActionPlan_ValidatorVote) isActionPlan_Action()        {}
func (*ActionPlan_DelegatorVote) isActionPlan_Action()        {}
func (*ActionPlan_ProposalDepositClaim) isActionPlan_Action() {}
func (*ActionPlan_Withdrawal) isActionPlan_Action()           {}
func (*ActionPlan_PositionOpen) isActionPlan_Action()         {}
func (*ActionPlan_PositionClose) isActionPlan_Action()        {}
func (*ActionPlan_PositionWithdraw) isActionPlan_Action()     {}
func (*ActionPlan_PositionRewardClaim) isActionPlan_Action()  {}
func (*ActionPlan_Delegate) isActionPlan_Action()             {}
func (*ActionPlan_Undelegate) isActionPlan_Action()           {}
func (*ActionPlan_UndelegateClaim) isActionPlan_Action()      {}
func (*ActionPlan_DaoSpend) isActionPlan_Action()             {}
func (*ActionPlan_DaoOutput) isActionPlan_Action()            {}
func (*ActionPlan_DaoDeposit) isActionPlan_Action()           {}

func (m *ActionPlan) GetAction() isActionPlan_Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *ActionPlan) GetSpend() *v1alpha13.SpendPlan {
	if x, ok := m.GetAction().(*ActionPlan_Spend); ok {
		return x.Spend
	}
	return nil
}

func (m *ActionPlan) GetOutput() *v1alpha13.OutputPlan {
	if x, ok := m.GetAction().(*ActionPlan_Output); ok {
		return x.Output
	}
	return nil
}

func (m *ActionPlan) GetSwap() *v1alpha14.SwapPlan {
	if x, ok := m.GetAction().(*ActionPlan_Swap); ok {
		return x.Swap
	}
	return nil
}

func (m *ActionPlan) GetSwapClaim() *v1alpha14.SwapClaimPlan {
	if x, ok := m.GetAction().(*ActionPlan_SwapClaim); ok {
		return x.SwapClaim
	}
	return nil
}

func (m *ActionPlan) GetValidatorDefinition() *v1alpha15.ValidatorDefinition {
	if x, ok := m.GetAction().(*ActionPlan_ValidatorDefinition); ok {
		return x.ValidatorDefinition
	}
	return nil
}

func (m *ActionPlan) GetIbcRelayAction() *v1alpha16.IbcRelay {
	if x, ok := m.GetAction().(*ActionPlan_IbcRelayAction); ok {
		return x.IbcRelayAction
	}
	return nil
}

func (m *ActionPlan) GetProposalSubmit() *v1alpha17.ProposalSubmit {
	if x, ok := m.GetAction().(*ActionPlan_ProposalSubmit); ok {
		return x.ProposalSubmit
	}
	return nil
}

func (m *ActionPlan) GetProposalWithdraw() *v1alpha17.ProposalWithdraw {
	if x, ok := m.GetAction().(*ActionPlan_ProposalWithdraw); ok {
		return x.ProposalWithdraw
	}
	return nil
}

func (m *ActionPlan) GetValidatorVote() *v1alpha17.ValidatorVote {
	if x, ok := m.GetAction().(*ActionPlan_ValidatorVote); ok {
		return x.ValidatorVote
	}
	return nil
}

func (m *ActionPlan) GetDelegatorVote() *v1alpha17.DelegatorVotePlan {
	if x, ok := m.GetAction().(*ActionPlan_DelegatorVote); ok {
		return x.DelegatorVote
	}
	return nil
}

func (m *ActionPlan) GetProposalDepositClaim() *v1alpha17.ProposalDepositClaim {
	if x, ok := m.GetAction().(*ActionPlan_ProposalDepositClaim); ok {
		return x.ProposalDepositClaim
	}
	return nil
}

func (m *ActionPlan) GetWithdrawal() *v1alpha16.Ics20Withdrawal {
	if x, ok := m.GetAction().(*ActionPlan_Withdrawal); ok {
		return x.Withdrawal
	}
	return nil
}

func (m *ActionPlan) GetPositionOpen() *v1alpha14.PositionOpen {
	if x, ok := m.GetAction().(*ActionPlan_PositionOpen); ok {
		return x.PositionOpen
	}
	return nil
}

func (m *ActionPlan) GetPositionClose() *v1alpha14.PositionClose {
	if x, ok := m.GetAction().(*ActionPlan_PositionClose); ok {
		return x.PositionClose
	}
	return nil
}

func (m *ActionPlan) GetPositionWithdraw() *v1alpha14.PositionWithdrawPlan {
	if x, ok := m.GetAction().(*ActionPlan_PositionWithdraw); ok {
		return x.PositionWithdraw
	}
	return nil
}

func (m *ActionPlan) GetPositionRewardClaim() *v1alpha14.PositionRewardClaimPlan {
	if x, ok := m.GetAction().(*ActionPlan_PositionRewardClaim); ok {
		return x.PositionRewardClaim
	}
	return nil
}

func (m *ActionPlan) GetDelegate() *v1alpha15.Delegate {
	if x, ok := m.GetAction().(*ActionPlan_Delegate); ok {
		return x.Delegate
	}
	return nil
}

func (m *ActionPlan) GetUndelegate() *v1alpha15.Undelegate {
	if x, ok := m.GetAction().(*ActionPlan_Undelegate); ok {
		return x.Undelegate
	}
	return nil
}

func (m *ActionPlan) GetUndelegateClaim() *v1alpha15.UndelegateClaimPlan {
	if x, ok := m.GetAction().(*ActionPlan_UndelegateClaim); ok {
		return x.UndelegateClaim
	}
	return nil
}

func (m *ActionPlan) GetDaoSpend() *v1alpha17.DaoSpend {
	if x, ok := m.GetAction().(*ActionPlan_DaoSpend); ok {
		return x.DaoSpend
	}
	return nil
}

func (m *ActionPlan) GetDaoOutput() *v1alpha17.DaoOutput {
	if x, ok := m.GetAction().(*ActionPlan_DaoOutput); ok {
		return x.DaoOutput
	}
	return nil
}

func (m *ActionPlan) GetDaoDeposit() *v1alpha17.DaoDeposit {
	if x, ok := m.GetAction().(*ActionPlan_DaoDeposit); ok {
		return x.DaoDeposit
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ActionPlan) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ActionPlan_Spend)(nil),
		(*ActionPlan_Output)(nil),
		(*ActionPlan_Swap)(nil),
		(*ActionPlan_SwapClaim)(nil),
		(*ActionPlan_ValidatorDefinition)(nil),
		(*ActionPlan_IbcRelayAction)(nil),
		(*ActionPlan_ProposalSubmit)(nil),
		(*ActionPlan_ProposalWithdraw)(nil),
		(*ActionPlan_ValidatorVote)(nil),
		(*ActionPlan_DelegatorVote)(nil),
		(*ActionPlan_ProposalDepositClaim)(nil),
		(*ActionPlan_Withdrawal)(nil),
		(*ActionPlan_PositionOpen)(nil),
		(*ActionPlan_PositionClose)(nil),
		(*ActionPlan_PositionWithdraw)(nil),
		(*ActionPlan_PositionRewardClaim)(nil),
		(*ActionPlan_Delegate)(nil),
		(*ActionPlan_Undelegate)(nil),
		(*ActionPlan_UndelegateClaim)(nil),
		(*ActionPlan_DaoSpend)(nil),
		(*ActionPlan_DaoOutput)(nil),
		(*ActionPlan_DaoDeposit)(nil),
	}
}

// Describes a plan for forming a `Clue`.
type CluePlan struct {
	// The address.
	Address *v1alpha18.Address `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// The random seed to use for the clue plan.
	Rseed []byte `protobuf:"bytes,2,opt,name=rseed,proto3" json:"rseed,omitempty"`
	// The bits of precision.
	PrecisionBits uint64 `protobuf:"varint,3,opt,name=precision_bits,json=precisionBits,proto3" json:"precision_bits,omitempty"`
}

func (m *CluePlan) Reset()         { *m = CluePlan{} }
func (m *CluePlan) String() string { return proto.CompactTextString(m) }
func (*CluePlan) ProtoMessage()    {}
func (*CluePlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{18}
}
func (m *CluePlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CluePlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CluePlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CluePlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CluePlan.Merge(m, src)
}
func (m *CluePlan) XXX_Size() int {
	return m.Size()
}
func (m *CluePlan) XXX_DiscardUnknown() {
	xxx_messageInfo_CluePlan.DiscardUnknown(m)
}

var xxx_messageInfo_CluePlan proto.InternalMessageInfo

func (m *CluePlan) GetAddress() *v1alpha18.Address {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *CluePlan) GetRseed() []byte {
	if m != nil {
		return m.Rseed
	}
	return nil
}

func (m *CluePlan) GetPrecisionBits() uint64 {
	if m != nil {
		return m.PrecisionBits
	}
	return 0
}

// Describes a plan for forming a `Memo`.
type MemoPlan struct {
	// The plaintext.
	Plaintext *MemoPlaintext `protobuf:"bytes,1,opt,name=plaintext,proto3" json:"plaintext,omitempty"`
	// The key to use to encrypt the memo.
	Key []byte `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *MemoPlan) Reset()         { *m = MemoPlan{} }
func (m *MemoPlan) String() string { return proto.CompactTextString(m) }
func (*MemoPlan) ProtoMessage()    {}
func (*MemoPlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{19}
}
func (m *MemoPlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemoPlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemoPlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemoPlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemoPlan.Merge(m, src)
}
func (m *MemoPlan) XXX_Size() int {
	return m.Size()
}
func (m *MemoPlan) XXX_DiscardUnknown() {
	xxx_messageInfo_MemoPlan.DiscardUnknown(m)
}

var xxx_messageInfo_MemoPlan proto.InternalMessageInfo

func (m *MemoPlan) GetPlaintext() *MemoPlaintext {
	if m != nil {
		return m.Plaintext
	}
	return nil
}

func (m *MemoPlan) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type MemoCiphertext struct {
	Inner []byte `protobuf:"bytes,1,opt,name=inner,proto3" json:"inner,omitempty"`
}

func (m *MemoCiphertext) Reset()         { *m = MemoCiphertext{} }
func (m *MemoCiphertext) String() string { return proto.CompactTextString(m) }
func (*MemoCiphertext) ProtoMessage()    {}
func (*MemoCiphertext) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{20}
}
func (m *MemoCiphertext) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemoCiphertext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemoCiphertext.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemoCiphertext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemoCiphertext.Merge(m, src)
}
func (m *MemoCiphertext) XXX_Size() int {
	return m.Size()
}
func (m *MemoCiphertext) XXX_DiscardUnknown() {
	xxx_messageInfo_MemoCiphertext.DiscardUnknown(m)
}

var xxx_messageInfo_MemoCiphertext proto.InternalMessageInfo

func (m *MemoCiphertext) GetInner() []byte {
	if m != nil {
		return m.Inner
	}
	return nil
}

type MemoPlaintext struct {
	ReturnAddress *v1alpha18.Address `protobuf:"bytes,1,opt,name=return_address,json=returnAddress,proto3" json:"return_address,omitempty"`
	Text          string             `protobuf:"bytes,2,opt,name=text,proto3" json:"text,omitempty"`
}

func (m *MemoPlaintext) Reset()         { *m = MemoPlaintext{} }
func (m *MemoPlaintext) String() string { return proto.CompactTextString(m) }
func (*MemoPlaintext) ProtoMessage()    {}
func (*MemoPlaintext) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{21}
}
func (m *MemoPlaintext) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemoPlaintext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemoPlaintext.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemoPlaintext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemoPlaintext.Merge(m, src)
}
func (m *MemoPlaintext) XXX_Size() int {
	return m.Size()
}
func (m *MemoPlaintext) XXX_DiscardUnknown() {
	xxx_messageInfo_MemoPlaintext.DiscardUnknown(m)
}

var xxx_messageInfo_MemoPlaintext proto.InternalMessageInfo

func (m *MemoPlaintext) GetReturnAddress() *v1alpha18.Address {
	if m != nil {
		return m.ReturnAddress
	}
	return nil
}

func (m *MemoPlaintext) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

type MemoPlaintextView struct {
	ReturnAddress *v1alpha18.AddressView `protobuf:"bytes,1,opt,name=return_address,json=returnAddress,proto3" json:"return_address,omitempty"`
	Text          string                 `protobuf:"bytes,2,opt,name=text,proto3" json:"text,omitempty"`
}

func (m *MemoPlaintextView) Reset()         { *m = MemoPlaintextView{} }
func (m *MemoPlaintextView) String() string { return proto.CompactTextString(m) }
func (*MemoPlaintextView) ProtoMessage()    {}
func (*MemoPlaintextView) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{22}
}
func (m *MemoPlaintextView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemoPlaintextView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemoPlaintextView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemoPlaintextView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemoPlaintextView.Merge(m, src)
}
func (m *MemoPlaintextView) XXX_Size() int {
	return m.Size()
}
func (m *MemoPlaintextView) XXX_DiscardUnknown() {
	xxx_messageInfo_MemoPlaintextView.DiscardUnknown(m)
}

var xxx_messageInfo_MemoPlaintextView proto.InternalMessageInfo

func (m *MemoPlaintextView) GetReturnAddress() *v1alpha18.AddressView {
	if m != nil {
		return m.ReturnAddress
	}
	return nil
}

func (m *MemoPlaintextView) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

type MemoView struct {
	// Types that are valid to be assigned to MemoView:
	//
	//	*MemoView_Visible_
	//	*MemoView_Opaque_
	MemoView isMemoView_MemoView `protobuf_oneof:"memo_view"`
}

func (m *MemoView) Reset()         { *m = MemoView{} }
func (m *MemoView) String() string { return proto.CompactTextString(m) }
func (*MemoView) ProtoMessage()    {}
func (*MemoView) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{23}
}
func (m *MemoView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemoView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemoView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemoView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemoView.Merge(m, src)
}
func (m *MemoView) XXX_Size() int {
	return m.Size()
}
func (m *MemoView) XXX_DiscardUnknown() {
	xxx_messageInfo_MemoView.DiscardUnknown(m)
}

var xxx_messageInfo_MemoView proto.InternalMessageInfo

type isMemoView_MemoView interface {
	isMemoView_MemoView()
	MarshalTo([]byte) (int, error)
	Size() int
}

type MemoView_Visible_ struct {
	Visible *MemoView_Visible `protobuf:"bytes,1,opt,name=visible,proto3,oneof" json:"visible,omitempty"`
}
type MemoView_Opaque_ struct {
	Opaque *MemoView_Opaque `protobuf:"bytes,2,opt,name=opaque,proto3,oneof" json:"opaque,omitempty"`
}

func (*MemoView_Visible_) isMemoView_MemoView() {}
func (*MemoView_Opaque_) isMemoView_MemoView()  {}

func (m *MemoView) GetMemoView() isMemoView_MemoView {
	if m != nil {
		return m.MemoView
	}
	return nil
}

func (m *MemoView) GetVisible() *MemoView_Visible {
	if x, ok := m.GetMemoView().(*MemoView_Visible_); ok {
		return x.Visible
	}
	return nil
}

func (m *MemoView) GetOpaque() *MemoView_Opaque {
	if x, ok := m.GetMemoView().(*MemoView_Opaque_); ok {
		return x.Opaque
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MemoView) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MemoView_Visible_)(nil),
		(*MemoView_Opaque_)(nil),
	}
}

type MemoView_Visible struct {
	Ciphertext *MemoCiphertext    `protobuf:"bytes,1,opt,name=ciphertext,proto3" json:"ciphertext,omitempty"`
	Plaintext  *MemoPlaintextView `protobuf:"bytes,2,opt,name=plaintext,proto3" json:"plaintext,omitempty"`
}

func (m *MemoView_Visible) Reset()         { *m = MemoView_Visible{} }
func (m *MemoView_Visible) String() string { return proto.CompactTextString(m) }
func (*MemoView_Visible) ProtoMessage()    {}
func (*MemoView_Visible) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{23, 0}
}
func (m *MemoView_Visible) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemoView_Visible) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemoView_Visible.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemoView_Visible) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemoView_Visible.Merge(m, src)
}
func (m *MemoView_Visible) XXX_Size() int {
	return m.Size()
}
func (m *MemoView_Visible) XXX_DiscardUnknown() {
	xxx_messageInfo_MemoView_Visible.DiscardUnknown(m)
}

var xxx_messageInfo_MemoView_Visible proto.InternalMessageInfo

func (m *MemoView_Visible) GetCiphertext() *MemoCiphertext {
	if m != nil {
		return m.Ciphertext
	}
	return nil
}

func (m *MemoView_Visible) GetPlaintext() *MemoPlaintextView {
	if m != nil {
		return m.Plaintext
	}
	return nil
}

type MemoView_Opaque struct {
	Ciphertext *MemoCiphertext `protobuf:"bytes,1,opt,name=ciphertext,proto3" json:"ciphertext,omitempty"`
}

func (m *MemoView_Opaque) Reset()         { *m = MemoView_Opaque{} }
func (m *MemoView_Opaque) String() string { return proto.CompactTextString(m) }
func (*MemoView_Opaque) ProtoMessage()    {}
func (*MemoView_Opaque) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd20ea79758052c4, []int{23, 1}
}
func (m *MemoView_Opaque) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemoView_Opaque) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemoView_Opaque.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemoView_Opaque) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemoView_Opaque.Merge(m, src)
}
func (m *MemoView_Opaque) XXX_Size() int {
	return m.Size()
}
func (m *MemoView_Opaque) XXX_DiscardUnknown() {
	xxx_messageInfo_MemoView_Opaque.DiscardUnknown(m)
}

var xxx_messageInfo_MemoView_Opaque proto.InternalMessageInfo

func (m *MemoView_Opaque) GetCiphertext() *MemoCiphertext {
	if m != nil {
		return m.Ciphertext
	}
	return nil
}

func init() {
	proto.RegisterType((*Transaction)(nil), "penumbra.core.transaction.v1alpha1.Transaction")
	proto.RegisterType((*Id)(nil), "penumbra.core.transaction.v1alpha1.Id")
	proto.RegisterType((*TransactionBody)(nil), "penumbra.core.transaction.v1alpha1.TransactionBody")
	proto.RegisterType((*MemoData)(nil), "penumbra.core.transaction.v1alpha1.MemoData")
	proto.RegisterType((*TransactionParameters)(nil), "penumbra.core.transaction.v1alpha1.TransactionParameters")
	proto.RegisterType((*DetectionData)(nil), "penumbra.core.transaction.v1alpha1.DetectionData")
	proto.RegisterType((*Action)(nil), "penumbra.core.transaction.v1alpha1.Action")
	proto.RegisterType((*TransactionPerspective)(nil), "penumbra.core.transaction.v1alpha1.TransactionPerspective")
	proto.RegisterType((*PayloadKeyWithCommitment)(nil), "penumbra.core.transaction.v1alpha1.PayloadKeyWithCommitment")
	proto.RegisterType((*NullifierWithNote)(nil), "penumbra.core.transaction.v1alpha1.NullifierWithNote")
	proto.RegisterType((*TransactionView)(nil), "penumbra.core.transaction.v1alpha1.TransactionView")
	proto.RegisterType((*TransactionBodyView)(nil), "penumbra.core.transaction.v1alpha1.TransactionBodyView")
	proto.RegisterType((*ActionView)(nil), "penumbra.core.transaction.v1alpha1.ActionView")
	proto.RegisterType((*EffectHash)(nil), "penumbra.core.transaction.v1alpha1.EffectHash")
	proto.RegisterType((*AuthorizationData)(nil), "penumbra.core.transaction.v1alpha1.AuthorizationData")
	proto.RegisterType((*WitnessData)(nil), "penumbra.core.transaction.v1alpha1.WitnessData")
	proto.RegisterType((*TransactionPlan)(nil), "penumbra.core.transaction.v1alpha1.TransactionPlan")
	proto.RegisterType((*ActionPlan)(nil), "penumbra.core.transaction.v1alpha1.ActionPlan")
	proto.RegisterType((*CluePlan)(nil), "penumbra.core.transaction.v1alpha1.CluePlan")
	proto.RegisterType((*MemoPlan)(nil), "penumbra.core.transaction.v1alpha1.MemoPlan")
	proto.RegisterType((*MemoCiphertext)(nil), "penumbra.core.transaction.v1alpha1.MemoCiphertext")
	proto.RegisterType((*MemoPlaintext)(nil), "penumbra.core.transaction.v1alpha1.MemoPlaintext")
	proto.RegisterType((*MemoPlaintextView)(nil), "penumbra.core.transaction.v1alpha1.MemoPlaintextView")
	proto.RegisterType((*MemoView)(nil), "penumbra.core.transaction.v1alpha1.MemoView")
	proto.RegisterType((*MemoView_Visible)(nil), "penumbra.core.transaction.v1alpha1.MemoView.Visible")
	proto.RegisterType((*MemoView_Opaque)(nil), "penumbra.core.transaction.v1alpha1.MemoView.Opaque")
}

func init() {
	proto.RegisterFile("penumbra/core/transaction/v1alpha1/transaction.proto", fileDescriptor_cd20ea79758052c4)
}

var fileDescriptor_cd20ea79758052c4 = []byte{
	// 2372 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5a, 0xcd, 0x73, 0x1b, 0x49,
	0x15, 0x97, 0x2c, 0xc5, 0xb1, 0x9f, 0x2c, 0xc7, 0xee, 0x7c, 0xac, 0xc8, 0xc1, 0x9b, 0x1a, 0x48,
	0x70, 0xb2, 0x20, 0x6f, 0xec, 0x40, 0x58, 0x65, 0x77, 0x6b, 0x63, 0x1b, 0x56, 0xae, 0x94, 0x63,
	0xed, 0xd8, 0xc4, 0x6c, 0x70, 0xd5, 0xd0, 0x9a, 0x69, 0x59, 0x4d, 0x46, 0xd3, 0xc3, 0x74, 0x4b,
	0x8e, 0xf9, 0x07, 0xb8, 0x72, 0xe3, 0xce, 0x11, 0xa8, 0xa2, 0x0a, 0x4e, 0x14, 0x70, 0xdf, 0x5a,
	0x2e, 0x7b, 0xa1, 0x8a, 0xe2, 0x04, 0xc9, 0x8d, 0x13, 0x7f, 0x02, 0xd5, 0x3d, 0x3d, 0x5f, 0xb6,
	0x14, 0x7d, 0xc4, 0xa4, 0x76, 0xab, 0x7c, 0x4a, 0xf7, 0x4b, 0xbf, 0xdf, 0xeb, 0x7e, 0xfd, 0xa6,
	0xfb, 0xf7, 0x73, 0x0b, 0xee, 0xf9, 0xc4, 0xeb, 0x76, 0x9a, 0x01, 0x5e, 0xb1, 0x59, 0x40, 0x56,
	0x44, 0x80, 0x3d, 0x8e, 0x6d, 0x41, 0x99, 0xb7, 0xd2, 0xbb, 0x8b, 0x5d, 0xbf, 0x8d, 0xef, 0xa6,
	0x8d, 0x55, 0x3f, 0x60, 0x82, 0x21, 0x23, 0xf2, 0xaa, 0x4a, 0xaf, 0x6a, 0x7a, 0x40, 0xe4, 0x75,
	0x7d, 0x39, 0x8b, 0x8c, 0x39, 0x27, 0x22, 0xc1, 0x54, 0xdd, 0x10, 0xed, 0x7a, 0x35, 0x3b, 0xd2,
	0x66, 0x1d, 0x9f, 0x79, 0xc4, 0x13, 0x2b, 0x0e, 0x79, 0x9e, 0x78, 0x38, 0xe4, 0xf9, 0xb0, 0xf1,
	0x2d, 0x42, 0x92, 0xf1, 0x2d, 0x42, 0xf4, 0xf8, 0xf7, 0x07, 0x8d, 0x3f, 0x64, 0x3d, 0x12, 0x78,
	0xd8, 0xb3, 0x53, 0x6e, 0x89, 0x6d, 0x58, 0x34, 0xda, 0xb4, 0x13, 0x37, 0xda, 0xb4, 0x87, 0x8d,
	0xe7, 0x76, 0x6a, 0xfd, 0xdc, 0x8e, 0x56, 0xbf, 0x3e, 0x70, 0x7c, 0x9b, 0x12, 0xd7, 0x21, 0x8e,
	0xe5, 0x33, 0xe6, 0xa6, 0x3c, 0xd3, 0x66, 0x8d, 0xb1, 0x3a, 0x10, 0x43, 0xe0, 0x67, 0xa9, 0xc5,
	0xa9, 0xae, 0xf6, 0xb9, 0x95, 0xf5, 0x79, 0x46, 0x8e, 0x79, 0x32, 0x50, 0xf6, 0xf4, 0xb8, 0xef,
	0x25, 0xe3, 0x82, 0x63, 0x5f, 0xb0, 0x15, 0x87, 0xd8, 0xb8, 0xb5, 0x76, 0xff, 0xbe, 0xd5, 0xea,
	0x38, 0xe9, 0xed, 0x49, 0xac, 0xda, 0xb3, 0x36, 0xd0, 0x33, 0x70, 0x38, 0xee, 0xe3, 0x2a, 0xcd,
	0xa7, 0x67, 0x17, 0xfa, 0x8a, 0x74, 0xf6, 0x44, 0x94, 0x3d, 0xe3, 0x4f, 0x79, 0x28, 0xed, 0x25,
	0xe5, 0x87, 0x3e, 0x86, 0x62, 0x93, 0x39, 0xc7, 0x95, 0xfc, 0x8d, 0xfc, 0x72, 0x69, 0x75, 0xad,
	0x3a, 0xbc, 0x50, 0xab, 0x29, 0xf7, 0x75, 0xe6, 0x1c, 0x9b, 0x0a, 0x00, 0xbd, 0x0d, 0xa5, 0x26,
	0xf5, 0x1c, 0xea, 0x1d, 0x5a, 0x9c, 0x1e, 0x56, 0xa6, 0x6e, 0xe4, 0x97, 0xe7, 0x4c, 0xd0, 0xa6,
	0x5d, 0x7a, 0x88, 0x3e, 0x82, 0x69, 0xec, 0xd9, 0x6d, 0x16, 0x54, 0x0a, 0x2a, 0xd6, 0x72, 0x2a,
	0x96, 0x9a, 0x72, 0x55, 0xce, 0x32, 0x8e, 0xb2, 0x4d, 0x82, 0x67, 0x2e, 0x31, 0x19, 0x13, 0xa6,
	0xf6, 0x33, 0x2a, 0x30, 0xb5, 0xe5, 0x20, 0x04, 0xc5, 0x36, 0xe6, 0x6d, 0x35, 0xe3, 0x39, 0x53,
	0xb5, 0x8d, 0xdf, 0x16, 0xe0, 0xd2, 0x89, 0x69, 0xa1, 0x4d, 0xb8, 0x18, 0xf6, 0x78, 0x25, 0x7f,
	0xa3, 0xb0, 0x5c, 0x5a, 0xbd, 0x33, 0xca, 0xe2, 0x1e, 0xaa, 0xbe, 0x19, 0xb9, 0x22, 0x1f, 0xae,
	0xa5, 0xc6, 0x59, 0x3e, 0x0e, 0x70, 0x87, 0x08, 0x12, 0x70, 0xb5, 0xc2, 0xd2, 0xea, 0x7b, 0x63,
	0x66, 0xac, 0x11, 0x03, 0x98, 0x57, 0x45, 0x3f, 0x33, 0x7a, 0x00, 0x85, 0x16, 0x21, 0x3a, 0x49,
	0xb7, 0x4f, 0xc0, 0xc7, 0x95, 0x5a, 0x95, 0x9f, 0x6b, 0x1c, 0xe0, 0x07, 0x84, 0x98, 0xd2, 0x0b,
	0xfd, 0x08, 0xe6, 0x1d, 0x22, 0x48, 0x38, 0x59, 0x07, 0x0b, 0x5c, 0x29, 0x2a, 0x9c, 0xbb, 0xa3,
	0x4c, 0x73, 0x33, 0xf2, 0xdc, 0xc4, 0x02, 0x9b, 0x65, 0x27, 0xdd, 0x45, 0x5b, 0x30, 0xdb, 0x21,
	0x1d, 0x16, 0x82, 0x5e, 0x50, 0xa0, 0xdf, 0x1a, 0x05, 0x74, 0x9b, 0x74, 0x98, 0xc2, 0x9b, 0xe9,
	0xe8, 0x96, 0x71, 0x17, 0x66, 0x22, 0x2b, 0xba, 0x09, 0xf3, 0xc4, 0x53, 0xfb, 0x4f, 0x1c, 0x4b,
	0x8e, 0xd0, 0xfb, 0x5a, 0x8e, 0xad, 0x72, 0xa8, 0xb1, 0x0f, 0x57, 0xfb, 0x26, 0x11, 0x7d, 0x1d,
	0xca, 0xe4, 0xb9, 0x4f, 0x83, 0x63, 0xab, 0x4d, 0xe8, 0x61, 0x5b, 0x28, 0xf7, 0xa2, 0x39, 0x17,
	0x1a, 0xeb, 0xca, 0x86, 0xbe, 0x06, 0x33, 0x76, 0x1b, 0x53, 0xcf, 0xa2, 0x8e, 0xda, 0xb6, 0x59,
	0xf3, 0xa2, 0xea, 0x6f, 0x39, 0xc6, 0xa7, 0x50, 0xce, 0x2c, 0x1b, 0xd5, 0x61, 0xb6, 0xd5, 0x71,
	0x2c, 0xdb, 0xed, 0x12, 0x5e, 0x29, 0xaa, 0xc2, 0x79, 0xe7, 0x54, 0xa5, 0x66, 0x3e, 0xde, 0x78,
	0xa9, 0x1b, 0x6e, 0x97, 0x98, 0x33, 0xad, 0x8e, 0x23, 0x1b, 0xdc, 0xf8, 0xeb, 0x02, 0x4c, 0x87,
	0xe5, 0x84, 0xb6, 0xe1, 0x02, 0xf7, 0x89, 0xe7, 0xe8, 0xcf, 0xec, 0x3b, 0x03, 0x77, 0x35, 0x7b,
	0x58, 0xc5, 0xc8, 0xbb, 0xd2, 0xb9, 0x9e, 0x33, 0x43, 0x14, 0xd4, 0x80, 0x69, 0xd6, 0x15, 0x7e,
	0x57, 0xe8, 0x22, 0xfc, 0xee, 0xb8, 0x78, 0x3b, 0xca, 0xbb, 0x9e, 0x33, 0x35, 0x0e, 0xfa, 0x08,
	0x8a, 0xfc, 0x08, 0xfb, 0xba, 0xea, 0xee, 0x0c, 0xc4, 0x93, 0x97, 0x4a, 0x32, 0xab, 0x23, 0xec,
	0xd7, 0x73, 0xa6, 0xf2, 0x44, 0x0d, 0x00, 0xf9, 0xaf, 0x65, 0xbb, 0x98, 0x76, 0x74, 0xd5, 0xad,
	0x8c, 0x8e, 0xb3, 0x21, 0xdd, 0xea, 0x39, 0x73, 0x96, 0x47, 0x1d, 0xe4, 0xc3, 0x95, 0x1e, 0x76,
	0xa9, 0x83, 0x05, 0x0b, 0x2c, 0x87, 0xb4, 0xa8, 0x47, 0x65, 0x32, 0x2b, 0x0b, 0x0a, 0xfb, 0xc1,
	0xe0, 0x35, 0xab, 0x43, 0x3b, 0x46, 0x7f, 0x12, 0x61, 0x6c, 0xc6, 0x10, 0xf5, 0x9c, 0x79, 0xb9,
	0x77, 0xda, 0x8c, 0x9e, 0xc2, 0x02, 0x6d, 0xda, 0x56, 0x40, 0x5c, 0x7c, 0x6c, 0x85, 0xa5, 0x56,
	0x59, 0x54, 0xd1, 0xaa, 0x03, 0xa3, 0xc9, 0x8b, 0x2c, 0x8e, 0xb5, 0xd5, 0xb4, 0x4d, 0xe9, 0x5c,
	0xcf, 0x99, 0xf3, 0x54, 0xb7, 0x75, 0x09, 0xb4, 0xe0, 0x92, 0x1f, 0x30, 0x9f, 0x71, 0xec, 0x5a,
	0xbc, 0xdb, 0xec, 0x50, 0x51, 0x41, 0x43, 0x16, 0x92, 0xba, 0x5a, 0xe3, 0x08, 0x0d, 0x8d, 0xb1,
	0xab, 0x20, 0x64, 0x1c, 0x3f, 0x63, 0x41, 0x2e, 0x2c, 0xc6, 0x71, 0x8e, 0xa8, 0x68, 0x3b, 0x01,
	0x3e, 0xaa, 0x5c, 0x56, 0x91, 0x3e, 0x98, 0x28, 0xd2, 0xbe, 0x06, 0xa9, 0xe7, 0xcc, 0x05, 0xff,
	0x84, 0x0d, 0xd9, 0x30, 0x9f, 0xec, 0x51, 0x8f, 0x09, 0x52, 0xb9, 0xa2, 0x42, 0xd5, 0xc6, 0x0a,
	0x15, 0x6f, 0xd1, 0x13, 0x26, 0x48, 0x3d, 0x67, 0x96, 0x7b, 0x69, 0x83, 0x0c, 0xe2, 0x10, 0x97,
	0x1c, 0x26, 0x41, 0xae, 0x4e, 0x10, 0x64, 0x33, 0x82, 0x88, 0x82, 0x38, 0x69, 0x03, 0x3a, 0x86,
	0x6b, 0x71, 0xde, 0x1c, 0xe2, 0x33, 0x4e, 0x85, 0xae, 0xe5, 0x6b, 0x2a, 0xd8, 0xc3, 0x89, 0x92,
	0xb7, 0x19, 0x22, 0x45, 0xd5, 0x7d, 0xc5, 0xef, 0x63, 0x47, 0x9f, 0x42, 0x59, 0xf5, 0xe4, 0x99,
	0xcd, 0x7c, 0xe2, 0x55, 0x96, 0x54, 0xc4, 0xd5, 0xd1, 0xbe, 0x9e, 0x86, 0x76, 0xdd, 0xf1, 0x89,
	0x2c, 0xec, 0x39, 0x3f, 0xd5, 0x47, 0x07, 0x30, 0x1f, 0x43, 0xdb, 0x2e, 0xe3, 0xa4, 0xf2, 0x76,
	0xdf, 0x8b, 0x7e, 0x08, 0xf6, 0x86, 0x74, 0x95, 0x39, 0xf3, 0xd3, 0x06, 0x44, 0x60, 0x31, 0x46,
	0x8f, 0x6b, 0xed, 0xc6, 0x90, 0x23, 0xa9, 0x6f, 0x80, 0x4c, 0x91, 0x9d, 0xb0, 0x21, 0x06, 0x57,
	0xe3, 0x30, 0x01, 0x39, 0xc2, 0x81, 0xa3, 0x77, 0xc6, 0xe8, 0x7b, 0x05, 0x0f, 0x09, 0x65, 0x2a,
	0x84, 0x68, 0x47, 0x2e, 0xfb, 0xa7, 0xcd, 0xe8, 0x31, 0xcc, 0xe8, 0xe2, 0x20, 0x95, 0x65, 0x15,
	0xe3, 0xdd, 0x51, 0x4f, 0x1b, 0x5d, 0x65, 0x32, 0x59, 0x31, 0x06, 0xda, 0x03, 0xe8, 0x7a, 0x31,
	0xe2, 0xed, 0x21, 0xbb, 0x7b, 0x02, 0xf1, 0x87, 0xb1, 0x67, 0x3d, 0x67, 0xa6, 0x70, 0x90, 0x03,
	0x0b, 0x49, 0x4f, 0x67, 0xe4, 0x8e, 0xc2, 0xbe, 0x3f, 0x3e, 0x76, 0x94, 0x8f, 0x4b, 0xdd, 0xac,
	0x09, 0xed, 0xc1, 0xac, 0x83, 0x99, 0x15, 0x5e, 0x5f, 0xab, 0x43, 0xae, 0xaf, 0xbe, 0xdf, 0x1d,
	0x66, 0xd1, 0xf5, 0x35, 0xe3, 0xe8, 0x36, 0xda, 0x07, 0x90, 0xa8, 0xfa, 0x16, 0x5b, 0x1b, 0x52,
	0x32, 0x03, 0x60, 0xe3, 0x5b, 0x4c, 0xce, 0x30, 0xec, 0xa0, 0xa7, 0x50, 0x92, 0xc0, 0xfa, 0x0b,
	0xae, 0xdc, 0x1b, 0x92, 0x8f, 0x01, 0xc8, 0xfa, 0xf3, 0x94, 0x09, 0x77, 0xe2, 0x1e, 0xb2, 0x61,
	0x81, 0xda, 0x7c, 0xf5, 0xdd, 0xb8, 0xd6, 0xb1, 0x5b, 0xf9, 0x6c, 0xd8, 0x8d, 0x9e, 0xbd, 0x1f,
	0xa4, 0xfb, 0x7e, 0xec, 0x2d, 0xf3, 0x4d, 0xb3, 0xa6, 0xf5, 0x19, 0x98, 0x0e, 0x6f, 0x1e, 0xe3,
	0x57, 0x45, 0xb8, 0x96, 0x26, 0x3d, 0x24, 0xe0, 0xbe, 0x24, 0x2a, 0x3d, 0x82, 0x2c, 0x98, 0xf3,
	0xf1, 0xb1, 0xcb, 0xb0, 0x63, 0x49, 0xe5, 0xa1, 0x09, 0xee, 0xfb, 0xa3, 0xf0, 0xb1, 0x46, 0xe8,
	0xf7, 0x88, 0x1c, 0xcb, 0xa0, 0x1b, 0xac, 0xd3, 0xa1, 0xa2, 0x43, 0x3c, 0x61, 0x96, 0xfc, 0xf8,
	0x7f, 0x38, 0xfa, 0x09, 0x2c, 0xa8, 0x1d, 0xb7, 0xbc, 0xae, 0xeb, 0xd2, 0x16, 0x0d, 0x09, 0x6f,
	0xa1, 0xcf, 0x4a, 0xfb, 0x06, 0x79, 0x1c, 0x79, 0xc9, 0x18, 0x8f, 0x99, 0x20, 0xe6, 0x25, 0x05,
	0x17, 0xdb, 0x39, 0xda, 0x87, 0x39, 0xec, 0xf4, 0xa8, 0x4d, 0x2c, 0x8f, 0x09, 0xc2, 0x2b, 0x05,
	0x85, 0x7e, 0x6f, 0x5c, 0x26, 0xa3, 0xc0, 0x4b, 0x21, 0x92, 0x6c, 0x73, 0xb4, 0x0d, 0x65, 0xec,
	0x38, 0x01, 0xe1, 0xdc, 0xea, 0x51, 0x72, 0x14, 0x91, 0xb8, 0xe5, 0x13, 0xc8, 0x4a, 0xb1, 0x25,
	0xb4, 0x3f, 0xf4, 0x78, 0x42, 0xc9, 0x91, 0x39, 0x87, 0x93, 0x0e, 0x47, 0x1b, 0x30, 0xed, 0x10,
	0x8f, 0x75, 0x78, 0xe5, 0xc2, 0x29, 0x32, 0x28, 0x71, 0x42, 0x61, 0x9e, 0xfa, 0xfe, 0x3d, 0xd6,
	0xd9, 0x26, 0x02, 0x4b, 0x9e, 0x6c, 0x6a, 0x57, 0xb4, 0x0d, 0xf3, 0x69, 0x15, 0x41, 0x9d, 0xca,
	0xb4, 0x2a, 0x9b, 0x5b, 0xa3, 0x24, 0x73, 0xcb, 0x31, 0xcb, 0xa9, 0xff, 0xd8, 0x72, 0x8c, 0x3f,
	0xe6, 0xa1, 0x32, 0x68, 0x1f, 0x51, 0x1d, 0x4a, 0xa9, 0xda, 0xd0, 0x8c, 0xf3, 0x9b, 0xaf, 0x5c,
	0x7d, 0x82, 0x65, 0x42, 0x52, 0x05, 0x68, 0x1b, 0xc0, 0x8e, 0x71, 0x35, 0xd5, 0xfc, 0xf6, 0xab,
	0x55, 0xdb, 0xae, 0x90, 0x07, 0x47, 0x52, 0x54, 0x29, 0x00, 0xe3, 0x77, 0x79, 0x58, 0x3c, 0x55,
	0x18, 0x68, 0x1b, 0x66, 0xe3, 0x1a, 0xd3, 0x93, 0x1d, 0x4c, 0x1b, 0x79, 0x3a, 0x56, 0x8c, 0x65,
	0x26, 0x08, 0xa8, 0x0e, 0x45, 0x59, 0x4f, 0x7a, 0xb6, 0x93, 0x95, 0x93, 0x42, 0x30, 0x3e, 0xcf,
	0x67, 0x34, 0xa5, 0xac, 0x06, 0x79, 0x18, 0x4a, 0xb1, 0xab, 0x0a, 0x4b, 0x4f, 0xf6, 0xfe, 0x04,
	0x92, 0x59, 0x95, 0xd9, 0x4c, 0x53, 0xb7, 0xde, 0x84, 0x74, 0xfe, 0x4b, 0x01, 0x2e, 0xf7, 0x99,
	0x04, 0xfa, 0x04, 0xe6, 0x74, 0x4d, 0x86, 0xdf, 0x4a, 0x78, 0x90, 0x54, 0x47, 0x57, 0xca, 0x6a,
	0x29, 0xa5, 0x24, 0x45, 0xe7, 0x8a, 0xf9, 0x94, 0x62, 0x56, 0xc5, 0x32, 0xa6, 0x62, 0x0e, 0x2b,
	0xa4, 0xa3, 0x5b, 0xc6, 0x3f, 0x17, 0x00, 0x92, 0x7c, 0xa3, 0x4f, 0xb2, 0x72, 0xf2, 0xbd, 0x89,
	0xe4, 0xa4, 0x44, 0x4a, 0x24, 0xe5, 0xde, 0x09, 0x49, 0x59, 0x9b, 0x4c, 0x52, 0x6a, 0xd0, 0x48,
	0x56, 0x6e, 0x66, 0x64, 0x65, 0x75, 0x74, 0x39, 0xa8, 0x71, 0x42, 0x69, 0xb9, 0xd7, 0x47, 0x5a,
	0xae, 0x8d, 0x29, 0x2d, 0x35, 0xe0, 0xb9, 0xbc, 0x3c, 0x97, 0x97, 0x27, 0xe5, 0xe5, 0xe1, 0x00,
	0x79, 0xf9, 0xe1, 0xe4, 0xf2, 0x52, 0x57, 0xdb, 0xb9, 0xc4, 0x3c, 0x97, 0x98, 0x23, 0x48, 0xcc,
	0xdb, 0x67, 0x2e, 0x31, 0xef, 0x9c, 0x91, 0xc4, 0x3c, 0x17, 0x7f, 0xb1, 0xf8, 0xeb, 0xa7, 0xb6,
	0xdf, 0x39, 0x73, 0xb5, 0xfd, 0x46, 0x24, 0x66, 0x19, 0x4a, 0x29, 0xd2, 0x67, 0x18, 0x00, 0xdf,
	0x6f, 0xb5, 0x88, 0x2d, 0xea, 0x98, 0xb7, 0xd1, 0x15, 0xb8, 0x40, 0x3d, 0x4f, 0x73, 0xf1, 0x39,
	0x33, 0xec, 0x18, 0xbf, 0x9f, 0x82, 0xc5, 0x87, 0x5d, 0xd1, 0x66, 0x01, 0xfd, 0x39, 0x8e, 0x19,
	0xce, 0x0e, 0x94, 0x88, 0xf2, 0xb4, 0xe2, 0x17, 0x99, 0x11, 0xc9, 0x63, 0x12, 0xd0, 0x04, 0x92,
	0x04, 0xff, 0x31, 0x94, 0x42, 0xd9, 0x89, 0xbb, 0xa2, 0x1d, 0x29, 0xce, 0xda, 0xe0, 0x3f, 0xbf,
	0xab, 0x07, 0xb0, 0x2c, 0xad, 0x91, 0xb3, 0xdc, 0xa5, 0x87, 0x1e, 0x16, 0xdd, 0x80, 0x98, 0xc0,
	0x23, 0x1b, 0x47, 0x2e, 0x5c, 0xc9, 0x9e, 0xf3, 0x3a, 0x4a, 0xe1, 0xb5, 0xa3, 0xa0, 0xcc, 0x39,
	0xaf, 0xa2, 0x19, 0x7f, 0xce, 0x43, 0x69, 0x9f, 0x0a, 0x8f, 0x70, 0xae, 0x72, 0x95, 0x70, 0xf8,
	0xfc, 0x64, 0x1c, 0x1e, 0xfd, 0x14, 0xde, 0xe2, 0x42, 0x15, 0x5f, 0xac, 0xa9, 0x2c, 0x3f, 0x60,
	0xac, 0x15, 0x25, 0x6a, 0x75, 0x2c, 0x6d, 0xd6, 0x90, 0xae, 0xe6, 0x55, 0xde, 0xc7, 0xca, 0x8d,
	0xff, 0x4e, 0x65, 0xc4, 0x4f, 0xc3, 0xc5, 0x1e, 0xaa, 0x9f, 0x7c, 0x50, 0x1b, 0x43, 0x26, 0x48,
	0x80, 0xe4, 0x51, 0xed, 0xd4, 0xa3, 0xcd, 0xd4, 0x90, 0x47, 0x9b, 0x42, 0xe6, 0xd1, 0x26, 0x22,
	0xfc, 0xc5, 0x89, 0x08, 0xff, 0x23, 0x00, 0xdb, 0xed, 0x12, 0xcb, 0x77, 0xb1, 0x17, 0x89, 0xfa,
	0x91, 0x78, 0xf9, 0x86, 0xdb, 0x25, 0x6a, 0x1d, 0xb3, 0xb6, 0x6e, 0xf1, 0x98, 0xe3, 0x4b, 0x30,
	0xad, 0xe9, 0x47, 0xe6, 0xf8, 0x0a, 0x4b, 0x71, 0x7c, 0xd9, 0x32, 0xfe, 0x1e, 0x73, 0x7c, 0x95,
	0xed, 0x33, 0xe1, 0xf8, 0x12, 0xe9, 0xcc, 0x39, 0xbe, 0x06, 0x7d, 0x6d, 0x8e, 0xaf, 0x71, 0xce,
	0x8e, 0xe3, 0x6b, 0xc0, 0x73, 0x8e, 0x7f, 0xce, 0xf1, 0xdf, 0x00, 0xc7, 0xd7, 0xd5, 0xf6, 0xe5,
	0xe1, 0xf8, 0xfb, 0x00, 0x29, 0xd6, 0xf0, 0xd6, 0xeb, 0x91, 0x86, 0x14, 0xd4, 0x57, 0x57, 0x3c,
	0xd0, 0xc1, 0xe2, 0xa1, 0x36, 0x99, 0x78, 0xd0, 0x9b, 0x7e, 0x5a, 0x40, 0xf0, 0x57, 0x0b, 0x88,
	0x0f, 0x26, 0x16, 0x10, 0x3a, 0xe2, 0x57, 0xf8, 0x9d, 0xaa, 0x3d, 0xf0, 0x9d, 0xea, 0xc1, 0x84,
	0xcc, 0x59, 0xe7, 0xe4, 0xfc, 0xad, 0x6a, 0xa0, 0x5c, 0x49, 0x3d, 0x23, 0xfd, 0x22, 0x0f, 0x33,
	0x11, 0x75, 0x41, 0x1f, 0xc2, 0x45, 0xfd, 0xba, 0xa1, 0x79, 0xc5, 0x37, 0x46, 0x79, 0x16, 0x31,
	0x23, 0x27, 0xa9, 0x0e, 0x02, 0x4e, 0x88, 0xa3, 0xff, 0x48, 0x1d, 0x76, 0xd0, 0x4d, 0x98, 0xf7,
	0x03, 0x62, 0x53, 0x2e, 0xab, 0xbf, 0x49, 0x05, 0x57, 0x64, 0xa0, 0x68, 0x96, 0x63, 0xeb, 0x3a,
	0x15, 0xdc, 0xe8, 0x84, 0xbf, 0xfb, 0x51, 0x13, 0xd9, 0x81, 0x59, 0xdf, 0xc5, 0xd4, 0x13, 0xe4,
	0xb9, 0xd0, 0x53, 0xb9, 0x3b, 0x06, 0x71, 0x0a, 0x1d, 0xcd, 0x04, 0x03, 0x2d, 0x40, 0xe1, 0x19,
	0x39, 0xd6, 0xf3, 0x92, 0x4d, 0xe3, 0x16, 0xcc, 0xcb, 0xd1, 0x1b, 0xd4, 0x6f, 0x93, 0x40, 0x8d,
	0xe9, 0xaf, 0x6d, 0x7c, 0x28, 0x67, 0x50, 0xd1, 0x23, 0x98, 0x0f, 0x88, 0xe8, 0x06, 0x9e, 0x35,
	0x49, 0xae, 0xca, 0xa1, 0xaf, 0xee, 0x22, 0x04, 0x45, 0xb5, 0xc6, 0xf0, 0x77, 0x47, 0xaa, 0x6d,
	0x3c, 0x87, 0xc5, 0x4c, 0x44, 0xf5, 0x47, 0xdd, 0x9d, 0x01, 0x51, 0x47, 0x7f, 0xb8, 0x1a, 0x21,
	0xf2, 0xdf, 0x0a, 0xe1, 0x1e, 0xa8, 0x88, 0x0d, 0xb8, 0xd8, 0xa3, 0x9c, 0x36, 0x5d, 0xa2, 0x43,
	0xdd, 0x1b, 0xe7, 0xcf, 0xd3, 0xd5, 0x27, 0xa1, 0x6f, 0x3d, 0x67, 0x46, 0x30, 0x68, 0x1b, 0xa6,
	0x99, 0x8f, 0x7f, 0xd6, 0x8d, 0xde, 0x5f, 0xd6, 0xc6, 0x02, 0xdc, 0x51, 0xae, 0x8a, 0x5a, 0xaa,
	0xd6, 0xf5, 0x3f, 0xe4, 0xe1, 0xa2, 0x8e, 0x82, 0x4c, 0x00, 0x3b, 0xde, 0x49, 0x3d, 0xdf, 0xd5,
	0x51, 0xe1, 0x93, 0x1a, 0x30, 0x53, 0x28, 0x68, 0x37, 0x5d, 0x84, 0x53, 0x7d, 0xcf, 0x8b, 0xe1,
	0x45, 0xa8, 0x52, 0x9f, 0xe0, 0x5c, 0x3f, 0x80, 0xe9, 0x70, 0x21, 0xff, 0x8f, 0x29, 0xaf, 0x97,
	0x52, 0x8f, 0x0a, 0xeb, 0xff, 0x9e, 0xfa, 0xec, 0xc5, 0x52, 0xfe, 0x8b, 0x17, 0x4b, 0xf9, 0x7f,
	0xbd, 0x58, 0xca, 0xff, 0xf2, 0xe5, 0x52, 0xee, 0x8b, 0x97, 0x4b, 0xb9, 0x7f, 0xbc, 0x5c, 0xca,
	0xc1, 0x2d, 0x9b, 0x75, 0x46, 0x08, 0xb5, 0xbe, 0x90, 0x56, 0x79, 0x01, 0x13, 0xac, 0x91, 0x7f,
	0xda, 0x3c, 0xa4, 0xa2, 0xdd, 0x6d, 0xca, 0xa3, 0x67, 0xc5, 0x66, 0xbc, 0xc3, 0xf8, 0x8a, 0xe2,
	0xb3, 0x24, 0x58, 0xe9, 0xad, 0xc6, 0x4d, 0x25, 0xc6, 0xf8, 0xca, 0xf0, 0xdf, 0x43, 0x3f, 0x48,
	0x19, 0x23, 0xdb, 0xaf, 0xa7, 0x0a, 0x8d, 0x8d, 0xbd, 0xdf, 0x4c, 0x19, 0x8d, 0x68, 0x8a, 0x1b,
	0x72, 0x8a, 0xa9, 0xc9, 0x54, 0x9f, 0xe8, 0xa1, 0x9f, 0x27, 0x83, 0x0e, 0xe4, 0xa0, 0x83, 0xd4,
	0xa0, 0x83, 0x68, 0xd0, 0x8b, 0xa9, 0xea, 0xf0, 0x41, 0x07, 0x1f, 0x37, 0xd6, 0xa3, 0xa7, 0xd9,
	0xff, 0x4c, 0xdd, 0x8c, 0x1c, 0x6a, 0x35, 0xe9, 0x51, 0xab, 0xa5, 0x5c, 0x6a, 0xb5, 0xc8, 0xa7,
	0x39, 0xad, 0x7e, 0x37, 0xbb, 0xf6, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x2f, 0x12, 0x32, 0xf8,
	0xf9, 0x2d, 0x00, 0x00,
}

func (m *Transaction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Transaction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Transaction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Anchor != nil {
		{
			size, err := m.Anchor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BindingSig) > 0 {
		i -= len(m.BindingSig)
		copy(dAtA[i:], m.BindingSig)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.BindingSig)))
		i--
		dAtA[i] = 0x12
	}
	if m.Body != nil {
		{
			size, err := m.Body.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Id) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Id) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Id) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TransactionBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransactionBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MemoData != nil {
		{
			size, err := m.MemoData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.DetectionData != nil {
		{
			size, err := m.DetectionData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Fee != nil {
		{
			size, err := m.Fee.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.TransactionParameters != nil {
		{
			size, err := m.TransactionParameters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Actions) > 0 {
		for iNdEx := len(m.Actions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Actions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransaction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MemoData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemoData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemoData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EncryptedMemo) > 0 {
		i -= len(m.EncryptedMemo)
		copy(dAtA[i:], m.EncryptedMemo)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.EncryptedMemo)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TransactionParameters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionParameters) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransactionParameters) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x12
	}
	if m.ExpiryHeight != 0 {
		i = encodeVarintTransaction(dAtA, i, uint64(m.ExpiryHeight))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DetectionData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DetectionData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DetectionData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FmdClues) > 0 {
		for iNdEx := len(m.FmdClues) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FmdClues[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransaction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	return len(dAtA) - i, nil
}

func (m *Action) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Action) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Action != nil {
		{
			size := m.Action.Size()
			i -= size
			if _, err := m.Action.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Action_Spend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_Spend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Spend != nil {
		{
			size, err := m.Spend.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Action_Output) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_Output) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Output != nil {
		{
			size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Action_Swap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_Swap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Swap != nil {
		{
			size, err := m.Swap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Action_SwapClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_SwapClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SwapClaim != nil {
		{
			size, err := m.SwapClaim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Action_ValidatorDefinition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_ValidatorDefinition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ValidatorDefinition != nil {
		{
			size, err := m.ValidatorDefinition.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *Action_IbcRelayAction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_IbcRelayAction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IbcRelayAction != nil {
		{
			size, err := m.IbcRelayAction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *Action_ProposalSubmit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_ProposalSubmit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ProposalSubmit != nil {
		{
			size, err := m.ProposalSubmit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *Action_ProposalWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_ProposalWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ProposalWithdraw != nil {
		{
			size, err := m.ProposalWithdraw.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *Action_ValidatorVote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_ValidatorVote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ValidatorVote != nil {
		{
			size, err := m.ValidatorVote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *Action_DelegatorVote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_DelegatorVote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DelegatorVote != nil {
		{
			size, err := m.DelegatorVote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *Action_ProposalDepositClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_ProposalDepositClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ProposalDepositClaim != nil {
		{
			size, err := m.ProposalDepositClaim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *Action_PositionOpen) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_PositionOpen) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PositionOpen != nil {
		{
			size, err := m.PositionOpen.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	return len(dAtA) - i, nil
}
func (m *Action_PositionClose) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_PositionClose) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PositionClose != nil {
		{
			size, err := m.PositionClose.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	return len(dAtA) - i, nil
}
func (m *Action_PositionWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_PositionWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PositionWithdraw != nil {
		{
			size, err := m.PositionWithdraw.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *Action_PositionRewardClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_PositionRewardClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PositionRewardClaim != nil {
		{
			size, err := m.PositionRewardClaim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *Action_Delegate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_Delegate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Delegate != nil {
		{
			size, err := m.Delegate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *Action_Undelegate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_Undelegate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Undelegate != nil {
		{
			size, err := m.Undelegate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *Action_UndelegateClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_UndelegateClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UndelegateClaim != nil {
		{
			size, err := m.UndelegateClaim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *Action_DaoSpend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_DaoSpend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DaoSpend != nil {
		{
			size, err := m.DaoSpend.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *Action_DaoOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_DaoOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DaoOutput != nil {
		{
			size, err := m.DaoOutput.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *Action_DaoDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_DaoDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DaoDeposit != nil {
		{
			size, err := m.DaoDeposit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *Action_Ics20Withdrawal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_Ics20Withdrawal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ics20Withdrawal != nil {
		{
			size, err := m.Ics20Withdrawal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *TransactionPerspective) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionPerspective) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransactionPerspective) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TransactionId != nil {
		{
			size, err := m.TransactionId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Denoms) > 0 {
		for iNdEx := len(m.Denoms) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Denoms[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransaction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.AddressViews) > 0 {
		for iNdEx := len(m.AddressViews) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AddressViews[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransaction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.AdviceNotes) > 0 {
		for iNdEx := len(m.AdviceNotes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AdviceNotes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransaction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.SpendNullifiers) > 0 {
		for iNdEx := len(m.SpendNullifiers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SpendNullifiers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransaction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.PayloadKeys) > 0 {
		for iNdEx := len(m.PayloadKeys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PayloadKeys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransaction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PayloadKeyWithCommitment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PayloadKeyWithCommitment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PayloadKeyWithCommitment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Commitment != nil {
		{
			size, err := m.Commitment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.PayloadKey != nil {
		{
			size, err := m.PayloadKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NullifierWithNote) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NullifierWithNote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NullifierWithNote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Note != nil {
		{
			size, err := m.Note.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Nullifier != nil {
		{
			size, err := m.Nullifier.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TransactionView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionView) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransactionView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Anchor != nil {
		{
			size, err := m.Anchor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BindingSig) > 0 {
		i -= len(m.BindingSig)
		copy(dAtA[i:], m.BindingSig)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.BindingSig)))
		i--
		dAtA[i] = 0x12
	}
	if m.BodyView != nil {
		{
			size, err := m.BodyView.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TransactionBodyView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionBodyView) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransactionBodyView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MemoView != nil {
		{
			size, err := m.MemoView.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.DetectionData != nil {
		{
			size, err := m.DetectionData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Fee != nil {
		{
			size, err := m.Fee.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.TransactionParameters != nil {
		{
			size, err := m.TransactionParameters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ActionViews) > 0 {
		for iNdEx := len(m.ActionViews) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ActionViews[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransaction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ActionView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionView) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ActionView != nil {
		{
			size := m.ActionView.Size()
			i -= size
			if _, err := m.ActionView.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ActionView_Spend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_Spend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Spend != nil {
		{
			size, err := m.Spend.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_Output) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_Output) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Output != nil {
		{
			size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_Swap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_Swap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Swap != nil {
		{
			size, err := m.Swap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_SwapClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_SwapClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SwapClaim != nil {
		{
			size, err := m.SwapClaim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_ValidatorDefinition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_ValidatorDefinition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ValidatorDefinition != nil {
		{
			size, err := m.ValidatorDefinition.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_IbcRelayAction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_IbcRelayAction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IbcRelayAction != nil {
		{
			size, err := m.IbcRelayAction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_ProposalSubmit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_ProposalSubmit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ProposalSubmit != nil {
		{
			size, err := m.ProposalSubmit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_ProposalWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_ProposalWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ProposalWithdraw != nil {
		{
			size, err := m.ProposalWithdraw.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_ValidatorVote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_ValidatorVote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ValidatorVote != nil {
		{
			size, err := m.ValidatorVote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_DelegatorVote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_DelegatorVote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DelegatorVote != nil {
		{
			size, err := m.DelegatorVote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_ProposalDepositClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_ProposalDepositClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ProposalDepositClaim != nil {
		{
			size, err := m.ProposalDepositClaim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_PositionOpen) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_PositionOpen) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PositionOpen != nil {
		{
			size, err := m.PositionOpen.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_PositionClose) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_PositionClose) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PositionClose != nil {
		{
			size, err := m.PositionClose.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_PositionWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_PositionWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PositionWithdraw != nil {
		{
			size, err := m.PositionWithdraw.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_PositionRewardClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_PositionRewardClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PositionRewardClaim != nil {
		{
			size, err := m.PositionRewardClaim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_Delegate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_Delegate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Delegate != nil {
		{
			size, err := m.Delegate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_Undelegate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_Undelegate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Undelegate != nil {
		{
			size, err := m.Undelegate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_UndelegateClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_UndelegateClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UndelegateClaim != nil {
		{
			size, err := m.UndelegateClaim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_DaoSpend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_DaoSpend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DaoSpend != nil {
		{
			size, err := m.DaoSpend.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_DaoOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_DaoOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DaoOutput != nil {
		{
			size, err := m.DaoOutput.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_DaoDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_DaoDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DaoDeposit != nil {
		{
			size, err := m.DaoDeposit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *ActionView_Ics20Withdrawal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionView_Ics20Withdrawal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ics20Withdrawal != nil {
		{
			size, err := m.Ics20Withdrawal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *EffectHash) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EffectHash) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EffectHash) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Inner) > 0 {
		i -= len(m.Inner)
		copy(dAtA[i:], m.Inner)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Inner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuthorizationData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthorizationData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthorizationData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DelegatorVoteAuths) > 0 {
		for iNdEx := len(m.DelegatorVoteAuths) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DelegatorVoteAuths[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransaction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.SpendAuths) > 0 {
		for iNdEx := len(m.SpendAuths) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SpendAuths[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransaction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.EffectHash != nil {
		{
			size, err := m.EffectHash.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WitnessData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WitnessData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WitnessData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StateCommitmentProofs) > 0 {
		for iNdEx := len(m.StateCommitmentProofs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StateCommitmentProofs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransaction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Anchor != nil {
		{
			size, err := m.Anchor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TransactionPlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionPlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransactionPlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MemoPlan != nil {
		{
			size, err := m.MemoPlan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.CluePlans) > 0 {
		for iNdEx := len(m.CluePlans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CluePlans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransaction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Fee != nil {
		{
			size, err := m.Fee.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ExpiryHeight != 0 {
		i = encodeVarintTransaction(dAtA, i, uint64(m.ExpiryHeight))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Actions) > 0 {
		for iNdEx := len(m.Actions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Actions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransaction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ActionPlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionPlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Action != nil {
		{
			size := m.Action.Size()
			i -= size
			if _, err := m.Action.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ActionPlan_Spend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_Spend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Spend != nil {
		{
			size, err := m.Spend.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_Output) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_Output) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Output != nil {
		{
			size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_Swap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_Swap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Swap != nil {
		{
			size, err := m.Swap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_SwapClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_SwapClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SwapClaim != nil {
		{
			size, err := m.SwapClaim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_ValidatorDefinition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_ValidatorDefinition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ValidatorDefinition != nil {
		{
			size, err := m.ValidatorDefinition.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_IbcRelayAction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_IbcRelayAction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IbcRelayAction != nil {
		{
			size, err := m.IbcRelayAction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_ProposalSubmit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_ProposalSubmit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ProposalSubmit != nil {
		{
			size, err := m.ProposalSubmit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_ProposalWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_ProposalWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ProposalWithdraw != nil {
		{
			size, err := m.ProposalWithdraw.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_ValidatorVote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_ValidatorVote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ValidatorVote != nil {
		{
			size, err := m.ValidatorVote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_DelegatorVote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_DelegatorVote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DelegatorVote != nil {
		{
			size, err := m.DelegatorVote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_ProposalDepositClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_ProposalDepositClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ProposalDepositClaim != nil {
		{
			size, err := m.ProposalDepositClaim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_Withdrawal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_Withdrawal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Withdrawal != nil {
		{
			size, err := m.Withdrawal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_PositionOpen) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_PositionOpen) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PositionOpen != nil {
		{
			size, err := m.PositionOpen.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_PositionClose) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_PositionClose) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PositionClose != nil {
		{
			size, err := m.PositionClose.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_PositionWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_PositionWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PositionWithdraw != nil {
		{
			size, err := m.PositionWithdraw.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_PositionRewardClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_PositionRewardClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PositionRewardClaim != nil {
		{
			size, err := m.PositionRewardClaim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_Delegate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_Delegate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Delegate != nil {
		{
			size, err := m.Delegate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_Undelegate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_Undelegate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Undelegate != nil {
		{
			size, err := m.Undelegate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_UndelegateClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_UndelegateClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UndelegateClaim != nil {
		{
			size, err := m.UndelegateClaim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_DaoSpend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_DaoSpend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DaoSpend != nil {
		{
			size, err := m.DaoSpend.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_DaoOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_DaoOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DaoOutput != nil {
		{
			size, err := m.DaoOutput.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *ActionPlan_DaoDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPlan_DaoDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DaoDeposit != nil {
		{
			size, err := m.DaoDeposit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *CluePlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CluePlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CluePlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PrecisionBits != 0 {
		i = encodeVarintTransaction(dAtA, i, uint64(m.PrecisionBits))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Rseed) > 0 {
		i -= len(m.Rseed)
		copy(dAtA[i:], m.Rseed)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Rseed)))
		i--
		dAtA[i] = 0x12
	}
	if m.Address != nil {
		{
			size, err := m.Address.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MemoPlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemoPlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemoPlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if m.Plaintext != nil {
		{
			size, err := m.Plaintext.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MemoCiphertext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemoCiphertext) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemoCiphertext) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Inner) > 0 {
		i -= len(m.Inner)
		copy(dAtA[i:], m.Inner)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Inner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MemoPlaintext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemoPlaintext) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemoPlaintext) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Text) > 0 {
		i -= len(m.Text)
		copy(dAtA[i:], m.Text)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Text)))
		i--
		dAtA[i] = 0x12
	}
	if m.ReturnAddress != nil {
		{
			size, err := m.ReturnAddress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MemoPlaintextView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemoPlaintextView) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemoPlaintextView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Text) > 0 {
		i -= len(m.Text)
		copy(dAtA[i:], m.Text)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Text)))
		i--
		dAtA[i] = 0x12
	}
	if m.ReturnAddress != nil {
		{
			size, err := m.ReturnAddress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MemoView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemoView) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemoView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MemoView != nil {
		{
			size := m.MemoView.Size()
			i -= size
			if _, err := m.MemoView.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *MemoView_Visible_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemoView_Visible_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Visible != nil {
		{
			size, err := m.Visible.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *MemoView_Opaque_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemoView_Opaque_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Opaque != nil {
		{
			size, err := m.Opaque.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *MemoView_Visible) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemoView_Visible) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemoView_Visible) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Plaintext != nil {
		{
			size, err := m.Plaintext.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Ciphertext != nil {
		{
			size, err := m.Ciphertext.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MemoView_Opaque) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemoView_Opaque) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemoView_Opaque) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ciphertext != nil {
		{
			size, err := m.Ciphertext.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTransaction(dAtA []byte, offset int, v uint64) int {
	offset -= sovTransaction(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Transaction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Body != nil {
		l = m.Body.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.BindingSig)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Anchor != nil {
		l = m.Anchor.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *Id) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *TransactionBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Actions) > 0 {
		for _, e := range m.Actions {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	if m.TransactionParameters != nil {
		l = m.TransactionParameters.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Fee != nil {
		l = m.Fee.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.DetectionData != nil {
		l = m.DetectionData.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.MemoData != nil {
		l = m.MemoData.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *MemoData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EncryptedMemo)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *TransactionParameters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExpiryHeight != 0 {
		n += 1 + sovTransaction(uint64(m.ExpiryHeight))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *DetectionData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.FmdClues) > 0 {
		for _, e := range m.FmdClues {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	return n
}

func (m *Action) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Action != nil {
		n += m.Action.Size()
	}
	return n
}

func (m *Action_Spend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spend != nil {
		l = m.Spend.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_Output) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Output != nil {
		l = m.Output.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_Swap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Swap != nil {
		l = m.Swap.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_SwapClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SwapClaim != nil {
		l = m.SwapClaim.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_ValidatorDefinition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ValidatorDefinition != nil {
		l = m.ValidatorDefinition.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_IbcRelayAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IbcRelayAction != nil {
		l = m.IbcRelayAction.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_ProposalSubmit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalSubmit != nil {
		l = m.ProposalSubmit.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_ProposalWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalWithdraw != nil {
		l = m.ProposalWithdraw.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_ValidatorVote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ValidatorVote != nil {
		l = m.ValidatorVote.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_DelegatorVote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DelegatorVote != nil {
		l = m.DelegatorVote.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_ProposalDepositClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalDepositClaim != nil {
		l = m.ProposalDepositClaim.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_PositionOpen) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionOpen != nil {
		l = m.PositionOpen.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_PositionClose) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionClose != nil {
		l = m.PositionClose.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_PositionWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionWithdraw != nil {
		l = m.PositionWithdraw.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_PositionRewardClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionRewardClaim != nil {
		l = m.PositionRewardClaim.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_Delegate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Delegate != nil {
		l = m.Delegate.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_Undelegate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Undelegate != nil {
		l = m.Undelegate.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_UndelegateClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UndelegateClaim != nil {
		l = m.UndelegateClaim.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_DaoSpend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DaoSpend != nil {
		l = m.DaoSpend.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_DaoOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DaoOutput != nil {
		l = m.DaoOutput.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_DaoDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DaoDeposit != nil {
		l = m.DaoDeposit.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Action_Ics20Withdrawal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ics20Withdrawal != nil {
		l = m.Ics20Withdrawal.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *TransactionPerspective) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PayloadKeys) > 0 {
		for _, e := range m.PayloadKeys {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	if len(m.SpendNullifiers) > 0 {
		for _, e := range m.SpendNullifiers {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	if len(m.AdviceNotes) > 0 {
		for _, e := range m.AdviceNotes {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	if len(m.AddressViews) > 0 {
		for _, e := range m.AddressViews {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	if len(m.Denoms) > 0 {
		for _, e := range m.Denoms {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	if m.TransactionId != nil {
		l = m.TransactionId.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *PayloadKeyWithCommitment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PayloadKey != nil {
		l = m.PayloadKey.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Commitment != nil {
		l = m.Commitment.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *NullifierWithNote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nullifier != nil {
		l = m.Nullifier.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Note != nil {
		l = m.Note.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *TransactionView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BodyView != nil {
		l = m.BodyView.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.BindingSig)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Anchor != nil {
		l = m.Anchor.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *TransactionBodyView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ActionViews) > 0 {
		for _, e := range m.ActionViews {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	if m.TransactionParameters != nil {
		l = m.TransactionParameters.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Fee != nil {
		l = m.Fee.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.DetectionData != nil {
		l = m.DetectionData.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.MemoView != nil {
		l = m.MemoView.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *ActionView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ActionView != nil {
		n += m.ActionView.Size()
	}
	return n
}

func (m *ActionView_Spend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spend != nil {
		l = m.Spend.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_Output) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Output != nil {
		l = m.Output.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_Swap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Swap != nil {
		l = m.Swap.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_SwapClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SwapClaim != nil {
		l = m.SwapClaim.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_ValidatorDefinition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ValidatorDefinition != nil {
		l = m.ValidatorDefinition.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_IbcRelayAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IbcRelayAction != nil {
		l = m.IbcRelayAction.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_ProposalSubmit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalSubmit != nil {
		l = m.ProposalSubmit.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_ProposalWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalWithdraw != nil {
		l = m.ProposalWithdraw.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_ValidatorVote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ValidatorVote != nil {
		l = m.ValidatorVote.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_DelegatorVote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DelegatorVote != nil {
		l = m.DelegatorVote.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_ProposalDepositClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalDepositClaim != nil {
		l = m.ProposalDepositClaim.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_PositionOpen) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionOpen != nil {
		l = m.PositionOpen.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_PositionClose) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionClose != nil {
		l = m.PositionClose.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_PositionWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionWithdraw != nil {
		l = m.PositionWithdraw.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_PositionRewardClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionRewardClaim != nil {
		l = m.PositionRewardClaim.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_Delegate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Delegate != nil {
		l = m.Delegate.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_Undelegate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Undelegate != nil {
		l = m.Undelegate.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_UndelegateClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UndelegateClaim != nil {
		l = m.UndelegateClaim.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_DaoSpend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DaoSpend != nil {
		l = m.DaoSpend.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_DaoOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DaoOutput != nil {
		l = m.DaoOutput.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_DaoDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DaoDeposit != nil {
		l = m.DaoDeposit.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionView_Ics20Withdrawal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ics20Withdrawal != nil {
		l = m.Ics20Withdrawal.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *EffectHash) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Inner)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *AuthorizationData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EffectHash != nil {
		l = m.EffectHash.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if len(m.SpendAuths) > 0 {
		for _, e := range m.SpendAuths {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	if len(m.DelegatorVoteAuths) > 0 {
		for _, e := range m.DelegatorVoteAuths {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	return n
}

func (m *WitnessData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Anchor != nil {
		l = m.Anchor.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if len(m.StateCommitmentProofs) > 0 {
		for _, e := range m.StateCommitmentProofs {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	return n
}

func (m *TransactionPlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Actions) > 0 {
		for _, e := range m.Actions {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	if m.ExpiryHeight != 0 {
		n += 1 + sovTransaction(uint64(m.ExpiryHeight))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Fee != nil {
		l = m.Fee.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if len(m.CluePlans) > 0 {
		for _, e := range m.CluePlans {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	if m.MemoPlan != nil {
		l = m.MemoPlan.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *ActionPlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Action != nil {
		n += m.Action.Size()
	}
	return n
}

func (m *ActionPlan_Spend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spend != nil {
		l = m.Spend.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_Output) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Output != nil {
		l = m.Output.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_Swap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Swap != nil {
		l = m.Swap.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_SwapClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SwapClaim != nil {
		l = m.SwapClaim.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_ValidatorDefinition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ValidatorDefinition != nil {
		l = m.ValidatorDefinition.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_IbcRelayAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IbcRelayAction != nil {
		l = m.IbcRelayAction.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_ProposalSubmit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalSubmit != nil {
		l = m.ProposalSubmit.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_ProposalWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalWithdraw != nil {
		l = m.ProposalWithdraw.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_ValidatorVote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ValidatorVote != nil {
		l = m.ValidatorVote.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_DelegatorVote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DelegatorVote != nil {
		l = m.DelegatorVote.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_ProposalDepositClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalDepositClaim != nil {
		l = m.ProposalDepositClaim.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_Withdrawal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Withdrawal != nil {
		l = m.Withdrawal.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_PositionOpen) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionOpen != nil {
		l = m.PositionOpen.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_PositionClose) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionClose != nil {
		l = m.PositionClose.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_PositionWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionWithdraw != nil {
		l = m.PositionWithdraw.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_PositionRewardClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionRewardClaim != nil {
		l = m.PositionRewardClaim.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_Delegate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Delegate != nil {
		l = m.Delegate.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_Undelegate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Undelegate != nil {
		l = m.Undelegate.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_UndelegateClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UndelegateClaim != nil {
		l = m.UndelegateClaim.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_DaoSpend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DaoSpend != nil {
		l = m.DaoSpend.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_DaoOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DaoOutput != nil {
		l = m.DaoOutput.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *ActionPlan_DaoDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DaoDeposit != nil {
		l = m.DaoDeposit.Size()
		n += 2 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *CluePlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Address != nil {
		l = m.Address.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.Rseed)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.PrecisionBits != 0 {
		n += 1 + sovTransaction(uint64(m.PrecisionBits))
	}
	return n
}

func (m *MemoPlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Plaintext != nil {
		l = m.Plaintext.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *MemoCiphertext) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Inner)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *MemoPlaintext) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReturnAddress != nil {
		l = m.ReturnAddress.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *MemoPlaintextView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReturnAddress != nil {
		l = m.ReturnAddress.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *MemoView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MemoView != nil {
		n += m.MemoView.Size()
	}
	return n
}

func (m *MemoView_Visible_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Visible != nil {
		l = m.Visible.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *MemoView_Opaque_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Opaque != nil {
		l = m.Opaque.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *MemoView_Visible) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ciphertext != nil {
		l = m.Ciphertext.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Plaintext != nil {
		l = m.Plaintext.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *MemoView_Opaque) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ciphertext != nil {
		l = m.Ciphertext.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func sovTransaction(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTransaction(x uint64) (n int) {
	return sovTransaction(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Transaction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Transaction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Transaction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Body == nil {
				m.Body = &TransactionBody{}
			}
			if err := m.Body.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BindingSig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BindingSig = append(m.BindingSig[:0], dAtA[iNdEx:postIndex]...)
			if m.BindingSig == nil {
				m.BindingSig = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Anchor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Anchor == nil {
				m.Anchor = &v1alpha1.MerkleRoot{}
			}
			if err := m.Anchor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Id) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Id: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Id: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actions = append(m.Actions, &Action{})
			if err := m.Actions[len(m.Actions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransactionParameters == nil {
				m.TransactionParameters = &TransactionParameters{}
			}
			if err := m.TransactionParameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fee == nil {
				m.Fee = &v1alpha11.Fee{}
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DetectionData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DetectionData == nil {
				m.DetectionData = &DetectionData{}
			}
			if err := m.DetectionData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MemoData == nil {
				m.MemoData = &MemoData{}
			}
			if err := m.MemoData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemoData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemoData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemoData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedMemo", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedMemo = append(m.EncryptedMemo[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedMemo == nil {
				m.EncryptedMemo = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionParameters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionParameters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionParameters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiryHeight", wireType)
			}
			m.ExpiryHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiryHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DetectionData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DetectionData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DetectionData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FmdClues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FmdClues = append(m.FmdClues, &v1alpha12.Clue{})
			if err := m.FmdClues[len(m.FmdClues)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Action) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Action: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Action: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha13.Spend{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_Spend{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha13.Output{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_Output{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Swap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.Swap{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_Swap{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.SwapClaim{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_SwapClaim{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorDefinition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha15.ValidatorDefinition{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_ValidatorDefinition{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IbcRelayAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha16.IbcRelay{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_IbcRelayAction{v}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalSubmit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha17.ProposalSubmit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_ProposalSubmit{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalWithdraw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha17.ProposalWithdraw{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_ProposalWithdraw{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorVote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha17.ValidatorVote{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_ValidatorVote{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorVote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha17.DelegatorVote{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_DelegatorVote{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalDepositClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha17.ProposalDepositClaim{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_ProposalDepositClaim{v}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionOpen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.PositionOpen{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_PositionOpen{v}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionClose", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.PositionClose{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_PositionClose{v}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionWithdraw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.PositionWithdraw{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_PositionWithdraw{v}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionRewardClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.PositionRewardClaim{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_PositionRewardClaim{v}
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delegate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha15.Delegate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_Delegate{v}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Undelegate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha15.Undelegate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_Undelegate{v}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UndelegateClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha15.UndelegateClaim{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_UndelegateClaim{v}
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DaoSpend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha17.DaoSpend{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_DaoSpend{v}
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DaoOutput", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha17.DaoOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_DaoOutput{v}
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DaoDeposit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha17.DaoDeposit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_DaoDeposit{v}
			iNdEx = postIndex
		case 200:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ics20Withdrawal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha16.Ics20Withdrawal{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_Ics20Withdrawal{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionPerspective) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionPerspective: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionPerspective: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PayloadKeys = append(m.PayloadKeys, &PayloadKeyWithCommitment{})
			if err := m.PayloadKeys[len(m.PayloadKeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpendNullifiers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpendNullifiers = append(m.SpendNullifiers, &NullifierWithNote{})
			if err := m.SpendNullifiers[len(m.SpendNullifiers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdviceNotes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdviceNotes = append(m.AdviceNotes, &v1alpha13.Note{})
			if err := m.AdviceNotes[len(m.AdviceNotes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressViews", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressViews = append(m.AddressViews, &v1alpha18.AddressView{})
			if err := m.AddressViews[len(m.AddressViews)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denoms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denoms = append(m.Denoms, &v1alpha19.DenomMetadata{})
			if err := m.Denoms[len(m.Denoms)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransactionId == nil {
				m.TransactionId = &Id{}
			}
			if err := m.TransactionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PayloadKeyWithCommitment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PayloadKeyWithCommitment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PayloadKeyWithCommitment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PayloadKey == nil {
				m.PayloadKey = &v1alpha18.PayloadKey{}
			}
			if err := m.PayloadKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commitment == nil {
				m.Commitment = &v1alpha1.StateCommitment{}
			}
			if err := m.Commitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NullifierWithNote) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NullifierWithNote: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NullifierWithNote: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nullifier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Nullifier == nil {
				m.Nullifier = &v1alpha110.Nullifier{}
			}
			if err := m.Nullifier.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Note", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Note == nil {
				m.Note = &v1alpha13.Note{}
			}
			if err := m.Note.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BodyView", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BodyView == nil {
				m.BodyView = &TransactionBodyView{}
			}
			if err := m.BodyView.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BindingSig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BindingSig = append(m.BindingSig[:0], dAtA[iNdEx:postIndex]...)
			if m.BindingSig == nil {
				m.BindingSig = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Anchor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Anchor == nil {
				m.Anchor = &v1alpha1.MerkleRoot{}
			}
			if err := m.Anchor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionBodyView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionBodyView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionBodyView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionViews", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionViews = append(m.ActionViews, &ActionView{})
			if err := m.ActionViews[len(m.ActionViews)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransactionParameters == nil {
				m.TransactionParameters = &TransactionParameters{}
			}
			if err := m.TransactionParameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fee == nil {
				m.Fee = &v1alpha11.Fee{}
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DetectionData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DetectionData == nil {
				m.DetectionData = &DetectionData{}
			}
			if err := m.DetectionData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoView", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MemoView == nil {
				m.MemoView = &MemoView{}
			}
			if err := m.MemoView.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha13.SpendView{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_Spend{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha13.OutputView{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_Output{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Swap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.SwapView{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_Swap{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.SwapClaimView{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_SwapClaim{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorDefinition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha15.ValidatorDefinition{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_ValidatorDefinition{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IbcRelayAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha16.IbcRelay{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_IbcRelayAction{v}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalSubmit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha17.ProposalSubmit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_ProposalSubmit{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalWithdraw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha17.ProposalWithdraw{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_ProposalWithdraw{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorVote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha17.ValidatorVote{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_ValidatorVote{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorVote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha17.DelegatorVoteView{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_DelegatorVote{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalDepositClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha17.ProposalDepositClaim{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_ProposalDepositClaim{v}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionOpen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.PositionOpen{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_PositionOpen{v}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionClose", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.PositionClose{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_PositionClose{v}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionWithdraw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.PositionWithdraw{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_PositionWithdraw{v}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionRewardClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.PositionRewardClaim{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_PositionRewardClaim{v}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delegate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha15.Delegate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_Delegate{v}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Undelegate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha15.Undelegate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_Undelegate{v}
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UndelegateClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha15.UndelegateClaim{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_UndelegateClaim{v}
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DaoSpend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha17.DaoSpend{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_DaoSpend{v}
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DaoOutput", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha17.DaoOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_DaoOutput{v}
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DaoDeposit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha17.DaoDeposit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_DaoDeposit{v}
			iNdEx = postIndex
		case 200:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ics20Withdrawal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha16.Ics20Withdrawal{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionView = &ActionView_Ics20Withdrawal{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EffectHash) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EffectHash: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EffectHash: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inner = append(m.Inner[:0], dAtA[iNdEx:postIndex]...)
			if m.Inner == nil {
				m.Inner = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthorizationData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthorizationData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthorizationData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectHash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EffectHash == nil {
				m.EffectHash = &EffectHash{}
			}
			if err := m.EffectHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpendAuths", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpendAuths = append(m.SpendAuths, &v1alpha111.SpendAuthSignature{})
			if err := m.SpendAuths[len(m.SpendAuths)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorVoteAuths", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelegatorVoteAuths = append(m.DelegatorVoteAuths, &v1alpha111.SpendAuthSignature{})
			if err := m.DelegatorVoteAuths[len(m.DelegatorVoteAuths)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WitnessData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WitnessData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WitnessData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Anchor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Anchor == nil {
				m.Anchor = &v1alpha1.MerkleRoot{}
			}
			if err := m.Anchor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateCommitmentProofs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StateCommitmentProofs = append(m.StateCommitmentProofs, &v1alpha1.StateCommitmentProof{})
			if err := m.StateCommitmentProofs[len(m.StateCommitmentProofs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionPlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionPlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionPlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actions = append(m.Actions, &ActionPlan{})
			if err := m.Actions[len(m.Actions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiryHeight", wireType)
			}
			m.ExpiryHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiryHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fee == nil {
				m.Fee = &v1alpha11.Fee{}
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CluePlans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CluePlans = append(m.CluePlans, &CluePlan{})
			if err := m.CluePlans[len(m.CluePlans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoPlan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MemoPlan == nil {
				m.MemoPlan = &MemoPlan{}
			}
			if err := m.MemoPlan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionPlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionPlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionPlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha13.SpendPlan{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_Spend{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha13.OutputPlan{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_Output{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Swap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.SwapPlan{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_Swap{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.SwapClaimPlan{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_SwapClaim{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorDefinition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha15.ValidatorDefinition{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_ValidatorDefinition{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IbcRelayAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha16.IbcRelay{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_IbcRelayAction{v}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalSubmit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha17.ProposalSubmit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_ProposalSubmit{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalWithdraw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha17.ProposalWithdraw{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_ProposalWithdraw{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorVote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha17.ValidatorVote{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_ValidatorVote{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorVote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha17.DelegatorVotePlan{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_DelegatorVote{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalDepositClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha17.ProposalDepositClaim{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_ProposalDepositClaim{v}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Withdrawal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha16.Ics20Withdrawal{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_Withdrawal{v}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionOpen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.PositionOpen{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_PositionOpen{v}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionClose", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.PositionClose{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_PositionClose{v}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionWithdraw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.PositionWithdrawPlan{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_PositionWithdraw{v}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionRewardClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha14.PositionRewardClaimPlan{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_PositionRewardClaim{v}
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delegate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha15.Delegate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_Delegate{v}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Undelegate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha15.Undelegate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_Undelegate{v}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UndelegateClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha15.UndelegateClaimPlan{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_UndelegateClaim{v}
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DaoSpend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha17.DaoSpend{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_DaoSpend{v}
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DaoOutput", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha17.DaoOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_DaoOutput{v}
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DaoDeposit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1alpha17.DaoDeposit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionPlan_DaoDeposit{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CluePlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CluePlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CluePlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Address == nil {
				m.Address = &v1alpha18.Address{}
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rseed", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rseed = append(m.Rseed[:0], dAtA[iNdEx:postIndex]...)
			if m.Rseed == nil {
				m.Rseed = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrecisionBits", wireType)
			}
			m.PrecisionBits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrecisionBits |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemoPlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemoPlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemoPlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plaintext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Plaintext == nil {
				m.Plaintext = &MemoPlaintext{}
			}
			if err := m.Plaintext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemoCiphertext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemoCiphertext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemoCiphertext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inner = append(m.Inner[:0], dAtA[iNdEx:postIndex]...)
			if m.Inner == nil {
				m.Inner = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemoPlaintext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemoPlaintext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemoPlaintext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReturnAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReturnAddress == nil {
				m.ReturnAddress = &v1alpha18.Address{}
			}
			if err := m.ReturnAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemoPlaintextView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemoPlaintextView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemoPlaintextView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReturnAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReturnAddress == nil {
				m.ReturnAddress = &v1alpha18.AddressView{}
			}
			if err := m.ReturnAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemoView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemoView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemoView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visible", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MemoView_Visible{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.MemoView = &MemoView_Visible_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opaque", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MemoView_Opaque{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.MemoView = &MemoView_Opaque_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemoView_Visible) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Visible: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Visible: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ciphertext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ciphertext == nil {
				m.Ciphertext = &MemoCiphertext{}
			}
			if err := m.Ciphertext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plaintext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Plaintext == nil {
				m.Plaintext = &MemoPlaintextView{}
			}
			if err := m.Plaintext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemoView_Opaque) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Opaque: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Opaque: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ciphertext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ciphertext == nil {
				m.Ciphertext = &MemoCiphertext{}
			}
			if err := m.Ciphertext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTransaction(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTransaction
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTransaction
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTransaction
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTransaction        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTransaction          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTransaction = fmt.Errorf("proto: unexpected end of group")
)
