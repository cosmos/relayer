// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: penumbra/core/governance/v1alpha1/governance.proto

package governancev1alpha1

import (
	fmt "fmt"
	types "github.com/cosmos/cosmos-sdk/codec/types"
	proto "github.com/cosmos/gogoproto/proto"
	v1alpha11 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/chain/v1alpha1"
	v1alpha1 "github.com/cosmos/relayer/v2/relayer/chains/penumbra/core/crypto/v1alpha1"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// A vote.
type Vote_Vote int32

const (
	Vote_VOTE_UNSPECIFIED Vote_Vote = 0
	Vote_VOTE_ABSTAIN     Vote_Vote = 1
	Vote_VOTE_YES         Vote_Vote = 2
	Vote_VOTE_NO          Vote_Vote = 3
)

var Vote_Vote_name = map[int32]string{
	0: "VOTE_UNSPECIFIED",
	1: "VOTE_ABSTAIN",
	2: "VOTE_YES",
	3: "VOTE_NO",
}

var Vote_Vote_value = map[string]int32{
	"VOTE_UNSPECIFIED": 0,
	"VOTE_ABSTAIN":     1,
	"VOTE_YES":         2,
	"VOTE_NO":          3,
}

func (x Vote_Vote) String() string {
	return proto.EnumName(Vote_Vote_name, int32(x))
}

func (Vote_Vote) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1bc89f5bf0aed114, []int{11, 0}
}

type ProposalSubmit struct {
	// The proposal to be submitted.
	Proposal *Proposal `protobuf:"bytes,1,opt,name=proposal,proto3" json:"proposal,omitempty"`
	// The amount of the proposal deposit.
	DepositAmount *v1alpha1.Amount `protobuf:"bytes,3,opt,name=deposit_amount,json=depositAmount,proto3" json:"deposit_amount,omitempty"`
}

func (m *ProposalSubmit) Reset()         { *m = ProposalSubmit{} }
func (m *ProposalSubmit) String() string { return proto.CompactTextString(m) }
func (*ProposalSubmit) ProtoMessage()    {}
func (*ProposalSubmit) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bc89f5bf0aed114, []int{0}
}
func (m *ProposalSubmit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProposalSubmit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProposalSubmit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProposalSubmit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProposalSubmit.Merge(m, src)
}
func (m *ProposalSubmit) XXX_Size() int {
	return m.Size()
}
func (m *ProposalSubmit) XXX_DiscardUnknown() {
	xxx_messageInfo_ProposalSubmit.DiscardUnknown(m)
}

var xxx_messageInfo_ProposalSubmit proto.InternalMessageInfo

func (m *ProposalSubmit) GetProposal() *Proposal {
	if m != nil {
		return m.Proposal
	}
	return nil
}

func (m *ProposalSubmit) GetDepositAmount() *v1alpha1.Amount {
	if m != nil {
		return m.DepositAmount
	}
	return nil
}

type ProposalWithdraw struct {
	// The proposal to be withdrawn.
	Proposal uint64 `protobuf:"varint,1,opt,name=proposal,proto3" json:"proposal,omitempty"`
	// The reason for the proposal being withdrawn.
	Reason string `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *ProposalWithdraw) Reset()         { *m = ProposalWithdraw{} }
func (m *ProposalWithdraw) String() string { return proto.CompactTextString(m) }
func (*ProposalWithdraw) ProtoMessage()    {}
func (*ProposalWithdraw) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bc89f5bf0aed114, []int{1}
}
func (m *ProposalWithdraw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProposalWithdraw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProposalWithdraw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProposalWithdraw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProposalWithdraw.Merge(m, src)
}
func (m *ProposalWithdraw) XXX_Size() int {
	return m.Size()
}
func (m *ProposalWithdraw) XXX_DiscardUnknown() {
	xxx_messageInfo_ProposalWithdraw.DiscardUnknown(m)
}

var xxx_messageInfo_ProposalWithdraw proto.InternalMessageInfo

func (m *ProposalWithdraw) GetProposal() uint64 {
	if m != nil {
		return m.Proposal
	}
	return 0
}

func (m *ProposalWithdraw) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

type ProposalDepositClaim struct {
	// The proposal to claim the deposit for.
	Proposal uint64 `protobuf:"varint,1,opt,name=proposal,proto3" json:"proposal,omitempty"`
	// The expected deposit amount.
	DepositAmount *v1alpha1.Amount `protobuf:"bytes,2,opt,name=deposit_amount,json=depositAmount,proto3" json:"deposit_amount,omitempty"`
	// The outcome of the proposal.
	Outcome *ProposalOutcome `protobuf:"bytes,3,opt,name=outcome,proto3" json:"outcome,omitempty"`
}

func (m *ProposalDepositClaim) Reset()         { *m = ProposalDepositClaim{} }
func (m *ProposalDepositClaim) String() string { return proto.CompactTextString(m) }
func (*ProposalDepositClaim) ProtoMessage()    {}
func (*ProposalDepositClaim) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bc89f5bf0aed114, []int{2}
}
func (m *ProposalDepositClaim) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProposalDepositClaim) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProposalDepositClaim.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProposalDepositClaim) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProposalDepositClaim.Merge(m, src)
}
func (m *ProposalDepositClaim) XXX_Size() int {
	return m.Size()
}
func (m *ProposalDepositClaim) XXX_DiscardUnknown() {
	xxx_messageInfo_ProposalDepositClaim.DiscardUnknown(m)
}

var xxx_messageInfo_ProposalDepositClaim proto.InternalMessageInfo

func (m *ProposalDepositClaim) GetProposal() uint64 {
	if m != nil {
		return m.Proposal
	}
	return 0
}

func (m *ProposalDepositClaim) GetDepositAmount() *v1alpha1.Amount {
	if m != nil {
		return m.DepositAmount
	}
	return nil
}

func (m *ProposalDepositClaim) GetOutcome() *ProposalOutcome {
	if m != nil {
		return m.Outcome
	}
	return nil
}

type ValidatorVote struct {
	// The effecting data for the vote.
	Body *ValidatorVoteBody `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// The vote authorization signature is authorizing data.
	AuthSig *v1alpha1.SpendAuthSignature `protobuf:"bytes,2,opt,name=auth_sig,json=authSig,proto3" json:"auth_sig,omitempty"`
}

func (m *ValidatorVote) Reset()         { *m = ValidatorVote{} }
func (m *ValidatorVote) String() string { return proto.CompactTextString(m) }
func (*ValidatorVote) ProtoMessage()    {}
func (*ValidatorVote) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bc89f5bf0aed114, []int{3}
}
func (m *ValidatorVote) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorVote) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorVote.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorVote) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorVote.Merge(m, src)
}
func (m *ValidatorVote) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorVote) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorVote.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorVote proto.InternalMessageInfo

func (m *ValidatorVote) GetBody() *ValidatorVoteBody {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *ValidatorVote) GetAuthSig() *v1alpha1.SpendAuthSignature {
	if m != nil {
		return m.AuthSig
	}
	return nil
}

type ValidatorVoteBody struct {
	// The proposal being voted on.
	Proposal uint64 `protobuf:"varint,1,opt,name=proposal,proto3" json:"proposal,omitempty"`
	// The vote.
	Vote *Vote `protobuf:"bytes,2,opt,name=vote,proto3" json:"vote,omitempty"`
	// The validator identity.
	IdentityKey *v1alpha1.IdentityKey `protobuf:"bytes,3,opt,name=identity_key,json=identityKey,proto3" json:"identity_key,omitempty"`
	// The validator governance key.
	GovernanceKey *v1alpha1.GovernanceKey `protobuf:"bytes,4,opt,name=governance_key,json=governanceKey,proto3" json:"governance_key,omitempty"`
}

func (m *ValidatorVoteBody) Reset()         { *m = ValidatorVoteBody{} }
func (m *ValidatorVoteBody) String() string { return proto.CompactTextString(m) }
func (*ValidatorVoteBody) ProtoMessage()    {}
func (*ValidatorVoteBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bc89f5bf0aed114, []int{4}
}
func (m *ValidatorVoteBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorVoteBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorVoteBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorVoteBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorVoteBody.Merge(m, src)
}
func (m *ValidatorVoteBody) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorVoteBody) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorVoteBody.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorVoteBody proto.InternalMessageInfo

func (m *ValidatorVoteBody) GetProposal() uint64 {
	if m != nil {
		return m.Proposal
	}
	return 0
}

func (m *ValidatorVoteBody) GetVote() *Vote {
	if m != nil {
		return m.Vote
	}
	return nil
}

func (m *ValidatorVoteBody) GetIdentityKey() *v1alpha1.IdentityKey {
	if m != nil {
		return m.IdentityKey
	}
	return nil
}

func (m *ValidatorVoteBody) GetGovernanceKey() *v1alpha1.GovernanceKey {
	if m != nil {
		return m.GovernanceKey
	}
	return nil
}

type DelegatorVote struct {
	// The effecting data for the vote.
	Body *DelegatorVoteBody `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// The vote authorization signature is authorizing data.
	AuthSig *v1alpha1.SpendAuthSignature `protobuf:"bytes,2,opt,name=auth_sig,json=authSig,proto3" json:"auth_sig,omitempty"`
	// The vote proof is authorizing data.
	Proof *v1alpha1.ZKDelegatorVoteProof `protobuf:"bytes,3,opt,name=proof,proto3" json:"proof,omitempty"`
}

func (m *DelegatorVote) Reset()         { *m = DelegatorVote{} }
func (m *DelegatorVote) String() string { return proto.CompactTextString(m) }
func (*DelegatorVote) ProtoMessage()    {}
func (*DelegatorVote) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bc89f5bf0aed114, []int{5}
}
func (m *DelegatorVote) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelegatorVote) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelegatorVote.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelegatorVote) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelegatorVote.Merge(m, src)
}
func (m *DelegatorVote) XXX_Size() int {
	return m.Size()
}
func (m *DelegatorVote) XXX_DiscardUnknown() {
	xxx_messageInfo_DelegatorVote.DiscardUnknown(m)
}

var xxx_messageInfo_DelegatorVote proto.InternalMessageInfo

func (m *DelegatorVote) GetBody() *DelegatorVoteBody {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *DelegatorVote) GetAuthSig() *v1alpha1.SpendAuthSignature {
	if m != nil {
		return m.AuthSig
	}
	return nil
}

func (m *DelegatorVote) GetProof() *v1alpha1.ZKDelegatorVoteProof {
	if m != nil {
		return m.Proof
	}
	return nil
}

type DelegatorVoteBody struct {
	// The proposal being voted on.
	Proposal uint64 `protobuf:"varint,1,opt,name=proposal,proto3" json:"proposal,omitempty"`
	// The start position of the proposal in the TCT.
	StartPosition uint64 `protobuf:"varint,2,opt,name=start_position,json=startPosition,proto3" json:"start_position,omitempty"`
	// The vote.
	Vote *Vote `protobuf:"bytes,3,opt,name=vote,proto3" json:"vote,omitempty"`
	// The value of the delegation note.
	Value *v1alpha1.Value `protobuf:"bytes,4,opt,name=value,proto3" json:"value,omitempty"`
	// The amount of the delegation note, in unbonded penumbra.
	UnbondedAmount *v1alpha1.Amount `protobuf:"bytes,5,opt,name=unbonded_amount,json=unbondedAmount,proto3" json:"unbonded_amount,omitempty"`
	// The nullifier of the input note.
	Nullifier []byte `protobuf:"bytes,6,opt,name=nullifier,proto3" json:"nullifier,omitempty"`
	// The randomized validating key for the spend authorization signature.
	Rk []byte `protobuf:"bytes,7,opt,name=rk,proto3" json:"rk,omitempty"`
}

func (m *DelegatorVoteBody) Reset()         { *m = DelegatorVoteBody{} }
func (m *DelegatorVoteBody) String() string { return proto.CompactTextString(m) }
func (*DelegatorVoteBody) ProtoMessage()    {}
func (*DelegatorVoteBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bc89f5bf0aed114, []int{6}
}
func (m *DelegatorVoteBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelegatorVoteBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelegatorVoteBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelegatorVoteBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelegatorVoteBody.Merge(m, src)
}
func (m *DelegatorVoteBody) XXX_Size() int {
	return m.Size()
}
func (m *DelegatorVoteBody) XXX_DiscardUnknown() {
	xxx_messageInfo_DelegatorVoteBody.DiscardUnknown(m)
}

var xxx_messageInfo_DelegatorVoteBody proto.InternalMessageInfo

func (m *DelegatorVoteBody) GetProposal() uint64 {
	if m != nil {
		return m.Proposal
	}
	return 0
}

func (m *DelegatorVoteBody) GetStartPosition() uint64 {
	if m != nil {
		return m.StartPosition
	}
	return 0
}

func (m *DelegatorVoteBody) GetVote() *Vote {
	if m != nil {
		return m.Vote
	}
	return nil
}

func (m *DelegatorVoteBody) GetValue() *v1alpha1.Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *DelegatorVoteBody) GetUnbondedAmount() *v1alpha1.Amount {
	if m != nil {
		return m.UnbondedAmount
	}
	return nil
}

func (m *DelegatorVoteBody) GetNullifier() []byte {
	if m != nil {
		return m.Nullifier
	}
	return nil
}

func (m *DelegatorVoteBody) GetRk() []byte {
	if m != nil {
		return m.Rk
	}
	return nil
}

type DelegatorVotePlan struct {
	// The proposal to vote on.
	Proposal uint64 `protobuf:"varint,1,opt,name=proposal,proto3" json:"proposal,omitempty"`
	// The start position of the proposal in the TCT.
	StartPosition uint64 `protobuf:"varint,2,opt,name=start_position,json=startPosition,proto3" json:"start_position,omitempty"`
	// The vote to cast.
	Vote *Vote `protobuf:"bytes,3,opt,name=vote,proto3" json:"vote,omitempty"`
	// The delegation note to prove that we can vote.
	StakedNote *v1alpha1.Note `protobuf:"bytes,4,opt,name=staked_note,json=stakedNote,proto3" json:"staked_note,omitempty"`
	// The position of that delegation note.
	StakedNotePosition uint64 `protobuf:"varint,5,opt,name=staked_note_position,json=stakedNotePosition,proto3" json:"staked_note_position,omitempty"`
	// The unbonded amount equivalent to the delegation note.
	UnbondedAmount *v1alpha1.Amount `protobuf:"bytes,6,opt,name=unbonded_amount,json=unbondedAmount,proto3" json:"unbonded_amount,omitempty"`
	// The randomizer to use for the proof of spend capability.
	Randomizer []byte `protobuf:"bytes,7,opt,name=randomizer,proto3" json:"randomizer,omitempty"`
	// The first blinding factor to use for the ZK delegator vote proof.
	ProofBlindingR []byte `protobuf:"bytes,8,opt,name=proof_blinding_r,json=proofBlindingR,proto3" json:"proof_blinding_r,omitempty"`
	// The second blinding factor to use for the ZK delegator vote proof.
	ProofBlindingS []byte `protobuf:"bytes,9,opt,name=proof_blinding_s,json=proofBlindingS,proto3" json:"proof_blinding_s,omitempty"`
}

func (m *DelegatorVotePlan) Reset()         { *m = DelegatorVotePlan{} }
func (m *DelegatorVotePlan) String() string { return proto.CompactTextString(m) }
func (*DelegatorVotePlan) ProtoMessage()    {}
func (*DelegatorVotePlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bc89f5bf0aed114, []int{7}
}
func (m *DelegatorVotePlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelegatorVotePlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelegatorVotePlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelegatorVotePlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelegatorVotePlan.Merge(m, src)
}
func (m *DelegatorVotePlan) XXX_Size() int {
	return m.Size()
}
func (m *DelegatorVotePlan) XXX_DiscardUnknown() {
	xxx_messageInfo_DelegatorVotePlan.DiscardUnknown(m)
}

var xxx_messageInfo_DelegatorVotePlan proto.InternalMessageInfo

func (m *DelegatorVotePlan) GetProposal() uint64 {
	if m != nil {
		return m.Proposal
	}
	return 0
}

func (m *DelegatorVotePlan) GetStartPosition() uint64 {
	if m != nil {
		return m.StartPosition
	}
	return 0
}

func (m *DelegatorVotePlan) GetVote() *Vote {
	if m != nil {
		return m.Vote
	}
	return nil
}

func (m *DelegatorVotePlan) GetStakedNote() *v1alpha1.Note {
	if m != nil {
		return m.StakedNote
	}
	return nil
}

func (m *DelegatorVotePlan) GetStakedNotePosition() uint64 {
	if m != nil {
		return m.StakedNotePosition
	}
	return 0
}

func (m *DelegatorVotePlan) GetUnbondedAmount() *v1alpha1.Amount {
	if m != nil {
		return m.UnbondedAmount
	}
	return nil
}

func (m *DelegatorVotePlan) GetRandomizer() []byte {
	if m != nil {
		return m.Randomizer
	}
	return nil
}

func (m *DelegatorVotePlan) GetProofBlindingR() []byte {
	if m != nil {
		return m.ProofBlindingR
	}
	return nil
}

func (m *DelegatorVotePlan) GetProofBlindingS() []byte {
	if m != nil {
		return m.ProofBlindingS
	}
	return nil
}

type DaoDeposit struct {
	// The value to deposit into the DAO.
	Value *v1alpha1.Value `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *DaoDeposit) Reset()         { *m = DaoDeposit{} }
func (m *DaoDeposit) String() string { return proto.CompactTextString(m) }
func (*DaoDeposit) ProtoMessage()    {}
func (*DaoDeposit) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bc89f5bf0aed114, []int{8}
}
func (m *DaoDeposit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaoDeposit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DaoDeposit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DaoDeposit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaoDeposit.Merge(m, src)
}
func (m *DaoDeposit) XXX_Size() int {
	return m.Size()
}
func (m *DaoDeposit) XXX_DiscardUnknown() {
	xxx_messageInfo_DaoDeposit.DiscardUnknown(m)
}

var xxx_messageInfo_DaoDeposit proto.InternalMessageInfo

func (m *DaoDeposit) GetValue() *v1alpha1.Value {
	if m != nil {
		return m.Value
	}
	return nil
}

type DaoSpend struct {
	// The value to spend from the DAO.
	Value *v1alpha1.Value `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *DaoSpend) Reset()         { *m = DaoSpend{} }
func (m *DaoSpend) String() string { return proto.CompactTextString(m) }
func (*DaoSpend) ProtoMessage()    {}
func (*DaoSpend) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bc89f5bf0aed114, []int{9}
}
func (m *DaoSpend) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaoSpend) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DaoSpend.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DaoSpend) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaoSpend.Merge(m, src)
}
func (m *DaoSpend) XXX_Size() int {
	return m.Size()
}
func (m *DaoSpend) XXX_DiscardUnknown() {
	xxx_messageInfo_DaoSpend.DiscardUnknown(m)
}

var xxx_messageInfo_DaoSpend proto.InternalMessageInfo

func (m *DaoSpend) GetValue() *v1alpha1.Value {
	if m != nil {
		return m.Value
	}
	return nil
}

type DaoOutput struct {
	// The value to output from the DAO.
	Value *v1alpha1.Value `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	// The address to send the output to.
	Address *v1alpha1.Address `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *DaoOutput) Reset()         { *m = DaoOutput{} }
func (m *DaoOutput) String() string { return proto.CompactTextString(m) }
func (*DaoOutput) ProtoMessage()    {}
func (*DaoOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bc89f5bf0aed114, []int{10}
}
func (m *DaoOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaoOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DaoOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DaoOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaoOutput.Merge(m, src)
}
func (m *DaoOutput) XXX_Size() int {
	return m.Size()
}
func (m *DaoOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_DaoOutput.DiscardUnknown(m)
}

var xxx_messageInfo_DaoOutput proto.InternalMessageInfo

func (m *DaoOutput) GetValue() *v1alpha1.Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *DaoOutput) GetAddress() *v1alpha1.Address {
	if m != nil {
		return m.Address
	}
	return nil
}

// A vote on a proposal.
type Vote struct {
	// The vote.
	Vote Vote_Vote `protobuf:"varint,1,opt,name=vote,proto3,enum=penumbra.core.governance.v1alpha1.Vote_Vote" json:"vote,omitempty"`
}

func (m *Vote) Reset()         { *m = Vote{} }
func (m *Vote) String() string { return proto.CompactTextString(m) }
func (*Vote) ProtoMessage()    {}
func (*Vote) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bc89f5bf0aed114, []int{11}
}
func (m *Vote) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Vote) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Vote.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Vote) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Vote.Merge(m, src)
}
func (m *Vote) XXX_Size() int {
	return m.Size()
}
func (m *Vote) XXX_DiscardUnknown() {
	xxx_messageInfo_Vote.DiscardUnknown(m)
}

var xxx_messageInfo_Vote proto.InternalMessageInfo

func (m *Vote) GetVote() Vote_Vote {
	if m != nil {
		return m.Vote
	}
	return Vote_VOTE_UNSPECIFIED
}

// The current state of a proposal.
type ProposalState struct {
	// The state of the proposal.
	//
	// Types that are valid to be assigned to State:
	//	*ProposalState_Voting_
	//	*ProposalState_Withdrawn_
	//	*ProposalState_Finished_
	//	*ProposalState_Claimed_
	State isProposalState_State `protobuf_oneof:"state"`
}

func (m *ProposalState) Reset()         { *m = ProposalState{} }
func (m *ProposalState) String() string { return proto.CompactTextString(m) }
func (*ProposalState) ProtoMessage()    {}
func (*ProposalState) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bc89f5bf0aed114, []int{12}
}
func (m *ProposalState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProposalState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProposalState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProposalState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProposalState.Merge(m, src)
}
func (m *ProposalState) XXX_Size() int {
	return m.Size()
}
func (m *ProposalState) XXX_DiscardUnknown() {
	xxx_messageInfo_ProposalState.DiscardUnknown(m)
}

var xxx_messageInfo_ProposalState proto.InternalMessageInfo

type isProposalState_State interface {
	isProposalState_State()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ProposalState_Voting_ struct {
	Voting *ProposalState_Voting `protobuf:"bytes,2,opt,name=voting,proto3,oneof" json:"voting,omitempty"`
}
type ProposalState_Withdrawn_ struct {
	Withdrawn *ProposalState_Withdrawn `protobuf:"bytes,3,opt,name=withdrawn,proto3,oneof" json:"withdrawn,omitempty"`
}
type ProposalState_Finished_ struct {
	Finished *ProposalState_Finished `protobuf:"bytes,4,opt,name=finished,proto3,oneof" json:"finished,omitempty"`
}
type ProposalState_Claimed_ struct {
	Claimed *ProposalState_Claimed `protobuf:"bytes,5,opt,name=claimed,proto3,oneof" json:"claimed,omitempty"`
}

func (*ProposalState_Voting_) isProposalState_State()    {}
func (*ProposalState_Withdrawn_) isProposalState_State() {}
func (*ProposalState_Finished_) isProposalState_State()  {}
func (*ProposalState_Claimed_) isProposalState_State()   {}

func (m *ProposalState) GetState() isProposalState_State {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *ProposalState) GetVoting() *ProposalState_Voting {
	if x, ok := m.GetState().(*ProposalState_Voting_); ok {
		return x.Voting
	}
	return nil
}

func (m *ProposalState) GetWithdrawn() *ProposalState_Withdrawn {
	if x, ok := m.GetState().(*ProposalState_Withdrawn_); ok {
		return x.Withdrawn
	}
	return nil
}

func (m *ProposalState) GetFinished() *ProposalState_Finished {
	if x, ok := m.GetState().(*ProposalState_Finished_); ok {
		return x.Finished
	}
	return nil
}

func (m *ProposalState) GetClaimed() *ProposalState_Claimed {
	if x, ok := m.GetState().(*ProposalState_Claimed_); ok {
		return x.Claimed
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ProposalState) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ProposalState_Voting_)(nil),
		(*ProposalState_Withdrawn_)(nil),
		(*ProposalState_Finished_)(nil),
		(*ProposalState_Claimed_)(nil),
	}
}

// Voting is in progress and the proposal has not yet concluded voting or been withdrawn.
type ProposalState_Voting struct {
}

func (m *ProposalState_Voting) Reset()         { *m = ProposalState_Voting{} }
func (m *ProposalState_Voting) String() string { return proto.CompactTextString(m) }
func (*ProposalState_Voting) ProtoMessage()    {}
func (*ProposalState_Voting) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bc89f5bf0aed114, []int{12, 0}
}
func (m *ProposalState_Voting) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProposalState_Voting) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProposalState_Voting.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProposalState_Voting) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProposalState_Voting.Merge(m, src)
}
func (m *ProposalState_Voting) XXX_Size() int {
	return m.Size()
}
func (m *ProposalState_Voting) XXX_DiscardUnknown() {
	xxx_messageInfo_ProposalState_Voting.DiscardUnknown(m)
}

var xxx_messageInfo_ProposalState_Voting proto.InternalMessageInfo

// The proposal has been withdrawn but the voting period is not yet concluded.
type ProposalState_Withdrawn struct {
	// The reason for the withdrawal.
	Reason string `protobuf:"bytes,1,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *ProposalState_Withdrawn) Reset()         { *m = ProposalState_Withdrawn{} }
func (m *ProposalState_Withdrawn) String() string { return proto.CompactTextString(m) }
func (*ProposalState_Withdrawn) ProtoMessage()    {}
func (*ProposalState_Withdrawn) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bc89f5bf0aed114, []int{12, 1}
}
func (m *ProposalState_Withdrawn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProposalState_Withdrawn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProposalState_Withdrawn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProposalState_Withdrawn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProposalState_Withdrawn.Merge(m, src)
}
func (m *ProposalState_Withdrawn) XXX_Size() int {
	return m.Size()
}
func (m *ProposalState_Withdrawn) XXX_DiscardUnknown() {
	xxx_messageInfo_ProposalState_Withdrawn.DiscardUnknown(m)
}

var xxx_messageInfo_ProposalState_Withdrawn proto.InternalMessageInfo

func (m *ProposalState_Withdrawn) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// The voting period has ended, and the proposal has been assigned an outcome.
type ProposalState_Finished struct {
	Outcome *ProposalOutcome `protobuf:"bytes,1,opt,name=outcome,proto3" json:"outcome,omitempty"`
}

func (m *ProposalState_Finished) Reset()         { *m = ProposalState_Finished{} }
func (m *ProposalState_Finished) String() string { return proto.CompactTextString(m) }
func (*ProposalState_Finished) ProtoMessage()    {}
func (*ProposalState_Finished) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bc89f5bf0aed114, []int{12, 2}
}
func (m *ProposalState_Finished) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProposalState_Finished) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProposalState_Finished.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProposalState_Finished) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProposalState_Finished.Merge(m, src)
}
func (m *ProposalState_Finished) XXX_Size() int {
	return m.Size()
}
func (m *ProposalState_Finished) XXX_DiscardUnknown() {
	xxx_messageInfo_ProposalState_Finished.DiscardUnknown(m)
}

var xxx_messageInfo_ProposalState_Finished proto.InternalMessageInfo

func (m *ProposalState_Finished) GetOutcome() *ProposalOutcome {
	if m != nil {
		return m.Outcome
	}
	return nil
}

// The voting period has ended, and the original proposer has claimed their deposit.
type ProposalState_Claimed struct {
	Outcome *ProposalOutcome `protobuf:"bytes,1,opt,name=outcome,proto3" json:"outcome,omitempty"`
}

func (m *ProposalState_Claimed) Reset()         { *m = ProposalState_Claimed{} }
func (m *ProposalState_Claimed) String() string { return proto.CompactTextString(m) }
func (*ProposalState_Claimed) ProtoMessage()    {}
func (*ProposalState_Claimed) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bc89f5bf0aed114, []int{12, 3}
}
func (m *ProposalState_Claimed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProposalState_Claimed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProposalState_Claimed.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProposalState_Claimed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProposalState_Claimed.Merge(m, src)
}
func (m *ProposalState_Claimed) XXX_Size() int {
	return m.Size()
}
func (m *ProposalState_Claimed) XXX_DiscardUnknown() {
	xxx_messageInfo_ProposalState_Claimed.DiscardUnknown(m)
}

var xxx_messageInfo_ProposalState_Claimed proto.InternalMessageInfo

func (m *ProposalState_Claimed) GetOutcome() *ProposalOutcome {
	if m != nil {
		return m.Outcome
	}
	return nil
}

// The outcome of a concluded proposal.
type ProposalOutcome struct {
	// Types that are valid to be assigned to Outcome:
	//
	//	*ProposalOutcome_Passed_
	//	*ProposalOutcome_Failed_
	//	*ProposalOutcome_Slashed_
	Outcome isProposalOutcome_Outcome `protobuf_oneof:"outcome"`
}

func (m *ProposalOutcome) Reset()         { *m = ProposalOutcome{} }
func (m *ProposalOutcome) String() string { return proto.CompactTextString(m) }
func (*ProposalOutcome) ProtoMessage()    {}
func (*ProposalOutcome) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bc89f5bf0aed114, []int{13}
}
func (m *ProposalOutcome) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProposalOutcome) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProposalOutcome.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProposalOutcome) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProposalOutcome.Merge(m, src)
}
func (m *ProposalOutcome) XXX_Size() int {
	return m.Size()
}
func (m *ProposalOutcome) XXX_DiscardUnknown() {
	xxx_messageInfo_ProposalOutcome.DiscardUnknown(m)
}

var xxx_messageInfo_ProposalOutcome proto.InternalMessageInfo

type isProposalOutcome_Outcome interface {
	isProposalOutcome_Outcome()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ProposalOutcome_Passed_ struct {
	Passed *ProposalOutcome_Passed `protobuf:"bytes,1,opt,name=passed,proto3,oneof" json:"passed,omitempty"`
}
type ProposalOutcome_Failed_ struct {
	Failed *ProposalOutcome_Failed `protobuf:"bytes,2,opt,name=failed,proto3,oneof" json:"failed,omitempty"`
}
type ProposalOutcome_Slashed_ struct {
	Slashed *ProposalOutcome_Slashed `protobuf:"bytes,3,opt,name=slashed,proto3,oneof" json:"slashed,omitempty"`
}

func (*ProposalOutcome_Passed_) isProposalOutcome_Outcome()  {}
func (*ProposalOutcome_Failed_) isProposalOutcome_Outcome()  {}
func (*ProposalOutcome_Slashed_) isProposalOutcome_Outcome() {}

func (m *ProposalOutcome) GetOutcome() isProposalOutcome_Outcome {
	if m != nil {
		return m.Outcome
	}
	return nil
}

func (m *ProposalOutcome) GetPassed() *ProposalOutcome_Passed {
	if x, ok := m.GetOutcome().(*ProposalOutcome_Passed_); ok {
		return x.Passed
	}
	return nil
}

func (m *ProposalOutcome) GetFailed() *ProposalOutcome_Failed {
	if x, ok := m.GetOutcome().(*ProposalOutcome_Failed_); ok {
		return x.Failed
	}
	return nil
}

func (m *ProposalOutcome) GetSlashed() *ProposalOutcome_Slashed {
	if x, ok := m.GetOutcome().(*ProposalOutcome_Slashed_); ok {
		return x.Slashed
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ProposalOutcome) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ProposalOutcome_Passed_)(nil),
		(*ProposalOutcome_Failed_)(nil),
		(*ProposalOutcome_Slashed_)(nil),
	}
}

// The proposal was passed.
type ProposalOutcome_Passed struct {
}

func (m *ProposalOutcome_Passed) Reset()         { *m = ProposalOutcome_Passed{} }
func (m *ProposalOutcome_Passed) String() string { return proto.CompactTextString(m) }
func (*ProposalOutcome_Passed) ProtoMessage()    {}
func (*ProposalOutcome_Passed) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bc89f5bf0aed114, []int{13, 0}
}
func (m *ProposalOutcome_Passed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProposalOutcome_Passed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProposalOutcome_Passed.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProposalOutcome_Passed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProposalOutcome_Passed.Merge(m, src)
}
func (m *ProposalOutcome_Passed) XXX_Size() int {
	return m.Size()
}
func (m *ProposalOutcome_Passed) XXX_DiscardUnknown() {
	xxx_messageInfo_ProposalOutcome_Passed.DiscardUnknown(m)
}

var xxx_messageInfo_ProposalOutcome_Passed proto.InternalMessageInfo

// The proposal did not pass.
type ProposalOutcome_Failed struct {
	// Types that are valid to be assigned to XWithdrawnWithReason:
	//
	//	*ProposalOutcome_Failed_WithdrawnWithReason
	XWithdrawnWithReason isProposalOutcome_Failed_XWithdrawnWithReason `protobuf_oneof:"_withdrawn_with_reason"`
}

func (m *ProposalOutcome_Failed) Reset()         { *m = ProposalOutcome_Failed{} }
func (m *ProposalOutcome_Failed) String() string { return proto.CompactTextString(m) }
func (*ProposalOutcome_Failed) ProtoMessage()    {}
func (*ProposalOutcome_Failed) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bc89f5bf0aed114, []int{13, 1}
}
func (m *ProposalOutcome_Failed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProposalOutcome_Failed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProposalOutcome_Failed.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProposalOutcome_Failed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProposalOutcome_Failed.Merge(m, src)
}
func (m *ProposalOutcome_Failed) XXX_Size() int {
	return m.Size()
}
func (m *ProposalOutcome_Failed) XXX_DiscardUnknown() {
	xxx_messageInfo_ProposalOutcome_Failed.DiscardUnknown(m)
}

var xxx_messageInfo_ProposalOutcome_Failed proto.InternalMessageInfo

type isProposalOutcome_Failed_XWithdrawnWithReason interface {
	isProposalOutcome_Failed_XWithdrawnWithReason()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ProposalOutcome_Failed_WithdrawnWithReason struct {
	WithdrawnWithReason string `protobuf:"bytes,1,opt,name=withdrawn_with_reason,json=withdrawnWithReason,proto3,oneof" json:"withdrawn_with_reason,omitempty"`
}

func (*ProposalOutcome_Failed_WithdrawnWithReason) isProposalOutcome_Failed_XWithdrawnWithReason() {}

func (m *ProposalOutcome_Failed) GetXWithdrawnWithReason() isProposalOutcome_Failed_XWithdrawnWithReason {
	if m != nil {
		return m.XWithdrawnWithReason
	}
	return nil
}

func (m *ProposalOutcome_Failed) GetWithdrawnWithReason() string {
	if x, ok := m.GetXWithdrawnWithReason().(*ProposalOutcome_Failed_WithdrawnWithReason); ok {
		return x.WithdrawnWithReason
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ProposalOutcome_Failed) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ProposalOutcome_Failed_WithdrawnWithReason)(nil),
	}
}

// The proposal did not pass, and was slashed.
type ProposalOutcome_Slashed struct {
	// Types that are valid to be assigned to XWithdrawnWithReason:
	//
	//	*ProposalOutcome_Slashed_WithdrawnWithReason
	XWithdrawnWithReason isProposalOutcome_Slashed_XWithdrawnWithReason `protobuf_oneof:"_withdrawn_with_reason"`
}

func (m *ProposalOutcome_Slashed) Reset()         { *m = ProposalOutcome_Slashed{} }
func (m *ProposalOutcome_Slashed) String() string { return proto.CompactTextString(m) }
func (*ProposalOutcome_Slashed) ProtoMessage()    {}
func (*ProposalOutcome_Slashed) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bc89f5bf0aed114, []int{13, 2}
}
func (m *ProposalOutcome_Slashed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProposalOutcome_Slashed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProposalOutcome_Slashed.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProposalOutcome_Slashed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProposalOutcome_Slashed.Merge(m, src)
}
func (m *ProposalOutcome_Slashed) XXX_Size() int {
	return m.Size()
}
func (m *ProposalOutcome_Slashed) XXX_DiscardUnknown() {
	xxx_messageInfo_ProposalOutcome_Slashed.DiscardUnknown(m)
}

var xxx_messageInfo_ProposalOutcome_Slashed proto.InternalMessageInfo

type isProposalOutcome_Slashed_XWithdrawnWithReason interface {
	isProposalOutcome_Slashed_XWithdrawnWithReason()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ProposalOutcome_Slashed_WithdrawnWithReason struct {
	WithdrawnWithReason string `protobuf:"bytes,1,opt,name=withdrawn_with_reason,json=withdrawnWithReason,proto3,oneof" json:"withdrawn_with_reason,omitempty"`
}

func (*ProposalOutcome_Slashed_WithdrawnWithReason) isProposalOutcome_Slashed_XWithdrawnWithReason() {
}

func (m *ProposalOutcome_Slashed) GetXWithdrawnWithReason() isProposalOutcome_Slashed_XWithdrawnWithReason {
	if m != nil {
		return m.XWithdrawnWithReason
	}
	return nil
}

func (m *ProposalOutcome_Slashed) GetWithdrawnWithReason() string {
	if x, ok := m.GetXWithdrawnWithReason().(*ProposalOutcome_Slashed_WithdrawnWithReason); ok {
		return x.WithdrawnWithReason
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ProposalOutcome_Slashed) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ProposalOutcome_Slashed_WithdrawnWithReason)(nil),
	}
}

// A tally of votes on a proposal.
type Tally struct {
	// The number of votes in favor of the proposal.
	Yes uint64 `protobuf:"varint,1,opt,name=yes,proto3" json:"yes,omitempty"`
	// The number of votes against the proposal.
	No uint64 `protobuf:"varint,2,opt,name=no,proto3" json:"no,omitempty"`
	// The number of abstentions.
	Abstain uint64 `protobuf:"varint,3,opt,name=abstain,proto3" json:"abstain,omitempty"`
}

func (m *Tally) Reset()         { *m = Tally{} }
func (m *Tally) String() string { return proto.CompactTextString(m) }
func (*Tally) ProtoMessage()    {}
func (*Tally) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bc89f5bf0aed114, []int{14}
}
func (m *Tally) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tally) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tally.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tally) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tally.Merge(m, src)
}
func (m *Tally) XXX_Size() int {
	return m.Size()
}
func (m *Tally) XXX_DiscardUnknown() {
	xxx_messageInfo_Tally.DiscardUnknown(m)
}

var xxx_messageInfo_Tally proto.InternalMessageInfo

func (m *Tally) GetYes() uint64 {
	if m != nil {
		return m.Yes
	}
	return 0
}

func (m *Tally) GetNo() uint64 {
	if m != nil {
		return m.No
	}
	return 0
}

func (m *Tally) GetAbstain() uint64 {
	if m != nil {
		return m.Abstain
	}
	return 0
}

// A proposal to be voted upon.
type Proposal struct {
	// The unique identifier of the proposal.
	Id uint64 `protobuf:"varint,4,opt,name=id,proto3" json:"id,omitempty"`
	// A short title for the proposal.
	Title string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	// A natural-language description of the effect of the proposal and its justification.
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// The different kinds of proposal. Only one of these should be set.
	Signaling       *Proposal_Signaling       `protobuf:"bytes,5,opt,name=signaling,proto3" json:"signaling,omitempty"`
	Emergency       *Proposal_Emergency       `protobuf:"bytes,6,opt,name=emergency,proto3" json:"emergency,omitempty"`
	ParameterChange *Proposal_ParameterChange `protobuf:"bytes,7,opt,name=parameter_change,json=parameterChange,proto3" json:"parameter_change,omitempty"`
	DaoSpend        *Proposal_DaoSpend        `protobuf:"bytes,8,opt,name=dao_spend,json=daoSpend,proto3" json:"dao_spend,omitempty"`
}

func (m *Proposal) Reset()         { *m = Proposal{} }
func (m *Proposal) String() string { return proto.CompactTextString(m) }
func (*Proposal) ProtoMessage()    {}
func (*Proposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bc89f5bf0aed114, []int{15}
}
func (m *Proposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Proposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Proposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Proposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Proposal.Merge(m, src)
}
func (m *Proposal) XXX_Size() int {
	return m.Size()
}
func (m *Proposal) XXX_DiscardUnknown() {
	xxx_messageInfo_Proposal.DiscardUnknown(m)
}

var xxx_messageInfo_Proposal proto.InternalMessageInfo

func (m *Proposal) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Proposal) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Proposal) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Proposal) GetSignaling() *Proposal_Signaling {
	if m != nil {
		return m.Signaling
	}
	return nil
}

func (m *Proposal) GetEmergency() *Proposal_Emergency {
	if m != nil {
		return m.Emergency
	}
	return nil
}

func (m *Proposal) GetParameterChange() *Proposal_ParameterChange {
	if m != nil {
		return m.ParameterChange
	}
	return nil
}

func (m *Proposal) GetDaoSpend() *Proposal_DaoSpend {
	if m != nil {
		return m.DaoSpend
	}
	return nil
}

// A signaling proposal is meant to register a vote on-chain, but does not have an automatic
// effect when passed.
//
// It optionally contains a reference to a commit which contains code to upgrade the chain.
type Proposal_Signaling struct {
	// Types that are valid to be assigned to XCommit:
	//
	//	*Proposal_Signaling_Commit
	XCommit isProposal_Signaling_XCommit `protobuf_oneof:"_commit"`
}

func (m *Proposal_Signaling) Reset()         { *m = Proposal_Signaling{} }
func (m *Proposal_Signaling) String() string { return proto.CompactTextString(m) }
func (*Proposal_Signaling) ProtoMessage()    {}
func (*Proposal_Signaling) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bc89f5bf0aed114, []int{15, 0}
}
func (m *Proposal_Signaling) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Proposal_Signaling) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Proposal_Signaling.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Proposal_Signaling) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Proposal_Signaling.Merge(m, src)
}
func (m *Proposal_Signaling) XXX_Size() int {
	return m.Size()
}
func (m *Proposal_Signaling) XXX_DiscardUnknown() {
	xxx_messageInfo_Proposal_Signaling.DiscardUnknown(m)
}

var xxx_messageInfo_Proposal_Signaling proto.InternalMessageInfo

type isProposal_Signaling_XCommit interface {
	isProposal_Signaling_XCommit()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Proposal_Signaling_Commit struct {
	Commit string `protobuf:"bytes,1,opt,name=commit,proto3,oneof" json:"commit,omitempty"`
}

func (*Proposal_Signaling_Commit) isProposal_Signaling_XCommit() {}

func (m *Proposal_Signaling) GetXCommit() isProposal_Signaling_XCommit {
	if m != nil {
		return m.XCommit
	}
	return nil
}

func (m *Proposal_Signaling) GetCommit() string {
	if x, ok := m.GetXCommit().(*Proposal_Signaling_Commit); ok {
		return x.Commit
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Proposal_Signaling) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Proposal_Signaling_Commit)(nil),
	}
}

// An emergency proposal can be passed instantaneously by a 2/3 majority of validators, without
// waiting for the voting period to expire.
//
// If the boolean `halt_chain` is set to `true`, then the chain will halt immediately when the
// proposal is passed.
type Proposal_Emergency struct {
	// If `true`, the chain will halt immediately when the proposal is passed.
	HaltChain bool `protobuf:"varint,1,opt,name=halt_chain,json=haltChain,proto3" json:"halt_chain,omitempty"`
}

func (m *Proposal_Emergency) Reset()         { *m = Proposal_Emergency{} }
func (m *Proposal_Emergency) String() string { return proto.CompactTextString(m) }
func (*Proposal_Emergency) ProtoMessage()    {}
func (*Proposal_Emergency) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bc89f5bf0aed114, []int{15, 1}
}
func (m *Proposal_Emergency) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Proposal_Emergency) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Proposal_Emergency.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Proposal_Emergency) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Proposal_Emergency.Merge(m, src)
}
func (m *Proposal_Emergency) XXX_Size() int {
	return m.Size()
}
func (m *Proposal_Emergency) XXX_DiscardUnknown() {
	xxx_messageInfo_Proposal_Emergency.DiscardUnknown(m)
}

var xxx_messageInfo_Proposal_Emergency proto.InternalMessageInfo

func (m *Proposal_Emergency) GetHaltChain() bool {
	if m != nil {
		return m.HaltChain
	}
	return false
}

// A parameter change proposal describes a replacement of the chain parameters, which should take
// effect when the proposal is passed.
type Proposal_ParameterChange struct {
	// The old chain parameters to be replaced: even if the proposal passes, the update will not be
	// applied if the chain parameters have changed *at all* from these chain parameters. Usually,
	// this should be set to the current chain parameters at time of proposal.
	OldParameters *v1alpha11.ChainParameters `protobuf:"bytes,1,opt,name=old_parameters,json=oldParameters,proto3" json:"old_parameters,omitempty"`
	// The new chain parameters to be set: the *entire* chain parameters will be replaced with these
	// at the time the proposal is passed.
	NewParameters *v1alpha11.ChainParameters `protobuf:"bytes,2,opt,name=new_parameters,json=newParameters,proto3" json:"new_parameters,omitempty"`
}

func (m *Proposal_ParameterChange) Reset()         { *m = Proposal_ParameterChange{} }
func (m *Proposal_ParameterChange) String() string { return proto.CompactTextString(m) }
func (*Proposal_ParameterChange) ProtoMessage()    {}
func (*Proposal_ParameterChange) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bc89f5bf0aed114, []int{15, 2}
}
func (m *Proposal_ParameterChange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Proposal_ParameterChange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Proposal_ParameterChange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Proposal_ParameterChange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Proposal_ParameterChange.Merge(m, src)
}
func (m *Proposal_ParameterChange) XXX_Size() int {
	return m.Size()
}
func (m *Proposal_ParameterChange) XXX_DiscardUnknown() {
	xxx_messageInfo_Proposal_ParameterChange.DiscardUnknown(m)
}

var xxx_messageInfo_Proposal_ParameterChange proto.InternalMessageInfo

func (m *Proposal_ParameterChange) GetOldParameters() *v1alpha11.ChainParameters {
	if m != nil {
		return m.OldParameters
	}
	return nil
}

func (m *Proposal_ParameterChange) GetNewParameters() *v1alpha11.ChainParameters {
	if m != nil {
		return m.NewParameters
	}
	return nil
}

// A DAO spend proposal describes zero or more transactions to execute on behalf of the DAO, with
// access to its funds, and zero or more scheduled transactions from previous passed proposals to
// cancel.
type Proposal_DaoSpend struct {
	// The transaction plan to be executed at the time the proposal is passed. This must be a
	// transaction plan which can be executed by the DAO, which means it can't require any witness
	// data or authorization signatures, but it may use the `DaoSpend` action.
	TransactionPlan *types.Any `protobuf:"bytes,2,opt,name=transaction_plan,json=transactionPlan,proto3" json:"transaction_plan,omitempty"`
}

func (m *Proposal_DaoSpend) Reset()         { *m = Proposal_DaoSpend{} }
func (m *Proposal_DaoSpend) String() string { return proto.CompactTextString(m) }
func (*Proposal_DaoSpend) ProtoMessage()    {}
func (*Proposal_DaoSpend) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bc89f5bf0aed114, []int{15, 3}
}
func (m *Proposal_DaoSpend) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Proposal_DaoSpend) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Proposal_DaoSpend.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Proposal_DaoSpend) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Proposal_DaoSpend.Merge(m, src)
}
func (m *Proposal_DaoSpend) XXX_Size() int {
	return m.Size()
}
func (m *Proposal_DaoSpend) XXX_DiscardUnknown() {
	xxx_messageInfo_Proposal_DaoSpend.DiscardUnknown(m)
}

var xxx_messageInfo_Proposal_DaoSpend proto.InternalMessageInfo

func (m *Proposal_DaoSpend) GetTransactionPlan() *types.Any {
	if m != nil {
		return m.TransactionPlan
	}
	return nil
}

func init() {
	proto.RegisterEnum("penumbra.core.governance.v1alpha1.Vote_Vote", Vote_Vote_name, Vote_Vote_value)
	proto.RegisterType((*ProposalSubmit)(nil), "penumbra.core.governance.v1alpha1.ProposalSubmit")
	proto.RegisterType((*ProposalWithdraw)(nil), "penumbra.core.governance.v1alpha1.ProposalWithdraw")
	proto.RegisterType((*ProposalDepositClaim)(nil), "penumbra.core.governance.v1alpha1.ProposalDepositClaim")
	proto.RegisterType((*ValidatorVote)(nil), "penumbra.core.governance.v1alpha1.ValidatorVote")
	proto.RegisterType((*ValidatorVoteBody)(nil), "penumbra.core.governance.v1alpha1.ValidatorVoteBody")
	proto.RegisterType((*DelegatorVote)(nil), "penumbra.core.governance.v1alpha1.DelegatorVote")
	proto.RegisterType((*DelegatorVoteBody)(nil), "penumbra.core.governance.v1alpha1.DelegatorVoteBody")
	proto.RegisterType((*DelegatorVotePlan)(nil), "penumbra.core.governance.v1alpha1.DelegatorVotePlan")
	proto.RegisterType((*DaoDeposit)(nil), "penumbra.core.governance.v1alpha1.DaoDeposit")
	proto.RegisterType((*DaoSpend)(nil), "penumbra.core.governance.v1alpha1.DaoSpend")
	proto.RegisterType((*DaoOutput)(nil), "penumbra.core.governance.v1alpha1.DaoOutput")
	proto.RegisterType((*Vote)(nil), "penumbra.core.governance.v1alpha1.Vote")
	proto.RegisterType((*ProposalState)(nil), "penumbra.core.governance.v1alpha1.ProposalState")
	proto.RegisterType((*ProposalState_Voting)(nil), "penumbra.core.governance.v1alpha1.ProposalState.Voting")
	proto.RegisterType((*ProposalState_Withdrawn)(nil), "penumbra.core.governance.v1alpha1.ProposalState.Withdrawn")
	proto.RegisterType((*ProposalState_Finished)(nil), "penumbra.core.governance.v1alpha1.ProposalState.Finished")
	proto.RegisterType((*ProposalState_Claimed)(nil), "penumbra.core.governance.v1alpha1.ProposalState.Claimed")
	proto.RegisterType((*ProposalOutcome)(nil), "penumbra.core.governance.v1alpha1.ProposalOutcome")
	proto.RegisterType((*ProposalOutcome_Passed)(nil), "penumbra.core.governance.v1alpha1.ProposalOutcome.Passed")
	proto.RegisterType((*ProposalOutcome_Failed)(nil), "penumbra.core.governance.v1alpha1.ProposalOutcome.Failed")
	proto.RegisterType((*ProposalOutcome_Slashed)(nil), "penumbra.core.governance.v1alpha1.ProposalOutcome.Slashed")
	proto.RegisterType((*Tally)(nil), "penumbra.core.governance.v1alpha1.Tally")
	proto.RegisterType((*Proposal)(nil), "penumbra.core.governance.v1alpha1.Proposal")
	proto.RegisterType((*Proposal_Signaling)(nil), "penumbra.core.governance.v1alpha1.Proposal.Signaling")
	proto.RegisterType((*Proposal_Emergency)(nil), "penumbra.core.governance.v1alpha1.Proposal.Emergency")
	proto.RegisterType((*Proposal_ParameterChange)(nil), "penumbra.core.governance.v1alpha1.Proposal.ParameterChange")
	proto.RegisterType((*Proposal_DaoSpend)(nil), "penumbra.core.governance.v1alpha1.Proposal.DaoSpend")
}

func init() {
	proto.RegisterFile("penumbra/core/governance/v1alpha1/governance.proto", fileDescriptor_1bc89f5bf0aed114)
}

var fileDescriptor_1bc89f5bf0aed114 = []byte{
	// 1546 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x58, 0x5d, 0x6f, 0x1b, 0x45,
	0x17, 0xf6, 0x3a, 0x8e, 0x3f, 0x4e, 0x12, 0xc7, 0x9d, 0x37, 0x6f, 0xe5, 0xd7, 0x2f, 0x44, 0xa9,
	0xdb, 0x42, 0x54, 0xa8, 0x4d, 0x53, 0x50, 0xa9, 0x7b, 0x41, 0x63, 0xe7, 0x53, 0x6d, 0x13, 0x77,
	0x1d, 0x52, 0x28, 0x91, 0x96, 0xb1, 0x77, 0x62, 0xaf, 0xb2, 0x9e, 0xb1, 0x76, 0xc7, 0x89, 0xcc,
	0x2f, 0x80, 0xbb, 0x4a, 0xfc, 0x03, 0x24, 0x84, 0xc4, 0x7f, 0xe0, 0x1e, 0x21, 0x01, 0xbd, 0x2c,
	0x77, 0x28, 0xb9, 0xe3, 0x92, 0x5f, 0x80, 0x66, 0x76, 0xf6, 0x23, 0x1f, 0xd4, 0x75, 0x42, 0xc5,
	0xdd, 0x9c, 0xe3, 0xf3, 0x3c, 0xe7, 0x63, 0xce, 0xcc, 0x1c, 0x2f, 0x2c, 0xf4, 0x08, 0xed, 0x77,
	0x9b, 0x0e, 0x2e, 0xb7, 0x98, 0x43, 0xca, 0x6d, 0xb6, 0x4f, 0x1c, 0x8a, 0x69, 0x8b, 0x94, 0xf7,
	0x6f, 0x61, 0xbb, 0xd7, 0xc1, 0xb7, 0x22, 0xba, 0x52, 0xcf, 0x61, 0x9c, 0xa1, 0x2b, 0x3e, 0xa6,
	0x24, 0x30, 0xa5, 0xc8, 0xef, 0x3e, 0xa6, 0xf0, 0xbf, 0x36, 0x63, 0x6d, 0x9b, 0x94, 0x25, 0xa0,
	0xd9, 0xdf, 0x2d, 0x63, 0x3a, 0xf0, 0xd0, 0x85, 0x1b, 0xc7, 0x3d, 0xb6, 0x9c, 0x41, 0x8f, 0xb3,
	0xd0, 0x9b, 0x27, 0x2b, 0xdb, 0xf9, 0x13, 0xb6, 0x1d, 0x6c, 0xd1, 0x88, 0xa9, 0x10, 0x3d, 0xcb,
	0xe2, 0x77, 0x1a, 0x64, 0xeb, 0x0e, 0xeb, 0x31, 0x17, 0xdb, 0x8d, 0x7e, 0xb3, 0x6b, 0x71, 0xb4,
	0x0a, 0xe9, 0x9e, 0xd2, 0xe4, 0xb5, 0x39, 0x6d, 0x7e, 0x62, 0xe1, 0x9d, 0xd2, 0xd0, 0xc8, 0x4b,
	0x3e, 0x89, 0x1e, 0x80, 0xd1, 0x43, 0xc8, 0x9a, 0xa4, 0xc7, 0x5c, 0x8b, 0x1b, 0xb8, 0xcb, 0xfa,
	0x94, 0xe7, 0xc7, 0x24, 0xdd, 0xf5, 0x13, 0x74, 0x2a, 0xf4, 0x80, 0x6a, 0x51, 0x1a, 0xeb, 0x53,
	0x0a, 0xec, 0x89, 0xc5, 0x15, 0xc8, 0xf9, 0x3e, 0x9e, 0x58, 0xbc, 0x63, 0x3a, 0xf8, 0x00, 0x15,
	0x4e, 0x84, 0x9a, 0x88, 0x78, 0xbf, 0x0c, 0x49, 0x87, 0x60, 0x97, 0xd1, 0x7c, 0x7c, 0x4e, 0x9b,
	0xcf, 0xe8, 0x4a, 0x2a, 0xfe, 0xa2, 0xc1, 0x8c, 0x4f, 0xb4, 0xe4, 0x79, 0xa8, 0xd9, 0xd8, 0xea,
	0xbe, 0x94, 0xec, 0x74, 0x2a, 0xf1, 0xf3, 0xa7, 0x82, 0x1e, 0x42, 0x8a, 0xf5, 0x79, 0x8b, 0x75,
	0x89, 0xaa, 0xc8, 0xc2, 0x08, 0x05, 0xde, 0xf4, 0x90, 0xba, 0x4f, 0x21, 0xb6, 0x70, 0x6a, 0x1b,
	0xdb, 0x96, 0x89, 0x39, 0x73, 0xb6, 0x19, 0x27, 0x68, 0x0d, 0x12, 0x4d, 0x66, 0x0e, 0xd4, 0xee,
	0xbd, 0xff, 0x0a, 0xe4, 0xc7, 0xf0, 0x55, 0x66, 0x0e, 0x74, 0xc9, 0x80, 0x1e, 0x42, 0x1a, 0xf7,
	0x79, 0xc7, 0x70, 0xad, 0xb6, 0xca, 0xf8, 0xd6, 0x90, 0x8c, 0x1b, 0x3d, 0x42, 0xcd, 0xc5, 0x3e,
	0xef, 0x34, 0xac, 0x36, 0xc5, 0xbc, 0xef, 0x10, 0x3d, 0x85, 0x3d, 0xb1, 0xf8, 0x2c, 0x0e, 0x97,
	0x4e, 0x79, 0x7a, 0x69, 0xdd, 0xef, 0x41, 0x62, 0x9f, 0x71, 0xa2, 0x7c, 0xbf, 0xfd, 0x2a, 0x99,
	0x30, 0x4e, 0x74, 0x09, 0x42, 0x8f, 0x60, 0xd2, 0x32, 0x09, 0xe5, 0x16, 0x1f, 0x18, 0x7b, 0x64,
	0xa0, 0x6a, 0x7d, 0x63, 0x48, 0x02, 0xeb, 0x0a, 0xf2, 0x80, 0x0c, 0xf4, 0x09, 0x2b, 0x14, 0x50,
	0x03, 0xb2, 0xa1, 0x43, 0x49, 0x98, 0x90, 0x84, 0xef, 0x0e, 0x21, 0x5c, 0x0d, 0x40, 0x82, 0x72,
	0xaa, 0x1d, 0x15, 0x8b, 0x7f, 0x6a, 0x30, 0xb5, 0x44, 0x6c, 0xd2, 0xbe, 0xc0, 0xe6, 0x1d, 0xc3,
	0xbf, 0xae, 0xcd, 0x43, 0xeb, 0x30, 0xde, 0x73, 0x18, 0xdb, 0x55, 0x65, 0xbc, 0x3d, 0x84, 0xea,
	0xe9, 0x83, 0x63, 0x61, 0xd5, 0x05, 0x54, 0xf7, 0x18, 0x8a, 0x3f, 0xc7, 0xe1, 0xd2, 0xa9, 0xa0,
	0x5f, 0xda, 0x07, 0xd7, 0x21, 0xeb, 0x72, 0xec, 0x70, 0x43, 0x1e, 0x23, 0x4b, 0x1d, 0xea, 0x84,
	0x3e, 0x25, 0xb5, 0x75, 0xa5, 0x0c, 0xda, 0x65, 0xec, 0x3c, 0xed, 0x52, 0x81, 0xf1, 0x7d, 0x6c,
	0xf7, 0x89, 0xda, 0xd6, 0x6b, 0x43, 0x12, 0xdc, 0x16, 0xb6, 0xba, 0x07, 0x41, 0x1b, 0x30, 0xdd,
	0xa7, 0x4d, 0x46, 0x4d, 0x62, 0xfa, 0x17, 0xc4, 0xf8, 0x28, 0x17, 0x44, 0xd6, 0x47, 0xab, 0x1b,
	0xe2, 0x0d, 0xc8, 0xd0, 0xbe, 0x6d, 0x5b, 0xbb, 0x16, 0x71, 0xf2, 0xc9, 0x39, 0x6d, 0x7e, 0x52,
	0x0f, 0x15, 0x28, 0x0b, 0x71, 0x67, 0x2f, 0x9f, 0x92, 0xea, 0xb8, 0xb3, 0x57, 0xfc, 0x75, 0xec,
	0x44, 0x3d, 0xeb, 0x36, 0xa6, 0xff, 0x7a, 0x3d, 0x97, 0x60, 0xc2, 0xe5, 0x78, 0x8f, 0x98, 0x06,
	0x15, 0x1c, 0x5e, 0x55, 0xaf, 0x0e, 0xa9, 0xc7, 0x86, 0xc0, 0x83, 0x87, 0x13, 0x6b, 0xf4, 0x1e,
	0xcc, 0x44, 0x58, 0xc2, 0x78, 0xc7, 0x65, 0xbc, 0x28, 0xb4, 0x0c, 0x82, 0x3e, 0x63, 0x2f, 0x92,
	0x17, 0xd9, 0x8b, 0x59, 0x00, 0x07, 0x53, 0x93, 0x75, 0xad, 0x2f, 0x88, 0xa3, 0xaa, 0x1e, 0xd1,
	0xa0, 0x79, 0xc8, 0xc9, 0xb6, 0x36, 0x9a, 0xb6, 0x45, 0x4d, 0x8b, 0xb6, 0x0d, 0x27, 0x9f, 0x96,
	0x56, 0x59, 0xa9, 0xaf, 0x2a, 0xb5, 0x7e, 0x86, 0xa5, 0x9b, 0xcf, 0x9c, 0x61, 0xd9, 0x28, 0xae,
	0x01, 0x2c, 0x61, 0xa6, 0x9e, 0xa7, 0xb0, 0x33, 0xb5, 0x91, 0x3b, 0xb3, 0xb8, 0x02, 0xe9, 0x25,
	0xcc, 0xe4, 0xc1, 0xbe, 0x10, 0xcf, 0x57, 0x1a, 0x64, 0x96, 0x30, 0xdb, 0xec, 0xf3, 0x5e, 0xff,
	0x42, 0x11, 0xa1, 0xfb, 0x90, 0xc2, 0xa6, 0xe9, 0x10, 0xd7, 0x55, 0xb7, 0xd2, 0x5b, 0xc3, 0xf6,
	0xc5, 0xb3, 0xd6, 0x7d, 0x58, 0xf1, 0x6b, 0x0d, 0x12, 0xf2, 0xae, 0xbc, 0xaf, 0xfa, 0x53, 0x44,
	0x91, 0x3d, 0x75, 0x11, 0xff, 0x5d, 0x7f, 0x46, 0x9a, 0xb4, 0xb8, 0xae, 0x98, 0x66, 0x20, 0xb7,
	0xbd, 0xb9, 0xb5, 0x6c, 0x7c, 0xbc, 0xd1, 0xa8, 0x2f, 0xd7, 0xd6, 0x57, 0xd6, 0x97, 0x97, 0x72,
	0x31, 0x94, 0x83, 0x49, 0xa9, 0x5d, 0xac, 0x36, 0xb6, 0x16, 0xd7, 0x37, 0x72, 0x1a, 0x9a, 0x84,
	0xb4, 0xd4, 0x7c, 0xba, 0xdc, 0xc8, 0xc5, 0xd1, 0x04, 0xa4, 0xa4, 0xb4, 0xb1, 0x99, 0x1b, 0x2b,
	0xbe, 0x48, 0xc0, 0x54, 0x30, 0x4a, 0x71, 0xcc, 0x09, 0x7a, 0x0c, 0xc9, 0x7d, 0xc6, 0x2d, 0xea,
	0x5f, 0xbf, 0x77, 0x46, 0x78, 0xe6, 0x25, 0x83, 0x88, 0xd4, 0xa2, 0xed, 0xb5, 0x98, 0xae, 0x88,
	0xd0, 0x53, 0xc8, 0x1c, 0xa8, 0xe9, 0x87, 0xaa, 0x63, 0x59, 0x19, 0x99, 0xd5, 0x9f, 0x9f, 0xe8,
	0x5a, 0x4c, 0x0f, 0xe9, 0xd0, 0x13, 0x48, 0xef, 0x5a, 0xd4, 0x72, 0x3b, 0xc4, 0x54, 0xa7, 0xf5,
	0xee, 0xc8, 0xd4, 0x2b, 0x8a, 0x60, 0x2d, 0xa6, 0x07, 0x64, 0x68, 0x0b, 0x52, 0x2d, 0x31, 0x62,
	0x11, 0x53, 0xdd, 0x8a, 0x1f, 0x8e, 0xcc, 0x5b, 0xf3, 0xf0, 0x6b, 0x31, 0xdd, 0xa7, 0x2a, 0xa4,
	0x21, 0xe9, 0x95, 0xa7, 0x70, 0x15, 0x32, 0x41, 0x4a, 0x91, 0xb9, 0x4f, 0x8b, 0xce, 0x7d, 0x85,
	0x4f, 0x20, 0xed, 0x07, 0x17, 0x1d, 0xc0, 0xb4, 0x0b, 0x0f, 0x60, 0x85, 0x27, 0x90, 0x52, 0xe1,
	0xfd, 0xb3, 0xc4, 0xd5, 0x14, 0x8c, 0xbb, 0x22, 0xfb, 0xe2, 0xd1, 0x18, 0x4c, 0x9f, 0xb0, 0x42,
	0x0d, 0x48, 0xf6, 0xb0, 0xeb, 0x12, 0x53, 0x79, 0xba, 0x3b, 0xba, 0xa7, 0x52, 0x5d, 0x12, 0x88,
	0xf6, 0xf2, 0xa8, 0x04, 0xe9, 0x2e, 0xb6, 0x6c, 0x62, 0xaa, 0x8e, 0x3d, 0x0f, 0xe9, 0x8a, 0x24,
	0x10, 0xa4, 0x1e, 0x15, 0xda, 0x86, 0x94, 0x6b, 0x63, 0xd9, 0x56, 0xa3, 0x77, 0xac, 0xcf, 0xda,
	0xf0, 0x18, 0x44, 0x03, 0x28, 0x32, 0xd1, 0x00, 0x5e, 0x02, 0x85, 0xcf, 0x20, 0xe9, 0x79, 0x45,
	0x77, 0xe0, 0xbf, 0x41, 0x43, 0x1b, 0x62, 0x65, 0x44, 0x9b, 0x61, 0x2d, 0xa6, 0xff, 0x27, 0xf8,
	0x59, 0xb4, 0x8c, 0x2e, 0x7f, 0xfc, 0x52, 0xd3, 0xaa, 0x79, 0xb8, 0x6c, 0x9c, 0x89, 0x2c, 0xec,
	0x40, 0x4a, 0x39, 0x7f, 0x0d, 0xec, 0xd5, 0x4c, 0xd0, 0x31, 0xc5, 0x1a, 0x8c, 0x6f, 0x61, 0xdb,
	0x1e, 0xa0, 0x1c, 0x8c, 0x0d, 0x88, 0xab, 0x1e, 0x6d, 0xb1, 0x14, 0x2f, 0x3e, 0x65, 0xea, 0x8d,
	0x8e, 0x53, 0x86, 0xf2, 0x90, 0xc2, 0x4d, 0x97, 0x63, 0xcb, 0xbb, 0x04, 0x12, 0xba, 0x2f, 0x16,
	0xbf, 0x4d, 0x42, 0xda, 0xaf, 0x9d, 0x80, 0x59, 0xde, 0x59, 0x4e, 0xe8, 0x71, 0xcb, 0x44, 0x33,
	0x30, 0xce, 0x2d, 0x6e, 0x13, 0x75, 0x34, 0x3c, 0x01, 0xcd, 0xc1, 0x84, 0x49, 0xdc, 0x96, 0x63,
	0xf5, 0x82, 0x49, 0x20, 0xa3, 0x47, 0x55, 0xa8, 0x01, 0x19, 0x57, 0x4c, 0x84, 0xb6, 0xb8, 0xcb,
	0xbc, 0x23, 0xfc, 0xc1, 0x08, 0x7b, 0x58, 0x6a, 0xf8, 0x60, 0x3d, 0xe4, 0x11, 0xa4, 0xa4, 0x4b,
	0x9c, 0x36, 0xa1, 0xad, 0x81, 0x7a, 0xa1, 0x47, 0x22, 0x5d, 0xf6, 0xc1, 0x7a, 0xc8, 0x83, 0x76,
	0x21, 0xd7, 0xc3, 0x0e, 0xee, 0x12, 0x4e, 0x1c, 0xa3, 0xd5, 0xc1, 0xb4, 0x4d, 0xe4, 0x93, 0x3d,
	0xb1, 0x70, 0x6f, 0x14, 0xee, 0xba, 0xcf, 0x51, 0x93, 0x14, 0xfa, 0x74, 0xef, 0xb8, 0x02, 0x3d,
	0x86, 0x8c, 0x89, 0x99, 0xe1, 0x8a, 0x77, 0x55, 0xbe, 0xf6, 0xaf, 0x36, 0xaa, 0x07, 0x0e, 0xfc,
	0x37, 0x59, 0x4f, 0x9b, 0x6a, 0x55, 0xb8, 0x0d, 0x99, 0xa0, 0x4e, 0xe8, 0xff, 0x90, 0x6c, 0xb1,
	0x6e, 0xd7, 0xe2, 0x41, 0x6b, 0x29, 0x59, 0x74, 0x53, 0x06, 0x52, 0x86, 0x27, 0x15, 0x6e, 0x40,
	0x26, 0xa8, 0x03, 0x7a, 0x13, 0xa0, 0x83, 0x6d, 0x6e, 0xc8, 0x3f, 0xf8, 0x12, 0x98, 0xd6, 0x33,
	0x42, 0x53, 0x13, 0x8a, 0xc2, 0x0f, 0x1a, 0x4c, 0x9f, 0x48, 0x0c, 0x6d, 0x41, 0x96, 0xd9, 0xa6,
	0x11, 0xa4, 0xe7, 0xaa, 0xdb, 0xe4, 0xe6, 0xc9, 0x37, 0x59, 0x7e, 0x33, 0x08, 0xf2, 0x90, 0x84,
	0x01, 0x97, 0xab, 0x4f, 0x31, 0xdb, 0x0c, 0x45, 0xc1, 0x4a, 0xc9, 0x41, 0x94, 0x35, 0x7e, 0x2e,
	0x56, 0x4a, 0x0e, 0x42, 0xb1, 0xf0, 0x20, 0x32, 0xca, 0x7c, 0x04, 0x39, 0xee, 0x60, 0xea, 0xe2,
	0x96, 0x68, 0x50, 0xa3, 0x67, 0x63, 0xaa, 0x7c, 0xcc, 0x94, 0xbc, 0x6f, 0x28, 0x25, 0xff, 0x1b,
	0x4a, 0x69, 0x91, 0x0e, 0xf4, 0xe9, 0x88, 0xb5, 0x98, 0x8e, 0xab, 0xbf, 0xc5, 0x7f, 0x3c, 0x9c,
	0xd5, 0x9e, 0x1f, 0xce, 0x6a, 0xbf, 0x1f, 0xce, 0x6a, 0xcf, 0x8e, 0x66, 0x63, 0xcf, 0x8f, 0x66,
	0x63, 0x2f, 0x8e, 0x66, 0x63, 0x70, 0xbd, 0xc5, 0xba, 0xc3, 0xf7, 0xb2, 0x3a, 0x1d, 0xfe, 0xb1,
	0xab, 0x0b, 0x57, 0x75, 0xed, 0xe9, 0xe7, 0x6d, 0x8b, 0x77, 0xfa, 0xcd, 0x52, 0x8b, 0x75, 0xcb,
	0x2d, 0xe6, 0x76, 0x99, 0x5b, 0x76, 0x88, 0x8d, 0x07, 0xc4, 0x29, 0xef, 0x2f, 0x04, 0x4b, 0x99,
	0xb5, 0x5b, 0x1e, 0xfa, 0x05, 0xe9, 0x5e, 0xa8, 0xf3, 0x55, 0xdf, 0xc4, 0xc7, 0xea, 0xb5, 0xd5,
	0xef, 0xe3, 0x57, 0xea, 0x7e, 0x78, 0x35, 0x11, 0x5e, 0x18, 0x49, 0x69, 0x5b, 0x59, 0xfe, 0x14,
	0xda, 0xec, 0x08, 0x9b, 0x9d, 0xd0, 0x66, 0xc7, 0xb7, 0x39, 0x8c, 0xdf, 0x1c, 0x6a, 0xb3, 0xb3,
	0x5a, 0xaf, 0x3e, 0x22, 0x1c, 0x9b, 0x98, 0xe3, 0x3f, 0xe2, 0xd7, 0x7c, 0xfb, 0x4a, 0x45, 0x00,
	0x2a, 0x95, 0x10, 0x51, 0xa9, 0xf8, 0x90, 0x66, 0x52, 0x96, 0xfe, 0xf6, 0x5f, 0x01, 0x00, 0x00,
	0xff, 0xff, 0x07, 0xf0, 0xab, 0xae, 0x25, 0x13, 0x00, 0x00,
}

func (m *ProposalSubmit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProposalSubmit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalSubmit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DepositAmount != nil {
		{
			size, err := m.DepositAmount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Proposal != nil {
		{
			size, err := m.Proposal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProposalWithdraw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProposalWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintGovernance(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x12
	}
	if m.Proposal != 0 {
		i = encodeVarintGovernance(dAtA, i, uint64(m.Proposal))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProposalDepositClaim) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProposalDepositClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalDepositClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Outcome != nil {
		{
			size, err := m.Outcome.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.DepositAmount != nil {
		{
			size, err := m.DepositAmount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Proposal != 0 {
		i = encodeVarintGovernance(dAtA, i, uint64(m.Proposal))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ValidatorVote) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorVote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorVote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AuthSig != nil {
		{
			size, err := m.AuthSig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Body != nil {
		{
			size, err := m.Body.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidatorVoteBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorVoteBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorVoteBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GovernanceKey != nil {
		{
			size, err := m.GovernanceKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.IdentityKey != nil {
		{
			size, err := m.IdentityKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Vote != nil {
		{
			size, err := m.Vote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Proposal != 0 {
		i = encodeVarintGovernance(dAtA, i, uint64(m.Proposal))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DelegatorVote) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelegatorVote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelegatorVote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Proof != nil {
		{
			size, err := m.Proof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.AuthSig != nil {
		{
			size, err := m.AuthSig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Body != nil {
		{
			size, err := m.Body.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DelegatorVoteBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelegatorVoteBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelegatorVoteBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Rk) > 0 {
		i -= len(m.Rk)
		copy(dAtA[i:], m.Rk)
		i = encodeVarintGovernance(dAtA, i, uint64(len(m.Rk)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Nullifier) > 0 {
		i -= len(m.Nullifier)
		copy(dAtA[i:], m.Nullifier)
		i = encodeVarintGovernance(dAtA, i, uint64(len(m.Nullifier)))
		i--
		dAtA[i] = 0x32
	}
	if m.UnbondedAmount != nil {
		{
			size, err := m.UnbondedAmount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Vote != nil {
		{
			size, err := m.Vote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.StartPosition != 0 {
		i = encodeVarintGovernance(dAtA, i, uint64(m.StartPosition))
		i--
		dAtA[i] = 0x10
	}
	if m.Proposal != 0 {
		i = encodeVarintGovernance(dAtA, i, uint64(m.Proposal))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DelegatorVotePlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelegatorVotePlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelegatorVotePlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProofBlindingS) > 0 {
		i -= len(m.ProofBlindingS)
		copy(dAtA[i:], m.ProofBlindingS)
		i = encodeVarintGovernance(dAtA, i, uint64(len(m.ProofBlindingS)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ProofBlindingR) > 0 {
		i -= len(m.ProofBlindingR)
		copy(dAtA[i:], m.ProofBlindingR)
		i = encodeVarintGovernance(dAtA, i, uint64(len(m.ProofBlindingR)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Randomizer) > 0 {
		i -= len(m.Randomizer)
		copy(dAtA[i:], m.Randomizer)
		i = encodeVarintGovernance(dAtA, i, uint64(len(m.Randomizer)))
		i--
		dAtA[i] = 0x3a
	}
	if m.UnbondedAmount != nil {
		{
			size, err := m.UnbondedAmount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.StakedNotePosition != 0 {
		i = encodeVarintGovernance(dAtA, i, uint64(m.StakedNotePosition))
		i--
		dAtA[i] = 0x28
	}
	if m.StakedNote != nil {
		{
			size, err := m.StakedNote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Vote != nil {
		{
			size, err := m.Vote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.StartPosition != 0 {
		i = encodeVarintGovernance(dAtA, i, uint64(m.StartPosition))
		i--
		dAtA[i] = 0x10
	}
	if m.Proposal != 0 {
		i = encodeVarintGovernance(dAtA, i, uint64(m.Proposal))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DaoDeposit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaoDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DaoSpend) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaoSpend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoSpend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DaoOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaoOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Address != nil {
		{
			size, err := m.Address.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Vote) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Vote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Vote != 0 {
		i = encodeVarintGovernance(dAtA, i, uint64(m.Vote))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProposalState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProposalState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != nil {
		{
			size := m.State.Size()
			i -= size
			if _, err := m.State.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ProposalState_Voting_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalState_Voting_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Voting != nil {
		{
			size, err := m.Voting.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ProposalState_Withdrawn_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalState_Withdrawn_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Withdrawn != nil {
		{
			size, err := m.Withdrawn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ProposalState_Finished_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalState_Finished_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Finished != nil {
		{
			size, err := m.Finished.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ProposalState_Claimed_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalState_Claimed_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Claimed != nil {
		{
			size, err := m.Claimed.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *ProposalState_Voting) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProposalState_Voting) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalState_Voting) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ProposalState_Withdrawn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProposalState_Withdrawn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalState_Withdrawn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintGovernance(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProposalState_Finished) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProposalState_Finished) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalState_Finished) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Outcome != nil {
		{
			size, err := m.Outcome.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProposalState_Claimed) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProposalState_Claimed) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalState_Claimed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Outcome != nil {
		{
			size, err := m.Outcome.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProposalOutcome) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProposalOutcome) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalOutcome) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Outcome != nil {
		{
			size := m.Outcome.Size()
			i -= size
			if _, err := m.Outcome.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ProposalOutcome_Passed_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalOutcome_Passed_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Passed != nil {
		{
			size, err := m.Passed.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ProposalOutcome_Failed_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalOutcome_Failed_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Failed != nil {
		{
			size, err := m.Failed.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ProposalOutcome_Slashed_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalOutcome_Slashed_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Slashed != nil {
		{
			size, err := m.Slashed.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ProposalOutcome_Passed) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProposalOutcome_Passed) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalOutcome_Passed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ProposalOutcome_Failed) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProposalOutcome_Failed) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalOutcome_Failed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XWithdrawnWithReason != nil {
		{
			size := m.XWithdrawnWithReason.Size()
			i -= size
			if _, err := m.XWithdrawnWithReason.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ProposalOutcome_Failed_WithdrawnWithReason) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalOutcome_Failed_WithdrawnWithReason) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.WithdrawnWithReason)
	copy(dAtA[i:], m.WithdrawnWithReason)
	i = encodeVarintGovernance(dAtA, i, uint64(len(m.WithdrawnWithReason)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *ProposalOutcome_Slashed) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProposalOutcome_Slashed) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalOutcome_Slashed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XWithdrawnWithReason != nil {
		{
			size := m.XWithdrawnWithReason.Size()
			i -= size
			if _, err := m.XWithdrawnWithReason.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ProposalOutcome_Slashed_WithdrawnWithReason) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalOutcome_Slashed_WithdrawnWithReason) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.WithdrawnWithReason)
	copy(dAtA[i:], m.WithdrawnWithReason)
	i = encodeVarintGovernance(dAtA, i, uint64(len(m.WithdrawnWithReason)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *Tally) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tally) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tally) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Abstain != 0 {
		i = encodeVarintGovernance(dAtA, i, uint64(m.Abstain))
		i--
		dAtA[i] = 0x18
	}
	if m.No != 0 {
		i = encodeVarintGovernance(dAtA, i, uint64(m.No))
		i--
		dAtA[i] = 0x10
	}
	if m.Yes != 0 {
		i = encodeVarintGovernance(dAtA, i, uint64(m.Yes))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Proposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Proposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Proposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DaoSpend != nil {
		{
			size, err := m.DaoSpend.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.ParameterChange != nil {
		{
			size, err := m.ParameterChange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Emergency != nil {
		{
			size, err := m.Emergency.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Signaling != nil {
		{
			size, err := m.Signaling.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Id != 0 {
		i = encodeVarintGovernance(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintGovernance(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintGovernance(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Proposal_Signaling) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Proposal_Signaling) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Proposal_Signaling) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XCommit != nil {
		{
			size := m.XCommit.Size()
			i -= size
			if _, err := m.XCommit.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Proposal_Signaling_Commit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Proposal_Signaling_Commit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Commit)
	copy(dAtA[i:], m.Commit)
	i = encodeVarintGovernance(dAtA, i, uint64(len(m.Commit)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *Proposal_Emergency) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Proposal_Emergency) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Proposal_Emergency) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HaltChain {
		i--
		if m.HaltChain {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Proposal_ParameterChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Proposal_ParameterChange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Proposal_ParameterChange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NewParameters != nil {
		{
			size, err := m.NewParameters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.OldParameters != nil {
		{
			size, err := m.OldParameters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Proposal_DaoSpend) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Proposal_DaoSpend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Proposal_DaoSpend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TransactionPlan != nil {
		{
			size, err := m.TransactionPlan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGovernance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func encodeVarintGovernance(dAtA []byte, offset int, v uint64) int {
	offset -= sovGovernance(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ProposalSubmit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Proposal != nil {
		l = m.Proposal.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	if m.DepositAmount != nil {
		l = m.DepositAmount.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func (m *ProposalWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Proposal != 0 {
		n += 1 + sovGovernance(uint64(m.Proposal))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func (m *ProposalDepositClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Proposal != 0 {
		n += 1 + sovGovernance(uint64(m.Proposal))
	}
	if m.DepositAmount != nil {
		l = m.DepositAmount.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	if m.Outcome != nil {
		l = m.Outcome.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func (m *ValidatorVote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Body != nil {
		l = m.Body.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	if m.AuthSig != nil {
		l = m.AuthSig.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func (m *ValidatorVoteBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Proposal != 0 {
		n += 1 + sovGovernance(uint64(m.Proposal))
	}
	if m.Vote != nil {
		l = m.Vote.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	if m.IdentityKey != nil {
		l = m.IdentityKey.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	if m.GovernanceKey != nil {
		l = m.GovernanceKey.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func (m *DelegatorVote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Body != nil {
		l = m.Body.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	if m.AuthSig != nil {
		l = m.AuthSig.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	if m.Proof != nil {
		l = m.Proof.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func (m *DelegatorVoteBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Proposal != 0 {
		n += 1 + sovGovernance(uint64(m.Proposal))
	}
	if m.StartPosition != 0 {
		n += 1 + sovGovernance(uint64(m.StartPosition))
	}
	if m.Vote != nil {
		l = m.Vote.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	if m.UnbondedAmount != nil {
		l = m.UnbondedAmount.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	l = len(m.Nullifier)
	if l > 0 {
		n += 1 + l + sovGovernance(uint64(l))
	}
	l = len(m.Rk)
	if l > 0 {
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func (m *DelegatorVotePlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Proposal != 0 {
		n += 1 + sovGovernance(uint64(m.Proposal))
	}
	if m.StartPosition != 0 {
		n += 1 + sovGovernance(uint64(m.StartPosition))
	}
	if m.Vote != nil {
		l = m.Vote.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	if m.StakedNote != nil {
		l = m.StakedNote.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	if m.StakedNotePosition != 0 {
		n += 1 + sovGovernance(uint64(m.StakedNotePosition))
	}
	if m.UnbondedAmount != nil {
		l = m.UnbondedAmount.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	l = len(m.Randomizer)
	if l > 0 {
		n += 1 + l + sovGovernance(uint64(l))
	}
	l = len(m.ProofBlindingR)
	if l > 0 {
		n += 1 + l + sovGovernance(uint64(l))
	}
	l = len(m.ProofBlindingS)
	if l > 0 {
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func (m *DaoDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func (m *DaoSpend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func (m *DaoOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	if m.Address != nil {
		l = m.Address.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func (m *Vote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Vote != 0 {
		n += 1 + sovGovernance(uint64(m.Vote))
	}
	return n
}

func (m *ProposalState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != nil {
		n += m.State.Size()
	}
	return n
}

func (m *ProposalState_Voting_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Voting != nil {
		l = m.Voting.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}
func (m *ProposalState_Withdrawn_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Withdrawn != nil {
		l = m.Withdrawn.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}
func (m *ProposalState_Finished_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Finished != nil {
		l = m.Finished.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}
func (m *ProposalState_Claimed_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Claimed != nil {
		l = m.Claimed.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}
func (m *ProposalState_Voting) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ProposalState_Withdrawn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func (m *ProposalState_Finished) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Outcome != nil {
		l = m.Outcome.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func (m *ProposalState_Claimed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Outcome != nil {
		l = m.Outcome.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func (m *ProposalOutcome) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Outcome != nil {
		n += m.Outcome.Size()
	}
	return n
}

func (m *ProposalOutcome_Passed_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Passed != nil {
		l = m.Passed.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}
func (m *ProposalOutcome_Failed_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Failed != nil {
		l = m.Failed.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}
func (m *ProposalOutcome_Slashed_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Slashed != nil {
		l = m.Slashed.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}
func (m *ProposalOutcome_Passed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ProposalOutcome_Failed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XWithdrawnWithReason != nil {
		n += m.XWithdrawnWithReason.Size()
	}
	return n
}

func (m *ProposalOutcome_Failed_WithdrawnWithReason) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.WithdrawnWithReason)
	n += 1 + l + sovGovernance(uint64(l))
	return n
}
func (m *ProposalOutcome_Slashed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XWithdrawnWithReason != nil {
		n += m.XWithdrawnWithReason.Size()
	}
	return n
}

func (m *ProposalOutcome_Slashed_WithdrawnWithReason) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.WithdrawnWithReason)
	n += 1 + l + sovGovernance(uint64(l))
	return n
}
func (m *Tally) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Yes != 0 {
		n += 1 + sovGovernance(uint64(m.Yes))
	}
	if m.No != 0 {
		n += 1 + sovGovernance(uint64(m.No))
	}
	if m.Abstain != 0 {
		n += 1 + sovGovernance(uint64(m.Abstain))
	}
	return n
}

func (m *Proposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovGovernance(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovGovernance(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovGovernance(uint64(m.Id))
	}
	if m.Signaling != nil {
		l = m.Signaling.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	if m.Emergency != nil {
		l = m.Emergency.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	if m.ParameterChange != nil {
		l = m.ParameterChange.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	if m.DaoSpend != nil {
		l = m.DaoSpend.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func (m *Proposal_Signaling) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XCommit != nil {
		n += m.XCommit.Size()
	}
	return n
}

func (m *Proposal_Signaling_Commit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Commit)
	n += 1 + l + sovGovernance(uint64(l))
	return n
}
func (m *Proposal_Emergency) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HaltChain {
		n += 2
	}
	return n
}

func (m *Proposal_ParameterChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OldParameters != nil {
		l = m.OldParameters.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	if m.NewParameters != nil {
		l = m.NewParameters.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func (m *Proposal_DaoSpend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TransactionPlan != nil {
		l = m.TransactionPlan.Size()
		n += 1 + l + sovGovernance(uint64(l))
	}
	return n
}

func sovGovernance(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGovernance(x uint64) (n int) {
	return sovGovernance(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ProposalSubmit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProposalSubmit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProposalSubmit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proposal == nil {
				m.Proposal = &Proposal{}
			}
			if err := m.Proposal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DepositAmount == nil {
				m.DepositAmount = &v1alpha1.Amount{}
			}
			if err := m.DepositAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProposalWithdraw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProposalWithdraw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProposalWithdraw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposal", wireType)
			}
			m.Proposal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Proposal |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProposalDepositClaim) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProposalDepositClaim: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProposalDepositClaim: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposal", wireType)
			}
			m.Proposal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Proposal |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DepositAmount == nil {
				m.DepositAmount = &v1alpha1.Amount{}
			}
			if err := m.DepositAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outcome", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Outcome == nil {
				m.Outcome = &ProposalOutcome{}
			}
			if err := m.Outcome.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorVote) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorVote: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorVote: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Body == nil {
				m.Body = &ValidatorVoteBody{}
			}
			if err := m.Body.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthSig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuthSig == nil {
				m.AuthSig = &v1alpha1.SpendAuthSignature{}
			}
			if err := m.AuthSig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorVoteBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorVoteBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorVoteBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposal", wireType)
			}
			m.Proposal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Proposal |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vote == nil {
				m.Vote = &Vote{}
			}
			if err := m.Vote.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdentityKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdentityKey == nil {
				m.IdentityKey = &v1alpha1.IdentityKey{}
			}
			if err := m.IdentityKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GovernanceKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GovernanceKey == nil {
				m.GovernanceKey = &v1alpha1.GovernanceKey{}
			}
			if err := m.GovernanceKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelegatorVote) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelegatorVote: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelegatorVote: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Body == nil {
				m.Body = &DelegatorVoteBody{}
			}
			if err := m.Body.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthSig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuthSig == nil {
				m.AuthSig = &v1alpha1.SpendAuthSignature{}
			}
			if err := m.AuthSig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proof == nil {
				m.Proof = &v1alpha1.ZKDelegatorVoteProof{}
			}
			if err := m.Proof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelegatorVoteBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelegatorVoteBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelegatorVoteBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposal", wireType)
			}
			m.Proposal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Proposal |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartPosition", wireType)
			}
			m.StartPosition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartPosition |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vote == nil {
				m.Vote = &Vote{}
			}
			if err := m.Vote.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &v1alpha1.Value{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondedAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UnbondedAmount == nil {
				m.UnbondedAmount = &v1alpha1.Amount{}
			}
			if err := m.UnbondedAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nullifier", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nullifier = append(m.Nullifier[:0], dAtA[iNdEx:postIndex]...)
			if m.Nullifier == nil {
				m.Nullifier = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rk = append(m.Rk[:0], dAtA[iNdEx:postIndex]...)
			if m.Rk == nil {
				m.Rk = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelegatorVotePlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelegatorVotePlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelegatorVotePlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposal", wireType)
			}
			m.Proposal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Proposal |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartPosition", wireType)
			}
			m.StartPosition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartPosition |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vote == nil {
				m.Vote = &Vote{}
			}
			if err := m.Vote.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakedNote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StakedNote == nil {
				m.StakedNote = &v1alpha1.Note{}
			}
			if err := m.StakedNote.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakedNotePosition", wireType)
			}
			m.StakedNotePosition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StakedNotePosition |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondedAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UnbondedAmount == nil {
				m.UnbondedAmount = &v1alpha1.Amount{}
			}
			if err := m.UnbondedAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Randomizer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Randomizer = append(m.Randomizer[:0], dAtA[iNdEx:postIndex]...)
			if m.Randomizer == nil {
				m.Randomizer = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofBlindingR", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofBlindingR = append(m.ProofBlindingR[:0], dAtA[iNdEx:postIndex]...)
			if m.ProofBlindingR == nil {
				m.ProofBlindingR = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofBlindingS", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofBlindingS = append(m.ProofBlindingS[:0], dAtA[iNdEx:postIndex]...)
			if m.ProofBlindingS == nil {
				m.ProofBlindingS = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaoDeposit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaoDeposit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaoDeposit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &v1alpha1.Value{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaoSpend) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaoSpend: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaoSpend: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &v1alpha1.Value{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaoOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaoOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaoOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &v1alpha1.Value{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Address == nil {
				m.Address = &v1alpha1.Address{}
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vote) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vote: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vote: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vote", wireType)
			}
			m.Vote = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vote |= Vote_Vote(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProposalState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProposalState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProposalState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voting", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ProposalState_Voting{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.State = &ProposalState_Voting_{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Withdrawn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ProposalState_Withdrawn{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.State = &ProposalState_Withdrawn_{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Finished", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ProposalState_Finished{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.State = &ProposalState_Finished_{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Claimed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ProposalState_Claimed{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.State = &ProposalState_Claimed_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProposalState_Voting) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Voting: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Voting: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProposalState_Withdrawn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Withdrawn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Withdrawn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProposalState_Finished) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Finished: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Finished: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outcome", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Outcome == nil {
				m.Outcome = &ProposalOutcome{}
			}
			if err := m.Outcome.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProposalState_Claimed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Claimed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Claimed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outcome", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Outcome == nil {
				m.Outcome = &ProposalOutcome{}
			}
			if err := m.Outcome.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProposalOutcome) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProposalOutcome: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProposalOutcome: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Passed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ProposalOutcome_Passed{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Outcome = &ProposalOutcome_Passed_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ProposalOutcome_Failed{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Outcome = &ProposalOutcome_Failed_{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slashed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ProposalOutcome_Slashed{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Outcome = &ProposalOutcome_Slashed_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProposalOutcome_Passed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Passed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Passed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProposalOutcome_Failed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Failed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Failed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithdrawnWithReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XWithdrawnWithReason = &ProposalOutcome_Failed_WithdrawnWithReason{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProposalOutcome_Slashed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Slashed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Slashed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithdrawnWithReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XWithdrawnWithReason = &ProposalOutcome_Slashed_WithdrawnWithReason{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tally) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tally: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tally: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yes", wireType)
			}
			m.Yes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Yes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field No", wireType)
			}
			m.No = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.No |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Abstain", wireType)
			}
			m.Abstain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Abstain |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Proposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Proposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Proposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signaling", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signaling == nil {
				m.Signaling = &Proposal_Signaling{}
			}
			if err := m.Signaling.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Emergency", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Emergency == nil {
				m.Emergency = &Proposal_Emergency{}
			}
			if err := m.Emergency.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParameterChange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParameterChange == nil {
				m.ParameterChange = &Proposal_ParameterChange{}
			}
			if err := m.ParameterChange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DaoSpend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DaoSpend == nil {
				m.DaoSpend = &Proposal_DaoSpend{}
			}
			if err := m.DaoSpend.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Proposal_Signaling) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Signaling: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Signaling: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XCommit = &Proposal_Signaling_Commit{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Proposal_Emergency) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Emergency: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Emergency: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HaltChain", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HaltChain = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Proposal_ParameterChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParameterChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParameterChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OldParameters == nil {
				m.OldParameters = &v1alpha11.ChainParameters{}
			}
			if err := m.OldParameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewParameters == nil {
				m.NewParameters = &v1alpha11.ChainParameters{}
			}
			if err := m.NewParameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Proposal_DaoSpend) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaoSpend: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaoSpend: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionPlan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGovernance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGovernance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransactionPlan == nil {
				m.TransactionPlan = &types.Any{}
			}
			if err := m.TransactionPlan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGovernance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGovernance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGovernance(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGovernance
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGovernance
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGovernance
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGovernance
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGovernance
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGovernance        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGovernance          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGovernance = fmt.Errorf("proto: unexpected end of group")
)
